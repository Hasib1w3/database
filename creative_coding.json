[
  {
    "title": "-",
    "description": "-",
    "code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>IronHill Scroll Animation | CodeGrid Recreation</title>\n    <style>\n        /* CSS RESET & FONTS */\n        @import url(\"https://fonts.googleapis.com/css2?family=Instrument+Sans:ital,wght@0,400..700;1,400..700&family=Instrument+Serif:ital@0;1&display=swap\");\n\n        :root {\n            --base-100: #ebf5df;\n            --base-200: #fec81d;\n            --base-300: #0f0f0f;\n        }\n\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        img {\n            width: 100%;\n            height: 100%;\n            object-fit: cover;\n        }\n\n        body {\n            overscroll-behavior: none;\n        }\n\n        /* TYPOGRAPHY */\n        h1, h2 {\n            text-transform: uppercase;\n            font-family: \"Instrument Serif\", sans-serif;\n            font-weight: 500;\n            line-height: 0.9;\n        }\n\n        h1 {\n            font-size: clamp(4rem, 7.5vw, 10rem);\n        }\n\n        h2 {\n            font-size: clamp(2.5rem, 4.5vw, 5rem);\n        }\n\n        p {\n            font-family: \"Instrument Sans\", sans-serif;\n            font-size: 1.125rem;\n            font-weight: 400;\n        }\n\n        /* HERO SECTION */\n        .hero {\n            position: relative;\n            width: 100%;\n            height: 175svh; /* Taller than viewport for scroll space */\n            color: var(--base-200);\n            overflow: hidden;\n        }\n\n        .hero-img {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            top: 0;\n            left: 0;\n            z-index: -1; /* Behind everything */\n        }\n\n        /* Hero Text Container */\n        .hero-header {\n            position: absolute;\n            width: 100%;\n            height: 100svh;\n            top: 0;\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n            gap: 0.5rem;\n            text-align: center;\n            z-index: 1;\n        }\n\n        .hero-header p {\n            width: 75%;\n        }\n\n        /* ThreeJS Overlay Canvas */\n        .hero-canvas {\n            position: absolute;\n            bottom: 0;\n            width: 100%;\n            height: 100%;\n            pointer-events: none; /* Pass scroll events through */\n            z-index: 2; /* On top of image, under revealed text */\n        }\n\n        /* Revealed Content Container */\n        .hero-content {\n            position: absolute;\n            bottom: 0;\n            width: 100%;\n            height: 125svh; /* Position logic from video */\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            text-align: center;\n            z-index: 3;\n        }\n\n        .hero-content h2 {\n            width: 75%;\n            color: var(--base-300); /* Dark text for contrast */\n        }\n\n        /* The span class for our manual text splitter */\n        .split-word {\n            display: inline-block;\n            opacity: 0; /* Hidden by default */\n        }\n\n        /* ABOUT SECTION (OUTRO) */\n        .about {\n            position: relative;\n            width: 100%;\n            height: 100svh;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            text-align: center;\n            background-color: var(--base-300);\n            color: var(--base-100);\n            z-index: 4;\n        }\n\n        .about p {\n            width: 40%;\n        }\n\n        /* Responsive Adjustment */\n        @media (max-width: 1000px) {\n            .hero-content h2, .about p {\n                width: calc(100% - 4rem);\n            }\n        }\n    </style>\n</head>\n<body>\n\n    <!-- HTML STRUCTURE -->\n    <section class=\"hero\">\n        <!-- Visual Base Image -->\n        <div class=\"hero-img\">\n            <!-- Replace src with your image -->\n            <img src=\"https://images.unsplash.com/photo-1542273917363-3b1817f69a2d?q=80&w=2074&auto=format&fit=crop\" alt=\"Hero background\">\n        </div>\n\n        <!-- Initial Fixed Content -->\n        <div class=\"hero-header\">\n            <h1>Morphogenesis</h1>\n            <p>Solid form gives way to liquid movement.</p>\n        </div>\n\n        <!-- WebGL Canvas -->\n        <canvas class=\"hero-canvas\"></canvas>\n\n        <!-- Revealed Text on Scroll -->\n        <div class=\"hero-content\">\n            <h2>\n                An underlying field of motion pushes and pulls the image across its surface,\n                redistributing pixels in a way that feels organic and constantly in flux.\n            </h2>\n        </div>\n    </section>\n\n    <section class=\"about\">\n        <p>\n            This animation is driven by a real-time WebGL displacement process where \n            interaction introduces force into the surface, causing form to bend, stretch, \n            and reorganize dynamically. Rather than relying on fixed keyframes, the visual \n            state evolves continuously, allowing motion to feel organic, responsive, \n            and materially present as the page progresses.\n        </p>\n    </section>\n\n    <!-- DEPENDENCIES (Module imports) -->\n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://unpkg.com/three@0.160.0/build/three.module.js\",\n                \"gsap\": \"https://unpkg.com/gsap@3.12.5/index.js\",\n                \"gsap/ScrollTrigger\": \"https://unpkg.com/gsap@3.12.5/ScrollTrigger.js\",\n                \"lenis\": \"https://unpkg.com/@studio-freight/lenis@1.0.33/dist/lenis.mjs\"\n            }\n        }\n    </script>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import gsap from 'gsap';\n        import { ScrollTrigger } from 'gsap/ScrollTrigger';\n        import Lenis from 'lenis';\n\n        gsap.registerPlugin(ScrollTrigger);\n\n        /* -------------------------------------- */\n        /* --- SHADERS (Stored in constants) ---- */\n        /* -------------------------------------- */\n\n        const vertexShader = `\n            varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        `;\n\n        const fragmentShader = `\n            uniform float uProgress;\n            uniform vec2 uResolution;\n            uniform vec3 uColor;\n            uniform float uSpread;\n            varying vec2 vUv;\n\n            // Pseudo-random function\n            float hash(vec2 p) {\n                vec3 p3 = fract(vec3(p.xyx) * .1031);\n                p3 += dot(p3, p3.yzx + 33.33);\n                return fract((p3.x + p3.y) * p3.z);\n            }\n\n            // Noise function\n            float noise(in vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), f.x),\n                    mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x),\n                    f.y\n                );\n            }\n\n            // Fractal Brownian Motion (FBM) to layer noise\n            float fbm(vec2 p) {\n                float v = 0.0;\n                v += noise(p * 1.0) * 0.5;\n                v += noise(p * 2.0) * 0.25;\n                v += noise(p * 4.0) * 0.125;\n                return v;\n            }\n\n            void main() {\n                // Screen Resolution normalization logic\n                vec2 uv = vUv;\n                vec2 aspectRatio = vec2(uResolution.x / uResolution.y, 1.0);\n                vec2 centeredUv = (uv - 0.5) * aspectRatio + 0.5; // Aspect ratio correction logic (implied) or raw noise map\n\n                // Simplified aspect approach to match tutorial feel directly on uv\n                // For exact match to \"organic flow up\", we often just use vUv and scale:\n                float noiseValue = fbm(vUv * 15.0); \n                \n                // Compare uv.y (vertical scroll) plus offset against noise\n                // We add uProgress to \"push\" the transition\n                float dissolveEdge = vUv.y - uProgress * 1.2;\n                \n                float d = dissolveEdge + noiseValue * uSpread;\n                \n                // Smoothstep to clean the edges based on pixel size relative to resolution\n                // The video uses smoothstep for alpha\n                // Logic derived from video shader:\n                // alpha = 1.0 if solid overlay, 0.0 if image visible\n                \n                // Inverted logic: We want solid color to disappear (go to 0) as progress increases? \n                // OR overlay disappears. The visual in video shows solid white transforming into image.\n                // uProgress 0 -> Full Color. uProgress 1 -> Image.\n                \n                float alpha = smoothstep(0.0, 0.1, d); // Simple edge logic based on dist\n                \n                // Correction: video logic creates \"holes\". \n                // Let's refine based on \"noise dissolve\" math\n                // target > 0 ? Color : Transparent\n                \n                // For a specific \"Liquid\" Upward movement:\n                float t = uProgress; \n                float pattern = fbm(vUv * 10.0 + t * 0.5); // Add movement\n                // We need the sheet to recede up.\n                float mask = step(vUv.y, t + pattern * 0.2); \n                \n                // Let's adhere strictly to the video's inferred simplified dissolve:\n                float edge = fbm(vUv * 20.0);\n                float dist = vUv.y - (uProgress * 1.5) + edge * uSpread;\n                \n                float a = smoothstep(0.0, 0.05, dist);\n                \n                gl_FragColor = vec4(uColor, a);\n            }\n        `;\n\n        /* -------------------------------------- */\n        /* --- JS IMPLEMENTATION & CONFIG ------- */\n        /* -------------------------------------- */\n\n        // Configuration Object\n        const CONFIG = {\n            color: \"#ebf5df\", // Corresponds to --base-100 (light color overlay)\n            spread: 0.5,\n            speed: 1\n        };\n\n        // DOM Selections\n        const canvas = document.querySelector(\".hero-canvas\");\n        const hero = document.querySelector(\".hero\");\n        const heroHeader = document.querySelector(\".hero-content h2\"); // The revealed text\n\n        // --- Custom Text Splitter (Free GSAP SplitText Replacement) ---\n        function splitTextToSpans(element) {\n            const text = element.innerText;\n            element.innerHTML = '';\n            const words = text.split(' ');\n            const spans = [];\n            \n            words.forEach((word, index) => {\n                const span = document.createElement('span');\n                span.innerText = word + ' '; // Add space back\n                span.className = 'split-word';\n                element.appendChild(span);\n                spans.push(span);\n            });\n            return spans;\n        }\n\n        const words = splitTextToSpans(heroHeader);\n\n        // --- THREE.JS Setup ---\n        const scene = new THREE.Scene();\n        // Orthographic camera for 2D UI plane effect\n        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        \n        const renderer = new THREE.WebGLRenderer({\n            canvas: canvas,\n            alpha: true, // Allow transparency behind the WebGL\n            antialias: false // Crisp pixel look\n        });\n\n        // Convert HEX to normalized RGB\n        function hexToRgb(hex) {\n            const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n            return result ? {\n                r: parseInt(result[1], 16) / 255,\n                g: parseInt(result[2], 16) / 255,\n                b: parseInt(result[3], 16) / 255\n            } : { r: 1, g: 1, b: 1 };\n        }\n\n        const rgb = hexToRgb(CONFIG.color);\n\n        const geometry = new THREE.PlaneGeometry(2, 2); // Full screen plane\n        const material = new THREE.ShaderMaterial({\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                uProgress: { value: 0 },\n                uResolution: { value: new THREE.Vector2(hero.offsetWidth, hero.offsetHeight) },\n                uColor: { value: new THREE.Vector3(rgb.r, rgb.g, rgb.b) },\n                uSpread: { value: CONFIG.spread }\n            },\n            transparent: true,\n        });\n\n        const mesh = new THREE.Mesh(geometry, material);\n        scene.add(mesh);\n\n        // --- Logic: Variables ---\n        let scrollProgress = 0;\n\n        // --- Resize Handler ---\n        function resize() {\n            const width = hero.offsetWidth;\n            const height = hero.offsetHeight;\n            renderer.setSize(width, height);\n            // Handling high-DPI displays while checking performance\n            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); \n            \n            // Update Uniforms\n            material.uniforms.uResolution.value.set(width, height);\n        }\n        \n        resize(); // Initial call\n        window.addEventListener(\"resize\", resize);\n\n        // --- Animation Loop ---\n        function animate() {\n            // Apply scroll progress to the shader logic\n            // The scrollProgress calculated via Lenis drives the 'melt'\n            material.uniforms.uProgress.value = scrollProgress;\n            \n            renderer.render(scene, camera);\n            requestAnimationFrame(animate);\n        }\n        animate();\n\n        // --- LENIS Setup (Smooth Scrolling) ---\n        const lenis = new Lenis();\n\n        // Animation Frame for Lenis\n        function raf(time) {\n            lenis.raf(time);\n            requestAnimationFrame(raf);\n        }\n        requestAnimationFrame(raf);\n\n        // --- SCROLL ANIMATION LOGIC (The Glue) ---\n        // Binding Scroll Position to Shader & Text Reveal\n        \n        // This function executes on every Lenis scroll event\n        lenis.on('scroll', ({ scroll }) => {\n            // Calculate how far down the Hero section we are.\n            // Start: 0, End: Height of viewport relative to Hero height\n            const heroHeight = hero.offsetHeight;\n            const windowHeight = window.innerHeight;\n            \n            // We scroll through the \"sticky\" duration (visual relative movement)\n            // Effective range: From 0 scroll to (heroHeight - windowHeight)\n            // We multiply by config speed to adjust pacing\n            const progress = Math.min(\n                (scroll / (heroHeight - windowHeight)) * CONFIG.speed, \n                1.1 // Cap slightly above 1 to ensure full clear\n            );\n            \n            // Store global scroll progress for shader animation loop\n            scrollProgress = progress;\n\n            // --- Text Reveal Logic ---\n            // Calculate total words and iterate\n            const totalWords = words.length;\n            \n            words.forEach((word, index) => {\n                // Determine the \"active window\" for this specific word\n                // Each word gets a slice of the 0.0 to 1.0 progress bar\n                const wordStart = index / totalWords;\n                // Add a small buffer to start looking for next word\n                const wordEnd = (index + 1) / totalWords;\n                \n                let opacity = 0;\n\n                if (progress >= wordEnd) {\n                    opacity = 1;\n                } else if (progress > wordStart) {\n                    // Normalize the progress within this word's specific chunk\n                    // (current - start) / (end - start) -> 0 to 1 range locally\n                    const fade = (progress - wordStart) / (wordEnd - wordStart);\n                    opacity = fade;\n                }\n\n                // Apply efficiently using GSAP overwrites to prevent conflict\n                gsap.to(word, {\n                    opacity: opacity,\n                    duration: 0.1, // Quick snap-fade\n                    overwrite: true\n                });\n            });\n        });\n\n        // Initialize transparency \n        gsap.set(words, { opacity: 0 });\n\n    </script>\n</body>\n</html>"
  }
]