[
  {
    "title": "-",
    "description": "-",
    "code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>IronHill Scroll Animation | CodeGrid Recreation</title>\n    <style>\n        /* CSS RESET & FONTS */\n        @import url(\"https://fonts.googleapis.com/css2?family=Instrument+Sans:ital,wght@0,400..700;1,400..700&family=Instrument+Serif:ital@0;1&display=swap\");\n\n        :root {\n            --base-100: #ebf5df;\n            --base-200: #fec81d;\n            --base-300: #0f0f0f;\n        }\n\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        img {\n            width: 100%;\n            height: 100%;\n            object-fit: cover;\n        }\n\n        body {\n            overscroll-behavior: none;\n        }\n\n        /* TYPOGRAPHY */\n        h1, h2 {\n            text-transform: uppercase;\n            font-family: \"Instrument Serif\", sans-serif;\n            font-weight: 500;\n            line-height: 0.9;\n        }\n\n        h1 {\n            font-size: clamp(4rem, 7.5vw, 10rem);\n        }\n\n        h2 {\n            font-size: clamp(2.5rem, 4.5vw, 5rem);\n        }\n\n        p {\n            font-family: \"Instrument Sans\", sans-serif;\n            font-size: 1.125rem;\n            font-weight: 400;\n        }\n\n        /* HERO SECTION */\n        .hero {\n            position: relative;\n            width: 100%;\n            height: 175svh; /* Taller than viewport for scroll space */\n            color: var(--base-200);\n            overflow: hidden;\n        }\n\n        .hero-img {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            top: 0;\n            left: 0;\n            z-index: -1; /* Behind everything */\n        }\n\n        /* Hero Text Container */\n        .hero-header {\n            position: absolute;\n            width: 100%;\n            height: 100svh;\n            top: 0;\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n            gap: 0.5rem;\n            text-align: center;\n            z-index: 1;\n        }\n\n        .hero-header p {\n            width: 75%;\n        }\n\n        /* ThreeJS Overlay Canvas */\n        .hero-canvas {\n            position: absolute;\n            bottom: 0;\n            width: 100%;\n            height: 100%;\n            pointer-events: none; /* Pass scroll events through */\n            z-index: 2; /* On top of image, under revealed text */\n        }\n\n        /* Revealed Content Container */\n        .hero-content {\n            position: absolute;\n            bottom: 0;\n            width: 100%;\n            height: 125svh; /* Position logic from video */\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            text-align: center;\n            z-index: 3;\n        }\n\n        .hero-content h2 {\n            width: 75%;\n            color: var(--base-300); /* Dark text for contrast */\n        }\n\n        /* The span class for our manual text splitter */\n        .split-word {\n            display: inline-block;\n            opacity: 0; /* Hidden by default */\n        }\n\n        /* ABOUT SECTION (OUTRO) */\n        .about {\n            position: relative;\n            width: 100%;\n            height: 100svh;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            text-align: center;\n            background-color: var(--base-300);\n            color: var(--base-100);\n            z-index: 4;\n        }\n\n        .about p {\n            width: 40%;\n        }\n\n        /* Responsive Adjustment */\n        @media (max-width: 1000px) {\n            .hero-content h2, .about p {\n                width: calc(100% - 4rem);\n            }\n        }\n    </style>\n</head>\n<body>\n\n    <!-- HTML STRUCTURE -->\n    <section class=\"hero\">\n        <!-- Visual Base Image -->\n        <div class=\"hero-img\">\n            <!-- Replace src with your image -->\n            <img src=\"https://images.unsplash.com/photo-1542273917363-3b1817f69a2d?q=80&w=2074&auto=format&fit=crop\" alt=\"Hero background\">\n        </div>\n\n        <!-- Initial Fixed Content -->\n        <div class=\"hero-header\">\n            <h1>Morphogenesis</h1>\n            <p>Solid form gives way to liquid movement.</p>\n        </div>\n\n        <!-- WebGL Canvas -->\n        <canvas class=\"hero-canvas\"></canvas>\n\n        <!-- Revealed Text on Scroll -->\n        <div class=\"hero-content\">\n            <h2>\n                An underlying field of motion pushes and pulls the image across its surface,\n                redistributing pixels in a way that feels organic and constantly in flux.\n            </h2>\n        </div>\n    </section>\n\n    <section class=\"about\">\n        <p>\n            This animation is driven by a real-time WebGL displacement process where \n            interaction introduces force into the surface, causing form to bend, stretch, \n            and reorganize dynamically. Rather than relying on fixed keyframes, the visual \n            state evolves continuously, allowing motion to feel organic, responsive, \n            and materially present as the page progresses.\n        </p>\n    </section>\n\n    <!-- DEPENDENCIES (Module imports) -->\n    <script type=\"importmap\">\n        {\n            \"imports\": {\n                \"three\": \"https://unpkg.com/three@0.160.0/build/three.module.js\",\n                \"gsap\": \"https://unpkg.com/gsap@3.12.5/index.js\",\n                \"gsap/ScrollTrigger\": \"https://unpkg.com/gsap@3.12.5/ScrollTrigger.js\",\n                \"lenis\": \"https://unpkg.com/@studio-freight/lenis@1.0.33/dist/lenis.mjs\"\n            }\n        }\n    </script>\n\n    <script type=\"module\">\n        import * as THREE from 'three';\n        import gsap from 'gsap';\n        import { ScrollTrigger } from 'gsap/ScrollTrigger';\n        import Lenis from 'lenis';\n\n        gsap.registerPlugin(ScrollTrigger);\n\n        /* -------------------------------------- */\n        /* --- SHADERS (Stored in constants) ---- */\n        /* -------------------------------------- */\n\n        const vertexShader = `\n            varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        `;\n\n        const fragmentShader = `\n            uniform float uProgress;\n            uniform vec2 uResolution;\n            uniform vec3 uColor;\n            uniform float uSpread;\n            varying vec2 vUv;\n\n            // Pseudo-random function\n            float hash(vec2 p) {\n                vec3 p3 = fract(vec3(p.xyx) * .1031);\n                p3 += dot(p3, p3.yzx + 33.33);\n                return fract((p3.x + p3.y) * p3.z);\n            }\n\n            // Noise function\n            float noise(in vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), f.x),\n                    mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x),\n                    f.y\n                );\n            }\n\n            // Fractal Brownian Motion (FBM) to layer noise\n            float fbm(vec2 p) {\n                float v = 0.0;\n                v += noise(p * 1.0) * 0.5;\n                v += noise(p * 2.0) * 0.25;\n                v += noise(p * 4.0) * 0.125;\n                return v;\n            }\n\n            void main() {\n                // Screen Resolution normalization logic\n                vec2 uv = vUv;\n                vec2 aspectRatio = vec2(uResolution.x / uResolution.y, 1.0);\n                vec2 centeredUv = (uv - 0.5) * aspectRatio + 0.5; // Aspect ratio correction logic (implied) or raw noise map\n\n                // Simplified aspect approach to match tutorial feel directly on uv\n                // For exact match to \"organic flow up\", we often just use vUv and scale:\n                float noiseValue = fbm(vUv * 15.0); \n                \n                // Compare uv.y (vertical scroll) plus offset against noise\n                // We add uProgress to \"push\" the transition\n                float dissolveEdge = vUv.y - uProgress * 1.2;\n                \n                float d = dissolveEdge + noiseValue * uSpread;\n                \n                // Smoothstep to clean the edges based on pixel size relative to resolution\n                // The video uses smoothstep for alpha\n                // Logic derived from video shader:\n                // alpha = 1.0 if solid overlay, 0.0 if image visible\n                \n                // Inverted logic: We want solid color to disappear (go to 0) as progress increases? \n                // OR overlay disappears. The visual in video shows solid white transforming into image.\n                // uProgress 0 -> Full Color. uProgress 1 -> Image.\n                \n                float alpha = smoothstep(0.0, 0.1, d); // Simple edge logic based on dist\n                \n                // Correction: video logic creates \"holes\". \n                // Let's refine based on \"noise dissolve\" math\n                // target > 0 ? Color : Transparent\n                \n                // For a specific \"Liquid\" Upward movement:\n                float t = uProgress; \n                float pattern = fbm(vUv * 10.0 + t * 0.5); // Add movement\n                // We need the sheet to recede up.\n                float mask = step(vUv.y, t + pattern * 0.2); \n                \n                // Let's adhere strictly to the video's inferred simplified dissolve:\n                float edge = fbm(vUv * 20.0);\n                float dist = vUv.y - (uProgress * 1.5) + edge * uSpread;\n                \n                float a = smoothstep(0.0, 0.05, dist);\n                \n                gl_FragColor = vec4(uColor, a);\n            }\n        `;\n\n        /* -------------------------------------- */\n        /* --- JS IMPLEMENTATION & CONFIG ------- */\n        /* -------------------------------------- */\n\n        // Configuration Object\n        const CONFIG = {\n            color: \"#ebf5df\", // Corresponds to --base-100 (light color overlay)\n            spread: 0.5,\n            speed: 1\n        };\n\n        // DOM Selections\n        const canvas = document.querySelector(\".hero-canvas\");\n        const hero = document.querySelector(\".hero\");\n        const heroHeader = document.querySelector(\".hero-content h2\"); // The revealed text\n\n        // --- Custom Text Splitter (Free GSAP SplitText Replacement) ---\n        function splitTextToSpans(element) {\n            const text = element.innerText;\n            element.innerHTML = '';\n            const words = text.split(' ');\n            const spans = [];\n            \n            words.forEach((word, index) => {\n                const span = document.createElement('span');\n                span.innerText = word + ' '; // Add space back\n                span.className = 'split-word';\n                element.appendChild(span);\n                spans.push(span);\n            });\n            return spans;\n        }\n\n        const words = splitTextToSpans(heroHeader);\n\n        // --- THREE.JS Setup ---\n        const scene = new THREE.Scene();\n        // Orthographic camera for 2D UI plane effect\n        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        \n        const renderer = new THREE.WebGLRenderer({\n            canvas: canvas,\n            alpha: true, // Allow transparency behind the WebGL\n            antialias: false // Crisp pixel look\n        });\n\n        // Convert HEX to normalized RGB\n        function hexToRgb(hex) {\n            const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n            return result ? {\n                r: parseInt(result[1], 16) / 255,\n                g: parseInt(result[2], 16) / 255,\n                b: parseInt(result[3], 16) / 255\n            } : { r: 1, g: 1, b: 1 };\n        }\n\n        const rgb = hexToRgb(CONFIG.color);\n\n        const geometry = new THREE.PlaneGeometry(2, 2); // Full screen plane\n        const material = new THREE.ShaderMaterial({\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                uProgress: { value: 0 },\n                uResolution: { value: new THREE.Vector2(hero.offsetWidth, hero.offsetHeight) },\n                uColor: { value: new THREE.Vector3(rgb.r, rgb.g, rgb.b) },\n                uSpread: { value: CONFIG.spread }\n            },\n            transparent: true,\n        });\n\n        const mesh = new THREE.Mesh(geometry, material);\n        scene.add(mesh);\n\n        // --- Logic: Variables ---\n        let scrollProgress = 0;\n\n        // --- Resize Handler ---\n        function resize() {\n            const width = hero.offsetWidth;\n            const height = hero.offsetHeight;\n            renderer.setSize(width, height);\n            // Handling high-DPI displays while checking performance\n            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); \n            \n            // Update Uniforms\n            material.uniforms.uResolution.value.set(width, height);\n        }\n        \n        resize(); // Initial call\n        window.addEventListener(\"resize\", resize);\n\n        // --- Animation Loop ---\n        function animate() {\n            // Apply scroll progress to the shader logic\n            // The scrollProgress calculated via Lenis drives the 'melt'\n            material.uniforms.uProgress.value = scrollProgress;\n            \n            renderer.render(scene, camera);\n            requestAnimationFrame(animate);\n        }\n        animate();\n\n        // --- LENIS Setup (Smooth Scrolling) ---\n        const lenis = new Lenis();\n\n        // Animation Frame for Lenis\n        function raf(time) {\n            lenis.raf(time);\n            requestAnimationFrame(raf);\n        }\n        requestAnimationFrame(raf);\n\n        // --- SCROLL ANIMATION LOGIC (The Glue) ---\n        // Binding Scroll Position to Shader & Text Reveal\n        \n        // This function executes on every Lenis scroll event\n        lenis.on('scroll', ({ scroll }) => {\n            // Calculate how far down the Hero section we are.\n            // Start: 0, End: Height of viewport relative to Hero height\n            const heroHeight = hero.offsetHeight;\n            const windowHeight = window.innerHeight;\n            \n            // We scroll through the \"sticky\" duration (visual relative movement)\n            // Effective range: From 0 scroll to (heroHeight - windowHeight)\n            // We multiply by config speed to adjust pacing\n            const progress = Math.min(\n                (scroll / (heroHeight - windowHeight)) * CONFIG.speed, \n                1.1 // Cap slightly above 1 to ensure full clear\n            );\n            \n            // Store global scroll progress for shader animation loop\n            scrollProgress = progress;\n\n            // --- Text Reveal Logic ---\n            // Calculate total words and iterate\n            const totalWords = words.length;\n            \n            words.forEach((word, index) => {\n                // Determine the \"active window\" for this specific word\n                // Each word gets a slice of the 0.0 to 1.0 progress bar\n                const wordStart = index / totalWords;\n                // Add a small buffer to start looking for next word\n                const wordEnd = (index + 1) / totalWords;\n                \n                let opacity = 0;\n\n                if (progress >= wordEnd) {\n                    opacity = 1;\n                } else if (progress > wordStart) {\n                    // Normalize the progress within this word's specific chunk\n                    // (current - start) / (end - start) -> 0 to 1 range locally\n                    const fade = (progress - wordStart) / (wordEnd - wordStart);\n                    opacity = fade;\n                }\n\n                // Apply efficiently using GSAP overwrites to prevent conflict\n                gsap.to(word, {\n                    opacity: opacity,\n                    duration: 0.1, // Quick snap-fade\n                    overwrite: true\n                });\n            });\n        });\n\n        // Initialize transparency \n        gsap.set(words, { opacity: 0 });\n\n    </script>\n</body>\n</html>"
  },
  {
    "title": "Procedural Leaf Growth with Three.js",
    "description": "",
    "code": "index.html: <audio id=\"click-sound\" src=\"https://onload.agency/_codepen_files/a-whimsical-clicking-in-enchanted-woods_v3.mp3\" preload=\"auto\"></audio>\nstyle.css: body { margin: 0; overflow: hidden; background-color: #e2e8f0; font-family: 'Inter', sans-serif; } canvas { display: block; }\nscript.js: import * as THREE from \"https://esm.sh/three\"; // --- Scene Setup --- let scene, camera, renderer; let width, height; const tendrils = []; const worldWidth = 100; let worldHeight; const clock = new THREE.Clock(); let audio; // --- Color Palette --- const PALETTES = [ [\"#B5E0B5\", \"#C7E9C0\", \"#D9F2D9\", \"#A9D8A9\", \"#CCE5CC\"], // Greens [\"#E6E3B3\", \"#D9D9A6\", \"#F2EFD0\"], // Yellows & Olives [\"#B3D9D2\", \"#C9E3DE\", \"#A6CFC6\", \"#E0F2EE\"] // Blue-Greens ]; const ACCENT_PALETTE = [\"#E0CFC4\", \"#D4BFA7\"]; // --- GLSL Shaders --- const stemVertexShader = ` attribute float segmentT; varying float vT; void main() { vT = segmentT; float maxWidth = 0.2; float minWidth = 0.05; float currentWidth = mix(maxWidth, minWidth, segmentT); vec3 displaced = position + normal * currentWidth; gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0); } `; const stemFragmentShader = ` uniform vec3 color; void main() { gl_FragColor = vec4(color, 0.8); } `; const leafVertexShader = ` uniform float uGrow; varying vec2 vUv; void main() { vUv = uv; vec3 pos = position; // Animate growth from base pos.x *= uGrow; pos.y *= pow(uGrow, 1.5); // Width grows slightly slower gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0); } `; const leafFragmentShader = ` uniform vec3 color; varying vec2 vUv; void main() { gl_FragColor = vec4(color, 0.8); } `; // --- Utility Functions --- function rand(min, max) { return min + Math.random() * (max - min); } function bellCurve(t) { return Math.sin(Math.PI * t); } // --- Geometry Function --- function createStemGeometry(curve, segments) { const points = curve.getPoints(segments); const geometry = new THREE.BufferGeometry(); const vertices = []; const normals = []; const segmentTs = []; for (let i = 0; i <= segments; i++) { const t = i / segments; const point = points[i]; const tangent = curve.getTangent(t).normalize(); const normal = new THREE.Vector3(-tangent.y, tangent.x, 0); vertices.push(point.x, point.y, point.z); normals.push(normal.x, normal.y, normal.z); segmentTs.push(t); vertices.push(point.x, point.y, point.z); normals.push(-normal.x, -normal.y, -normal.z); segmentTs.push(t); } const indices = []; for (let i = 0; i < segments; i++) { const i2 = i * 2; indices.push(i2, i2 + 1, i2 + 2); indices.push(i2 + 1, i2 + 3, i2 + 2); } geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3)); geometry.setAttribute('segmentT', new THREE.Float32BufferAttribute(segmentTs, 1)); geometry.setIndex(indices); return geometry; } // --- Tendril Class --- class Tendril { constructor(startX, startY) { const start = new THREE.Vector3(startX, startY, 0); const margin = 10; const randomY = startY + (Math.random() * worldHeight * 0.5 + worldHeight * 0.4); const endY = Math.min(randomY, worldHeight - margin); const end = new THREE.Vector3( startX + (Math.random() - 0.5) * worldWidth * 0.4, endY, 0 ); const control = new THREE.Vector3( (start.x + end.x) / 2 + (Math.random() - 0.5) * worldWidth * 0.4, (start.y + end.y) / 2 + (Math.random() * worldHeight * 0.1), 0 ); this.curve = new THREE.QuadraticBezierCurve3(start, control, end); this.segments = 100; this.progress = 0; this.speed = Math.random() * 0.01 + 0.005; const basePalette = PALETTES[Math.floor(Math.random() * PALETTES.length)]; this.activePalette = [...basePalette, ...basePalette, ...basePalette, ...ACCENT_PALETTE]; const stemGeometry = createStemGeometry(this.curve, this.segments); stemGeometry.setDrawRange(0, 0); this.stemMaterial = new THREE.ShaderMaterial({ vertexShader: stemVertexShader, fragmentShader: stemFragmentShader, uniforms: { color: { value: new THREE.Color(0x503214) } }, side: THREE.DoubleSide, transparent: true }); this.stemMesh = new THREE.Mesh(stemGeometry, this.stemMaterial); scene.add(this.stemMesh); this.leafMeshes = []; this.createLeaves(); } createLeaves() { const leafPairs = 40; for (let k = 1; k < leafPairs; k++) { [-1, 1].forEach(side => { const t_k = Math.pow(k / leafPairs, 0.8); let p, w_ratio, kappa, beta, length_scale = 1.0; const r = Math.random(); if (r < 0.4) { p = rand(2.2, 2.6); w_ratio = rand(0.08, 0.12); kappa = rand(-0.05, 0.05); beta = rand(-0.1, 0.1); } else if (r < 0.7) { p = rand(1.4, 1.8); w_ratio = rand(0.14, 0.18); kappa = 0; beta = 0; } else if (r < 0.9) { p = rand(1.8, 2.2); w_ratio = rand(0.1, 0.14); kappa = side * rand(0.12, 0.25); beta = side * rand(0.1, 0.2); } else { p = rand(1.6, 2.0); w_ratio = rand(0.12, 0.15); kappa = 0; beta = 0; length_scale = 0.6; } const L_max = worldWidth * 0.12; const L_k = bellCurve(t_k) * L_max * length_scale * rand(0.9, 1.1); const W_k = L_k * w_ratio; const leafShape = new THREE.Shape(); const segments = 32; const points = []; for (let i = 0; i <= segments; i++) { const s = i / segments; const c_x = s * L_k; const c_y = kappa * L_k * (1 - Math.pow(1 - 2 * s, 2)); const w_s = W_k * Math.pow(Math.sin(Math.PI * s), p); const delta_s = beta * (1 - s) * w_s; points.push({ x: c_x, y: c_y + w_s + delta_s }); } for (let i = segments; i >= 0; i--) { const s = i / segments; const c_x = s * L_k; const c_y = kappa * L_k * (1 - Math.pow(1 - 2 * s, 2)); const w_s = W_k * Math.pow(Math.sin(Math.PI * s), p); const delta_s = beta * (1 - s) * w_s; points.push({ x: c_x, y: c_y - w_s + delta_s }); } leafShape.moveTo(points[0].x, points[0].y); for(let i = 1; i < points.length; i++) { leafShape.lineTo(points[i].x, points[i].y); } const leafGeometry = new THREE.ShapeGeometry(leafShape); const randomColorHex = this.activePalette[Math.floor(Math.random() * this.activePalette.length)]; const color = new THREE.Color(randomColorHex); const hsl = {}; color.getHSL(hsl); color.setHSL(hsl.h, hsl.s, hsl.l * rand(0.95, 1.05)); const leafMaterial = new THREE.ShaderMaterial({ vertexShader: leafVertexShader, fragmentShader: leafFragmentShader, uniforms: { color: { value: color }, uGrow: { value: 0.0 } }, side: THREE.DoubleSide, transparent: true }); const leafMesh = new THREE.Mesh(leafGeometry, leafMaterial); const position = this.curve.getPoint(t_k); const tangent = this.curve.getTangent(t_k); const baseAngle = Math.atan2(tangent.y, tangent.x); const leafletAngle = THREE.MathUtils.lerp(25, 55, t_k) * THREE.MathUtils.DEG2RAD; const angle = baseAngle + side * leafletAngle + rand(-7, 7) * THREE.MathUtils.DEG2RAD; leafMesh.position.copy(position); leafMesh.rotation.z = angle; leafMesh.visible = false; this.leafMeshes.push({ mesh: leafMesh, t: t_k, isGrowing: false, growthProgress: 0, growthStartTime: 0, growthDuration: rand(0.4, 0.9) }); scene.add(leafMesh); }); } } update(elapsedTime) { if (this.progress < 1) { this.progress += this.speed; if (this.progress > 1) this.progress = 1; const indicesToShow = Math.floor(this.progress * this.segments * 6); this.stemMesh.geometry.setDrawRange(0, indicesToShow); } this.leafMeshes.forEach(leaf => { if (!leaf.isGrowing && leaf.t < this.progress) { leaf.isGrowing = true; leaf.growthStartTime = elapsedTime + rand(-0.12, 0.12); leaf.mesh.visible = true; } if (leaf.isGrowing && leaf.growthProgress < 1) { const timeSinceStart = elapsedTime - leaf.growthStartTime; leaf.growthProgress = Math.min(1.0, timeSinceStart / leaf.growthDuration); leaf.mesh.material.uniforms.uGrow.value = 1.0 - Math.pow(1.0 - leaf.growthProgress, 3); } }); } } // --- Main Functions --- function init() { width = window.innerWidth; height = window.innerHeight; scene = new THREE.Scene(); const aspect = height > 0 ? width / height : 1; worldHeight = worldWidth / aspect; camera = new THREE.OrthographicCamera(0, worldWidth, worldHeight, 0, 1, 1000); camera.position.z = 1; renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(width, height); renderer.setPixelRatio(window.devicePixelRatio); document.body.appendChild(renderer.domElement); audio = document.getElementById('click-sound'); window.addEventListener('resize', onWindowResize); window.addEventListener('click', onClick); window.addEventListener('touchstart', onClick); tendrils.push(new Tendril(worldWidth / 2, -5)); } function onWindowResize() { width = window.innerWidth; height = window.innerHeight; const aspect = height > 0 ? width / height : 1; worldHeight = worldWidth / aspect; camera.top = worldHeight; camera.updateProjectionMatrix(); renderer.setSize(width, height); } function onClick(event) { if (audio) { audio.currentTime = 0; audio.play(); } const touch = event.touches ? event.touches[0] : event; const screenX = touch.clientX / width; const startX = screenX * worldWidth; const startY = -5; tendrils.push(new Tendril(startX, startY)); } function animate() { requestAnimationFrame(animate); const elapsedTime = clock.getElapsedTime(); tendrils.forEach(tendril => { tendril.update(elapsedTime); }); renderer.render(scene, camera); } init(); animate();",
    "id": "procedural-leaf-growth-with-threejs"
  },
  {
    "title": "Animated Recam\u00e1n's Sequence",
    "description": "",
    "code": "index.html: \nstyle.css: \nscript.js: // Daniel Shiffman // http://youtube.com/thecodingtrain // http://codingtra.in // Recaman Sequence // https://youtu.be/DhFZfzOvNTU let numbers = []; let count = 1; let sequence = []; let index = 0; //how long between a new number is generated let newTickEveryMS = 1000; let oldTickTime = Date.now(); let currStep; let scl = 0; let arcs = []; let biggest = 0; class Arc { constructor(start, end, dir) { this.start = start; this.end = end; this.dir = dir; } show() { let diameter = abs(this.end - this.start); let x = (this.end + this.start) / 2; stroke(255); strokeWeight(0.5); noFill(); if (this.dir == 0) { //TOP arc(x, 0, diameter, diameter, PI, 0); } else { //BOTTOM arc(x, 0, diameter, diameter, 0, PI); } } showPartial() { stroke(255); strokeWeight(0.5); noFill(); let diameter = abs(this.end - this.start); let x = (this.end + this.start) / 2; if (this.dir == 0) { //TOP if (this.end < this.start) { drawLeftTop(x, 0, diameter, currStep); } else { drawRightTop(x, 0, diameter, currStep); } } else { //BOTTOM if (this.end < this.start) { drawLeftBottom(x, 0, diameter, currStep); } else { drawRightBottom(x, 0, diameter, currStep); } } } } function setup() { createCanvas(windowWidth, windowHeight); frameRate(30); background(0); numbers[index] = true; sequence.push(index); } function step() { let next = index - count; if (next < 0 || numbers[next]) { next = index + count; } numbers[next] = true; sequence.push(next); let a = new Arc(index, next, count % 2); arcs.push(a); index = next; if (index > biggest) { biggest = index; } count++; } function draw() { if (oldTickTime < Date.now()) { step(); oldTickTime = Date.now() + newTickEveryMS; //when did the new tick start start = Date.now(); //when is it going to end end = start + newTickEveryMS; } // at what point in the tick are we? map that to radians // v if this is 0 there phantom arcs appearing for a few frames currStep = map(end - Date.now(), newTickEveryMS, 0, 0.1, PI); translate(0, height / 2); scl = lerp(scl, width / (biggest * 1.1), 0.1); scale(scl); background(0); for (let i = 0; i < arcs.length - 1; i++) { arcs[i].show(); } arcs[arcs.length - 1].showPartial(); // if (count > windowWidth) { // noLoop(); // } } /** * drawing functions * naming scheme * draw[direction it is going on x axis][direction on y axis]() */ function drawRightBottom(x, y, diameter, currStep) { arc(x, y, diameter, diameter, PI - currStep, PI); } function drawRightTop(x, y, diameter, currStep) { arc(x, y, diameter, diameter, PI, currStep - PI); } function drawLeftBottom(x, y, diameter, currStep) { arc(x, y, diameter, diameter, 0, currStep); } function drawLeftTop(x, y, diameter, currStep) { arc(x, y, diameter, diameter, 0 - currStep, 0); }",
    "id": "animated-recamns-sequence"
  },
  {
    "title": "[javascript] \u274d Interactive Golden Spiral Visualizer",
    "description": "",
    "code": "index.html: <div id=\"spiral\"></div> <div class=\"layout-container\"> <div class=\"layout-header\"> <div class=\"layout-title\">GOLDEN SPIRAL METHOD</div> </div> <div class=\"layout-progress\"> <div>IMPLEMENTATION PROGRESS 100%</div> <div class=\"shortcut-info\">PRESS 'H' TO TOGGLE PANEL | 'R' TO RANDOMIZE</div> </div> <div class=\"layout-services\"> <div class=\"service-item\"> <h3>KEY CONCEPT</h3> <p>Inspired by phyllotaxis in plants, the golden spiral method (Vogel\u2019s model) places points at an angle equal to the <strong>golden angle</strong>\u20142\u03c0\u00b7(1\u20131/\u03c6) \u2248 137.5\u00b0\u2014and adjusts radius by \u221a(i/N) to ensure each new point occupies the same area as the last.</p> </div> <div class=\"service-item\"> <h3>DISK ALGORITHM</h3> <p>For a flat disk, assign each point an index <code>i + 0.5</code> (to center at mid\u2010cell) and compute:</p> <p><code>r = MAX_RADIUS \u00b7 \u221a((i + 0.5) / N)</code><br> <code>\u03b8 = (i + 0.5) \u00b7 GOLDEN_ANGLE</code> </p> </div> <div class=\"service-item\"> <h3>SPHERE ALGORITHM</h3> <p>To distribute on a sphere\u2019s surface, sample the polar angle via the inverse CDF of sin\u2009\u03c6:</p> <p><code>\u03c6 = acos(1 \u2013 2\u00b7(i + 0.5)/N)</code><br> <code>\u03b8 = (i + 0.5) \u00b7 GOLDEN_ANGLE</code> </p> </div> <div class=\"service-item\"> <h3>MATHEMATICS</h3> <p>\u221a(i/N) equalizes the differential ring areas (2\u03c0r\u2009dr), and the inverse\u2010CDF sampling for \u03c6 uses <code>sin\u2009\u03c6\u2009d\u03c6</code> to avoid polar clustering.</p> </div> <div class=\"service-item\"> <h3>IMPLEMENTATION</h3> <p>I build an SVG of <code>&lt;circle&gt;</code> elements, apply `<animate>` tags for pulsing radius and opacity\u2014offset by each point\u2019s fractional position to create a wave effect.</p> </div> <div class=\"service-item\"> <h3>APPLICATIONS</h3> <p>Ideal for generative art, data visualizations, computational geometry, or any scenario needing uniform sampling on circles or spheres.</p> </div> </div> <div class=\"tweakpane-container\" id=\"tweakpane-container\"></div>\nstyle.css: @import url(\"https://fonts.cdnfonts.com/css/thegoodmonolith\"); * { margin: 0; padding: 0; box-sizing: border-box; } body { background: #000; color: #f0f0f0; font-family: \"TheGoodMonolith\", monospace; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; padding: 20px; } #spiral { width: 400px; height: 400px; margin: 40px 0; } .layout-container { width: 80%; max-width: 900px; margin: 20px auto 60px; border: 1px solid #fff; } .layout-header { padding: 20px 30px; border-bottom: 1px solid #fff; height: 60px; display: flex; align-items: center; } .layout-title { font-size: 24px; font-weight: bold; letter-spacing: 1px; } .layout-progress { padding: 20px 30px; border-bottom: 1px solid #fff; font-size: 14px; display: flex; justify-content: space-between; align-items: center; } .shortcut-info { font-size: 12px; opacity: 0.7; } .layout-services { display: grid; grid-template-columns: 1fr 1fr 1fr; } .service-item { padding: 20px 30px; border-right: 1px solid #fff; border-bottom: 1px solid #fff; display: flex; flex-direction: column; } .service-item h3 { margin-top: 0; margin-bottom: 10px; font-size: 14px; } .service-item p { margin: 0; font-size: 12px; line-height: 1.4; } .service-item code { background: rgba(255, 255, 255, 0.1); padding: 2px 4px; border-radius: 3px; font-size: 10px; } .service-item:nth-child(3n) { border-right: none; } .service-item:nth-last-child(-n + 3) { border-bottom: none; } /* Code formatting */ pre { background: rgba(255, 255, 255, 0.1); padding: 10px; overflow-x: auto; font-size: 10px; margin: 10px 0; } /* Tweakpane container */ .tweakpane-container { position: fixed; top: 20px; right: 20px; transition: opacity 0.3s ease; } @media (max-width: 768px) { .layout-services { grid-template-columns: 1fr 1fr; } .service-item:nth-child(3n) { border-right: 1px solid #fff; } .service-item:nth-child(2n) { border-right: none; } .service-item:nth-last-child(-n + 3) { border-bottom: 1px solid #fff; } .service-item:nth-last-child(-n + 2) { border-bottom: none; } } @media (max-width: 480px) { .layout-services { grid-template-columns: 1fr; } .service-item { border-right: none !important; } .service-item:not(:last-child) { border-bottom: 1px solid #fff !important; } }\nscript.js: import { Pane } from \"https://cdn.skypack.dev/tweakpane@4.0.4\"; // Configuration object for the spiral const config = { points: 600, dotRadius: 2, duration: 3, colorPreset: \"white\", gradientPreset: \"none\", backgroundColor: \"#000000\", pulseEffect: true, opacityMin: 0.3, opacityMax: 1.0, sizeMin: 0.5, sizeMax: 1.5 }; // Color presets const colorPresets = { white: \"#ffffff\", gold: \"#ffd700\", cyan: \"#00ffff\", magenta: \"#ff00ff\", green: \"#00ff00\", orange: \"#ff8800\", red: \"#ff0000\", blue: \"#0066ff\", purple: \"#9900ff\", yellow: \"#ffff00\" }; // Gradient presets const gradientPresets = { none: null, rainbow: [\"#ff0000\", \"#ff9900\", \"#ffff00\", \"#00ff00\", \"#0099ff\", \"#6633ff\"], sunset: [\"#ff0000\", \"#ff9900\", \"#ffcc00\"], ocean: [\"#0066ff\", \"#00ccff\", \"#00ffcc\"], fire: [\"#ff0000\", \"#ff6600\", \"#ffcc00\"], neon: [\"#ff00ff\", \"#00ffff\", \"#ffff00\"], pastel: [\"#ffcccc\", \"#ccffcc\", \"#ccccff\"], grayscale: [\"#ffffff\", \"#999999\", \"#333333\"] }; // Light color presets (for dark backgrounds) const lightColorPresets = [ \"white\", \"gold\", \"cyan\", \"magenta\", \"green\", \"yellow\" ]; // Dark color presets (for light backgrounds) const darkColorPresets = [\"blue\", \"purple\", \"red\"]; // Light gradient presets (for dark backgrounds) const lightGradientPresets = [\"rainbow\", \"sunset\", \"ocean\", \"fire\", \"neon\"]; // Dark gradient presets (for light backgrounds) const darkGradientPresets = [\"ocean\", \"grayscale\"]; // Create Tweakpane instance const pane = new Pane({ container: document.getElementById(\"tweakpane-container\") }); // Add controls pane .addBinding(config, \"points\", { min: 100, max: 2000, step: 50 }) .on(\"change\", regenerateSpiral); pane .addBinding(config, \"dotRadius\", { min: 0.5, max: 5, step: 0.1 }) .on(\"change\", regenerateSpiral); pane .addBinding(config, \"duration\", { min: 1, max: 10, step: 0.5 }) .on(\"change\", regenerateSpiral); // Color controls pane .addBinding(config, \"colorPreset\", { options: Object.keys(colorPresets).reduce((acc, key) => { acc[key] = key; return acc; }, {}) }) .on(\"change\", regenerateSpiral); pane .addBinding(config, \"gradientPreset\", { options: Object.keys(gradientPresets).reduce((acc, key) => { acc[key] = key; return acc; }, {}) }) .on(\"change\", regenerateSpiral); pane.addBinding(config, \"backgroundColor\").on(\"change\", (ev) => { document.body.style.backgroundColor = ev.value; }); // Animation controls const animFolder = pane.addFolder({ title: \"Animation\" }); animFolder.addBinding(config, \"pulseEffect\").on(\"change\", regenerateSpiral); animFolder .addBinding(config, \"opacityMin\", { min: 0, max: 1, step: 0.05 }) .on(\"change\", regenerateSpiral); animFolder .addBinding(config, \"opacityMax\", { min: 0, max: 1, step: 0.05 }) .on(\"change\", regenerateSpiral); animFolder .addBinding(config, \"sizeMin\", { min: 0.1, max: 2, step: 0.1 }) .on(\"change\", regenerateSpiral); animFolder .addBinding(config, \"sizeMax\", { min: 0.1, max: 3, step: 0.1 }) .on(\"change\", regenerateSpiral); // Initialize with current background color document.body.style.backgroundColor = config.backgroundColor; // Toggle panel visibility with 'h' key let panelVisible = false; // Changed from true to false const tweakpaneContainer = document.getElementById(\"tweakpane-container\"); // Initialize panel as hidden tweakpaneContainer.style.opacity = \"0\"; tweakpaneContainer.style.pointerEvents = \"none\"; document.addEventListener(\"keydown\", (event) => { if (event.key.toLowerCase() === \"h\") { panelVisible = !panelVisible; tweakpaneContainer.style.opacity = panelVisible ? \"1\" : \"0\"; tweakpaneContainer.style.pointerEvents = panelVisible ? \"auto\" : \"none\"; } else if (event.key.toLowerCase() === \"r\") { randomizeSettings(); } }); // Helper function to determine if a color is light or dark function isLightColor(hexColor) { // Convert hex to RGB const r = parseInt(hexColor.slice(1, 3), 16); const g = parseInt(hexColor.slice(3, 5), 16); const b = parseInt(hexColor.slice(5, 7), 16); // Calculate perceived brightness (using YIQ formula) const brightness = (r * 299 + g * 587 + b * 114) / 1000; // Return true if the color is light return brightness > 128; } // Function to generate a random dark or light gray function randomGrayColor(isLight) { if (isLight) { // Light gray (from #AAAAAA to #EEEEEE) const value = Math.floor(Math.random() * (238 - 170) + 170).toString(16); return `#${value}${value}${value}`; } else { // Dark gray (from #111111 to #555555) const value = Math.floor(Math.random() * (85 - 17) + 17).toString(16); return `#${value}${value}${value}`; } } // Function to randomize settings with contrast awareness function randomizeSettings() { // Helper function to get random item from array const randomItem = (arr) => arr[Math.floor(Math.random() * arr.length)]; // Helper function to get random number in range const randomRange = (min, max) => Math.random() * (max - min) + min; // Randomize basic settings config.points = Math.floor(randomRange(100, 2000)); config.dotRadius = randomRange(0.5, 5); config.duration = randomRange(1, 10); config.pulseEffect = Math.random() > 0.3; // 70% chance of being true config.opacityMin = randomRange(0, 0.5); config.opacityMax = randomRange(0.5, 1); config.sizeMin = randomRange(0.1, 1); config.sizeMax = randomRange(1, 3); // Randomly decide if we want light or dark background const useLightBackground = Math.random() > 0.5; // Generate appropriate background color (light or dark gray) config.backgroundColor = randomGrayColor(useLightBackground); // Choose color preset with good contrast to background if (useLightBackground) { // For light backgrounds, use dark colors config.colorPreset = randomItem(darkColorPresets); config.gradientPreset = Math.random() > 0.5 ? randomItem(darkGradientPresets) : \"none\"; } else { // For dark backgrounds, use light colors config.colorPreset = randomItem(lightColorPresets); config.gradientPreset = Math.random() > 0.5 ? randomItem(lightGradientPresets) : \"none\"; } // Update background document.body.style.backgroundColor = config.backgroundColor; // Update UI text colors based on background updateUIColors(useLightBackground); // Update pane to reflect new values pane.refresh(); // Regenerate spiral regenerateSpiral(); } // Update UI colors based on background brightness function updateUIColors(isLightBackground) { const layoutContainer = document.querySelector(\".layout-container\"); const textElements = document.querySelectorAll( \".layout-title, .layout-progress, .service-item h3, .service-item p, .shortcut-info\" ); const borderElements = document.querySelectorAll( \".layout-container, .layout-header, .layout-progress, .service-item\" ); if (isLightBackground) { // For light backgrounds, use dark text textElements.forEach((el) => (el.style.color = \"#111111\")); borderElements.forEach((el) => (el.style.borderColor = \"#333333\")); } else { // For dark backgrounds, use light text textElements.forEach((el) => (el.style.color = \"#f0f0f0\")); borderElements.forEach((el) => (el.style.borderColor = \"#ffffff\")); } } // Function to generate the spiral function generateSpiral() { const N = config.points; const SIZE = 400; const DOT_RADIUS = config.dotRadius; const MARGIN = 2; const DURATION = config.duration; const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5)); const CENTER = SIZE / 2; const MAX_RADIUS = CENTER - MARGIN - DOT_RADIUS; const svgNS = \"http://www.w3.org/2000/svg\"; // Create SVG root const svg = document.createElementNS(svgNS, \"svg\"); svg.setAttribute(\"width\", SIZE); svg.setAttribute(\"height\", SIZE); svg.setAttribute(\"viewBox\", `0 0 ${SIZE} ${SIZE}`); // Add gradient definitions if needed if (config.gradientPreset !== \"none\") { const defs = document.createElementNS(svgNS, \"defs\"); const gradient = document.createElementNS(svgNS, \"linearGradient\"); gradient.setAttribute(\"id\", \"spiralGradient\"); gradient.setAttribute(\"gradientUnits\", \"userSpaceOnUse\"); gradient.setAttribute(\"x1\", \"0%\"); gradient.setAttribute(\"y1\", \"0%\"); gradient.setAttribute(\"x2\", \"100%\"); gradient.setAttribute(\"y2\", \"100%\"); const colors = gradientPresets[config.gradientPreset]; colors.forEach((color, index) => { const stop = document.createElementNS(svgNS, \"stop\"); stop.setAttribute(\"offset\", `${index * (100 / (colors.length - 1))}%`); stop.setAttribute(\"stop-color\", color); gradient.appendChild(stop); }); defs.appendChild(gradient); svg.appendChild(defs); } // Generate & animate dots for (let i = 0; i < N; i++) { const idx = i + 0.5; const frac = idx / N; const r = Math.sqrt(frac) * MAX_RADIUS; const theta = idx * GOLDEN_ANGLE; const x = CENTER + r * Math.cos(theta); const y = CENTER + r * Math.sin(theta); // Perfect SVG circle const c = document.createElementNS(svgNS, \"circle\"); c.setAttribute(\"cx\", x); c.setAttribute(\"cy\", y); c.setAttribute(\"r\", DOT_RADIUS); // Set color based on preset or gradient if (config.gradientPreset !== \"none\") { c.setAttribute(\"fill\", \"url(#spiralGradient)\"); } else { c.setAttribute(\"fill\", colorPresets[config.colorPreset]); } // Set initial opacity c.setAttribute(\"opacity\", \"0.6\"); svg.appendChild(c); if (config.pulseEffect) { // Radius pulse const animR = document.createElementNS(svgNS, \"animate\"); animR.setAttribute(\"attributeName\", \"r\"); animR.setAttribute( \"values\", `${DOT_RADIUS * config.sizeMin};${DOT_RADIUS * config.sizeMax};${ DOT_RADIUS * config.sizeMin }` ); animR.setAttribute(\"dur\", `${DURATION}s`); animR.setAttribute(\"begin\", `${frac * DURATION}s`); animR.setAttribute(\"repeatCount\", \"indefinite\"); animR.setAttribute(\"calcMode\", \"spline\"); animR.setAttribute(\"keySplines\", \"0.4 0 0.6 1;0.4 0 0.6 1\"); c.appendChild(animR); // Opacity pulse const animO = document.createElementNS(svgNS, \"animate\"); animO.setAttribute(\"attributeName\", \"opacity\"); animO.setAttribute( \"values\", `${config.opacityMin};${config.opacityMax};${config.opacityMin}` ); animO.setAttribute(\"dur\", `${DURATION}s`); animO.setAttribute(\"begin\", `${frac * DURATION}s`); animO.setAttribute(\"repeatCount\", \"indefinite\"); animO.setAttribute(\"calcMode\", \"spline\"); animO.setAttribute(\"keySplines\", \"0.4 0 0.6 1;0.4 0 0.6 1\"); c.appendChild(animO); } } return svg; } // Function to regenerate the spiral function regenerateSpiral() { const spiralContainer = document.getElementById(\"spiral\"); spiralContainer.innerHTML = \"\"; spiralContainer.appendChild(generateSpiral()); } // Initial generation regenerateSpiral();",
    "id": "javascript--interactive-golden-spiral-visualizer"
  },
  {
    "title": "Toon Fireball",
    "description": "",
    "code": "index.html: <div id=\"world\"></div>\nstyle.css: * { \tmargin: 0; \tpadding: 0; \tbox-sizing: border-box; }\nscript.js: import { EffectComposer } from \"https://unpkg.com/three@0.120.0/examples/jsm/postprocessing/EffectComposer.js\"; import { RenderPass } from \"https://unpkg.com/three@0.120.0/examples/jsm/postprocessing/RenderPass.js\"; import { UnrealBloomPass } from \"https://unpkg.com/three@0.120.0/examples/jsm/postprocessing/UnrealBloomPass.js\"; import { ShaderPass } from \"https://unpkg.com/three@0.120.0/examples/jsm/postprocessing/ShaderPass.js\"; import { OrbitControls } from \"https://unpkg.com/three@0.120.0/examples/jsm/controls/OrbitControls.js\"; const ENTIRE_SCENE = 0, \tBLOOM_SCENE = 1; const bloomLayer = new THREE.Layers(); bloomLayer.set(BLOOM_SCENE); const materials = {}; const darkMaterial = new THREE.MeshBasicMaterial({ color: \"black\" }); const vert = ` varying vec3 vNormal; varying vec3 camPos; varying vec2 vUv; void main() { vNormal = normal; vUv = uv; camPos = cameraPosition; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); } `; const frag = ` #define NUM_OCTAVES 5 #define M_PI 3.1415926535897932384626433832795 uniform vec4 resolution; varying vec3 vNormal; uniform sampler2D perlinnoise; uniform sampler2D sparknoise; uniform float time; uniform vec3 color0; uniform vec3 color1; uniform vec3 color2; uniform vec3 color3; uniform vec3 color4; uniform vec3 color5; varying vec3 camPos; varying vec2 vUv; float setOpacity(float r, float g, float b, float tonethreshold) { float tone = (r + g + b) / 3.0; float alpha = 1.0; if(tone<tonethreshold) { alpha = 0.0; } return alpha; } vec3 rgbcol(vec3 col) { return vec3(col.r/255.0,col.g/255.0,col.b/255.0); } vec2 rotate(vec2 v, float a) { float s = sin(a); float c = cos(a); mat2 m = mat2(c, -s, s, c); return m * v; } vec2 UnityPolarCoordinates (vec2 UV, vec2 Center, float RadialScale, float LengthScale){ //https://twitter.com/Cyanilux/status/1123950519133908995/photo/1 vec2 delta = UV - Center; float radius = length(delta) * 2. * RadialScale; float angle = atan(delta.x, delta.y) * 1.0/6.28 * LengthScale; return vec2(radius, angle); } void main() { vec2 olduv = gl_FragCoord.xy/resolution.xy ; vec2 uv = vUv ; vec2 imguv = uv; float scale = 1.; olduv *= 0.5 + time; olduv.y = olduv.y ; vec2 p = olduv*scale; vec4 txt = texture2D(perlinnoise, olduv); float gradient = dot(normalize( -camPos ), normalize( vNormal )); float pct = distance(vUv,vec2(0.5)); vec3 rgbcolor0 = rgbcol(color0); vec3 rgbcolor1 = rgbcol(color1); vec3 rgbcolor2 = rgbcol(color2); vec3 rgbcolor5 = rgbcol(color5); // set solid background float y = smoothstep(0.16,0.525,pct); vec3 backcolor = mix(rgbcolor0, rgbcolor5, y); gl_FragColor = vec4(backcolor,1.); // set polar coords vec2 center = vec2(0.5); vec2 cor = UnityPolarCoordinates(vec2(vUv.x,vUv.y), center, 1., 1.); // set textures vec2 newUv = vec2(cor.x + time,cor.x*0.2+cor.y); vec3 noisetex = texture2D(perlinnoise,mod(newUv,1.)).rgb; vec3 noisetex2 = texture2D(sparknoise,mod(newUv,1.)).rgb; // set textures tones float tone0 = 1. - smoothstep(0.3,0.6,noisetex.r); float tone1 = smoothstep(0.3,0.6,noisetex2.r); // set opacity for each tone float opacity0 = setOpacity(tone0,tone0,tone0,.29); float opacity1 = setOpacity(tone1,tone1,tone1,.49); //set final render if(opacity1>0.0){ gl_FragColor = vec4(rgbcolor2,0.)*vec4(opacity1); } else if(opacity0>0.0){ gl_FragColor = vec4(rgbcolor1,0.)*vec4(opacity0); } } `; const vertcylinder = ` varying vec2 vUv; void main() { vUv = uv; vec3 pos = vec3(position.x/1.,position.y,position.z/1.); if(pos.y >= 1.87){ pos = vec3(position.x*(sin((position.y - 0.6)*1.27)-0.16),position.y,position.z*(sin((position.y - 0.6)*1.27)-0.16)); } else{ pos = vec3(position.x*(sin((position.y/2. - .01)*.11)+0.75),position.y,position.z*(sin((position.y/2. - .01)*.11)+0.75)); } gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 ); } `; const fragcylinder = ` varying vec2 vUv; uniform sampler2D perlinnoise; uniform vec3 color4; uniform float time; varying vec3 vNormal; vec3 rgbcol(vec3 col) { return vec3(col.r/255.0,col.g/255.0,col.b/255.0); } void main() { vec3 noisetex = texture2D(perlinnoise,mod(1.*vec2(vUv.y-time*2.,vUv.x + time*1.),1.)).rgb; gl_FragColor = vec4(noisetex.r); if(gl_FragColor.r >= 0.5){ gl_FragColor = vec4(rgbcol(color4),gl_FragColor.r); }else{ gl_FragColor = vec4(0.); } gl_FragColor *= vec4(sin(vUv.y) - 0.1); gl_FragColor *= vec4(smoothstep(0.3,0.628,vUv.y)); } `; const vertflame = ` varying vec2 vUv; varying vec3 camPos; varying vec3 vNormal; varying vec3 nois; uniform sampler2D noise; uniform float time; void main() { vUv = uv; camPos = cameraPosition; vNormal = normal; vec3 pos = vec3(position.x/1.,position.y,position.z/1.); vec3 noisetex = texture2D(noise,mod(1.*vec2(vUv.y-time*2.,vUv.x + time*1.),1.)).rgb; if(pos.y >= 1.87){ pos = vec3(position.x*(sin((position.y - 0.64)*1.27)-0.12),position.y,position.z*(sin((position.y - 0.64)*1.27)-0.12)); } else{ pos = vec3(position.x*(sin((position.y/2. - .01)*.11)+0.79),position.y,position.z*(sin((position.y/2. - .01)*.11)+0.79)); } pos.xz *= noisetex.r; gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 ); } `; const fragflame = ` varying vec2 vUv; uniform sampler2D perlinnoise; uniform sampler2D noise; uniform vec3 color4; uniform float time; varying vec3 camPos; varying vec3 vNormal; varying vec3 nois; vec3 rgbcol(vec3 col) { return vec3(col.r/255.0,col.g/255.0,col.b/255.0); } void main() { // vec3 noisetex = texture2D(perlinnoise,mod(1.*vec2(vUv.y-time*2.,vUv.x + time*1.),1.)).rgb; // gl_FragColor += vec4(sin((vUv.y - time)*(20. + vUv.y))); vec3 noisetex = texture2D(noise,mod(1.*vec2(vUv.y-time*2.,vUv.x + time*1.),1.)).rgb; // nois = noisetex; gl_FragColor = vec4(noisetex.r); if(gl_FragColor.r >= 0.44){ gl_FragColor = vec4(rgbcol(color4),gl_FragColor.r); } // else if(gl_FragColor.r >= 0.9){ // // gl_FragColor = vec4(rgbcol(color4),gl_FragColor.r)*0.5; // } else{ gl_FragColor = vec4(0.); } gl_FragColor *= vec4(smoothstep(0.2,0.628,vUv.y)); // gl_FragColor = vec4(vUv.y - 0.3 ); // gl_FragColor = 1. - vec4(dot(normalize(vNormal),normalize(camPos)).r); } `; let options = { \texposure: 2.8, \tbloomStrength: 3.5, \tbloomRadius: 0.39, \tcolor0: [0, 0, 0], \tcolor1: [81, 14, 5], \tcolor2: [181, 156, 24], \tcolor3: [66, 66, 66], \tcolor4: [79, 79, 79], \tcolor5: [64, 27, 0] }; // let options = { // exposure: 2.8, // bloomStrength: 3.5, // // bloomStrength: 0, // bloomRadius: 0.39, // color0: [15, 0, 10], // color1: [13, 6, 5], // color2: [137, 56, 10], // color3: [166, 166, 166], // color4: [237, 149, 67], // color5: [20, 0, 51], // }; let gui = new dat.GUI(); let bloom = gui.addFolder(\"Bloom\"); bloom.add(options, \"bloomStrength\", 0.0, 5.0).name(\"bloomStrength\").listen(); bloom.add(options, \"bloomRadius\", 0.1, 2.0).name(\"bloomRadius\").listen(); bloom.open(); let color = gui.addFolder(\"Colors\"); color.addColor(options, \"color0\").name(\"ball0\"); color.addColor(options, \"color1\").name(\"ball1\"); color.addColor(options, \"color2\").name(\"ball2\"); color.addColor(options, \"color4\").name(\"steam\"); color.addColor(options, \"color5\").name(\"trail\"); color.open(); gui.close(); let scene, \tcamera, \trenderer, \tcontrols, \tmaterial, \tmaterial2, \tmaterial3, \tbloomPass, \tbloomComposer, \tcomposer, \tfinalPass, \tfinalComposer; const width = window.innerWidth, \theight = window.innerHeight; function init() { \tcreateScene(); \tpostProc(); \tmesh(); \tflame(); \tcylinder(); \tanimatBloom(); } function createScene() { \tscene = new THREE.Scene(); \tcamera = new THREE.PerspectiveCamera( \t\t75, \t\twindow.innerWidth / window.innerHeight, \t\t0.1, \t\t1000 \t); \tcamera.position.set(3.4369982203815655, 3.5239085092722098, 2.994862383531814); \trenderer = new THREE.WebGLRenderer(); \trenderer.antialias = true; \trenderer.setClearColor(new THREE.Color('#000')); \trenderer.setPixelRatio(window.devicePixelRatio); \trenderer.setSize(width, height); \tcontrols = new OrbitControls(camera, renderer.domElement); \tdocument.getElementById(\"world\").appendChild(renderer.domElement); } function postProc() { \tconst renderScene = new RenderPass(scene, camera); \tbloomPass = new UnrealBloomPass( \t\tnew THREE.Vector2(window.innerWidth, window.innerHeight), \t\t1.5, \t\t0.4, \t\t0.85 \t); \tbloomPass.threshold = options.bloomThreshold; \tbloomPass.strength = options.bloomStrength; \tbloomPass.radius = options.bloomRadius; \tbloomComposer = new EffectComposer(renderer); \tbloomComposer.addPass(renderScene); \tbloomComposer.addPass(bloomPass); } function mesh() { \tconst geometry = new THREE.SphereBufferGeometry(1, 30, 30); \tmaterial = new THREE.ShaderMaterial({ \t\tuniforms: { \t\t\ttime: { \t\t\t\ttype: \"f\", \t\t\t\tvalue: 0.0 \t\t\t}, \t\t\tperlinnoise: { \t\t\t\ttype: \"t\", \t\t\t\tvalue: new THREE.TextureLoader().load( \t\t\t\t\t\"https://raw.githubusercontent.com/pizza3/asset/master/noise9.jpg\" \t\t\t\t) \t\t\t}, \t\t\tsparknoise: { \t\t\t\ttype: \"t\", \t\t\t\tvalue: new THREE.TextureLoader().load( \t\t\t\t\t\"https://raw.githubusercontent.com/pizza3/asset/master/sparklenoise.jpg\" \t\t\t\t) \t\t\t}, \t\t\tcolor5: { \t\t\t\tvalue: new THREE.Vector3(...options.color5) \t\t\t}, \t\t\tcolor4: { \t\t\t\tvalue: new THREE.Vector3(...options.color4) \t\t\t}, \t\t\tcolor3: { \t\t\t\tvalue: new THREE.Vector3(...options.color3) \t\t\t}, \t\t\tcolor2: { \t\t\t\tvalue: new THREE.Vector3(...options.color2) \t\t\t}, \t\t\tcolor1: { \t\t\t\tvalue: new THREE.Vector3(...options.color1) \t\t\t}, \t\t\tcolor0: { \t\t\t\tvalue: new THREE.Vector3(...options.color0) \t\t\t}, \t\t\tresolution: { value: new THREE.Vector2(width, height) } \t\t}, \t\tvertexShader: vert, \t\tfragmentShader: frag \t}); \tconst mesh = new THREE.Mesh(geometry, material); \tmesh.scale.set(0.78, 0.78, 0.78); \tmesh.position.set(1 + 0, 0, 0); \tscene.add(mesh); } function cylinder() { \tconst geometry = new THREE.CylinderBufferGeometry(1.11, 0, 5.3, 50, 50, true); \tmaterial2 = new THREE.ShaderMaterial({ \t\tuniforms: { \t\t\tperlinnoise: { \t\t\t\ttype: \"t\", \t\t\t\tvalue: new THREE.TextureLoader().load( \t\t\t\t\t\"https://raw.githubusercontent.com/pizza3/asset/master/water-min.jpg\" \t\t\t\t) \t\t\t}, \t\t\tcolor4: { \t\t\t\tvalue: new THREE.Vector3(...options.color4) \t\t\t}, \t\t\ttime: { \t\t\t\ttype: \"f\", \t\t\t\tvalue: 0.0 \t\t\t}, \t\t\tnoise: { \t\t\t\ttype: \"t\", \t\t\t\tvalue: new THREE.TextureLoader().load( \t\t\t\t\t\"https://raw.githubusercontent.com/pizza3/asset/master/noise9.jpg\" \t\t\t\t) \t\t\t} \t\t}, \t\t// wireframe:true, \t\tvertexShader: vertcylinder, \t\tfragmentShader: fragcylinder, \t\ttransparent: true, \t\tdepthWrite: false, \t\tside: THREE.DoubleSide \t}); \tconst mesh = new THREE.Mesh(geometry, material2); \tmesh.rotation.set(0, 0, -Math.PI / 2); \tmesh.position.set(1 + -4.05, 0, 0); \tmesh.scale.set(1.5, 1.7, 1.5); \tscene.add(mesh); } function flame() { \tconst geometry = new THREE.CylinderBufferGeometry(1, 0, 5.3, 50, 50, true); \tmaterial3 = new THREE.ShaderMaterial({ \t\tuniforms: { \t\t\tperlinnoise: { \t\t\t\ttype: \"t\", \t\t\t\tvalue: new THREE.TextureLoader().load( \t\t\t\t\t\"https://raw.githubusercontent.com/pizza3/asset/master/water-min.jpg\" \t\t\t\t) \t\t\t}, \t\t\tcolor4: { \t\t\t\tvalue: new THREE.Vector3(...options.color5) \t\t\t}, \t\t\ttime: { \t\t\t\ttype: \"f\", \t\t\t\tvalue: 0.0 \t\t\t}, \t\t\tnoise: { \t\t\t\ttype: \"t\", \t\t\t\tvalue: new THREE.TextureLoader().load( \t\t\t\t\t\"https://raw.githubusercontent.com/pizza3/asset/master/noise9.jpg\" \t\t\t\t) \t\t\t} \t\t}, \t\t// wireframe:true, \t\tvertexShader: vertflame, \t\tfragmentShader: fragflame, \t\ttransparent: true, \t\tdepthWrite: false, \t\tside: THREE.DoubleSide \t}); \tconst mesh = new THREE.Mesh(geometry, material3); \tmesh.rotation.set(0, 0, -Math.PI / 2); \tmesh.position.set(1 + -4.78, 0, 0); \tmesh.scale.set(2, 2, 2); \tscene.add(mesh); } function updateDraw(deltaTime) { \tmaterial.uniforms.time.value = -deltaTime / (1000 * 2); \tmaterial2.uniforms.time.value = -deltaTime / (3000 * 2); \tmaterial3.uniforms.time.value = -deltaTime / (3000 * 2); \tmaterial.uniforms.color5.value = new THREE.Vector3(...options.color5); \tmaterial2.uniforms.color4.value = new THREE.Vector3(...options.color4); \tmaterial3.uniforms.color4.value = new THREE.Vector3(...options.color5); \tmaterial.uniforms.color3.value = new THREE.Vector3(...options.color3); \tmaterial.uniforms.color2.value = new THREE.Vector3(...options.color2); \tmaterial.uniforms.color1.value = new THREE.Vector3(...options.color1); \tmaterial.uniforms.color0.value = new THREE.Vector3(...options.color0); } function animatBloom(deltaTime) { \trequestAnimationFrame(animatBloom); \tupdateDraw(deltaTime); \tcontrols.update(); \tbloomPass.strength = options.bloomStrength; \tbloomPass.radius = options.bloomRadius; \tbloomComposer.render(); } function handleResize() { \tcamera.aspect = window.innerWidth / window.innerHeight; \tcamera.updateProjectionMatrix(); \trenderer.setSize(window.innerWidth, window.innerHeight); } window.addEventListener(\"load\", init); window.addEventListener(\"resize\", handleResize, false);",
    "id": "toon-fireball"
  },
  {
    "title": "Interactive Neural Network Viz",
    "description": "",
    "code": "index.html: <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"> <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin> <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap\" rel=\"stylesheet\"> <style> * { margin: 0; padding: 0; box-sizing: border-box; } canvas { display: block; width: 100%; height: 100%; cursor: pointer; position: absolute; top: 0; left: 0; z-index: 1; } .ui-panel { position: absolute; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); background: rgba(0, 0, 0, .7); border-radius: 12px; border: 1px solid rgba(255, 120, 50, .3); box-shadow: 0 4px 20px rgba(0, 0, 0, .5); z-index: 10; padding: 15px; color: #eee; font-family: 'Inter', sans-serif; } #instructions-container { top: 20px; left: 20px; font-size: 14px; line-height: 1.5; max-width: 280px; } #instruction-title { font-weight: 600; margin-bottom: 6px; font-size: 15px; } #theme-selector { top: 20px; right: 20px; display: flex; flex-direction: column; gap: 12px; max-width: 150px; } #theme-selector-title { font-weight: 600; font-size: 15px; margin-bottom: 2px; } .theme-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; } .theme-button { width: 36px; height: 36px; border-radius: 8px; border: 2px solid rgba(255, 255, 255, .3); cursor: pointer; transition: transform .2s, border-color .2s; outline: none; overflow: hidden; } .theme-button:hover, .theme-button:focus { transform: scale(1.05); border-color: rgba(255, 255, 255, .7); } .theme-button.active { transform: scale(1.05); border-color: rgba(255, 255, 255, .9); box-shadow: 0 0 10px rgba(255, 200, 150, .6); } #theme-1 { background: linear-gradient(45deg, #4F46E5, #7C3AED, #C026D3, #DB2777); } #theme-2 { background: linear-gradient(45deg, #F59E0B, #F97316, #DC2626, #7F1D1D); } #theme-3 { background: linear-gradient(45deg, #EC4899, #8B5CF6, #6366F1, #3B82F6); } #theme-4 { background: linear-gradient(45deg, #10B981, #A3E635, #FACC15, #FB923C); } #density-controls { margin-top: 8px; display: flex; flex-direction: column; gap: 8px; } .density-label { font-size: 13px; display: flex; justify-content: space-between; } .density-slider { width: 100%; appearance: none; height: 4px; border-radius: 2px; background: rgba(255, 120, 50, .3); outline: none; cursor: pointer; } .density-slider::-webkit-slider-thumb { appearance: none; width: 14px; height: 14px; border-radius: 50%; background: rgba(255, 120, 50, .8); cursor: pointer; transition: transform .1s, background .1s; } .density-slider::-moz-range-thumb { width: 14px; height: 14px; border-radius: 50%; background: rgba(255, 120, 50, .8); cursor: pointer; border: none; transition: transform .1s, background .1s; } .density-slider::-webkit-slider-thumb:hover { transform: scale(1.1); background: rgba(255, 140, 50, 1); } .density-slider::-moz-range-thumb:hover { transform: scale(1.1); background: rgba(255, 140, 50, 1); } #control-buttons { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; z-index: 10; background: rgba(0, 0, 0, .6); padding: 10px 15px; border-radius: 10px; border: 1px solid rgba(255, 120, 50, .2); } .control-button { background: rgba(255, 120, 50, .2); color: #eee; border: 1px solid rgba(255, 150, 50, .3); padding: 8px 15px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; transition: background-color 0.2s, transform 0.1s; white-space: nowrap; min-width: 80px; text-align: center; font-family: 'Inter', sans-serif; } .control-button:hover, .control-button:focus { background: rgba(255, 120, 50, .4); outline: none; } .control-button:active { background: rgba(255, 120, 50, .6); transform: scale(0.95); } @media (max-width: 640px) { #instructions-container { max-width: calc(100% - 40px); font-size: 13px; padding: 10px 15px; top: 10px; left: 10px; } #instruction-title { font-size: 14px; } #theme-selector { top: auto; bottom: 20px; right: 10px; left: auto; transform: none; max-width: 120px; padding: 10px; } #theme-selector-title { font-size: 14px; } .theme-button { width: 30px; height: 30px; } .density-label { font-size: 12px; } #control-buttons { bottom: 10px; gap: 10px; padding: 8px 10px; } .control-button { padding: 6px 10px; font-size: 12px; min-width: 65px; } } @media (max-width: 400px) { #theme-selector { flex-direction: column; align-items: center; max-width: none; width: calc(100% - 20px); left: 10px; right: 10px; bottom: 75px; } .theme-grid { grid-template-columns: repeat(4, 1fr); width: 100%; justify-items: center; } #density-controls { width: 80%; margin-top: 15px; } #control-buttons { width: calc(100% - 20px); justify-content: space-around; } } </style> <div id=\"instructions-container\" class=\"ui-panel\"> <div id=\"instruction-title\">Interactive Neural Network</div> <div>Click or tap to create energy pulses through the network. Drag to rotate.</div> </div> <div id=\"theme-selector\" class=\"ui-panel\"> <div id=\"theme-selector-title\">Visual Theme</div> <div class=\"theme-grid\"> <button class=\"theme-button\" id=\"theme-1\" data-theme=\"0\" aria-label=\"Theme 1\"></button> <button class=\"theme-button\" id=\"theme-2\" data-theme=\"1\" aria-label=\"Theme 2\"></button> <button class=\"theme-button\" id=\"theme-3\" data-theme=\"2\" aria-label=\"Theme 3\"></button> <button class=\"theme-button\" id=\"theme-4\" data-theme=\"3\" aria-label=\"Theme 4\"></button> </div> <div id=\"density-controls\"> <div class=\"density-label\"><span>Density</span><span id=\"density-value\">100%</span></div> <input type=\"range\" min=\"20\" max=\"100\" value=\"100\" class=\"density-slider\" id=\"density-slider\" aria-label=\"Network Density\"> </div> </div> <div id=\"control-buttons\"> <button id=\"change-formation-btn\" class=\"control-button\">Formation</button> <button id=\"pause-play-btn\" class=\"control-button\">Pause</button> <button id=\"reset-camera-btn\" class=\"control-button\">Reset Cam</button> </div> <canvas id=\"neural-network-canvas\"></canvas> <script type=\"importmap\"> { \"imports\": { \"three\": \"https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js\", \"three/addons/\": \"https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/\" } } </script> <script type=\"module\"> import * as THREE from 'three'; import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js'; import { RenderPass } from 'three/addons/postprocessing/RenderPass.js'; import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js'; import { FilmPass } from 'three/addons/postprocessing/FilmPass.js'; import { OutputPass } from 'three/addons/postprocessing/OutputPass.js'; const config = { paused: false, activePaletteIndex: 1, currentFormation: 0, numFormations: 4, densityFactor: 1 }; const colorPalettes = [ [new THREE.Color(0x4F46E5), new THREE.Color(0x7C3AED), new THREE.Color(0xC026D3), new THREE.Color(0xDB2777), new THREE.Color(0x8B5CF6)], [new THREE.Color(0xF59E0B), new THREE.Color(0xF97316), new THREE.Color(0xDC2626), new THREE.Color(0x7F1D1D), new THREE.Color(0xFBBF24)], [new THREE.Color(0xEC4899), new THREE.Color(0x8B5CF6), new THREE.Color(0x6366F1), new THREE.Color(0x3B82F6), new THREE.Color(0xA855F7)], [new THREE.Color(0x10B981), new THREE.Color(0xA3E635), new THREE.Color(0xFACC15), new THREE.Color(0xFB923C), new THREE.Color(0x4ADE80)] ]; const scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.0015); const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1200); camera.position.set(0, 5, 22); const canvasElement = document.getElementById('neural-network-canvas'); // Get canvas element const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, antialias: true, powerPreference: \"high-performance\" }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); renderer.setClearColor(0x000000); renderer.outputColorSpace = THREE.SRGBColorSpace; function createStarfield() { const count = 5000, pos = []; for (let i = 0; i < count; i++) { const r = THREE.MathUtils.randFloat(40, 120); const phi = Math.acos(THREE.MathUtils.randFloatSpread(2)); const theta = THREE.MathUtils.randFloat(0, Math.PI * 2); pos.push( r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi) ); } const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, sizeAttenuation: true, depthWrite: false, opacity: 0.8, transparent: true }); return new THREE.Points(geo, mat); } const starField = createStarfield(); scene.add(starField); const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.rotateSpeed = 0.5; controls.minDistance = 5; controls.maxDistance = 100; controls.autoRotate = true; controls.autoRotateSpeed = 0.15; controls.enablePan = false; const composer = new EffectComposer(renderer); composer.addPass(new RenderPass(scene, camera)); const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.68); composer.addPass(bloomPass); const filmPass = new FilmPass(0.35, 0.55, 2048, false); composer.addPass(filmPass); composer.addPass(new OutputPass()); const pulseUniforms = { uTime: { value: 0.0 }, uPulsePositions: { value: [new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3)] }, uPulseTimes: { value: [-1e3, -1e3, -1e3] }, uPulseColors: { value: [new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1)] }, uPulseSpeed: { value: 15.0 }, uBaseNodeSize: { value: 0.5 }, uActivePalette: { value: 0 } }; const noiseFunctions = ` vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;} vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;} vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);} vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;} float snoise(vec3 v){ const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0); vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz); vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy); vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i); vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0)); float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx; vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_); vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y); vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0; vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww; vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w); vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3))); p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0); m*=m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3))); } float fbm(vec3 p,float time){ float value=0.0;float amplitude=0.5;float frequency=1.0;int octaves=3; for(int i=0;i<octaves;i++){ value+=amplitude*snoise(p*frequency+time*0.2*frequency); amplitude*=0.5;frequency*=2.0; } return value; }`; const nodeShader = { vertexShader: `${noiseFunctions} attribute float nodeSize;attribute float nodeType;attribute vec3 nodeColor;attribute vec3 connectionIndices;attribute float distanceFromRoot; uniform float uTime;uniform vec3 uPulsePositions[3];uniform float uPulseTimes[3];uniform float uPulseSpeed;uniform float uBaseNodeSize; varying vec3 vColor;varying float vNodeType;varying vec3 vPosition;varying float vPulseIntensity;varying float vDistanceFromRoot; float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) { if (pulseTime < 0.0) return 0.0; float timeSinceClick = uTime - pulseTime; if (timeSinceClick < 0.0 || timeSinceClick > 3.0) return 0.0; float pulseRadius = timeSinceClick * uPulseSpeed; float distToClick = distance(worldPos, pulsePos); float pulseThickness = 2.0; float waveProximity = abs(distToClick - pulseRadius); return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(3.0, 0.0, timeSinceClick); } void main() { vNodeType = nodeType; vColor = nodeColor; vDistanceFromRoot = distanceFromRoot; vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz; vPosition = worldPos; float totalPulseIntensity = 0.0; for (int i = 0; i < 3; i++) { totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]); } vPulseIntensity = min(totalPulseIntensity, 1.0); float timeScale = 0.5 + 0.5 * sin(uTime * 0.8 + distanceFromRoot * 0.2); float baseSize = nodeSize * (0.8 + 0.2 * timeScale); float pulseSize = baseSize * (1.0 + vPulseIntensity * 2.0); vec3 modifiedPosition = position; if (nodeType > 0.5) { float noise = fbm(position * 0.1, uTime * 0.1); modifiedPosition += normal * noise * 0.2; } vec4 mvPosition = modelViewMatrix * vec4(modifiedPosition, 1.0); gl_PointSize = pulseSize * uBaseNodeSize * (800.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; }`, fragmentShader: ` uniform float uTime;uniform vec3 uPulseColors[3];uniform int uActivePalette; varying vec3 vColor;varying float vNodeType;varying vec3 vPosition;varying float vPulseIntensity;varying float vDistanceFromRoot; void main() { vec2 center = 2.0 * gl_PointCoord - 1.0; float dist = length(center); if (dist > 1.0) discard; float glowStrength = 1.0 - smoothstep(0.0, 1.0, dist); glowStrength = pow(glowStrength, 1.4); vec3 baseColor = vColor * (0.8 + 0.2 * sin(uTime * 0.5 + vDistanceFromRoot * 0.3)); vec3 finalColor = baseColor; if (vPulseIntensity > 0.0) { vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.3); finalColor = mix(baseColor, pulseColor, vPulseIntensity); finalColor *= (1.0 + vPulseIntensity * 0.7); } float alpha = glowStrength * (0.9 - 0.5 * dist); float camDistance = length(vPosition - cameraPosition); float distanceFade = smoothstep(80.0, 10.0, camDistance); if (vNodeType > 0.5) { alpha *= 0.85; } else { finalColor *= 1.2; } gl_FragColor = vec4(finalColor, alpha * distanceFade); }` }; const connectionShader = { vertexShader: `${noiseFunctions} attribute vec3 startPoint;attribute vec3 endPoint;attribute float connectionStrength;attribute float pathIndex;attribute vec3 connectionColor; uniform float uTime;uniform vec3 uPulsePositions[3];uniform float uPulseTimes[3];uniform float uPulseSpeed; varying vec3 vColor;varying float vConnectionStrength;varying float vPulseIntensity;varying float vPathPosition; float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) { if (pulseTime < 0.0) return 0.0; float timeSinceClick = uTime - pulseTime; if (timeSinceClick < 0.0 || timeSinceClick > 3.0) return 0.0; float pulseRadius = timeSinceClick * uPulseSpeed; float distToClick = distance(worldPos, pulsePos); float pulseThickness = 2.0; float waveProximity = abs(distToClick - pulseRadius); return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(3.0, 0.0, timeSinceClick); } void main() { float t = position.x; vPathPosition = t; vec3 midPoint = mix(startPoint, endPoint, 0.5); float pathOffset = sin(t * 3.14159) * 0.1; vec3 perpendicular = normalize(cross(normalize(endPoint - startPoint), vec3(0.0, 1.0, 0.0))); if (length(perpendicular) < 0.1) perpendicular = vec3(1.0, 0.0, 0.0); midPoint += perpendicular * pathOffset; vec3 p0 = mix(startPoint, midPoint, t); vec3 p1 = mix(midPoint, endPoint, t); vec3 finalPos = mix(p0, p1, t); float noiseTime = uTime * 0.2; float noise = fbm(vec3(pathIndex * 0.1, t * 0.5, noiseTime), noiseTime); finalPos += perpendicular * noise * 0.1; vec3 worldPos = (modelMatrix * vec4(finalPos, 1.0)).xyz; float totalPulseIntensity = 0.0; for (int i = 0; i < 3; i++) { totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]); } vPulseIntensity = min(totalPulseIntensity, 1.0); vColor = connectionColor; vConnectionStrength = connectionStrength; gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0); }`, fragmentShader: ` uniform float uTime;uniform vec3 uPulseColors[3]; varying vec3 vColor;varying float vConnectionStrength;varying float vPulseIntensity;varying float vPathPosition; void main() { vec3 baseColor = vColor * (0.7 + 0.3 * sin(uTime * 0.5 + vPathPosition * 10.0)); float flowPattern = sin(vPathPosition * 20.0 - uTime * 3.0) * 0.5 + 0.5; float flowIntensity = 0.3 * flowPattern * vConnectionStrength; vec3 finalColor = baseColor; if (vPulseIntensity > 0.0) { vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.3); finalColor = mix(baseColor, pulseColor, vPulseIntensity); flowIntensity += vPulseIntensity * 0.5; } finalColor *= (0.6 + flowIntensity + vConnectionStrength * 0.4); float alpha = 0.8 * vConnectionStrength + 0.2 * flowPattern; alpha = mix(alpha, min(1.0, alpha * 2.0), vPulseIntensity); gl_FragColor = vec4(finalColor, alpha); }` }; class Node { constructor(position, level = 0, type = 0) { this.position = position; this.connections = []; this.level = level; this.type = type; this.size = type === 0 ? THREE.MathUtils.randFloat(0.7, 1.2) : THREE.MathUtils.randFloat(0.4, 0.9); this.distanceFromRoot = 0; } addConnection(node, strength = 1.0) { if (!this.isConnectedTo(node)) { this.connections.push({ node, strength }); node.connections.push({ node: this, strength }); } } isConnectedTo(node) { return this.connections.some(conn => conn.node === node); } } function generateNeuralNetwork(formationIndex, densityFactor = 1.0) { let nodes = []; let rootNode; function generateQuantumCortex() { rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0); rootNode.size = 1.5; nodes.push(rootNode); const layers = 5, primaryAxes = 6, nodesPerAxis = 8, axisLength = 20; const axisEndpoints = []; for (let a = 0; a < primaryAxes; a++) { const phi = Math.acos(-1 + (2 * a) / primaryAxes); const theta = Math.PI * (1 + Math.sqrt(5)) * a; const dirVec = new THREE.Vector3( Math.sin(phi) * Math.cos(theta), Math.sin(phi) * Math.sin(theta), Math.cos(phi) ); let prevNode = rootNode; for (let i = 1; i <= nodesPerAxis; i++) { const t = i / nodesPerAxis; const distance = axisLength * Math.pow(t, 0.8); const pos = new THREE.Vector3().copy(dirVec).multiplyScalar(distance); const nodeType = (i === nodesPerAxis) ? 1 : 0; const newNode = new Node(pos, i, nodeType); newNode.distanceFromRoot = distance; nodes.push(newNode); prevNode.addConnection(newNode, 1.0 - (t * 0.3)); prevNode = newNode; if (i === nodesPerAxis) axisEndpoints.push(newNode); } } const ringDistances = [5, 10, 15]; const ringNodes = []; for (const ringDist of ringDistances) { const nodesInRing = Math.floor(ringDist * 3 * densityFactor); const ringLayer = []; for (let i = 0; i < nodesInRing; i++) { const t = i / nodesInRing; const ringPhi = Math.acos(2 * Math.random() - 1); const ringTheta = 2 * Math.PI * t; const pos = new THREE.Vector3( ringDist * Math.sin(ringPhi) * Math.cos(ringTheta), ringDist * Math.sin(ringPhi) * Math.sin(ringTheta), ringDist * Math.cos(ringPhi) ); const level = Math.ceil(ringDist / 5); const nodeType = Math.random() < 0.4 ? 1 : 0; const newNode = new Node(pos, level, nodeType); newNode.distanceFromRoot = ringDist; nodes.push(newNode); ringLayer.push(newNode); } ringNodes.push(ringLayer); for (let i = 0; i < ringLayer.length; i++) { const node = ringLayer[i]; const nextNode = ringLayer[(i + 1) % ringLayer.length]; node.addConnection(nextNode, 0.7); if (i % 4 === 0 && ringLayer.length > 5) { const jumpIdx = (i + Math.floor(ringLayer.length / 2)) % ringLayer.length; node.addConnection(ringLayer[jumpIdx], 0.4); } } } for (const ring of ringNodes) { for (const node of ring) { let closestAxisNode = null; let minDist = Infinity; for (const n of nodes) { if (n === rootNode || n === node) continue; if (n.level === 0 || n.type !== 0) continue; const dist = node.position.distanceTo(n.position); if (dist < minDist) { minDist = dist; closestAxisNode = n; } } if (closestAxisNode && minDist < 8) { const strength = 0.5 + (1 - minDist / 8) * 0.5; node.addConnection(closestAxisNode, strength); } } } for (let r = 0; r < ringNodes.length - 1; r++) { const innerRing = ringNodes[r]; const outerRing = ringNodes[r + 1]; const connectionsCount = Math.floor(innerRing.length * 0.5); for (let i = 0; i < connectionsCount; i++) { const innerNode = innerRing[Math.floor(Math.random() * innerRing.length)]; const outerNode = outerRing[Math.floor(Math.random() * outerRing.length)]; if (!innerNode.isConnectedTo(outerNode)) { innerNode.addConnection(outerNode, 0.6); } } } for (let i = 0; i < axisEndpoints.length; i++) { const startNode = axisEndpoints[i]; const endNode = axisEndpoints[(i + 2) % axisEndpoints.length]; const numIntermediates = 3; let prevNode = startNode; for (let j = 1; j <= numIntermediates; j++) { const t = j / (numIntermediates + 1); const pos = new THREE.Vector3().lerpVectors(startNode.position, endNode.position, t); pos.add(new THREE.Vector3( THREE.MathUtils.randFloatSpread(3), THREE.MathUtils.randFloatSpread(3), THREE.MathUtils.randFloatSpread(3) )); const newNode = new Node(pos, startNode.level, 0); newNode.distanceFromRoot = rootNode.position.distanceTo(pos); nodes.push(newNode); prevNode.addConnection(newNode, 0.5); prevNode = newNode; } prevNode.addConnection(endNode, 0.5); } } function generateHyperdimensionalMesh() { rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0); rootNode.size = 1.5; nodes.push(rootNode); const dimensions = 4; const nodesPerDimension = Math.floor(40 * densityFactor); const maxRadius = 20; const dimensionVectors = [ new THREE.Vector3(1, 1, 1).normalize(), new THREE.Vector3(-1, 1, -1).normalize(), new THREE.Vector3(1, -1, -1).normalize(), new THREE.Vector3(-1, -1, 1).normalize() ]; const dimensionNodes = []; for (let d = 0; d < dimensions; d++) { const dimNodes = []; const dimVec = dimensionVectors[d]; for (let i = 0; i < nodesPerDimension; i++) { const distance = maxRadius * Math.pow(Math.random(), 0.7); const randomVec = new THREE.Vector3( THREE.MathUtils.randFloatSpread(1), THREE.MathUtils.randFloatSpread(1), THREE.MathUtils.randFloatSpread(1) ).normalize(); const biasedVec = new THREE.Vector3().addVectors( dimVec.clone().multiplyScalar(0.6 + Math.random() * 0.4), randomVec.clone().multiplyScalar(0.3) ).normalize(); const pos = biasedVec.clone().multiplyScalar(distance); const isLeaf = Math.random() < 0.4 || distance > maxRadius * 0.8; const level = Math.floor(distance / (maxRadius / 4)) + 1; const newNode = new Node(pos, level, isLeaf ? 1 : 0); newNode.distanceFromRoot = distance; newNode.dimension = d; nodes.push(newNode); dimNodes.push(newNode); if (distance < maxRadius * 0.3) rootNode.addConnection(newNode, 0.7); } dimensionNodes.push(dimNodes); } for (let d = 0; d < dimensions; d++) { const dimNodes = dimensionNodes[d]; dimNodes.sort((a, b) => a.distanceFromRoot - b.distanceFromRoot); const layers = 4; const nodesPerLayer = Math.ceil(dimNodes.length / layers); for (let layer = 0; layer < layers; layer++) { const startIdx = layer * nodesPerLayer; const endIdx = Math.min(startIdx + nodesPerLayer, dimNodes.length); for (let i = startIdx; i < endIdx; i++) { const node = dimNodes[i]; const connectionsCount = 1 + Math.floor(Math.random() * 3); const nearbyNodes = dimNodes.slice(startIdx, endIdx).filter(n => n !== node) .sort((a, b) => node.position.distanceTo(a.position) - node.position.distanceTo(b.position)); for (let j = 0; j < Math.min(connectionsCount, nearbyNodes.length); j++) { if (!node.isConnectedTo(nearbyNodes[j])) { node.addConnection(nearbyNodes[j], 0.4 + Math.random() * 0.4); } } if (layer > 0) { const prevLayer = dimNodes.slice((layer - 1) * nodesPerLayer, layer * nodesPerLayer) .sort((a, b) => node.position.distanceTo(a.position) - node.position.distanceTo(b.position)); if (prevLayer.length > 0 && !node.isConnectedTo(prevLayer[0])) { node.addConnection(prevLayer[0], 0.8); } } } } } for (let d1 = 0; d1 < dimensions; d1++) { for (let d2 = d1 + 1; d2 < dimensions; d2++) { const connectionsCount = Math.floor(5 * densityFactor); for (let i = 0; i < connectionsCount; i++) { const n1 = dimensionNodes[d1][Math.floor(Math.random() * dimensionNodes[d1].length)]; const n2 = dimensionNodes[d2][Math.floor(Math.random() * dimensionNodes[d2].length)]; if (!n1.isConnectedTo(n2)) { const midPos = new THREE.Vector3().lerpVectors(n1.position, n2.position, 0.5); midPos.add(new THREE.Vector3( THREE.MathUtils.randFloatSpread(2), THREE.MathUtils.randFloatSpread(2), THREE.MathUtils.randFloatSpread(2) )); const interNode = new Node(midPos, Math.max(n1.level, n2.level), 0); interNode.distanceFromRoot = rootNode.position.distanceTo(midPos); nodes.push(interNode); n1.addConnection(interNode, 0.5); interNode.addConnection(n2, 0.5); } } } } const jumpConnections = Math.floor(10 * densityFactor); for (let i = 0; i < jumpConnections; i++) { const startDim = Math.floor(Math.random() * dimensions); const endDim = (startDim + 2) % dimensions; const startNode = dimensionNodes[startDim][Math.floor(Math.random() * dimensionNodes[startDim].length)]; const endNode = dimensionNodes[endDim][Math.floor(Math.random() * dimensionNodes[endDim].length)]; if (!startNode.isConnectedTo(endNode)) { const numPoints = 3 + Math.floor(Math.random() * 3); let prevNode = startNode; for (let j = 1; j < numPoints; j++) { const t = j / numPoints; const pos = new THREE.Vector3().lerpVectors(startNode.position, endNode.position, t); pos.add(new THREE.Vector3( THREE.MathUtils.randFloatSpread(8) * Math.sin(t * Math.PI), THREE.MathUtils.randFloatSpread(8) * Math.sin(t * Math.PI), THREE.MathUtils.randFloatSpread(8) * Math.sin(t * Math.PI) )); const jumpNode = new Node(pos, Math.max(startNode.level, endNode.level), 0); jumpNode.distanceFromRoot = rootNode.position.distanceTo(pos); nodes.push(jumpNode); prevNode.addConnection(jumpNode, 0.4); prevNode = jumpNode; } prevNode.addConnection(endNode, 0.4); } } } function generateNeuralVortex() { rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0); rootNode.size = 1.8; nodes.push(rootNode); const numSpirals = 6; const totalHeight = 30; const maxRadius = 16; const nodesPerSpiral = Math.floor(30 * densityFactor); const spiralNodes = []; for (let s = 0; s < numSpirals; s++) { const spiralPhase = (s / numSpirals) * Math.PI * 2; const spiralArray = []; for (let i = 0; i < nodesPerSpiral; i++) { const t = i / (nodesPerSpiral - 1); const heightCurve = 1 - Math.pow(2 * t - 1, 2); const height = (t - 0.5) * totalHeight; const radiusCurve = Math.sin(t * Math.PI); const radius = maxRadius * radiusCurve; const revolutions = 2.5; const angle = spiralPhase + t * Math.PI * 2 * revolutions; const pos = new THREE.Vector3(radius * Math.cos(angle), height, radius * Math.sin(angle)); pos.add(new THREE.Vector3( THREE.MathUtils.randFloatSpread(1.5), THREE.MathUtils.randFloatSpread(1.5), THREE.MathUtils.randFloatSpread(1.5) )); const level = Math.floor(t * 5) + 1; const isLeaf = Math.random() < 0.3 || i > nodesPerSpiral - 3; const newNode = new Node(pos, level, isLeaf ? 1 : 0); newNode.distanceFromRoot = Math.sqrt(radius * radius + height * height); newNode.spiralIndex = s; newNode.spiralPosition = t; nodes.push(newNode); spiralArray.push(newNode); } spiralNodes.push(spiralArray); } for (const spiral of spiralNodes) { rootNode.addConnection(spiral[0], 1.0); for (let i = 0; i < spiral.length - 1; i++) { spiral[i].addConnection(spiral[i + 1], 0.9); } } for (let s = 0; s < numSpirals; s++) { const currentSpiral = spiralNodes[s]; const nextSpiral = spiralNodes[(s + 1) % numSpirals]; const connectionPoints = 5; for (let c = 0; c < connectionPoints; c++) { const t = c / (connectionPoints - 1); const idx1 = Math.floor(t * (currentSpiral.length - 1)); const idx2 = Math.floor(t * (nextSpiral.length - 1)); currentSpiral[idx1].addConnection(nextSpiral[idx2], 0.7); } } for (let s = 0; s < numSpirals; s++) { const currentSpiral = spiralNodes[s]; const jumpSpiral = spiralNodes[(s + 2) % numSpirals]; const connections = 3; for (let c = 0; c < connections; c++) { const t1 = (c + 0.5) / connections; const t2 = (c + 1.0) / connections; const idx1 = Math.floor(t1 * (currentSpiral.length - 1)); const idx2 = Math.floor(t2 * (jumpSpiral.length - 1)); const start = currentSpiral[idx1]; const end = jumpSpiral[idx2]; const midPoint = new THREE.Vector3().lerpVectors(start.position, end.position, 0.5).multiplyScalar(0.7); const bridgeNode = new Node(midPoint, Math.max(start.level, end.level), 0); bridgeNode.distanceFromRoot = rootNode.position.distanceTo(midPoint); nodes.push(bridgeNode); start.addConnection(bridgeNode, 0.6); bridgeNode.addConnection(end, 0.6); } } const ringLevels = 5; for (let r = 0; r < ringLevels; r++) { const height = (r / (ringLevels - 1) - 0.5) * totalHeight * 0.7; const ringNodes = nodes.filter(n => n !== rootNode && Math.abs(n.position.y - height) < 2); ringNodes.sort((a, b) => Math.atan2(a.position.z, a.position.x) - Math.atan2(b.position.z, b.position.x)); if (ringNodes.length > 3) { for (let i = 0; i < ringNodes.length; i++) { ringNodes[i].addConnection(ringNodes[(i + 1) % ringNodes.length], 0.5); } } } const radialConnections = Math.floor(10 * densityFactor); const candidates = nodes.filter(n => n !== rootNode && n.position.length() > 5) .sort(() => Math.random() - 0.5) .slice(0, radialConnections); for (const node of candidates) { const numSegments = 1 + Math.floor(Math.random() * 2); let prevNode = node; for (let i = 1; i <= numSegments; i++) { const t = i / (numSegments + 1); const segPos = node.position.clone().multiplyScalar(1 - t); segPos.add(new THREE.Vector3( THREE.MathUtils.randFloatSpread(2), THREE.MathUtils.randFloatSpread(2), THREE.MathUtils.randFloatSpread(2) )); const newNode = new Node(segPos, Math.floor(node.level * (1 - t)), 0); newNode.distanceFromRoot = rootNode.position.distanceTo(segPos); nodes.push(newNode); prevNode.addConnection(newNode, 0.7); prevNode = newNode; } prevNode.addConnection(rootNode, 0.8); } } function generateSynapticCloud() { rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0); rootNode.size = 1.5; nodes.push(rootNode); const numClusters = 6; const maxDist = 18; const clusterNodes = []; for (let c = 0; c < numClusters; c++) { const phi = Math.acos(2 * Math.random() - 1); const theta = 2 * Math.PI * Math.random(); const distance = maxDist * (0.3 + 0.7 * Math.random()); const pos = new THREE.Vector3( distance * Math.sin(phi) * Math.cos(theta), distance * Math.sin(phi) * Math.sin(theta), distance * Math.cos(phi) ); const clusterNode = new Node(pos, 1, 0); clusterNode.size = 1.2; clusterNode.distanceFromRoot = distance; nodes.push(clusterNode); clusterNodes.push(clusterNode); rootNode.addConnection(clusterNode, 0.9); } for (let i = 0; i < clusterNodes.length; i++) { for (let j = i + 1; j < clusterNodes.length; j++) { const dist = clusterNodes[i].position.distanceTo(clusterNodes[j].position); const probability = 1.0 - (dist / (maxDist * 2)); if (Math.random() < probability) { const strength = 0.5 + 0.5 * (1 - dist / (maxDist * 2)); clusterNodes[i].addConnection(clusterNodes[j], strength); } } } for (const cluster of clusterNodes) { const clusterSize = Math.floor(20 * densityFactor); const cloudRadius = 7 + Math.random() * 3; for (let i = 0; i < clusterSize; i++) { const radius = cloudRadius * Math.pow(Math.random(), 0.5); const dir = new THREE.Vector3( THREE.MathUtils.randFloatSpread(2), THREE.MathUtils.randFloatSpread(2), THREE.MathUtils.randFloatSpread(2) ).normalize(); const pos = new THREE.Vector3().copy(cluster.position).add(dir.multiplyScalar(radius)); const distanceFromCluster = radius; const distanceFromRoot = rootNode.position.distanceTo(pos); const level = 2 + Math.floor(distanceFromCluster / 3); const isLeaf = Math.random() < 0.5; const newNode = new Node(pos, level, isLeaf ? 1 : 0); newNode.distanceFromRoot = distanceFromRoot; newNode.clusterRef = cluster; nodes.push(newNode); const strength = 0.7 * (1 - distanceFromCluster / cloudRadius); cluster.addConnection(newNode, strength); const nearbyNodes = nodes.filter(n => n !== newNode && n !== cluster && n.clusterRef === cluster && n.position.distanceTo(pos) < cloudRadius * 0.4 ); const connectionsCount = Math.floor(Math.random() * 3); nearbyNodes.sort((a, b) => pos.distanceTo(a.position) - pos.distanceTo(b.position)); for (let j = 0; j < Math.min(connectionsCount, nearbyNodes.length); j++) { const dist = pos.distanceTo(nearbyNodes[j].position); const connStrength = 0.4 * (1 - dist / (cloudRadius * 0.4)); newNode.addConnection(nearbyNodes[j], connStrength); } } } const interClusterCount = Math.floor(15 * densityFactor); for (let i = 0; i < interClusterCount; i++) { const cluster1 = clusterNodes[Math.floor(Math.random() * clusterNodes.length)]; let cluster2; do { cluster2 = clusterNodes[Math.floor(Math.random() * clusterNodes.length)]; } while (cluster2 === cluster1); const bridgePos = new THREE.Vector3().lerpVectors(cluster1.position, cluster2.position, 0.3 + Math.random() * 0.4); bridgePos.add(new THREE.Vector3( THREE.MathUtils.randFloatSpread(5), THREE.MathUtils.randFloatSpread(5), THREE.MathUtils.randFloatSpread(5) )); const bridgeNode = new Node(bridgePos, 2, 0); bridgeNode.distanceFromRoot = rootNode.position.distanceTo(bridgePos); nodes.push(bridgeNode); cluster1.addConnection(bridgeNode, 0.5); cluster2.addConnection(bridgeNode, 0.5); const nearbyNodes = nodes.filter(n => n !== bridgeNode && n !== cluster1 && n !== cluster2 && n.position.distanceTo(bridgePos) < 8); if (nearbyNodes.length > 0) { const target = nearbyNodes[Math.floor(Math.random() * nearbyNodes.length)]; bridgeNode.addConnection(target, 0.4); } } const longRangeCount = Math.floor(10 * densityFactor); const outerNodes = nodes.filter(n => n.distanceFromRoot > maxDist * 0.6) .sort(() => Math.random() - 0.5) .slice(0, longRangeCount); for (const outerNode of outerNodes) { const numSegments = 2 + Math.floor(Math.random() * 2); let prevNode = outerNode; for (let i = 1; i <= numSegments; i++) { const t = i / (numSegments + 1); const segPos = outerNode.position.clone().multiplyScalar(1 - t * 0.8); segPos.add(new THREE.Vector3( THREE.MathUtils.randFloatSpread(4), THREE.MathUtils.randFloatSpread(4), THREE.MathUtils.randFloatSpread(4) )); const newNode = new Node(segPos, outerNode.level, 0); newNode.distanceFromRoot = rootNode.position.distanceTo(segPos); nodes.push(newNode); prevNode.addConnection(newNode, 0.6); prevNode = newNode; } const innerNodes = nodes.filter(n => n.distanceFromRoot < maxDist * 0.4 && n !== rootNode); if (innerNodes.length > 0) { const targetNode = innerNodes[Math.floor(Math.random() * innerNodes.length)]; prevNode.addConnection(targetNode, 0.5); } } } switch (formationIndex % 4) { case 0: generateQuantumCortex(); break; case 1: generateHyperdimensionalMesh(); break; case 2: generateNeuralVortex(); break; case 3: generateSynapticCloud(); break; } if (densityFactor < 1.0) { const originalNodeCount = nodes.length; nodes = nodes.filter((node, index) => { if (node === rootNode) return true; const hash = (index * 31 + Math.floor(densityFactor * 100)) % 100; return hash < (densityFactor * 100); }); nodes.forEach(node => { node.connections = node.connections.filter(conn => nodes.includes(conn.node)); }); console.log(`Density Filter: ${originalNodeCount} -> ${nodes.length} nodes`); } return { nodes, rootNode }; } let neuralNetwork = null, nodesMesh = null, connectionsMesh = null; function createNetworkVisualization(formationIndex, densityFactor = 1.0) { console.log(`Creating formation ${formationIndex}, density ${densityFactor}`); if (nodesMesh) { scene.remove(nodesMesh); nodesMesh.geometry.dispose(); nodesMesh.material.dispose(); nodesMesh = null; } if (connectionsMesh) { scene.remove(connectionsMesh); connectionsMesh.geometry.dispose(); connectionsMesh.material.dispose(); connectionsMesh = null; } neuralNetwork = generateNeuralNetwork(formationIndex, densityFactor); if (!neuralNetwork || neuralNetwork.nodes.length === 0) { console.error(\"Network generation failed or resulted in zero nodes.\"); return; } const nodesGeometry = new THREE.BufferGeometry(); const nodePositions = [], nodeTypes = [], nodeSizes = [], nodeColors = [], connectionIndices = [], distancesFromRoot = []; neuralNetwork.nodes.forEach((node, index) => { nodePositions.push(node.position.x, node.position.y, node.position.z); nodeTypes.push(node.type); nodeSizes.push(node.size); distancesFromRoot.push(node.distanceFromRoot); const indices = node.connections.slice(0, 3).map(conn => neuralNetwork.nodes.indexOf(conn.node)); while (indices.length < 3) indices.push(-1); connectionIndices.push(...indices); const palette = colorPalettes[config.activePaletteIndex]; const colorIndex = Math.min(node.level, palette.length - 1); const baseColor = palette[colorIndex % palette.length].clone(); baseColor.offsetHSL( THREE.MathUtils.randFloatSpread(0.05), THREE.MathUtils.randFloatSpread(0.1), THREE.MathUtils.randFloatSpread(0.1) ); nodeColors.push(baseColor.r, baseColor.g, baseColor.b); }); nodesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nodePositions, 3)); nodesGeometry.setAttribute('nodeType', new THREE.Float32BufferAttribute(nodeTypes, 1)); nodesGeometry.setAttribute('nodeSize', new THREE.Float32BufferAttribute(nodeSizes, 1)); nodesGeometry.setAttribute('nodeColor', new THREE.Float32BufferAttribute(nodeColors, 3)); nodesGeometry.setAttribute('connectionIndices', new THREE.Float32BufferAttribute(connectionIndices, 3)); nodesGeometry.setAttribute('distanceFromRoot', new THREE.Float32BufferAttribute(distancesFromRoot, 1)); const nodesMaterial = new THREE.ShaderMaterial({ uniforms: THREE.UniformsUtils.clone(pulseUniforms), vertexShader: nodeShader.vertexShader, fragmentShader: nodeShader.fragmentShader, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }); nodesMesh = new THREE.Points(nodesGeometry, nodesMaterial); scene.add(nodesMesh); const connectionsGeometry = new THREE.BufferGeometry(); const connectionColors = [], connectionStrengths = [], connectionPositions = [], startPoints = [], endPoints = [], pathIndices = []; const processedConnections = new Set(); let pathIndex = 0; neuralNetwork.nodes.forEach((node, nodeIndex) => { node.connections.forEach(connection => { const connectedNode = connection.node; const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode); if (connectedIndex === -1) return; const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-'); if (!processedConnections.has(key)) { processedConnections.add(key); const startPoint = node.position; const endPoint = connectedNode.position; const numSegments = 15; for (let i = 0; i < numSegments; i++) { const t = i / (numSegments - 1); connectionPositions.push(t, 0, 0); startPoints.push(startPoint.x, startPoint.y, startPoint.z); endPoints.push(endPoint.x, endPoint.y, endPoint.z); pathIndices.push(pathIndex); connectionStrengths.push(connection.strength); const palette = colorPalettes[config.activePaletteIndex]; const avgLevel = Math.min(Math.floor((node.level + connectedNode.level) / 2), palette.length - 1); const baseColor = palette[avgLevel % palette.length].clone(); baseColor.offsetHSL( THREE.MathUtils.randFloatSpread(0.05), THREE.MathUtils.randFloatSpread(0.1), THREE.MathUtils.randFloatSpread(0.1) ); connectionColors.push(baseColor.r, baseColor.g, baseColor.b); } pathIndex++; } }); }); connectionsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(connectionPositions, 3)); connectionsGeometry.setAttribute('startPoint', new THREE.Float32BufferAttribute(startPoints, 3)); connectionsGeometry.setAttribute('endPoint', new THREE.Float32BufferAttribute(endPoints, 3)); connectionsGeometry.setAttribute('connectionStrength', new THREE.Float32BufferAttribute(connectionStrengths, 1)); connectionsGeometry.setAttribute('connectionColor', new THREE.Float32BufferAttribute(connectionColors, 3)); connectionsGeometry.setAttribute('pathIndex', new THREE.Float32BufferAttribute(pathIndices, 1)); const connectionsMaterial = new THREE.ShaderMaterial({ uniforms: THREE.UniformsUtils.clone(pulseUniforms), vertexShader: connectionShader.vertexShader, fragmentShader: connectionShader.fragmentShader, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }); connectionsMesh = new THREE.LineSegments(connectionsGeometry, connectionsMaterial); scene.add(connectionsMesh); const palette = colorPalettes[config.activePaletteIndex]; connectionsMaterial.uniforms.uPulseColors.value[0].copy(palette[0]); connectionsMaterial.uniforms.uPulseColors.value[1].copy(palette[1]); connectionsMaterial.uniforms.uPulseColors.value[2].copy(palette[2]); nodesMaterial.uniforms.uPulseColors.value[0].copy(palette[0]); nodesMaterial.uniforms.uPulseColors.value[1].copy(palette[1]); nodesMaterial.uniforms.uPulseColors.value[2].copy(palette[2]); nodesMaterial.uniforms.uActivePalette.value = config.activePaletteIndex; } function updateTheme(paletteIndex) { config.activePaletteIndex = paletteIndex; if (!nodesMesh || !connectionsMesh) return; const palette = colorPalettes[paletteIndex]; const nodeColorsAttr = nodesMesh.geometry.attributes.nodeColor; const nodeLevels = neuralNetwork.nodes.map(n => n.level); for (let i = 0; i < nodeColorsAttr.count; i++) { const node = neuralNetwork.nodes[i]; if (!node) continue; const colorIndex = Math.min(node.level, palette.length - 1); const baseColor = palette[colorIndex % palette.length].clone(); baseColor.offsetHSL( THREE.MathUtils.randFloatSpread(0.05), THREE.MathUtils.randFloatSpread(0.1), THREE.MathUtils.randFloatSpread(0.1) ); nodeColorsAttr.setXYZ(i, baseColor.r, baseColor.g, baseColor.b); } nodeColorsAttr.needsUpdate = true; const connectionColors = []; const processedConnections = new Set(); neuralNetwork.nodes.forEach((node, nodeIndex) => { node.connections.forEach(connection => { const connectedNode = connection.node; const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode); if (connectedIndex === -1) return; const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-'); if (!processedConnections.has(key)) { processedConnections.add(key); const numSegments = 15; for (let i = 0; i < numSegments; i++) { const avgLevel = Math.min(Math.floor((node.level + connectedNode.level) / 2), palette.length - 1); const baseColor = palette[avgLevel % palette.length].clone(); baseColor.offsetHSL( THREE.MathUtils.randFloatSpread(0.05), THREE.MathUtils.randFloatSpread(0.1), THREE.MathUtils.randFloatSpread(0.1) ); connectionColors.push(baseColor.r, baseColor.g, baseColor.b); } } }); }); connectionsMesh.geometry.setAttribute('connectionColor', new THREE.Float32BufferAttribute(connectionColors, 3)); connectionsMesh.geometry.attributes.connectionColor.needsUpdate = true; nodesMesh.material.uniforms.uPulseColors.value.forEach((c, i) => c.copy(palette[i % palette.length])); connectionsMesh.material.uniforms.uPulseColors.value.forEach((c, i) => c.copy(palette[i % palette.length])); nodesMesh.material.uniforms.uActivePalette.value = paletteIndex; } const raycaster = new THREE.Raycaster(); const pointer = new THREE.Vector2(); const interactionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); const interactionPoint = new THREE.Vector3(); let lastPulseIndex = 0; function triggerPulse(clientX, clientY) { pointer.x = (clientX / window.innerWidth) * 2 - 1; pointer.y = -(clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(pointer, camera); interactionPlane.normal.copy(camera.position).normalize(); interactionPlane.constant = -interactionPlane.normal.dot(camera.position) + camera.position.length() * 0.5; if (raycaster.ray.intersectPlane(interactionPlane, interactionPoint)) { const time = clock.getElapsedTime(); if (nodesMesh && connectionsMesh) { lastPulseIndex = (lastPulseIndex + 1) % 3; nodesMesh.material.uniforms.uPulsePositions.value[lastPulseIndex].copy(interactionPoint); nodesMesh.material.uniforms.uPulseTimes.value[lastPulseIndex] = time; connectionsMesh.material.uniforms.uPulsePositions.value[lastPulseIndex].copy(interactionPoint); connectionsMesh.material.uniforms.uPulseTimes.value[lastPulseIndex] = time; const palette = colorPalettes[config.activePaletteIndex]; const randomColor = palette[Math.floor(Math.random() * palette.length)]; nodesMesh.material.uniforms.uPulseColors.value[lastPulseIndex].copy(randomColor); connectionsMesh.material.uniforms.uPulseColors.value[lastPulseIndex].copy(randomColor); } } } renderer.domElement.addEventListener('click', (e) => { if (e.target.closest('.ui-panel, #control-buttons')) return; if (!config.paused) triggerPulse(e.clientX, e.clientY); }); renderer.domElement.addEventListener('touchstart', (e) => { if (e.target.closest('.ui-panel, #control-buttons')) return; e.preventDefault(); if (e.touches.length > 0 && !config.paused) { triggerPulse(e.touches[0].clientX, e.touches[0].clientY); } }, { passive: false }); const themeButtons = document.querySelectorAll('.theme-button'); themeButtons.forEach(btn => { btn.addEventListener('click', (e) => { e.stopPropagation(); const idx = parseInt(btn.dataset.theme, 10); updateTheme(idx); themeButtons.forEach(b => b.classList.remove('active')); btn.classList.add('active'); }); }); const densitySlider = document.getElementById('density-slider'); const densityValue = document.getElementById('density-value'); let densityTimeout; densitySlider.addEventListener('input', (e) => { e.stopPropagation(); const val = parseInt(densitySlider.value, 10); config.densityFactor = val / 100; densityValue.textContent = `${val}%`; clearTimeout(densityTimeout); densityTimeout = setTimeout(() => { createNetworkVisualization(config.currentFormation, config.densityFactor); }, 300); }); const changeFormationBtn = document.getElementById('change-formation-btn'); const pausePlayBtn = document.getElementById('pause-play-btn'); const resetCameraBtn = document.getElementById('reset-camera-btn'); changeFormationBtn.addEventListener('click', (e) => { e.stopPropagation(); config.currentFormation = (config.currentFormation + 1) % config.numFormations; createNetworkVisualization(config.currentFormation, config.densityFactor); controls.autoRotate = false; setTimeout(() => { controls.autoRotate = true; }, 2000); }); pausePlayBtn.addEventListener('click', (e) => { e.stopPropagation(); config.paused = !config.paused; pausePlayBtn.textContent = config.paused ? 'Play' : 'Pause'; controls.autoRotate = !config.paused; }); resetCameraBtn.addEventListener('click', (e) => { e.stopPropagation(); controls.reset(); controls.autoRotate = false; setTimeout(() => { controls.autoRotate = true; }, 1500); }); const clock = new THREE.Clock(); function animate() { requestAnimationFrame(animate); const t = clock.getElapsedTime(); if (!config.paused) { if (nodesMesh) { nodesMesh.material.uniforms.uTime.value = t; nodesMesh.rotation.y = Math.sin(t * 0.05) * 0.08; } if (connectionsMesh) { connectionsMesh.material.uniforms.uTime.value = t; connectionsMesh.rotation.y = Math.sin(t * 0.05) * 0.08; } } starField.rotation.y += 0.0003; controls.update(); composer.render(); } function init() { createNetworkVisualization(config.currentFormation, config.densityFactor); document.querySelectorAll('.theme-button').forEach(b => b.classList.remove('active')); document.querySelector(`.theme-button[data-theme=\"${config.activePaletteIndex}\"]`).classList.add('active'); updateTheme(config.activePaletteIndex); animate(); } function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); bloomPass.resolution.set(window.innerWidth, window.innerHeight); } window.addEventListener('resize', onWindowResize); init(); </script>\nstyle.css: \nscript.js: ",
    "id": "interactive-neural-network-viz"
  },
  {
    "title": "The 4 color formula",
    "description": "",
    "code": "index.html: <svg onclick=\"dark()\" id=\"dark\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\"> <path d=\"M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z\" /> </svg> <div class=\"c1\"> <h1>You need <span>4</span> colors</h1> <p>2 for text and background(primary & secondary colors). 1 accent color to highlight important elements(number 4 & link). And an optional tertiary color to add a bit of personality(the hue slider).</p> <a href=\"https://youtu.be/AmY3db_Qs94\">How it works?</a> <div class=\"controls\"> <p>Hue</p> <input type=\"range\" id=\"hue-slider\" min=\"0\" max=\"360\" value=\"0\"> <input type=\"number\" id=\"hue-value\"> </div> </div> <div class=\"c2\"> <pre id=\"code\">:root { --color-primary: hsl(0, 50%, 90%); --color-secondary: hsl(0, 50%, 10%); --color-tertiary: hsl(60, 80%, 20%); --color-accent: hsl(300, 80%, 20%); } .dark { --color-primary: hsl(0, 50%, 10%); --color-secondary: hsl(0, 50%, 90%); --color-tertiary: hsl(60, 80%, 80%); --color-accent: hsl(300, 80%, 80%); }</pre> </div>\nstyle.css: @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=Syne:wght@400..800&display=swap'); :root { --ff: \"Syne\", sans-serif; --ff2: \"Fira Code\", monospace; --h1: 800 2rem/1.2em var(--ff); --p: 400 1rem/1.5em var(--ff); --p-code: 300 .7rem/2em var(--ff2); --hue: 0; /* The formula starts here */ --tertiary-hue: calc(var(--hue) + 300); --accent-hue: calc(var(--hue) + 60); --primary-color: hsl(var(--hue), 50%, 90%); --pre-primary-color: hsl(var(--hue), 50%, 95%); --secondary-color: hsl(var(--hue), 50%, 10%); --tertiary-color: hsl(var(--tertiary-hue), 80%, 20%); --accent-color: hsl(var(--accent-hue), 80%, 20%); } .dark { --primary-color: hsl(var(--hue), 50%, 10%); --pre-primary-color: hsl(var(--hue), 50%, 15%); --secondary-color: hsl(var(--hue), 50%, 90%); --tertiary-color: hsl(var(--tertiary-hue), 80%, 80%); --accent-color: hsl(var(--accent-hue), 80%, 80%); } /* The formula ends here */ body { width: 90%; max-width: 1080px; margin: 40px auto; display: flex; height: 80vh; align-items: center; gap: 20px; background: var(--primary-color); color: var(--secondary-color); font-family: var(--ff); font: var(--p); } .c1{flex: 1;} #dark { width: 12px; fill: var(--secondary-color); cursor: pointer; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: var(--pre-primary-color); padding: 8px 11px; border-radius: 20px; box-shadow: 0 2px 2px hsla(var(--hue), 50%, 10%, .3), 0 4px 4px hsla(var(--hue), 50%, 10%, .15); } a{ font: 800 1rem/1em var(--ff); color: var(--accent-color); margin-right: 20px; text-underline-offset: 4px; } h1{ font: var(--h1); } span{ color: var(--accent-color); } .controls{ margin-top: 40px; display: flex; align-items: center; gap: 20px; } input[type=\"range\"] { -webkit-appearance: none; appearance: none; width: 70%; height: 4px; background: var(--tertiary-color); border-radius: 5px; outline: none; } input[type=\"range\"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 8px; height: 24px; background: var(--tertiary-color); border-radius: 4px; } input[type=\"number\"] { -webkit-appearance: none; appearance: none; color: var(--secondary-color); font: var(--p); padding: 8px; width: 40px; height: 20px; border: solid 1px var(--tertiary-color); border-radius: 4px; background: transparent; } input[type=\"number\"]::-webkit-inner-spin-button, input[type=\"number\"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; } .c2{ flex: 1; font: var(--p-code); background: var(--pre-primary-color); color: var(--secondary-color); padding: 40px; border-radius: 20px; box-shadow: 0 2px 2px hsla(var(--hue), 50%, 10%, .3), 0 4px 4px hsla(var(--hue), 50%, 10%, .15); } @media (max-width: 800px) { body { flex-direction: column; height: 90vh; } .c2{ width: 90%; padding: 20px; } }\nscript.js: const hueSlider = document.getElementById('hue-slider'); const hueValueInput = document.getElementById('hue-value'); function updateHue(hue) { hueSlider.value = hue; hueValueInput.value = hue; document.documentElement.style.setProperty('--hue', hue); hue = Number(hue); let ahue = hue + 60; ; let a2hue = hue + 300; if (hue > 300) { ahue = hue + 60 - 360; } if (hue > 60) { a2hue = hue + 300 - 360; } code.textContent = `:root { --color-primary: hsl(${hue}, 50%, 90%); --color-secondary: hsl(${hue}, 50%, 10%); --color-tertiary: hsl(${ahue}, 80%, 20%); --color-accent: hsl(${a2hue}, 80%, 20%); } .dark { --color-primary: hsl(${hue}, 50%, 10%); --color-secondary: hsl(${hue}, 50%, 90%); --color-tertiary: hsl(${ahue}, 80%, 80%); --color-accent: hsl(${a2hue}, 80%, 80%); }` } hueSlider.addEventListener('input', function () { updateHue(hueSlider.value); }); hueValueInput.addEventListener('input', function () { const hue = hueValueInput.value; if (hue >= 0 && hue <= 360) { updateHue(hue); } }); function dark() { document.body.classList.toggle(\"dark\"); }",
    "id": "the-4-color-formula"
  },
  {
    "title": "[javascript] \u274d Golden Spiral",
    "description": "",
    "code": "index.html: <div id=\"spiral\"></div>\nstyle.css: html, body { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; display: flex; align-items: center; justify-content: center; overflow: hidden; } #spiral { width: 400px; height: 400px; } circle { fill: #fff; opacity: 0.6; }\nscript.js: (function () { const N = 600; // total dots const SIZE = 400; // SVG px const DOT_RADIUS = 2; // px const MARGIN = 2; // px padding const DURATION = 3; // seconds per pulse cycle const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5)); // 2\u03c0/\u03c6\u00b2 const CENTER = SIZE / 2; const MAX_RADIUS = CENTER - MARGIN - DOT_RADIUS; const svgNS = \"http://www.w3.org/2000/svg\"; // Create SVG root const svg = document.createElementNS(svgNS, \"svg\"); svg.setAttribute(\"width\", SIZE); svg.setAttribute(\"height\", SIZE); svg.setAttribute(\"viewBox\", `0 0 ${SIZE} ${SIZE}`); document.getElementById(\"spiral\").appendChild(svg); // Generate & animate dots for (let i = 0; i < N; i++) { const idx = i + 0.5; const frac = idx / N; const r = Math.sqrt(frac) * MAX_RADIUS; const theta = idx * GOLDEN_ANGLE; const x = CENTER + r * Math.cos(theta); const y = CENTER + r * Math.sin(theta); // Perfect SVG circle const c = document.createElementNS(svgNS, \"circle\"); c.setAttribute(\"cx\", x); c.setAttribute(\"cy\", y); c.setAttribute(\"r\", DOT_RADIUS); svg.appendChild(c); // Radius pulse const animR = document.createElementNS(svgNS, \"animate\"); animR.setAttribute(\"attributeName\", \"r\"); animR.setAttribute( \"values\", `${DOT_RADIUS * 0.5};${DOT_RADIUS * 1.5};${DOT_RADIUS * 0.5}` ); animR.setAttribute(\"dur\", `${DURATION}s`); animR.setAttribute(\"begin\", `${frac * DURATION}s`); animR.setAttribute(\"repeatCount\", \"indefinite\"); animR.setAttribute(\"calcMode\", \"spline\"); animR.setAttribute(\"keySplines\", \"0.4 0 0.6 1;0.4 0 0.6 1\"); c.appendChild(animR); // Opacity pulse const animO = document.createElementNS(svgNS, \"animate\"); animO.setAttribute(\"attributeName\", \"opacity\"); animO.setAttribute(\"values\", \"0.3;1;0.3\"); animO.setAttribute(\"dur\", `${DURATION}s`); animO.setAttribute(\"begin\", `${frac * DURATION}s`); animO.setAttribute(\"repeatCount\", \"indefinite\"); animO.setAttribute(\"calcMode\", \"spline\"); animO.setAttribute(\"keySplines\", \"0.4 0 0.6 1;0.4 0 0.6 1\"); c.appendChild(animO); } })();",
    "id": "javascript--golden-spiral"
  },
  {
    "title": "184. instancing 1.b spherical",
    "description": "",
    "code": "index.html: <script type='importmap'> { \"imports\": { \"three\": \"https://unpkg.com/three@~0.181/build/three.webgpu.js\", \"three/webgpu\": \"https://unpkg.com/three@~0.181/build/three.webgpu.js\", \"three/addons/\": \"https://unpkg.com/three@~0.181/examples/jsm/\", \"YCW_tsl_x\": \"https://cdn.jsdelivr.net/gh/ycw/tsl-x@08c3e94c8d9e4b5f6351891be48f5a4a1c23ed9e/src/index.js\" } } </script> <h1> <a href='https://x.com/ycwhk' target='_top'>instancing 1.b spherical</a> <br> <a href='https://codepen.io/ycw/full/WbrLqyK' target='_top'>ref: instancing 1</a> <br> <a href='https://codepen.io/ycw/full/ByjEBZe' target='_top'>ref: spherical node</a> </h1>\nstyle.css: html,body {background:repeating-conic-gradient(#ccc 0% 25%,#fff 0% 50%) 0 0 / 16px 16px} canvas {display:block;width:100%;height:100vh;cursor:grab} h1 {position:fixed;top:0;left:0;padding:1em;margin:1em;background:#fffb;backdrop-filter:blur(2px)}\nscript.js: import * as THREE from 'three/webgpu' import { TSL as $ } from 'three/webgpu' import { OrbitControls } from 'three/addons/controls/OrbitControls.js' import * as $$ from 'YCW_tsl_x' const renderer = await new THREE.WebGPURenderer().init() const scene = new THREE.Scene() const camera = new THREE.PerspectiveCamera(35, 2, 0.1, 100) const controls = new OrbitControls(camera, renderer.domElement) camera.position.set(2, 1, 1) const radius_segments = 10 const azimuth_segments = 32 const inclination_segments = 16 const cells_count = azimuth_segments * inclination_segments * radius_segments const geom = new THREE.BoxGeometry(0.1, 0.1, 0.1) const mat = new THREE.MeshBasicNodeMaterial() scene.add(new THREE.InstancedMesh(geom, mat, cells_count)) const ii = $.instanceIndex.toFloat() const radius = ii.div(azimuth_segments * inclination_segments).floor().div(radius_segments).remap(0, 1, 0.3, 0.5) const azimuth = ii.mod(azimuth_segments * inclination_segments).mod(azimuth_segments) const azimuth01 = $$.mirrored_repeat(azimuth.div(azimuth_segments).mul(2)) // sym const inclination = ii.mod(azimuth_segments * inclination_segments).div(azimuth_segments).floor() const inclination01 = inclination.div(inclination_segments).remap(0, 1, 1 / inclination_segments, 1 - 1 / inclination_segments) // opened const spherical3d01 = $.vec3(radius, azimuth01, inclination01) const cartesian3d = $$.spherical3d01_to_cartesian3d(spherical3d01, $.vec3(0, 0, 0)) const cell_scale = $.mx_noise_float(cartesian3d.add($.time)).remap(-1, 1, 0, 1).smoothstep(0.4, 0.8) mat.positionNode = $.positionLocal.mul(cell_scale).add(cartesian3d) mat.colorNode = $.mix($.color('black'), $.color('cyan'), $.smoothstep(0.4, 0.7, cell_scale)) renderer.setAnimationLoop(() => renderer.render(scene, camera)) addEventListener('resize', () => { renderer.setPixelRatio(devicePixelRatio) renderer.setSize(innerWidth, innerHeight, false) camera.aspect = innerWidth / innerHeight camera.updateProjectionMatrix() }) dispatchEvent(new Event('resize')) document.body.prepend(renderer.domElement) controls.update()",
    "id": "184-instancing-1b-spherical"
  },
  {
    "title": "20.",
    "description": "",
    "code": "index.html: \nstyle.css: canvas { display:block; width:100%; height:100vh; }\nscript.js: import * as $ from '//unpkg.com/three@0.124.0/build/three.module.js' import { OrbitControls } from '//unpkg.com/three@0.124.0/examples/jsm/controls/OrbitControls.js' import { EffectComposer } from '//unpkg.com/three@0.124.0/examples/jsm/postprocessing/EffectComposer' import { RenderPass } from '//unpkg.com/three@0.124.0/examples/jsm/postprocessing/RenderPass' import { UnrealBloomPass } from '//unpkg.com/three@0.124.0/examples/jsm/postprocessing/UnrealBloomPass' import { Curves } from '//unpkg.com/three@0.124.0/examples/jsm/curves/CurveExtras' // ---- boot const renderer = new $.WebGLRenderer({}); const scene = new $.Scene(); const camera = new $.PerspectiveCamera(75, 2, .01, 5000); window.addEventListener('resize', () => { const { clientWidth, clientHeight } = renderer.domElement; renderer.setSize(clientWidth, clientHeight, false); renderer.setPixelRatio(window.devicePixelRatio); camera.aspect = clientWidth / clientHeight; camera.updateProjectionMatrix(); }); document.body.prepend(renderer.domElement); window.dispatchEvent(new Event('resize')); // ---- setup scene.fog = new $.FogExp2('black', 0.05); scene.add(new $.HemisphereLight('cyan', 'orange', 2)); // ---- const const mpms = (20) / 1e3; const steps = 2000; // ---- mesh const shape = new $.Shape(); // cw shape.moveTo(-5, -1); shape.quadraticCurveTo(0, -4, 5, -1); shape.lineTo(6, -1); shape.quadraticCurveTo(0, -5, -6, -1); const extrudePath = new Curves.TorusKnot(); const UVGenerator = (() => { let i = 0; // face id return { generateTopUV(...xs) { // for 2 \"cap\" faces return [new $.Vector2(), new $.Vector2(), new $.Vector2()]; }, generateSideWallUV(_geom, _vs, _a, _b, _c, _d) { // all side faces const segments = 5; // (shape-related; NOT eq `curveSegments`) if (i < segments * steps) { // ignore bottom road faces ++i; return [new $.Vector2(), new $.Vector2(), new $.Vector2(), new $.Vector2()]; } const n = i - segments * steps; // offseted face idx const total_col_segments = 7; // (shape-related) const col = n / steps | 0; const left = col / total_col_segments; // normalize const right = (col + 1) / total_col_segments; // normalize const row = n % steps; const bottom = row / steps; // normalize const top = (row + 1) / steps; // normalize ++i; return [ new $.Vector2(left, bottom), // bottom left new $.Vector2(right, bottom), // bottom right new $.Vector2(right, top), // top right new $.Vector2(left, top) // top left ]; } }; })(); const extrudeGeom = new $.ExtrudeBufferGeometry(shape, { bevelEnabled: false, steps, extrudePath, curveSegments: 5, UVGenerator }); const matSideWall = f(); const matTop = new $.MeshLambertMaterial({ color: 'black' }); const mesh = new $.Mesh(extrudeGeom, [matTop, matSideWall]); scene.add(mesh); // ---- composer const composer = new EffectComposer(renderer); composer.addPass(new RenderPass(scene, camera)); composer.addPass(new UnrealBloomPass(new $.Vector2(), 2, 0.5, 0.7)); // ---- anim const totalLen = extrudePath.getLength(); const { binormals } = extrudePath.computeFrenetFrames(steps); const $m = new $.Matrix4(); // rotation matrix renderer.setAnimationLoop((t /*ms*/) => { const $u = ((mpms * t) % totalLen) / totalLen; // update cam position extrudePath.getPointAt($u, camera.position); // update cam rotation camera.setRotationFromMatrix($m.lookAt( /* eye */ camera.position, /* target */ extrudePath.getPointAt(Math.min(1.0, $u + 0.01)), /* up */ binormals[$u * steps | 0] )); renderer.getDrawingBufferSize(composer.passes[1].resolution); composer.render(); mesh.material[1].uniforms.t.value = t; }); // ---- sidewall material function f() { const url = 'https://images.unsplash.com/photo-1550747528-cdb45925b3f7?ixid=MXwxMjA3fDB8MHxzZWFyY2h8Mnx8dW5pY29ybnxlbnwwfHwwfA%3D%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=60'; const tex = new $.TextureLoader().load(url); tex.wrapS = $.MirroredRepeatWrapping; tex.wrapT = $.RepeatWrapping; const shader = $.ShaderLib.lambert; const uniforms = $.UniformsUtils.merge([shader.uniforms, { t: { value: 0 }, stretch: { value: new $.Vector2(1, 10) }, div: { value: new $.Vector2(32, 8) }, }]); const vertexShader = ` uniform sampler2D map; uniform vec2 stretch; ` + shader.vertexShader.replace('#include <uv_vertex>', ` #ifdef USE_UV vUv = ( uvTransform * vec3( uv, 1 ) ).xy * stretch; #endif `); const fragmentShader = ` uniform vec2 div; uniform vec2 stretch; uniform float t; ` + shader.fragmentShader.replace('#include <map_fragment>', ` #ifdef USE_MAP { vec2 i = vec2(ivec2( vUv * div )); vec4 tA = texture2D( map, ( i ) / div ); vec4 tB = texture2D( map, ( i + 1.0 ) / div ); vec4 texel = 0.5 * (mix( tA, tB, vUv.x ) + mix( tA, tB, vUv.y )); texel.b = step( 0.5, texel.b ) + ( sin( t * 0.001 ) * 0.5 + 0.5 ); texel.r *= 2.0; texel.g *= 0.5; vec2 uv = fract( vUv * stretch * div ); texel *= step( 0.2, uv.x ) * step ( 0.2, uv.y ); diffuseColor *= texel; } \t#endif `); const mat = new $.ShaderMaterial({ uniforms, vertexShader, fragmentShader, lights: true, fog: true }); mat.map = mat.uniforms.map.value = tex; return mat; }",
    "id": "20"
  }
]