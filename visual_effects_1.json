[
  {
    "title": "[webgl/threejs] ‚ùç Spooky Spectral Ghost",
    "description": "",
    "code": "index.html: <!-- Preloader --> <div id=\"preloader\" class=\"preloader\"> <div class=\"preloader-content\"> <div class=\"ghost-loader\"> <svg class=\"ghost-svg\" height=\"80\" viewBox=\"0 0 512 512\" width=\"80\" xmlns=\"http://www.w3.org/2000/svg\"> <!-- Ghost body - white --> <path class=\"ghost-body\" d=\"m508.374 432.802s-46.6-39.038-79.495-275.781c-8.833-87.68-82.856-156.139-172.879-156.139-90.015 0-164.046 68.458-172.879 156.138-32.895 236.743-79.495 275.782-79.495 275.782-15.107 25.181 20.733 28.178 38.699 27.94 35.254-.478 35.254 40.294 70.516 40.294 35.254 0 35.254-35.261 70.508-35.261s37.396 45.343 72.65 45.343 37.389-45.343 72.651-45.343c35.254 0 35.254 35.261 70.508 35.261s35.27-40.772 70.524-40.294c17.959.238 53.798-2.76 38.692-27.94z\" fill=\"white\" /> <!-- Left eye - black with pulsing animation --> <circle class=\"ghost-eye left-eye\" cx=\"208\" cy=\"225\" r=\"22\" fill=\"black\" /> <!-- Right eye - black with pulsing animation --> <circle class=\"ghost-eye right-eye\" cx=\"297\" cy=\"225\" r=\"22\" fill=\"black\" /> </svg> </div> <div class=\"loading-text\">Summoning spirits</div> <div class=\"loading-progress\"> <div class=\"progress-bar\"></div> </div> </div> </div> <!-- Main Content (initially hidden) --> <div class=\"content\" id=\"main-content\"> <div class=\"quote-container\"> <h1 class=\"quote\"> Veil of Dust<br /> Trail of Ash<br /> Heart of Ice </h1> <span class=\"author\">Whispers through memory</span> </div> </div>\nstyle.css: @import url(\"https://fonts.googleapis.com/css2?family=Boldonse&display=swap\"); @font-face { font-family: \"PPSupplyMono\"; src: url(\"https://assets.codepen.io/7558/PPSupplyMono-Variable.woff2\") format(\"woff2\"); font-weight: 100 900; font-style: normal; } * { margin: 0; padding: 0; box-sizing: border-box; } html, body { width: 100%; height: 100%; overflow: hidden; background-color: #111; letter-spacing: -0.03em; } /* Preloader Styles */ .preloader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%); display: flex; justify-content: center; align-items: center; z-index: 10000; opacity: 1; transition: opacity 1s ease-out; } .preloader.fade-out { opacity: 0; pointer-events: none; } .preloader-content { text-align: center; color: #e0e0e0; } .ghost-loader { position: relative; width: 64px; height: 64px; margin: 0 auto 30px; display: flex; justify-content: center; align-items: center; } .ghost-svg { filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.3)); animation: ghostFloat 3s ease-in-out infinite; } .ghost-body { fill: white; opacity: 0.9; } .ghost-eye { fill: black; animation: eyePulse 2s ease-in-out infinite; transform-origin: center; } .left-eye { animation-delay: 0s; } .right-eye { animation-delay: 0.1s; } @keyframes ghostFloat { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-8px); } } @keyframes eyePulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.3); } } /* Remove the old ghost-orb and ghost-trail styles */ .ghost-orb, .ghost-trail { display: none; } .loading-text { font-family: \"PPSupplyMono\", monospace; font-size: 12px; text-transform: uppercase; opacity: 1; margin-bottom: 12px; animation: textPulse 2s ease-in-out infinite; } @keyframes textPulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.1; } } .loading-progress { width: 96px; height: 1px; margin: 0 auto; border-radius: 1px; overflow: hidden; } .progress-bar { height: 100%; background: linear-gradient(90deg, #00ff80, #00cc66); opacity: 0.1; width: 0%; transition: width 0.8s ease; } /* Main Content Styles */ .content { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; text-align: center; color: #e0e0e0; opacity: 0; transition: opacity 1.5s ease-in; } .content.fade-in { opacity: 1; } .quote-container { max-width: 90%; overflow: hidden; } .quote { font-family: \"Boldonse\", system-ui; font-size: 6vw; line-height: 1.3; font-weight: 400; letter-spacing: -0.02em; margin-bottom: 5vh; text-transform: uppercase; } .author { font-family: \"PPSupplyMono\", monospace; font-size: 12px; text-transform: uppercase; opacity: 0.7; margin-top: 2vh; } /* Canvas initially hidden */ canvas { opacity: 0 !important; transition: opacity 2s ease-in; } canvas.fade-in { opacity: 1 !important; }\nscript.js: import * as THREE from \"https://esm.sh/three\"; import { Pane } from \"https://cdn.skypack.dev/tweakpane@4.0.4\"; import { EffectComposer } from \"https://esm.sh/three/examples/jsm/postprocessing/EffectComposer.js\"; import { RenderPass } from \"https://esm.sh/three/examples/jsm/postprocessing/RenderPass.js\"; import { UnrealBloomPass } from \"https://esm.sh/three/examples/jsm/postprocessing/UnrealBloomPass.js\"; import { OutputPass } from \"https://esm.sh/three/examples/jsm/postprocessing/OutputPass.js\"; import { ShaderPass } from \"https://esm.sh/three/examples/jsm/postprocessing/ShaderPass.js\"; // Preloader management class PreloaderManager { constructor() { this.preloader = document.getElementById(\"preloader\"); this.mainContent = document.getElementById(\"main-content\"); this.progressBar = document.querySelector(\".progress-bar\"); this.loadingSteps = 0; this.totalSteps = 5; // Adjust based on loading steps this.isComplete = false; } updateProgress(step) { this.loadingSteps = Math.min(step, this.totalSteps); const percentage = (this.loadingSteps / this.totalSteps) * 100; this.progressBar.style.width = `${percentage}%`; } complete(canvas) { if (this.isComplete) return; this.isComplete = true; // Ensure we're at 100% this.updateProgress(this.totalSteps); // Wait a moment then start the reveal setTimeout(() => { // Fade out preloader this.preloader.classList.add(\"fade-out\"); // Fade in content and canvas simultaneously this.mainContent.classList.add(\"fade-in\"); canvas.classList.add(\"fade-in\"); // Remove preloader from DOM after animation setTimeout(() => { this.preloader.style.display = \"none\"; }, 1000); }, 1500); } } // Initialize preloader const preloader = new PreloaderManager(); // Force browser to use GPU acceleration document.body.style.transform = \"translateZ(0)\"; document.body.style.backfaceVisibility = \"hidden\"; document.body.style.perspective = \"1000px\"; preloader.updateProgress(1); // Create scene const scene = new THREE.Scene(); scene.background = null; const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 ); camera.position.z = 20; preloader.updateProgress(2); // Enhanced renderer with transparency const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: \"high-performance\", alpha: true, premultipliedAlpha: false, stencil: false, depth: true, preserveDrawingBuffer: false }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 0.9; renderer.setClearColor(0x000000, 0); document.body.appendChild(renderer.domElement); // Canvas styling - initially hidden renderer.domElement.style.position = \"absolute\"; renderer.domElement.style.top = \"0\"; renderer.domElement.style.left = \"0\"; renderer.domElement.style.zIndex = \"2\"; renderer.domElement.style.pointerEvents = \"auto\"; renderer.domElement.style.background = \"transparent\"; // Store original bloom values const originalBloomSettings = { strength: 0.3, radius: 1.25, threshold: 0.0 }; // Setup post-processing for bloom effects const composer = new EffectComposer(renderer); const renderPass = new RenderPass(scene, camera); composer.addPass(renderPass); // Fixed bloom settings to avoid transparency issues const bloomPass = new UnrealBloomPass( new THREE.Vector2(window.innerWidth, window.innerHeight), originalBloomSettings.strength, originalBloomSettings.radius, originalBloomSettings.threshold ); composer.addPass(bloomPass); preloader.updateProgress(3); // Analog Decay Shader with simple black/white mode const analogDecayShader = { uniforms: { tDiffuse: { value: null }, uTime: { value: 0.0 }, uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }, uAnalogGrain: { value: 0.4 }, uAnalogBleeding: { value: 1.0 }, uAnalogVSync: { value: 1.0 }, uAnalogScanlines: { value: 1.0 }, uAnalogVignette: { value: 1.0 }, uAnalogJitter: { value: 0.4 }, uAnalogIntensity: { value: 0.6 }, uLimboMode: { value: 0.0 } }, vertexShader: ` varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `, fragmentShader: ` uniform sampler2D tDiffuse; uniform float uTime; uniform vec2 uResolution; uniform float uAnalogGrain; uniform float uAnalogBleeding; uniform float uAnalogVSync; uniform float uAnalogScanlines; uniform float uAnalogVignette; uniform float uAnalogJitter; uniform float uAnalogIntensity; uniform float uLimboMode; varying vec2 vUv; float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123); } float random(float x) { return fract(sin(x) * 43758.5453123); } // Advanced procedural grain based on film grain simulation float gaussian(float z, float u, float o) { return (1.0 / (o * sqrt(2.0 * 3.1415))) * exp(-(((z - u) * (z - u)) / (2.0 * (o * o)))); } vec3 grain(vec2 uv, float time, float intensity) { float seed = dot(uv, vec2(12.9898, 78.233)); float noise = fract(sin(seed) * 43758.5453 + time * 2.0); noise = gaussian(noise, 0.0, 0.5 * 0.5); return vec3(noise) * intensity; } void main() { vec2 uv = vUv; float time = uTime * 1.8; // Analog Jitter - temporal instability vec2 jitteredUV = uv; if (uAnalogJitter > 0.01) { float jitterAmount = (random(vec2(floor(time * 60.0))) - 0.5) * 0.003 * uAnalogJitter * uAnalogIntensity; jitteredUV.x += jitterAmount; jitteredUV.y += (random(vec2(floor(time * 30.0) + 1.0)) - 0.5) * 0.001 * uAnalogJitter * uAnalogIntensity; } // VHS-style vertical sync roll if (uAnalogVSync > 0.01) { float vsyncRoll = sin(time * 2.0 + uv.y * 100.0) * 0.02 * uAnalogVSync * uAnalogIntensity; float vsyncChance = step(0.95, random(vec2(floor(time * 4.0)))); jitteredUV.y += vsyncRoll * vsyncChance; } vec4 color = texture2D(tDiffuse, jitteredUV); // Color bleeding/channel separation if (uAnalogBleeding > 0.01) { float bleedAmount = 0.012 * uAnalogBleeding * uAnalogIntensity; float offsetPhase = time * 1.5 + uv.y * 20.0; vec2 redOffset = vec2(sin(offsetPhase) * bleedAmount, 0.0); vec2 blueOffset = vec2(-sin(offsetPhase * 1.1) * bleedAmount * 0.8, 0.0); float r = texture2D(tDiffuse, jitteredUV + redOffset).r; float g = texture2D(tDiffuse, jitteredUV).g; float b = texture2D(tDiffuse, jitteredUV + blueOffset).b; color = vec4(r, g, b, color.a); } // Improved procedural film grain if (uAnalogGrain > 0.01) { vec3 grainEffect = grain(uv, time, 0.075 * uAnalogGrain * uAnalogIntensity); grainEffect *= (1.0 - color.rgb); color.rgb += grainEffect; } // Scanlines if (uAnalogScanlines > 0.01) { float scanlineFreq = 600.0 + uAnalogScanlines * 400.0; float scanlinePattern = sin(uv.y * scanlineFreq) * 0.5 + 0.5; float scanlineIntensity = 0.1 * uAnalogScanlines * uAnalogIntensity; color.rgb *= (1.0 - scanlinePattern * scanlineIntensity); float horizontalLines = sin(uv.y * scanlineFreq * 0.1) * 0.02 * uAnalogScanlines * uAnalogIntensity; color.rgb *= (1.0 - horizontalLines); } // Vignetting if (uAnalogVignette > 0.01) { vec2 vignetteUV = (uv - 0.5) * 2.0; float vignette = 1.0 - dot(vignetteUV, vignetteUV) * 0.3 * uAnalogVignette * uAnalogIntensity; color.rgb *= vignette; } // Simple Limbo Mode (Black and White) if (uLimboMode > 0.5) { float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114)); color.rgb = vec3(gray); } gl_FragColor = color; } ` }; // Add analog decay pass const analogDecayPass = new ShaderPass(analogDecayShader); composer.addPass(analogDecayPass); const outputPass = new OutputPass(); composer.addPass(outputPass); // Production parameters with user's specified defaults const params = { // Ghost appearance bodyColor: 0x0f2027, glowColor: \"orange\", eyeGlowColor: \"green\", ghostOpacity: 0.88, ghostScale: 2.4, // Glow effects - updated to match screenshot emissiveIntensity: 5.8, pulseSpeed: 1.6, pulseIntensity: 0.6, // Eyes - updated to match screenshot eyeGlowIntensity: 4.5, eyeGlowDecay: 0.95, eyeGlowResponse: 0.31, // Enhanced lighting rimLightIntensity: 1.8, // Behavior - updated to match screenshot followSpeed: 0.075, wobbleAmount: 0.35, floatSpeed: 1.6, movementThreshold: 0.07, // Particles particleCount: 250, particleDecayRate: 0.005, particleColor: \"orange\", createParticlesOnlyWhenMoving: true, particleCreationRate: 5, // Background reveal - updated to match screenshot revealRadius: 43, fadeStrength: 2.2, baseOpacity: 0.35, revealOpacity: 0.0, // Fireflies fireflyGlowIntensity: 2.6, fireflySpeed: 0.04, // Analog Decay settings - updated to match screenshot analogIntensity: 0.6, analogGrain: 0.4, analogBleeding: 1.0, analogVSync: 1.0, analogScanlines: 1.0, analogVignette: 1.0, analogJitter: 0.4, limboMode: false }; // Fluorescent color palette const fluorescentColors = { cyan: 0x00ffff, lime: 0x00ff00, magenta: 0xff00ff, yellow: 0xffff00, orange: 0xff4500, pink: 0xff1493, purple: 0x9400d3, blue: 0x0080ff, green: 0x00ff80, red: 0xff0040, teal: 0x00ffaa, violet: 0x8a2be2 }; // Create bloom-resistant atmosphere const atmosphereGeometry = new THREE.PlaneGeometry(300, 300); const atmosphereMaterial = new THREE.ShaderMaterial({ uniforms: { ghostPosition: { value: new THREE.Vector3(0, 0, 0) }, revealRadius: { value: params.revealRadius }, fadeStrength: { value: params.fadeStrength }, baseOpacity: { value: params.baseOpacity }, revealOpacity: { value: params.revealOpacity }, time: { value: 0 } }, vertexShader: ` varying vec2 vUv; varying vec3 vWorldPosition; void main() { vUv = uv; vec4 worldPos = modelMatrix * vec4(position, 1.0); vWorldPosition = worldPos.xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `, fragmentShader: ` uniform vec3 ghostPosition; uniform float revealRadius; uniform float fadeStrength; uniform float baseOpacity; uniform float revealOpacity; uniform float time; varying vec2 vUv; varying vec3 vWorldPosition; void main() { float dist = distance(vWorldPosition.xy, ghostPosition.xy); // Pulsing reveal radius float dynamicRadius = revealRadius + sin(time * 2.0) * 5.0; // Create smooth reveal gradient float reveal = smoothstep(dynamicRadius * 0.2, dynamicRadius, dist); reveal = pow(reveal, fadeStrength); // Mix between revealed and base opacity float opacity = mix(revealOpacity, baseOpacity, reveal); // EXTREMELY low RGB values to avoid bloom gl_FragColor = vec4(0.001, 0.001, 0.002, opacity); } `, transparent: true, depthWrite: false }); const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial); atmosphere.position.z = -50; atmosphere.renderOrder = -100; scene.add(atmosphere); // Minimal ambient light const ambientLight = new THREE.AmbientLight(0x0a0a2e, 0.08); scene.add(ambientLight); // Create ghost group const ghostGroup = new THREE.Group(); scene.add(ghostGroup); // Enhanced ghost geometry const ghostGeometry = new THREE.SphereGeometry(2, 40, 40); // Create organic wavy bottom const positionAttribute = ghostGeometry.getAttribute(\"position\"); const positions = positionAttribute.array; for (let i = 0; i < positions.length; i += 3) { if (positions[i + 1] < -0.2) { const x = positions[i]; const z = positions[i + 2]; const noise1 = Math.sin(x * 5) * 0.35; const noise2 = Math.cos(z * 4) * 0.25; const noise3 = Math.sin((x + z) * 3) * 0.15; const combinedNoise = noise1 + noise2 + noise3; positions[i + 1] = -2.0 + combinedNoise; } } ghostGeometry.computeVertexNormals(); // Ghost material const ghostMaterial = new THREE.MeshStandardMaterial({ color: params.bodyColor, transparent: true, opacity: params.ghostOpacity, emissive: fluorescentColors[params.glowColor], emissiveIntensity: params.emissiveIntensity, roughness: 0.02, metalness: 0.0, side: THREE.DoubleSide, alphaTest: 0.1 }); const ghostBody = new THREE.Mesh(ghostGeometry, ghostMaterial); ghostGroup.add(ghostBody); // Rim lights const rimLight1 = new THREE.DirectionalLight( 0x4a90e2, params.rimLightIntensity ); rimLight1.position.set(-8, 6, -4); scene.add(rimLight1); const rimLight2 = new THREE.DirectionalLight( 0x50e3c2, params.rimLightIntensity * 0.7 ); rimLight2.position.set(8, -4, -6); scene.add(rimLight2); preloader.updateProgress(4); // Improved eyes function - 50% bigger eyes function createEyes() { const eyeGroup = new THREE.Group(); ghostGroup.add(eyeGroup); // Create deeper, more realistic eye sockets const socketGeometry = new THREE.SphereGeometry(0.45, 16, 16); const socketMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: false }); // Left eye socket - positioned better const leftSocket = new THREE.Mesh(socketGeometry, socketMaterial); leftSocket.position.set(-0.7, 0.6, 1.9); leftSocket.scale.set(1.1, 1.0, 0.6); eyeGroup.add(leftSocket); // Right eye socket const rightSocket = new THREE.Mesh(socketGeometry, socketMaterial); rightSocket.position.set(0.7, 0.6, 1.9); rightSocket.scale.set(1.1, 1.0, 0.6); eyeGroup.add(rightSocket); // Create bigger glowing eyes (50% bigger: 0.2 * 1.5 = 0.3) const eyeGeometry = new THREE.SphereGeometry(0.3, 12, 12); // Left eye glow - starts invisible const leftEyeMaterial = new THREE.MeshBasicMaterial({ color: fluorescentColors[params.eyeGlowColor], transparent: true, opacity: 0 }); const leftEye = new THREE.Mesh(eyeGeometry, leftEyeMaterial); leftEye.position.set(-0.7, 0.6, 2.0); eyeGroup.add(leftEye); // Right eye glow const rightEyeMaterial = new THREE.MeshBasicMaterial({ color: fluorescentColors[params.eyeGlowColor], transparent: true, opacity: 0 }); const rightEye = new THREE.Mesh(eyeGeometry, rightEyeMaterial); rightEye.position.set(0.7, 0.6, 2.0); eyeGroup.add(rightEye); // Add subtle outer glow for each eye (also 50% bigger: 0.35 * 1.5 = 0.525) const outerGlowGeometry = new THREE.SphereGeometry(0.525, 12, 12); const leftOuterGlowMaterial = new THREE.MeshBasicMaterial({ color: fluorescentColors[params.eyeGlowColor], transparent: true, opacity: 0, side: THREE.BackSide }); const leftOuterGlow = new THREE.Mesh( outerGlowGeometry, leftOuterGlowMaterial ); leftOuterGlow.position.set(-0.7, 0.6, 1.95); eyeGroup.add(leftOuterGlow); const rightOuterGlowMaterial = new THREE.MeshBasicMaterial({ color: fluorescentColors[params.eyeGlowColor], transparent: true, opacity: 0, side: THREE.BackSide }); const rightOuterGlow = new THREE.Mesh( outerGlowGeometry, rightOuterGlowMaterial ); rightOuterGlow.position.set(0.7, 0.6, 1.95); eyeGroup.add(rightOuterGlow); return { leftEye, rightEye, leftEyeMaterial, rightEyeMaterial, leftOuterGlow, rightOuterGlow, leftOuterGlowMaterial, rightOuterGlowMaterial }; } const eyes = createEyes(); // Create fireflies with enhanced visibility const fireflies = []; const fireflyGroup = new THREE.Group(); scene.add(fireflyGroup); function createFireflies() { for (let i = 0; i < 20; i++) { // Create bright yellow firefly core const fireflyGeometry = new THREE.SphereGeometry(0.02, 2, 2); const fireflyMaterial = new THREE.MeshBasicMaterial({ color: 0xffff44, transparent: true, opacity: 0.9 }); const firefly = new THREE.Mesh(fireflyGeometry, fireflyMaterial); // Random starting position firefly.position.set( (Math.random() - 0.5) * 40, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 20 ); // Create visible glow around firefly const glowGeometry = new THREE.SphereGeometry(0.08, 8, 8); const glowMaterial = new THREE.MeshBasicMaterial({ color: 0xffff88, transparent: true, opacity: 0.4, side: THREE.BackSide }); const glow = new THREE.Mesh(glowGeometry, glowMaterial); firefly.add(glow); const fireflyLight = new THREE.PointLight(0xffff44, 0.8, 3, 2); firefly.add(fireflyLight); // Store movement data firefly.userData = { velocity: new THREE.Vector3( (Math.random() - 0.5) * params.fireflySpeed, (Math.random() - 0.5) * params.fireflySpeed, (Math.random() - 0.5) * params.fireflySpeed ), basePosition: firefly.position.clone(), phase: Math.random() * Math.PI * 2, pulseSpeed: 2 + Math.random() * 3, glow: glow, glowMaterial: glowMaterial, fireflyMaterial: fireflyMaterial, light: fireflyLight }; fireflyGroup.add(firefly); fireflies.push(firefly); } } createFireflies(); // Particle system const particles = []; const particleGroup = new THREE.Group(); scene.add(particleGroup); const particlePool = []; const particleGeometries = [ new THREE.SphereGeometry(0.05, 6, 6), new THREE.TetrahedronGeometry(0.04, 0), new THREE.OctahedronGeometry(0.045, 0) ]; const particleBaseMaterial = new THREE.MeshBasicMaterial({ color: fluorescentColors[params.particleColor], transparent: true, opacity: 0, alphaTest: 0.1 }); function initParticlePool(count) { for (let i = 0; i < count; i++) { const geomIndex = Math.floor(Math.random() * particleGeometries.length); const geometry = particleGeometries[geomIndex]; const material = particleBaseMaterial.clone(); const particle = new THREE.Mesh(geometry, material); particle.visible = false; particleGroup.add(particle); particlePool.push(particle); } } initParticlePool(100); function createParticle() { let particle; if (particlePool.length > 0) { particle = particlePool.pop(); particle.visible = true; } else if (particles.length < params.particleCount) { const geomIndex = Math.floor(Math.random() * particleGeometries.length); const geometry = particleGeometries[geomIndex]; const material = particleBaseMaterial.clone(); particle = new THREE.Mesh(geometry, material); particleGroup.add(particle); } else { return null; } const particleColor = new THREE.Color( fluorescentColors[params.particleColor] ); const hue = Math.random() * 0.1 - 0.05; particleColor.offsetHSL(hue, 0, 0); particle.material.color = particleColor; particle.position.copy(ghostGroup.position); particle.position.z -= 0.8 + Math.random() * 0.6; const scatterRange = 3.5; particle.position.x += (Math.random() - 0.5) * scatterRange; particle.position.y += (Math.random() - 0.5) * scatterRange - 0.8; const sizeVariation = 0.6 + Math.random() * 0.7; particle.scale.set(sizeVariation, sizeVariation, sizeVariation); particle.rotation.set( Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2 ); particle.userData.life = 1.0; particle.userData.decay = Math.random() * 0.003 + params.particleDecayRate; particle.userData.rotationSpeed = { x: (Math.random() - 0.5) * 0.015, y: (Math.random() - 0.5) * 0.015, z: (Math.random() - 0.5) * 0.015 }; particle.userData.velocity = { x: (Math.random() - 0.5) * 0.012, y: (Math.random() - 0.5) * 0.012 - 0.002, z: (Math.random() - 0.5) * 0.012 - 0.006 }; particle.material.opacity = Math.random() * 0.9; particles.push(particle); return particle; } // Enhanced GUI const pane = new Pane({ title: \"Spectral Ghost\", expanded: false }); const paneElement = pane.element; paneElement.style.position = \"fixed\"; paneElement.style.top = \"20px\"; paneElement.style.right = \"20px\"; paneElement.style.zIndex = \"10000\"; paneElement.style.backgroundColor = \"rgba(0, 0, 0, 0.9)\"; paneElement.style.borderRadius = \"12px\"; paneElement.style.padding = \"15px\"; paneElement.style.backdropFilter = \"blur(10px)\"; paneElement.style.border = \"1px solid rgba(0, 212, 255, 0.3)\"; paneElement.style.pointerEvents = \"auto\"; // Glow effects folder const glowFolder = pane.addFolder({ title: \"Glow Effects\", expanded: true }); const glowColorBinding = glowFolder .addBinding(params, \"glowColor\", { label: \"Glow Color\", options: { Cyan: \"cyan\", Lime: \"lime\", Magenta: \"magenta\", Yellow: \"yellow\", Orange: \"orange\", Pink: \"pink\", Purple: \"purple\", Blue: \"blue\", Green: \"green\", Red: \"red\", Teal: \"teal\", Violet: \"violet\" } }) .on(\"change\", (ev) => { const color = fluorescentColors[ev.value]; ghostMaterial.emissive.set(color); }); glowFolder .addBinding(params, \"emissiveIntensity\", { label: \"Ghost Glow\", min: 1.0, max: 10.0, step: 0.1 }) .on(\"change\", (ev) => { ghostMaterial.emissiveIntensity = ev.value; }); // Eye controls folder const eyeFolder = pane.addFolder({ title: \"Eye Controls\", expanded: true }); // Fixed eye glow color picker eyeFolder .addBinding(params, \"eyeGlowColor\", { label: \"Eye Glow Color\", options: { Cyan: \"cyan\", Lime: \"lime\", Magenta: \"magenta\", Yellow: \"yellow\", Orange: \"orange\", Pink: \"pink\", Purple: \"purple\", Blue: \"blue\", Green: \"green\", Red: \"red\", Teal: \"teal\", Violet: \"violet\" } }) .on(\"change\", (ev) => { const color = fluorescentColors[ev.value]; eyes.leftEyeMaterial.color.set(color); eyes.rightEyeMaterial.color.set(color); eyes.leftOuterGlowMaterial.color.set(color); eyes.rightOuterGlowMaterial.color.set(color); }); eyeFolder.addBinding(params, \"eyeGlowDecay\", { label: \"Glow Fade Speed\", min: 0.9, max: 0.99, step: 0.01 }); eyeFolder.addBinding(params, \"eyeGlowResponse\", { label: \"Glow Response\", min: 0.05, max: 0.5, step: 0.01 }); eyeFolder.addBinding(params, \"movementThreshold\", { label: \"Movement Threshold\", min: 0.01, max: 0.1, step: 0.01 }); // Background Reveal folder const revealFolder = pane.addFolder({ title: \"Background Reveal\", expanded: true }); revealFolder .addBinding(params, \"revealRadius\", { label: \"Reveal Radius\", min: 5, max: 100, step: 2 }) .on(\"change\", (ev) => { atmosphereMaterial.uniforms.revealRadius.value = ev.value; }); revealFolder .addBinding(params, \"fadeStrength\", { label: \"Fade Strength\", min: 0.1, max: 3, step: 0.1 }) .on(\"change\", (ev) => { atmosphereMaterial.uniforms.fadeStrength.value = ev.value; }); revealFolder .addBinding(params, \"baseOpacity\", { label: \"Base Darkness\", min: 0, max: 1, step: 0.05 }) .on(\"change\", (ev) => { atmosphereMaterial.uniforms.baseOpacity.value = ev.value; }); revealFolder .addBinding(params, \"revealOpacity\", { label: \"Revealed Opacity\", min: 0, max: 0.5, step: 0.01 }) .on(\"change\", (ev) => { atmosphereMaterial.uniforms.revealOpacity.value = ev.value; }); // Fireflies folder const firefliesFolder = pane.addFolder({ title: \"Fireflies\", expanded: false }); firefliesFolder .addBinding(params, \"fireflyGlowIntensity\", { label: \"Firefly Glow\", min: 0, max: 5, step: 0.1 }) .on(\"change\", (ev) => { fireflies.forEach((firefly) => { firefly.userData.glowMaterial.opacity = ev.value * 0.4; firefly.userData.fireflyMaterial.opacity = ev.value * 0.9; firefly.userData.light.intensity = ev.value * 0.8; }); }); firefliesFolder.addBinding(params, \"fireflySpeed\", { label: \"Firefly Speed\", min: 0.005, max: 0.1, step: 0.005 }); // Analog Decay folder const analogFolder = pane.addFolder({ title: \"Analog Decay\", expanded: true }); analogFolder .addBinding(params, \"limboMode\", { label: \"Limbo\" }) .on(\"change\", (ev) => { analogDecayPass.uniforms.uLimboMode.value = ev.value ? 1.0 : 0.0; }); analogFolder .addBinding(params, \"analogIntensity\", { label: \"Overall Intensity\", min: 0, max: 2, step: 0.1 }) .on(\"change\", (ev) => { analogDecayPass.uniforms.uAnalogIntensity.value = ev.value; }); analogFolder .addBinding(params, \"analogGrain\", { label: \"Film Grain\", min: 0, max: 3, step: 0.1 }) .on(\"change\", (ev) => { analogDecayPass.uniforms.uAnalogGrain.value = ev.value; }); analogFolder .addBinding(params, \"analogBleeding\", { label: \"Color Bleeding\", min: 0, max: 3, step: 0.1 }) .on(\"change\", (ev) => { analogDecayPass.uniforms.uAnalogBleeding.value = ev.value; }); analogFolder .addBinding(params, \"analogVSync\", { label: \"VSync Roll\", min: 0, max: 3, step: 0.1 }) .on(\"change\", (ev) => { analogDecayPass.uniforms.uAnalogVSync.value = ev.value; }); analogFolder .addBinding(params, \"analogScanlines\", { label: \"Scanlines\", min: 0, max: 3, step: 0.1 }) .on(\"change\", (ev) => { analogDecayPass.uniforms.uAnalogScanlines.value = ev.value; }); analogFolder .addBinding(params, \"analogVignette\", { label: \"Vignetting\", min: 0, max: 3, step: 0.1 }) .on(\"change\", (ev) => { analogDecayPass.uniforms.uAnalogVignette.value = ev.value; }); analogFolder .addBinding(params, \"analogJitter\", { label: \"Temporal Jitter\", min: 0, max: 3, step: 0.1 }) .on(\"change\", (ev) => { analogDecayPass.uniforms.uAnalogJitter.value = ev.value; }); // Behavior folder const behaviorFolder = pane.addFolder({ title: \"Behavior\", expanded: false }); behaviorFolder.addBinding(params, \"followSpeed\", { label: \"Follow Speed\", min: 0.01, max: 0.2, step: 0.005 }); behaviorFolder.addBinding(params, \"wobbleAmount\", { label: \"Wobble\", min: 0, max: 1, step: 0.05 }); // Particles folder const particlesFolder = pane.addFolder({ title: \"Particles\", expanded: false }); particlesFolder .addBinding(params, \"particleColor\", { label: \"Particle Color\", options: { Cyan: \"cyan\", Lime: \"lime\", Magenta: \"magenta\", Yellow: \"yellow\", Orange: \"orange\", Pink: \"pink\", Purple: \"purple\", Blue: \"blue\", Green: \"green\", Red: \"red\", Teal: \"teal\", Violet: \"violet\" } }) .on(\"change\", (ev) => { const color = fluorescentColors[ev.value]; particleBaseMaterial.color.set(color); }); particlesFolder.addBinding(params, \"createParticlesOnlyWhenMoving\", { label: \"Only When Moving\" }); particlesFolder.addBinding(params, \"particleCount\", { label: \"Particle Count\", min: 50, max: 400, step: 10 }); // Window resize handler let resizeTimeout; window.addEventListener(\"resize\", () => { if (resizeTimeout) clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); bloomPass.setSize(window.innerWidth, window.innerHeight); analogDecayPass.uniforms.uResolution.value.set( window.innerWidth, window.innerHeight ); }, 250); }); // Mouse tracking const mouse = new THREE.Vector2(); const prevMouse = new THREE.Vector2(); const mouseSpeed = new THREE.Vector2(); let lastMouseUpdate = 0; let isMouseMoving = false; let mouseMovementTimer = null; window.addEventListener(\"mousemove\", (e) => { const now = performance.now(); if (now - lastMouseUpdate > 16) { prevMouse.x = mouse.x; prevMouse.y = mouse.y; mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; mouseSpeed.x = mouse.x - prevMouse.x; mouseSpeed.y = mouse.y - prevMouse.y; isMouseMoving = true; if (mouseMovementTimer) { clearTimeout(mouseMovementTimer); } mouseMovementTimer = setTimeout(() => { isMouseMoving = false; }, 80); lastMouseUpdate = now; } }); // Animation loop let lastParticleTime = 0; let time = 0; let currentMovement = 0; let lastFrameTime = 0; let isInitialized = false; let frameCount = 0; function forceInitialRender() { for (let i = 0; i < 3; i++) { composer.render(); } for (let i = 0; i < 10; i++) { createParticle(); } composer.render(); isInitialized = true; // Complete the preloader once everything is ready preloader.complete(renderer.domElement); } // Complete loading step 5 and initialize preloader.updateProgress(5); setTimeout(forceInitialRender, 100); function animate(timestamp) { requestAnimationFrame(animate); if (!isInitialized) return; const deltaTime = timestamp - lastFrameTime; lastFrameTime = timestamp; if (deltaTime > 100) return; const timeIncrement = (deltaTime / 16.67) * 0.01; time += timeIncrement; frameCount++; // Update shader times atmosphereMaterial.uniforms.time.value = time; analogDecayPass.uniforms.uTime.value = time; analogDecayPass.uniforms.uLimboMode.value = params.limboMode ? 1.0 : 0.0; // Ghost movement const targetX = mouse.x * 11; const targetY = mouse.y * 7; const prevGhostPosition = ghostGroup.position.clone(); ghostGroup.position.x += (targetX - ghostGroup.position.x) * params.followSpeed; ghostGroup.position.y += (targetY - ghostGroup.position.y) * params.followSpeed; // Update atmosphere reveal position atmosphereMaterial.uniforms.ghostPosition.value.copy(ghostGroup.position); const movementAmount = prevGhostPosition.distanceTo(ghostGroup.position); currentMovement = currentMovement * params.eyeGlowDecay + movementAmount * (1 - params.eyeGlowDecay); // Floating animation const float1 = Math.sin(time * params.floatSpeed * 1.5) * 0.03; const float2 = Math.cos(time * params.floatSpeed * 0.7) * 0.018; const float3 = Math.sin(time * params.floatSpeed * 2.3) * 0.008; ghostGroup.position.y += float1 + float2 + float3; // Pulsing effects const pulse1 = Math.sin(time * params.pulseSpeed) * params.pulseIntensity; const pulse2 = Math.cos(time * params.pulseSpeed * 1.4) * params.pulseIntensity * 0.6; const breathe = Math.sin(time * 0.6) * 0.12; ghostMaterial.emissiveIntensity = params.emissiveIntensity + pulse1 + breathe; // Update fireflies with enhanced visibility fireflies.forEach((firefly, index) => { const userData = firefly.userData; // Pulsing glow effect const pulsePhase = time + userData.phase; const pulse = Math.sin(pulsePhase * userData.pulseSpeed) * 0.4 + 0.6; userData.glowMaterial.opacity = params.fireflyGlowIntensity * 0.4 * pulse; userData.fireflyMaterial.opacity = params.fireflyGlowIntensity * 0.9 * pulse; userData.light.intensity = params.fireflyGlowIntensity * 0.8 * pulse; // Random movement userData.velocity.x += (Math.random() - 0.5) * 0.001; userData.velocity.y += (Math.random() - 0.5) * 0.001; userData.velocity.z += (Math.random() - 0.5) * 0.001; // Limit velocity userData.velocity.clampLength(0, params.fireflySpeed); // Update position firefly.position.add(userData.velocity); // Keep fireflies in bounds if (Math.abs(firefly.position.x) > 30) userData.velocity.x *= -0.5; if (Math.abs(firefly.position.y) > 20) userData.velocity.y *= -0.5; if (Math.abs(firefly.position.z) > 15) userData.velocity.z *= -0.5; }); // Body animations const mouseDirection = new THREE.Vector2( targetX - ghostGroup.position.x, targetY - ghostGroup.position.y ).normalize(); const tiltStrength = 0.1 * params.wobbleAmount; const tiltDecay = 0.95; ghostBody.rotation.z = ghostBody.rotation.z * tiltDecay + -mouseDirection.x * tiltStrength * (1 - tiltDecay); ghostBody.rotation.x = ghostBody.rotation.x * tiltDecay + mouseDirection.y * tiltStrength * (1 - tiltDecay); ghostBody.rotation.y = Math.sin(time * 1.4) * 0.05 * params.wobbleAmount; // Scale variations const scaleVariation = 1 + Math.sin(time * 2.1) * 0.025 * params.wobbleAmount + pulse1 * 0.015; const scaleBreath = 1 + Math.sin(time * 0.8) * 0.012; const finalScale = scaleVariation * scaleBreath; ghostBody.scale.set(finalScale, finalScale, finalScale); // Improved eye glow animation const normalizedMouseSpeed = Math.sqrt(mouseSpeed.x * mouseSpeed.x + mouseSpeed.y * mouseSpeed.y) * 8; const isMoving = currentMovement > params.movementThreshold; const targetGlow = isMoving ? 1.0 : 0.0; // Gradually change eye glow const glowChangeSpeed = isMoving ? params.eyeGlowResponse * 2 : params.eyeGlowResponse; // Update both inner eye and outer glow const newOpacity = eyes.leftEyeMaterial.opacity + (targetGlow - eyes.leftEyeMaterial.opacity) * glowChangeSpeed; eyes.leftEyeMaterial.opacity = newOpacity; eyes.rightEyeMaterial.opacity = newOpacity; eyes.leftOuterGlowMaterial.opacity = newOpacity * 0.3; eyes.rightOuterGlowMaterial.opacity = newOpacity * 0.3; // Particle creation const shouldCreateParticles = params.createParticlesOnlyWhenMoving ? currentMovement > 0.005 && isMouseMoving : currentMovement > 0.005; if (shouldCreateParticles && timestamp - lastParticleTime > 100) { const speedRate = Math.floor(normalizedMouseSpeed * 3); const particleRate = Math.min( params.particleCreationRate, Math.max(1, speedRate) ); for (let i = 0; i < particleRate; i++) { createParticle(); } lastParticleTime = timestamp; } // Particle updates const particlesToUpdate = Math.min(particles.length, 60); for (let i = 0; i < particlesToUpdate; i++) { const index = (frameCount + i) % particles.length; if (index < particles.length) { const particle = particles[index]; particle.userData.life -= particle.userData.decay; particle.material.opacity = particle.userData.life * 0.85; if (particle.userData.velocity) { particle.position.x += particle.userData.velocity.x; particle.position.y += particle.userData.velocity.y; particle.position.z += particle.userData.velocity.z; const swirl = Math.cos(time * 1.8 + particle.position.y) * 0.0008; particle.position.x += swirl; } if (particle.userData.rotationSpeed) { particle.rotation.x += particle.userData.rotationSpeed.x; particle.rotation.y += particle.userData.rotationSpeed.y; particle.rotation.z += particle.userData.rotationSpeed.z; } if (particle.userData.life <= 0) { particle.visible = false; particle.material.opacity = 0; particlePool.push(particle); particles.splice(index, 1); i--; } } } // Render with analog decay effect composer.render(); } // Initialize const fakeEvent = new MouseEvent(\"mousemove\", { clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 }); window.dispatchEvent(fakeEvent); animate(0);",
    "id": "webglthreejs--spooky-spectral-ghost"
  },
  {
    "title": "Pure CSS iOS 26 Liquid Glass Effect",
    "description": "",
    "code": "index.html: <div class=\"glassContainer\"> <button type=\"button\" class=\"glassBtn\"> <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"> <path d=\"M5 12h14\"/> <path d=\"M12 5v14\"/> </svg> </button> </div> <svg style=\"display: none\"> <filter id=\"container-glass\" x=\"0%\" y=\"0%\" width=\"100%\" height=\"100%\"> <feTurbulence type=\"fractalNoise\" baseFrequency=\"0.008 0.008\" numOctaves=\"2\" seed=\"92\" result=\"noise\" /> <feGaussianBlur in=\"noise\" stdDeviation=\"0.02\" result=\"blur\" /> <feDisplacementMap in=\"SourceGraphic\" in2=\"blur\" scale=\"77\" xChannelSelector=\"R\" yChannelSelector=\"G\" /> </filter> <filter id=\"btn-glass\" primitiveUnits=\"objectBoundingBox\"> <feImage href=\"data:image/png;base64,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\" x=\"0\" y=\"0\" width=\"1\" height=\"1\" result=\"map\"></feImage> <feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"0.02\" result=\"blur\"></feGaussianBlur> <feDisplacementMap id=\"disp\" in=\"blur\" in2=\"map\" scale=\"1\" xChannelSelector=\"R\" yChannelSelector=\"G\" /> </feDisplacementMap> </filter> </svg>\nstyle.css: body { font-family: sans-serif; font-weight: 300; background: url(https://raw.githubusercontent.com/lucasromerodb/liquid-glass-effect-macos/refs/heads/main/assets/flowers.jpg) center center; background-size: 400px; height: 100vh; -webkit-animation: moveBackground 60s linear infinite; animation: moveBackground 60s linear infinite; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-align: center; -ms-flex-align: center; align-items: center; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; margin:0; padding:0; } .glassContainer { position: fixed; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-align: center; -ms-flex-align: center; align-items: center; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; width: 300px; height: 200px; border-radius: 30px; } .glassContainer::before { content: ''; position: absolute; inset: 0; z-index: 0; overflow: hidden; border-radius: 30px; -webkit-box-shadow: inset 2px 2px 0px -2px rgba(255, 255, 255, 0.7), inset 0 0 3px 1px rgba(255, 255, 255, 0.7); box-shadow: inset 2px 2px 0px -2px rgba(255, 255, 255, 0.7), inset 0 0 3px 1px rgba(255, 255, 255, 0.7); } .glassContainer::after { content: ''; position: absolute; z-index: -1; inset: 0; border-radius: 30px; -webkit-backdrop-filter: blur(0px); backdrop-filter: blur(0px); -webkit-filter: url(#container-glass); filter: url(#container-glass); overflow: hidden; isolation: isolate; } .glassBtn { position: relative; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-align: center; -ms-flex-align: center; align-items: center; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; cursor: pointer; width: 70px; height: 70px; padding: 15px; background: transparent; border-radius: 9999px; outline: none; border: none; z-index: 0; } .glassBtn::before { content: ''; position: absolute; inset: 0; z-index: 0; overflow: hidden; border-radius: 9999px; -webkit-box-shadow: inset 2px 2px 0px -2px rgba(255, 255, 255, 0.7), inset 0 0 3px 1px rgba(255, 255, 255, 0.7); box-shadow: inset 2px 2px 0px -2px rgba(255, 255, 255, 0.7), inset 0 0 3px 1px rgba(255, 255, 255, 0.7); background-color: rgb(255 255 255 / 10%); } .glassBtn::after { content: ''; position: absolute; z-index: -1; inset: 0; border-radius: 9999px; -webkit-backdrop-filter: blur(0px); backdrop-filter: blur(0px); -webkit-filter: url(#btn-glass); filter: url(#btn-glass); overflow: hidden; isolation: isolate; } .glassBtn svg { width: 100%; height: 100%; stroke: #fff; } @-webkit-keyframes moveBackground { from { background-position: 0% 0%; } to { background-position: 0% -1000%; } } @keyframes moveBackground { from { background-position: 0% 0%; } to { background-position: 0% -1000%; } }\nscript.js: ",
    "id": "pure-css-ios-26-liquid-glass-effect"
  },
  {
    "title": "[threejs/gsap] ‚ùç Interactive Glass Lens Effect with Sound FX",
    "description": "",
    "code": "index.html: <div class=\"error-message\" id=\"errorMessage\"></div> <div class=\"fallback-bg\" id=\"fallbackBg\"></div> <div class=\"audio-enable\"> <p>ENTER EXPERIENCE<br />WITH AUDIO</p> <button class=\"enable-button\" id=\"enableBtn\">START</button> </div> <div class=\"preloader\" id=\"preloader\"> <span id=\"counter\">[000]</span> </div> <canvas id=\"canvas\"></canvas> <p class=\"text-element description\">THE ARCHIVE COLLECTS RECORDS OF ABANDONED WORLDS AND LOST TECHNOLOGIES, WAITING TO BE DISCOVERED.</p> <nav class=\"text-element nav-links\"> <a href=\"#\">_DATA VAULTS</a> <a href=\"#\">_DEEP SPACE</a> <a href=\"#\">_FORBIDDEN ZONES</a> <a href=\"#\">_EXODUS LOGS</a> </nav> <div class=\"text-element footer\"> <p>Err: [404 - SIGNAL LOST]<br /> SYSTEM TIME: CYCLE 2187.42<br /> <span style=\"opacity: 0.7; font-size: 0.6rem;\">PRESS 'H' TO TOGGLE REFRACTION CONTROLS</span> </p> </div> <p class=\"text-element division\"> PERFORMANCE ANALYSIS: <span id=\"fpsCounter\"></span> FPS<br> OPTICAL REFRACTION ENGINE: ONLINE<br> ACCESS LEVEL: RESTRICTED.<br> TRACE INITIATED: SOURCE UNKNOWN. </p> <p class=\"text-element signal\">_Uplink Pending...</p> <div class=\"text-element central-text\"> THE VAULT RETAINS ECHOES OF CIVILIZATIONS ERASED BY TIME<br> DEAD SYSTEMS. BROKEN SIGNALS. MYTHS WRITTEN IN CODE. </div> <audio id=\"startClickSound\" preload=\"auto\"> <source src=\"https://assets.codepen.io/7558/preloader-2s-001.mp3\" type=\"audio/mpeg\"> </audio> <audio id=\"preloaderSound\" preload=\"auto\"> <source src=\"https://assets.codepen.io/7558/preloader-3s-002.mp3\" type=\"audio/mpeg\"> </audio> <audio id=\"hoverSound\" preload=\"auto\"> <source src=\"https://assets.codepen.io/7558/preloader-2s-001.mp3\" type=\"audio/mpeg\"> </audio> <audio id=\"backgroundMusic\" loop preload=\"auto\"> <source src=\"https://assets.codepen.io/7558/cinematic-02.mp3\" type=\"audio/mpeg\"> </audio>\nstyle.css: @font-face { font-family: \"PPSupplyMono\"; src: url(\"https://assets.codepen.io/7558/PPSupplyMono-Regular.ttf\") format(\"truetype\"); font-weight: normal; font-style: normal; font-display: swap; } *, *::after, *::before { margin: 0; padding: 0; box-sizing: border-box; } :root { --color--background: rgb(60, 60, 60); --color--foreground: #c4d5bc; --color--accent: rgb(170, 170, 170); --font-primary: \"PPSupplyMono\", \"Courier New\", monospace; --font-secondary: \"PPSupplyMono\", \"Courier New\", monospace; --margin: 32px; --gutter: 16px; } body { display: flex; flex-direction: column; justify-content: space-between; align-items: center; min-height: 100vh; margin: 0; padding: 0; font-family: var(--font-primary); background: radial-gradient( circle at 10% 20%, rgb(230, 230, 230) 0%, rgb(180, 180, 180) 45%, rgb(100, 100, 100) 90% ); color: var(--color--foreground); letter-spacing: -0.03em; position: relative; overflow: hidden; } body.loading-active { overflow: hidden !important; } body::before { content: \"\"; position: fixed; top: -50%; left: -50%; width: 200%; height: 200%; background: transparent url(\"https://assets.codepen.io/7558/noise.png\") repeat 0 0; background-size: 300px 300px; animation: noise-animation 0.3s steps(5) infinite; opacity: 0.9; will-change: transform; z-index: 100; pointer-events: none; } @keyframes noise-animation { 0% { transform: translate(0, 0); } 10% { transform: translate(-2%, -3%); } 20% { transform: translate(-4%, 2%); } 30% { transform: translate(2%, -4%); } 40% { transform: translate(-2%, 5%); } 50% { transform: translate(-4%, 2%); } 60% { transform: translate(3%, 0); } 70% { transform: translate(0, 3%); } 80% { transform: translate(-3%, 0); } 90% { transform: translate(2%, 2%); } 100% { transform: translate(1%, 0); } } #canvas { width: 100%; height: 100%; display: block; position: fixed; top: 0; left: 0; background: transparent; z-index: 1; pointer-events: none; opacity: 0; transition: opacity 0.5s ease-out; } #canvas.ready { opacity: 1; } .fallback-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-image: url(\"https://assets.codepen.io/7558/red-protocol-poster-03-bg.jpg\"); background-size: cover; background-position: center; z-index: 0; opacity: 0; transition: opacity 1s ease-out; } .fallback-bg.active { opacity: 1; } .container { display: flex; width: 100%; height: 100vh; padding: var(--gutter); position: relative; z-index: 10; transition: filter 0.1s ease-out; } .text-element { position: fixed; font-family: var(--font-primary); color: var(--color--foreground); text-transform: uppercase; z-index: 10; opacity: 0; transform: translateY(30px); } .audio-enable { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #0a0a0a; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; font-family: var(--font-primary); font-size: 12px; color: #c4d5bc; text-transform: uppercase; gap: 2rem; text-align: center; padding: 1rem; } .enable-button { border: 1px solid #c4d5bc; background: transparent; color: #c4d5bc; padding: 1rem 2rem; font-family: var(--font-primary); font-size: 12px; text-transform: uppercase; cursor: pointer; letter-spacing: 0.1em; transition: all 0.3s ease; } .enable-button:hover { background: #c4d5bc; color: #0a0a0a; } .preloader { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #0a0a0a; display: none; align-items: center; justify-content: center; z-index: 2000; font-family: var(--font-primary); font-size: 12px; color: #c4d5bc; letter-spacing: 0.1em; text-transform: uppercase; opacity: 1; transition: opacity 0.8s ease-out; } .preloader.fade-out { opacity: 0; } .error-message { position: fixed; top: 20px; left: 20px; background: rgba(255, 0, 0, 0.8); color: white; padding: 10px; font-size: 12px; display: none; z-index: 3000; } .description { top: 120px; left: 50px; width: 360px; font-size: 0.75rem; line-height: 1.2; } .nav-links { top: 50%; left: 50px; transform: translateY(-50%); } .nav-links a { position: relative; display: block; margin-bottom: 8px; color: var(--color--foreground); text-decoration: none; z-index: 1; transition: color 0.3s ease; padding: 4px 8px; } .nav-links a::after { content: \"\"; position: absolute; top: 0; left: 0; width: 0; height: 100%; background-color: var(--color--foreground); z-index: -1; transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); } .nav-links a:hover::after { width: 100%; } .nav-links a:hover { color: #1a1a1a; } .footer { bottom: 120px; right: 50px; font-size: 0.625rem; } .division { bottom: 120px; left: 50px; font-size: 0.625rem; } .signal { top: 50%; right: 100px; font-size: 0.625rem; transform: translateY(-50%); } .central-text { bottom: 30%; left: 50%; transform: translateX(-50%) translateY(0); text-align: center; font-size: 1.25rem; line-height: 1.1; white-space: nowrap; width: max-content; } .dg.ac { z-index: 3000 !important; position: fixed !important; top: 10px !important; right: 10px !important; } /* Responsive design */ @media (max-width: 768px) { .description, .nav-links, .division, .performance { left: 20px; } .footer, .signal { right: 20px; } .central-text { font-size: 1rem; white-space: normal; max-width: 90%; } .description { width: calc(100vw - 40px); max-width: 300px; } /* Optimize GUI for mobile */ .dg.ac { transform: scale(0.8); transform-origin: top right; } } @media (max-width: 480px) { .central-text { font-size: 0.9rem; } .description { font-size: 0.7rem; } /* Further scale down GUI on very small screens */ .dg.ac { transform: scale(0.7); } } /* Touch device optimizations */ @media (hover: none) and (pointer: coarse) { .nav-links a:hover::after { width: 0; } .nav-links a:active::after { width: 100%; } .enable-button:hover { background: transparent; color: #c4d5bc; } .enable-button:active { background: #c4d5bc; color: #0a0a0a; } }\nscript.js: import * as THREE from \"https://esm.sh/three@0.177.0\"; import { EffectComposer } from \"https://esm.sh/three@0.177.0/examples/jsm/postprocessing/EffectComposer.js\"; import { RenderPass } from \"https://esm.sh/three@0.177.0/examples/jsm/postprocessing/RenderPass.js\"; import { ShaderPass } from \"https://esm.sh/three@0.177.0/examples/jsm/postprocessing/ShaderPass.js\"; import { Pane } from \"https://cdn.skypack.dev/tweakpane@4.0.4\"; (function () { \"use strict\"; const supportsWebGL = () => { try { const c = document.createElement(\"canvas\"); return !!( window.WebGLRenderingContext && (c.getContext(\"webgl\") || c.getContext(\"experimental-webgl\")) ); } catch { return false; } }; if (!Array.prototype.forEach) { Array.prototype.forEach = function (cb, ctx) { for (let i = 0; i < this.length; i++) cb.call(ctx, this[i], i, this); }; } if (!window.requestAnimationFrame) { window.requestAnimationFrame = (cb) => setTimeout(cb, 16.67); } const App = { PARAMS: { distortion: { strength: 0.15, radius: 0.2, size: 1, edgeWidth: 0.05, edgeOpacity: 0.2, rimLightIntensity: 0.3, rimLightWidth: 0.08, chromaticAberration: 0.03, reflectionIntensity: 0.3, waveDistortion: 0.08, waveSpeed: 1.2, lensBlur: 0.15, clearCenterSize: 0.3, followMouse: true, animationSpeed: 1, overallIntensity: 1, preset: \"Classic Glass\" }, presets: { Minimal: { strength: 0.05, radius: 0.12, size: 0.8, edgeWidth: 0.02, edgeOpacity: 0.1, rimLightIntensity: 0.1, rimLightWidth: 0.04, chromaticAberration: 0.01, reflectionIntensity: 0.15, waveDistortion: 0.02, waveSpeed: 0.8, lensBlur: 0.05, clearCenterSize: 0.5 }, Subtle: { strength: 0.08, radius: 0.16, size: 0.9, edgeWidth: 0.03, edgeOpacity: 0.15, rimLightIntensity: 0.2, rimLightWidth: 0.06, chromaticAberration: 0.02, reflectionIntensity: 0.2, waveDistortion: 0.04, waveSpeed: 1, lensBlur: 0.08, clearCenterSize: 0.4 }, \"Classic Glass\": { strength: 0.12, radius: 0.18, size: 1, edgeWidth: 0.04, edgeOpacity: 0.25, rimLightIntensity: 0.3, rimLightWidth: 0.08, chromaticAberration: 0.025, reflectionIntensity: 0.35, waveDistortion: 0.03, waveSpeed: 0.5, lensBlur: 0.12, clearCenterSize: 0.2 }, Dramatic: { strength: 0.25, radius: 0.35, size: 1.2, edgeWidth: 0.08, edgeOpacity: 0.4, rimLightIntensity: 0.5, rimLightWidth: 0.1, chromaticAberration: 0.06, reflectionIntensity: 0.5, waveDistortion: 0.15, waveSpeed: 1.8, lensBlur: 0.25, clearCenterSize: 0.15 }, \"Chromatic Focus\": { strength: 0.1, radius: 0.22, size: 1, edgeWidth: 0.06, edgeOpacity: 0.3, rimLightIntensity: 0.25, rimLightWidth: 0.07, chromaticAberration: 0.08, reflectionIntensity: 0.2, waveDistortion: 0.05, waveSpeed: 0.8, lensBlur: 0.1, clearCenterSize: 0.25 }, \"Liquid Wave\": { strength: 0.18, radius: 0.28, size: 1.1, edgeWidth: 0.05, edgeOpacity: 0.2, rimLightIntensity: 0.4, rimLightWidth: 0.09, chromaticAberration: 0.04, reflectionIntensity: 0.4, waveDistortion: 0.2, waveSpeed: 2.5, lensBlur: 0.15, clearCenterSize: 0.1 }, Gigantic: { strength: 0.4, radius: 0.65, size: 1.8, edgeWidth: 0.12, edgeOpacity: 0.6, rimLightIntensity: 0.8, rimLightWidth: 0.15, chromaticAberration: 0.1, reflectionIntensity: 0.7, waveDistortion: 0.25, waveSpeed: 1.5, lensBlur: 0.35, clearCenterSize: 0.05 } } }, scene: null, camera: null, renderer: null, composer: null, customPass: null, backgroundTexture: null, backgroundMesh: null, aspect: 1, backgroundScene: null, backgroundCamera: null, mousePosition: { x: 0.5, y: 0.5 }, targetMousePosition: { x: 0.5, y: 0.5 }, staticMousePosition: { x: 0.5, y: 0.5 }, performanceMonitor: { frameCount: 0, lastTime: 0, fps: 60 }, pane: null, isBackgroundPlaying: false, paneVisible: false, paneInitialized: false, isSceneReady: false, isTextureLoaded: false, webglSupported: supportsWebGL(), init() { this.setupAudio(); this.setupKeyboardControls(); this.bindEvents(); if (!this.webglSupported) { this.showFallback(); return; } this.waitForDependencies(); }, waitForDependencies() { const chk = setInterval(() => { if (window.gsap && window.SplitText) { clearInterval(chk); this.onDependenciesReady(); } }, 100); setTimeout(() => { clearInterval(chk); this.onDependenciesReady(); }, 10000); }, onDependenciesReady() {}, showError(m) { const el = document.getElementById(\"errorMessage\"); if (!el) return; el.textContent = m; el.style.display = \"block\"; setTimeout(() => (el.style.display = \"none\"), 5000); }, showFallback() { document.getElementById(\"fallbackBg\").classList.add(\"active\"); this.finishPreloader(); }, setupAudio() { this.startClickSound = document.getElementById(\"startClickSound\"); this.preloaderSound = document.getElementById(\"preloaderSound\"); this.hoverSound = document.getElementById(\"hoverSound\"); this.backgroundMusic = document.getElementById(\"backgroundMusic\"); }, bindEvents() { document.getElementById(\"enableBtn\").onclick = () => this.onStartClick(); }, onStartClick() { document.body.classList.add(\"loading-active\"); this.startClickSound?.play().catch(() => {}); document.querySelector(\".audio-enable\").style.display = \"none\"; document.getElementById(\"preloader\").style.display = \"flex\"; this.preloaderSound?.play().catch(() => {}); setTimeout(() => { if (this.backgroundMusic) { this.backgroundMusic.volume = 0.3; this.backgroundMusic.play().catch(() => {}); this.isBackgroundPlaying = true; } }, 500); this.webglSupported ? this.initializeScene() : this.showFallback(); this.startPreloader(); }, startPreloader() { let c = 0; const timer = setInterval(() => { const el = document.getElementById(\"counter\"); if (el) el.textContent = \"[\" + (c < 10 ? \"00\" : c < 100 ? \"0\" : \"\") + ++c + \"]\"; if (c >= 100) { clearInterval(timer); setTimeout(() => { this.preloaderSound?.pause(); if (this.preloaderSound) this.preloaderSound.currentTime = 0; this.finishPreloader(); }, 200); } }, 30); }, finishPreloader() { const wait = () => { if ( (this.isSceneReady && this.isTextureLoaded) || !this.webglSupported ) { const pre = document.getElementById(\"preloader\"); pre.classList.add(\"fade-out\"); if (this.webglSupported) document.getElementById(\"canvas\").classList.add(\"ready\"); setTimeout(() => { document.body.classList.remove(\"loading-active\"); pre.style.display = \"none\"; pre.classList.remove(\"fade-out\"); this.animateTextElements(); }, 800); } else setTimeout(wait, 50); }; wait(); }, animateTextElements() { if (!window.gsap || !window.SplitText) { this.fallbackTextAnimation(); return; } const ease = window.CustomEase ? (CustomEase.create(\"customOut\", \"0.65,0.05,0.36,1\"), \"customOut\") : \"power2.out\"; const containers = [ \".description\", \".division\", \".signal\", \".central-text\", \".footer\" ]; gsap.set(containers.concat(\".nav-links\"), { opacity: 0 }); const splits = containers.map( (sel) => SplitText.create(sel, { type: \"lines\", linesClass: \"line\" }).lines ); const [descLines, divLines, sigLines, centralLines, footerLines] = splits; gsap.set(containers, { opacity: 1 }); gsap.set(splits.flat().concat(\".nav-links a\"), { opacity: 0, y: 30 }); const tl = gsap.timeline(); tl.to(descLines, { opacity: 1, y: 0, duration: 0.8, ease, stagger: 0.18 }) .to(\".nav-links\", { opacity: 1, duration: 0.2 }, 0.12) .to( \".nav-links a\", { opacity: 1, y: 0, duration: 0.8, ease, stagger: 0.15 }, 0.12 ) .to( centralLines, { opacity: 1, y: 0, duration: 0.8, ease, stagger: 0.22 }, 0.25 ) .to( footerLines, { opacity: 1, y: 0, duration: 0.8, ease, stagger: 0.18 }, 0.4 ) .to( divLines, { opacity: 1, y: 0, duration: 0.8, ease, stagger: 0.18 }, 0.55 ) .to( sigLines, { opacity: 1, y: 0, duration: 0.8, ease, stagger: 0.18 }, 0.55 ); }, fallbackTextAnimation() { let d = 0; document.querySelectorAll(\".text-element\").forEach((el) => { setTimeout(() => { el.style.opacity = \"1\"; el.style.transform = el.classList.contains(\"central-text\") ? \"translateX(-50%) translateY(0)\" : \"translateY(0)\"; }, d); d += 250; }); }, initializeScene() { if (!this.webglSupported) { this.isSceneReady = this.isTextureLoaded = true; return; } const canvas = document.getElementById(\"canvas\"); this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, premultipliedAlpha: false }); this.renderer.setSize(window.innerWidth, window.innerHeight); this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); this.renderer.autoClear = false; this.aspect = window.innerWidth / window.innerHeight; this.backgroundScene = new THREE.Scene(); this.backgroundCamera = new THREE.OrthographicCamera( -this.aspect, this.aspect, 1, -1, 0.1, 10 ); this.backgroundCamera.position.z = 1; this.scene = new THREE.Scene(); this.camera = new THREE.OrthographicCamera( -this.aspect, this.aspect, 1, -1, 0.1, 10 ); this.camera.position.z = 1; this.loadBackgroundTexture(); this.setupPostProcessing(); this.setupPane(); this.setupNavHoverSounds(); const onResize = this.onWindowResize.bind(this); const onMouseMove = this.onMouseMove.bind(this); const onTouchMove = this.onTouchMove.bind(this); const onTouchStart = this.onTouchStart.bind(this); window.addEventListener(\"resize\", onResize); document.addEventListener(\"mousemove\", onMouseMove); document.addEventListener(\"touchmove\", onTouchMove); document.addEventListener(\"touchstart\", onTouchStart); this.animate(); this.isSceneReady = true; }, onMouseMove(e) { if (this.PARAMS.distortion.followMouse) { this.targetMousePosition.x = e.clientX / window.innerWidth; this.targetMousePosition.y = 1 - e.clientY / window.innerHeight; } }, onTouchStart(e) { e.preventDefault(); if (e.touches.length) this.onTouchMove(e); }, onTouchMove(e) { e.preventDefault(); if (this.PARAMS.distortion.followMouse && e.touches.length) { const t = e.touches[0]; this.targetMousePosition.x = t.clientX / window.innerWidth; this.targetMousePosition.y = 1 - t.clientY / window.innerHeight; } }, loadBackgroundTexture() { new THREE.TextureLoader().load( \"https://assets.codepen.io/7558/red-protocol-poster-03-bg.jpg\", (tex) => { this.backgroundTexture = tex; this.createBackgroundMesh(); this.isTextureLoaded = true; }, undefined, () => (this.isTextureLoaded = true) ); }, createBackgroundMesh() { if (this.backgroundMesh) this.backgroundScene.remove(this.backgroundMesh); const imgAspect = this.backgroundTexture.image.width / this.backgroundTexture.image.height; const scAspect = window.innerWidth / window.innerHeight; let sx, sy; if (scAspect > imgAspect) { sx = scAspect * 2; sy = sx / imgAspect; } else { sy = 2; sx = sy * imgAspect; } const g = new THREE.PlaneGeometry(sx, sy); const m = new THREE.MeshBasicMaterial({ map: this.backgroundTexture }); this.backgroundMesh = new THREE.Mesh(g, m); this.backgroundScene.add(this.backgroundMesh); }, setupPostProcessing() { this.composer = new EffectComposer(this.renderer); const rp = new RenderPass(this.backgroundScene, this.backgroundCamera); this.composer.addPass(rp); this.setupDistortionPass(); }, setupDistortionPass() { const v = `varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}`; const f = `uniform sampler2D tDiffuse;uniform vec2 uMouse;uniform float uRadius;uniform float uSize;uniform float uStrength;uniform float uEdgeWidth;uniform float uEdgeOpacity;uniform float uRimLightIntensity;uniform float uRimLightWidth;uniform float uChromaticAberration;uniform float uReflectionIntensity;uniform float uWaveDistortion;uniform float uWaveSpeed;uniform float uLensBlur;uniform float uClearCenterSize;uniform float uOverallIntensity;uniform float uAspect;uniform float uTime;varying vec2 vUv; vec4 blur(sampler2D i,vec2 uv,vec2 r,vec2 d,float it){vec4 c=vec4(0.);vec2 o=1.3333333*d*it;c+=texture2D(i,uv)*.2941176;c+=texture2D(i,uv+(o/r))*.3529412;c+=texture2D(i,uv-(o/r))*.3529412;return c;} void main(){ vec2 c=uMouse; vec2 a=vUv; a.x*=uAspect; c.x*=uAspect; float dist=distance(a,c); float rad=uRadius*uSize; vec4 orig=texture2D(tDiffuse,vUv); // Calculate the effect for all pixels float nd=dist/rad; vec2 dir=normalize(a-c); float cl=uClearCenterSize*rad; float df=smoothstep(cl,rad,dist); float powd=1.+nd*2.; vec2 dUv=a-dir*uStrength*pow(df,powd); float w1=sin(nd*8.-uTime*uWaveSpeed)*uWaveDistortion; float w2=cos(nd*12.-uTime*uWaveSpeed*.7)*uWaveDistortion*.5; dUv+=dir*(w1+w2)*df; dUv.x/=uAspect; float ab=uChromaticAberration*df*(1.+nd); vec2 rO=dir*ab*1.2/vec2(uAspect,1.); vec2 bO=dir*ab*0.8/vec2(uAspect,1.); vec4 colR=texture2D(tDiffuse,dUv+rO); vec4 colG=texture2D(tDiffuse,dUv); vec4 colB=texture2D(tDiffuse,dUv-bO); vec4 ref1=texture2D(tDiffuse,vUv+dir*0.08*df); vec4 ref2=texture2D(tDiffuse,vUv+dir*0.15*df); vec4 ref=mix(ref1,ref2,.6); vec4 col=vec4(colR.r,colG.g,colB.b,1.); col=mix(col,ref,uReflectionIntensity*df); float bl=uLensBlur*df*(1.+nd*.5); vec4 blr=blur(tDiffuse,dUv,vec2(1./uAspect,1.),vec2(1.),bl); col=mix(col,blr,df*.7); float edge=smoothstep(rad-uEdgeWidth,rad,dist); vec3 eCol=mix(vec3(1.),vec3(.8,.9,1.),nd); col=mix(col,vec4(eCol,1.),edge*uEdgeOpacity); float rimD=rad-uRimLightWidth; float rim=smoothstep(rimD-0.02,rimD+0.02,dist); rim*=(1.-smoothstep(rad-0.01,rad,dist)); col=mix(col,vec4(1.),rim*uRimLightIntensity); float br=1.+sin(nd*6.-uTime*2.)*.1*df; col.rgb*=br; // Replace hard cutoff with ultra-tight smoothstep to fix jagged edges float effectMask = 1.0 - smoothstep(rad - 0.001, rad + 0.001, dist); gl_FragColor=mix(orig, mix(orig,col,uOverallIntensity), effectMask); }`; this.customPass = new ShaderPass({ uniforms: { tDiffuse: { value: null }, uMouse: { value: new THREE.Vector2(0.5, 0.5) }, uRadius: { value: this.PARAMS.distortion.radius }, uSize: { value: this.PARAMS.distortion.size }, uStrength: { value: this.PARAMS.distortion.strength }, uEdgeWidth: { value: this.PARAMS.distortion.edgeWidth }, uEdgeOpacity: { value: this.PARAMS.distortion.edgeOpacity }, uRimLightIntensity: { value: this.PARAMS.distortion.rimLightIntensity }, uRimLightWidth: { value: this.PARAMS.distortion.rimLightWidth }, uChromaticAberration: { value: this.PARAMS.distortion.chromaticAberration }, uReflectionIntensity: { value: this.PARAMS.distortion.reflectionIntensity }, uWaveDistortion: { value: this.PARAMS.distortion.waveDistortion }, uWaveSpeed: { value: this.PARAMS.distortion.waveSpeed }, uLensBlur: { value: this.PARAMS.distortion.lensBlur }, uClearCenterSize: { value: this.PARAMS.distortion.clearCenterSize }, uOverallIntensity: { value: this.PARAMS.distortion.overallIntensity }, uAspect: { value: this.aspect }, uTime: { value: 0 } }, vertexShader: v, fragmentShader: f }); this.customPass.renderToScreen = true; this.composer.addPass(this.customPass); }, setupNavHoverSounds() { document.querySelectorAll(\".nav-links a\").forEach((a) => { a.addEventListener(\"mouseenter\", () => { if (this.hoverSound && this.isBackgroundPlaying) { this.hoverSound.currentTime = 0; this.hoverSound.volume = 0.4; this.hoverSound.play().catch(() => {}); } }); }); }, setupKeyboardControls() { document.addEventListener(\"keydown\", (e) => { if (e.key.toLowerCase() === \"h\") { e.preventDefault(); this.togglePane(); } }); }, togglePane() { if (!this.paneInitialized) this.setupPane(); if (this.pane) { this.paneVisible = !this.paneVisible; this.pane.hidden = !this.paneVisible; } }, setupPane() { if (this.paneInitialized) return; const p = (this.pane = new Pane({ title: \"Glass Refraction Controls\", expanded: true })); p.addBinding(this.PARAMS.distortion, \"preset\", { label: \"Presets\", options: { Minimal: \"Minimal\", Subtle: \"Subtle\", \"Classic Glass\": \"Classic Glass\", Dramatic: \"Dramatic\", \"Chromatic Focus\": \"Chromatic Focus\", \"Liquid Wave\": \"Liquid Wave\", Gigantic: \"Gigantic\" } }).on(\"change\", (ev) => this.loadPreset(ev.value)); p.addButton({ title: \"Reload Preset\" }).on(\"click\", () => this.loadPreset(this.PARAMS.distortion.preset) ); const addBinding = (prop, opts) => p.addBinding(this.PARAMS.distortion, prop, opts).on(\"change\", (ev) => { const uniformName = \"u\" + prop.charAt(0).toUpperCase() + prop.slice(1); if (this.customPass?.uniforms[uniformName]) this.customPass.uniforms[uniformName].value = ev.value; }); addBinding(\"overallIntensity\", { min: 0, max: 2, step: 0.01, label: \"Overall Intensity\" }); p.addBinding(this.PARAMS.distortion, \"followMouse\", { label: \"Follow Mouse\" }).on(\"change\", (ev) => { if (!ev.value) this.staticMousePosition = { x: 0.5, y: 0.5 }; }); addBinding(\"animationSpeed\", { min: 0, max: 3, step: 0.1, label: \"Animation Speed\" }); const f1 = p.addFolder({ title: \"Size Controls\" }); f1.addBinding(this.PARAMS.distortion, \"size\", { min: 0.2, max: 3, step: 0.1, label: \"Effect Size\" }).on( \"change\", (ev) => (this.customPass.uniforms.uSize.value = ev.value) ); f1.addBinding(this.PARAMS.distortion, \"radius\", { min: 0.05, max: 0.8, step: 0.01, label: \"Base Radius\" }).on( \"change\", (ev) => (this.customPass.uniforms.uRadius.value = ev.value) ); const f2 = p.addFolder({ title: \"Refraction Properties\" }); f2.addBinding(this.PARAMS.distortion, \"strength\", { min: 0, max: 0.5, step: 0.01, label: \"Refraction Strength\" }).on( \"change\", (ev) => (this.customPass.uniforms.uStrength.value = ev.value) ); f2.addBinding(this.PARAMS.distortion, \"clearCenterSize\", { min: 0, max: 1, step: 0.01, label: \"Clear Center\" }).on( \"change\", (ev) => (this.customPass.uniforms.uClearCenterSize.value = ev.value) ); const f3 = p.addFolder({ title: \"Visual Effects\" }); f3.addBinding(this.PARAMS.distortion, \"chromaticAberration\", { min: 0, max: 0.15, step: 0.001, label: \"Chromatic Aberration\" }).on( \"change\", (ev) => (this.customPass.uniforms.uChromaticAberration.value = ev.value) ); f3.addBinding(this.PARAMS.distortion, \"reflectionIntensity\", { min: 0, max: 1, step: 0.01, label: \"Reflections\" }).on( \"change\", (ev) => (this.customPass.uniforms.uReflectionIntensity.value = ev.value) ); f3.addBinding(this.PARAMS.distortion, \"lensBlur\", { min: 0, max: 0.5, step: 0.01, label: \"Lens Blur\" }).on( \"change\", (ev) => (this.customPass.uniforms.uLensBlur.value = ev.value) ); const f4 = p.addFolder({ title: \"Wave Animation\" }); f4.addBinding(this.PARAMS.distortion, \"waveDistortion\", { min: 0, max: 0.3, step: 0.01, label: \"Wave Strength\" }).on( \"change\", (ev) => (this.customPass.uniforms.uWaveDistortion.value = ev.value) ); f4.addBinding(this.PARAMS.distortion, \"waveSpeed\", { min: 0, max: 5, step: 0.1, label: \"Wave Speed\" }).on( \"change\", (ev) => (this.customPass.uniforms.uWaveSpeed.value = ev.value) ); const f5 = p.addFolder({ title: \"Edge Effects\" }); f5.addBinding(this.PARAMS.distortion, \"edgeWidth\", { min: 0, max: 0.2, step: 0.01, label: \"Edge Width\" }).on( \"change\", (ev) => (this.customPass.uniforms.uEdgeWidth.value = ev.value) ); f5.addBinding(this.PARAMS.distortion, \"edgeOpacity\", { min: 0, max: 1, step: 0.01, label: \"Edge Opacity\" }).on( \"change\", (ev) => (this.customPass.uniforms.uEdgeOpacity.value = ev.value) ); const f6 = p.addFolder({ title: \"Rim Lighting\" }); f6.addBinding(this.PARAMS.distortion, \"rimLightIntensity\", { min: 0, max: 1, step: 0.01, label: \"Rim Light Intensity\" }).on( \"change\", (ev) => (this.customPass.uniforms.uRimLightIntensity.value = ev.value) ); f6.addBinding(this.PARAMS.distortion, \"rimLightWidth\", { min: 0, max: 0.3, step: 0.01, label: \"Rim Light Width\" }).on( \"change\", (ev) => (this.customPass.uniforms.uRimLightWidth.value = ev.value) ); Object.assign(p.element.style, { position: \"fixed\", top: \"10px\", right: \"10px\", zIndex: \"3000\" }); p.hidden = true; this.paneVisible = false; this.paneInitialized = true; this.loadPreset(\"Classic Glass\"); }, loadPreset(name) { const preset = this.PARAMS.presets[name]; if (!preset) return; Object.entries(preset).forEach(([k, v]) => { if (k in this.PARAMS.distortion) { this.PARAMS.distortion[k] = v; const uniformName = \"u\" + k.charAt(0).toUpperCase() + k.slice(1); if (this.customPass?.uniforms[uniformName]) this.customPass.uniforms[uniformName].value = v; } }); this.PARAMS.distortion.preset = name; this.pane?.refresh(); }, onWindowResize() { this.aspect = window.innerWidth / window.innerHeight; if (this.camera) { this.camera.left = this.camera.right = this.backgroundCamera.left = this.backgroundCamera.right = null; [this.camera, this.backgroundCamera].forEach((cam) => { cam.left = -this.aspect; cam.right = this.aspect; cam.updateProjectionMatrix(); }); } this.renderer?.setSize(window.innerWidth, window.innerHeight); this.composer?.setSize(window.innerWidth, window.innerHeight); if (this.customPass) this.customPass.uniforms.uAspect.value = this.aspect; if (this.backgroundTexture) this.createBackgroundMesh(); }, animate(time = 0) { requestAnimationFrame((t) => this.animate(t)); if (!this.webglSupported || !this.renderer) return; this.performanceMonitor.frameCount++; if (time - this.performanceMonitor.lastTime >= 1000) { this.performanceMonitor.fps = this.performanceMonitor.frameCount; this.performanceMonitor.frameCount = 0; this.performanceMonitor.lastTime = time; const fpsElement = document.getElementById(\"fpsCounter\"); if (fpsElement) fpsElement.textContent = String(this.performanceMonitor.fps); } const tgt = this.PARAMS.distortion.followMouse ? this.targetMousePosition : this.staticMousePosition; this.mousePosition.x += (tgt.x - this.mousePosition.x) * 0.1; this.mousePosition.y += (tgt.y - this.mousePosition.y) * 0.1; if (this.customPass) { this.customPass.uniforms.uMouse.value.set( this.mousePosition.x, this.mousePosition.y ); this.customPass.uniforms.uTime.value = time * 0.001 * this.PARAMS.distortion.animationSpeed; } this.composer ? this.composer.render() : (this.renderer.clear(), this.renderer.render(this.backgroundScene, this.backgroundCamera)); } }; window.addEventListener(\"error\", (e) => { let m = \"An error occurred\"; if (e.error?.message) m += \": \" + e.error.message; if (e.filename) m += \" in \" + e.filename; App.showError(m + \". Some features may not work properly.\"); }); window.addEventListener(\"unhandledrejection\", (e) => { App.showError( \"Loading failed: \" + (e.reason || \"Unknown error\") + \". Retrying...\" ); }); if (document.readyState === \"loading\") { document.addEventListener(\"DOMContentLoaded\", () => App.init()); } else { App.init(); } window.App = App; })();",
    "id": "threejsgsap--interactive-glass-lens-effect-with-sound-fx"
  },
  {
    "title": "Fluid Simulation",
    "description": "",
    "code": "index.html: <h1>Click and drag!</h1> <canvas id=\"c\"></canvas>\nstyle.css: @import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\"); body{ margin: 0; background: #000; font-family: \"Open Sans\"; } h1{ color: #ffffff; text-align: center; font-size: 20px; } canvas{ position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; border: 2px solid white; }\nscript.js: /* Comments were requested, here we go :) Here's the rundown: This script creates a grid of cells and a separate layer of particles that float on top of the grid. Each cell of the grid holds X and Y velocity (direction and magnitude) values and a pressure value. Whenever the user holds down and moves their mouse over the canvas, the velocity of the mouse is calculated and is used to influence the velocity and pressure in each cell that was within the defined range of the mouse coordinates. Then, the pressure change is communicated to all of the neighboring cells of those affected, adjusting their velocity and pressure, and this is repeated over and over until the change propogates to all of the cells in the path of the direction of movement. The particles are randomly placed on the canvas and move according to the velocity of the grid cells below, similar to grass seed floating on the surface of water as it's moving. Whenever the particles move off the edge of the canvas, they are \"dropped\" back on to the canvas in a random position. The velocity, however, is \"wrapped\" around to the opposite edge of the canvas. The slowing down of the movement is simulated viscosity, which is basically frictional drag in the liquid. Let's get started: -------- This is a self-invoking function. Basically, that means that it runs itself automatically. The reason for wrapping the script in this is to isolate the majority of the variables that I define inside from the global scope and only reveal specific functions and values. It looks like this: (function(argument) { alert(argument); })(\"Yo.\"); and it does the same thing as this: function thing(argument) { alert(argument); } thing(\"Yo.\"); */ (function(w) { var canvas, ctx; /* This is an associative array to hold the status of the mouse cursor Whenever the mouse is moved or pressed, there are event handlers that update the values in this array. */ var mouse = { x: 0, y: 0, px: 0, py: 0, down: false }; /* These are the variable definitions for the values that will be used throughout the rest of the script. */ var canvas_width = 500; //Needs to be a multiple of the resolution value below. var canvas_height = 500; //This too. var resolution = 10; //Width and height of each cell in the grid. var pen_size = 40; //Radius around the mouse cursor coordinates to reach when stirring var num_cols = canvas_width / resolution; //This value is the number of columns in the grid. var num_rows = canvas_height / resolution; //This is number of rows. var speck_count = 5000; //This determines how many particles will be made. var vec_cells = []; //The array that will contain the grid cells var particles = []; //The array that will contain the particles /* This is the main function. It is triggered to start the process of constructing the the grid and creating the particles, attaching event handlers, and starting the animation loop. */ function init() { //These lines get the canvas DOM element and canvas context, respectively. canvas = document.getElementById(\"c\"); ctx = canvas.getContext(\"2d\"); //These two set the width and height of the canvas to the defined values. canvas.width = canvas_width; canvas.height = canvas_height; /* This loop begins at zero and counts up to the defined number of particles, less one, because array elements are numbered beginning at zero. */ for (i = 0; i < speck_count; i++) { /* This calls the function particle() with random X and Y values. It then takes the returned object and pushes it into the particles array at the end. */ particles.push(new particle(Math.random() * canvas_width, Math.random() * canvas_height)); } //This loops through the count of columns. for (col = 0; col < num_cols; col++) { //This defines the array element as another array. vec_cells[col] = []; //This loops through the count of rows. for (row = 0; row < num_rows; row++) { /* This line calls the cell() function, which creates an individual grid cell and returns it as an object. The X and Y values are multiplied by the resolution so that when the loops are referring to \"column 2, row 2\", the width and height of \"column 1, row 1\" are counted in so that the top-left corner of the new grid cell is at the bottom right of the other cell. */ var cell_data = new cell(col * resolution, row * resolution, resolution) //This pushes the cell object into the grid array. vec_cells[col][row] = cell_data; /* These two lines set the object's column and row values so the object knows where in the grid it is positioned. */ vec_cells[col][row].col = col; vec_cells[col][row].row = row; } } /* These loops move through the rows and columns of the grid array again and set variables in each cell object that will hold the directional references to neighboring cells. For example, let's say the loop is currently on this cell: OOOOO OOOXO OOOOO These variables will hold the references to neighboring cells so you only need to use \"up\" to refer to the cell above the one you're currently on. */ for (col = 0; col < num_cols; col++) { for (row = 0; row < num_rows; row++) { /* This variable holds the reference to the current cell in the grid. When you refer to an element in an array, it doesn't copy that value into the new variable; the variable stores a \"link\" or reference to that spot in the array. If the value in the array is changed, the value of this variable would change also, and vice-versa. */ var cell_data = vec_cells[col][row]; /* Each of these lines has a ternary expression. A ternary expression is similar to an if/then clause and is represented as an expression (e.g. row - 1 >= 0) which is evaluated to either true or false. If it's true, the first value after the question mark is used, and if it's false, the second value is used instead. If you're on the first row and you move to the row above, this wraps the row around to the last row. This is done so that momentum that is pushed to the edge of the canvas is \"wrapped\" to the opposite side. */ var row_up = (row - 1 >= 0) ? row - 1 : num_rows - 1; var col_left = (col - 1 >= 0) ? col - 1 : num_cols - 1; var col_right = (col + 1 < num_cols) ? col + 1 : 0; //Get the reference to the cell on the row above. var up = vec_cells[col][row_up]; var left = vec_cells[col_left][row]; var up_left = vec_cells[col_left][row_up]; var up_right = vec_cells[col_right][row_up]; /* Set the current cell's \"up\", \"left\", \"up_left\" and \"up_right\" attributes to the respective neighboring cells. */ cell_data.up = up; cell_data.left = left; cell_data.up_left = up_left; cell_data.up_right = up_right; /* Set the neighboring cell's opposite attributes to point to the current cell. */ up.down = vec_cells[col][row]; left.right = vec_cells[col][row]; up_left.down_right = vec_cells[col][row]; up_right.down_left = vec_cells[col][row]; } } /* These lines create triggers that fire when certain events happen. For instance, when you move your mouse, the mouse_move_handler() function will run and will be passed the event object reference into it's \"e\" variable. Something to note, the mousemove event doesn't necessarily fire for *every* mouse coordinate position; the mouse movement is sampled at a certain rate, meaning that it's checked periodically, and if the mouse has moved, the event is fired and the current coordinates are sent. That's why you'll see large jumps from one pair of coordinates to the next if you move your mouse very fast across the screen. That's also how I measure the mouse's velocity. */ w.addEventListener(\"mousedown\", mouse_down_handler); w.addEventListener(\"touchstart\", touch_start_handler); w.addEventListener(\"mouseup\", mouse_up_handler); w.addEventListener(\"touchend\", touch_end_handler); canvas.addEventListener(\"mousemove\", mouse_move_handler); canvas.addEventListener(\"touchmove\", touch_move_handler); //When the page is finished loading, run the draw() function. w.onload = draw; } /* This function updates the position of the particles according to the velocity of the cells underneath, and also draws them to the canvas. */ function update_particle() { //Loops through all of the particles in the array for (i = 0; i < particles.length; i++) { //Sets this variable to the current particle so we can refer to the particle easier. var p = particles[i]; //If the particle's X and Y coordinates are within the bounds of the canvas... if (p.x >= 0 && p.x < canvas_width && p.y >= 0 && p.y < canvas_height) { /* These lines divide the X and Y values by the size of each cell. This number is then parsed to a whole number to determine which grid cell the particle is above. */ var col = parseInt(p.x / resolution); var row = parseInt(p.y / resolution); //Same as above, store reference to cell var cell_data = vec_cells[col][row]; /* These values are percentages. They represent the percentage of the distance across the cell (for each axis) that the particle is positioned. To give an example, if the particle is directly in the center of the cell, these values would both be \"0.5\" The modulus operator (%) is used to get the remainder from dividing the particle's coordinates by the resolution value. This number can only be smaller than the resolution, so we divide it by the resolution to get the percentage. */ var ax = (p.x % resolution) / resolution; var ay = (p.y % resolution) / resolution; /* These lines subtract the decimal from 1 to reverse it (e.g. 100% - 75% = 25%), multiply that value by the cell's velocity, and then by 0.05 to greatly reduce the overall change in velocity per frame (this slows down the movement). Then they add that value to the particle's velocity in each axis. This is done so that the change in velocity is incrementally made as the particle reaches the end of it's path across the cell. */ p.xv += (1 - ax) * cell_data.xv * 0.05; p.yv += (1 - ay) * cell_data.yv * 0.05; /* These next four lines are are pretty much the same, except the neighboring cell's velocities are being used to affect the particle's movement. If you were to comment them out, the particles would begin grouping at the boundary between cells because the neighboring cells wouldn't be able to pull the particle into their boundaries. */ p.xv += ax * cell_data.right.xv * 0.05; p.yv += ax * cell_data.right.yv * 0.05; p.xv += ay * cell_data.down.xv * 0.05; p.yv += ay * cell_data.down.yv * 0.05; //This adds the calculated velocity to the position coordinates of the particle. p.x += p.xv; p.y += p.yv; //For each axis, this gets the distance between the old position of the particle and it's new position. var dx = p.px - p.x; var dy = p.py - p.y; //Using the Pythagorean theorum (A^2 + B^2 = C^2), this determines the distance the particle travelled. var dist = Math.sqrt(dx * dx + dy * dy); //This line generates a random value between 0 and 0.5 var limit = Math.random() * 0.5; //If the distance the particle has travelled this frame is greater than the random value... if (dist > limit) { ctx.lineWidth = 1; ctx.beginPath(); //Begin a new path on the canvas ctx.moveTo(p.x, p.y); //Move the drawing cursor to the starting point ctx.lineTo(p.px, p.py); //Describe a line from the particle's old coordinates to the new ones ctx.stroke(); //Draw the path to the canvas }else{ //If the particle hasn't moved further than the random limit... ctx.beginPath(); ctx.moveTo(p.x, p.y); /* Describe a line from the particle's current coordinates to those same coordinates plus the random value. This is what creates the shimmering effect while the particles aren't moving. */ ctx.lineTo(p.x + limit, p.y + limit); ctx.stroke(); } //This updates the previous X and Y coordinates of the particle to the new ones for the next loop. p.px = p.x; p.py = p.y; } else { //If the particle's X and Y coordinates are outside the bounds of the canvas... //Place the particle at a random location on the canvas p.x = p.px = Math.random() * canvas_width; p.y = p.py = Math.random() * canvas_height; //Set the particles velocity to zero. p.xv = 0; p.yv = 0; } //These lines divide the particle's velocity in half everytime it loops, slowing them over time. p.xv *= 0.5; p.yv *= 0.5; } } /* This is the main animation loop. It is run once from the init() function when the page is fully loaded and uses RequestAnimationFrame to run itself again and again. */ function draw() { /* This calculates the velocity of the mouse by getting the distance between the last coordinates and the new ones. The coordinates will be further apart depending on how fast the mouse is moving. */ var mouse_xv = mouse.x - mouse.px; var mouse_yv = mouse.y - mouse.py; //Loops through all of the columns for (i = 0; i < vec_cells.length; i++) { var cell_datas = vec_cells[i]; //Loops through all of the rows for (j = 0; j < cell_datas.length; j++) { //References the current cell var cell_data = cell_datas[j]; //If the mouse button is down, updates the cell velocity using the mouse velocity if (mouse.down) { change_cell_velocity(cell_data, mouse_xv, mouse_yv, pen_size); } //This updates the pressure values for the cell. update_pressure(cell_data); } } /* This line clears the canvas. It needs to be cleared every time a new frame is drawn so the particles move. Otherwise, the particles would just look like long curvy lines. */ ctx.clearRect(0, 0, canvas.width, canvas.height); //This sets the color to draw with. ctx.strokeStyle = \"#00FFFF\"; //This calls the function to update the particle positions. update_particle(); /* This calls the function to update the cell velocity for every cell by looping through all of the rows and columns. */ for (i = 0; i < vec_cells.length; i++) { var cell_datas = vec_cells[i]; for (j = 0; j < cell_datas.length; j++) { var cell_data = cell_datas[j]; update_velocity(cell_data); } } //This replaces the previous mouse coordinates values with the current ones for the next frame. mouse.px = mouse.x; mouse.py = mouse.y; //This requests the next animation frame which runs the draw() function again. requestAnimationFrame(draw); } /* This function changes the cell velocity of an individual cell by first determining whether the cell is close enough to the mouse cursor to be affected, and then if it is, by calculating the effect that mouse velocity has on the cell's velocity. */ function change_cell_velocity(cell_data, mvelX, mvelY, pen_size) { //This gets the distance between the cell and the mouse cursor. var dx = cell_data.x - mouse.x; var dy = cell_data.y - mouse.y; var dist = Math.sqrt(dy * dy + dx * dx); //If the distance is less than the radius... if (dist < pen_size) { //If the distance is very small, set it to the pen_size. if (dist < 4) { dist = pen_size; } //Calculate the magnitude of the mouse's effect (closer is stronger) var power = pen_size / dist; /* Apply the velocity to the cell by multiplying the power by the mouse velocity and adding it to the cell velocity */ cell_data.xv += mvelX * power; cell_data.yv += mvelY * power; } } /* This function updates the pressure value for an individual cell using the pressures of neighboring cells. */ function update_pressure(cell_data) { //This calculates the collective pressure on the X axis by summing the surrounding velocities var pressure_x = ( cell_data.up_left.xv * 0.5 //Divided in half because it's diagonal + cell_data.left.xv + cell_data.down_left.xv * 0.5 //Same - cell_data.up_right.xv * 0.5 //Same - cell_data.right.xv - cell_data.down_right.xv * 0.5 //Same ); //This does the same for the Y axis. var pressure_y = ( cell_data.up_left.yv * 0.5 + cell_data.up.yv + cell_data.up_right.yv * 0.5 - cell_data.down_left.yv * 0.5 - cell_data.down.yv - cell_data.down_right.yv * 0.5 ); //This sets the cell pressure to one-fourth the sum of both axis pressure. cell_data.pressure = (pressure_x + pressure_y) * 0.25; } /* This function updates the velocity value for an individual cell using the velocities of neighboring cells. */ function update_velocity(cell_data) { /* This adds one-fourth of the collective pressure from surrounding cells to the cell's X axis velocity. */ cell_data.xv += ( cell_data.up_left.pressure * 0.5 + cell_data.left.pressure + cell_data.down_left.pressure * 0.5 - cell_data.up_right.pressure * 0.5 - cell_data.right.pressure - cell_data.down_right.pressure * 0.5 ) * 0.25; //This does the same for the Y axis. cell_data.yv += ( cell_data.up_left.pressure * 0.5 + cell_data.up.pressure + cell_data.up_right.pressure * 0.5 - cell_data.down_left.pressure * 0.5 - cell_data.down.pressure - cell_data.down_right.pressure * 0.5 ) * 0.25; /* This slowly decreases the cell's velocity over time so that the fluid stops if it's left alone. */ cell_data.xv *= 0.99; cell_data.yv *= 0.99; } //This function is used to create a cell object. function cell(x, y, res) { //This stores the position to place the cell on the canvas this.x = x; this.y = y; //This is the width and height of the cell this.r = res; //These are the attributes that will hold the row and column values this.col = 0; this.row = 0; //This stores the cell's velocity this.xv = 0; this.yv = 0; //This is the pressure attribute this.pressure = 0; } //This function is used to create a particle object. function particle(x, y) { this.x = this.px = x; this.y = this.py = y; this.xv = this.yv = 0; } /* This function is called whenever the mouse button is pressed. The event object is passed to this function when it's called. */ function mouse_down_handler(e) { e.preventDefault(); //Prevents the default action from happening (e.g. navigation) mouse.down = true; //Sets the mouse object's \"down\" value to true } //This function is called whenever the mouse button is released. function mouse_up_handler() { mouse.down = false; } //This function is called whenever a touch is registered. function touch_start_handler(e) { e.preventDefault(); //Prevents the default action from happening (e.g. navigation) var rect = canvas.getBoundingClientRect(); mouse.x = mouse.px = e.touches[0].pageX - rect.left; //Set both previous and current coordinates mouse.y = mouse.py = e.touches[0].pageY - rect.top; mouse.down = true; //Sets the mouse object's \"down\" value to true } //This function is called whenever a touch point is removed from the screen. function touch_end_handler(e) { if (!e.touches) mouse.down = false; //If there are no more touches on the screen, sets \"down\" to false. } /* This function is called whenever the mouse coordinates have changed. The coordinates are checked by the browser at intervals. */ function mouse_move_handler(e) { e.preventDefault(); //Prevents the default action from happening //Saves the previous coordinates mouse.px = mouse.x; mouse.py = mouse.y; //Sets the new coordinates mouse.x = e.offsetX || e.layerX; mouse.y = e.offsetY || e.layerY; } /* This function is called whenever one of the coordinates have changed. The coordinates are checked by the browser at intervals. */ function touch_move_handler(e) { e.preventDefault(); //Prevents the default action from happening mouse.px = mouse.x; mouse.py = mouse.y; //This line gets the coordinates for where the canvas is positioned on the screen. var rect = canvas.getBoundingClientRect(); /* And this sets the mouse coordinates to where the first touch is. Since we're using pageX and pageY, we need to subtract the top and left offset of the canvas so the values are correct. */ mouse.x = e.touches[0].pageX - rect.left; mouse.y = e.touches[0].pageY - rect.top; } /* And this line attaches an object called \"Fluid\" to the global scope. \"window\" was passed into the self-invoking function as \"w\", so setting \"w.Fluid\" adds it to \"window\". */ w.Fluid = { initialize: init } }(window)); //Passes \"window\" into the self-invoking function. /* Request animation frame polyfill. This enables you to use \"requestAnimationFrame\" regardless of the browser the script is running in. */ window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame; //And this line calls the init() function defined above to start the script. Fluid.initialize();",
    "id": "fluid-simulation"
  },
  {
    "title": "Animated SVG path with stops",
    "description": "",
    "code": "index.html: <div class=\"container\"> <!-- no width/height attributes here --> <svg viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\"> <!-- background oval --> <path class=\"oval\" d=\"M 15,15 H 85 Q 99,15 99,30 V 70 Q 100,85 85,85 H 15 Q 1,85 0,70 V 30 Q 1,15 15,15 Z\" /> <!-- moving line along same path --> <path class=\"path-line\" d=\"M 15,15 H 85 Q 99,15 99,30 V 70 Q 100,85 85,85 H 15 Q 1,85 0,70 V 30 Q 1,15 15,15 Z\" /> </svg> <!-- security --> <div class=\"circle security\"> <svg viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"> <g id=\"SVGRepo_iconCarrier\"> <path opacity=\"0.5\" d=\"M3 10.4167C3 7.21907 3 5.62028 3.37752 5.08241C3.75503 4.54454 5.25832 4.02996 8.26491 3.00079L8.83772 2.80472C10.405 2.26824 11.1886 2 12 2C12.8114 2 13.595 2.26824 15.1623 2.80472L15.7351 3.00079C18.7417 4.02996 20.245 4.54454 20.6225 5.08241C21 5.62028 21 7.21907 21 10.4167V11.9914C21 17.6294 16.761 20.3655 14.1014 21.5273C13.38 21.8424 13.0193 22 12 22C10.9807 22 10.62 21.8424 9.89856 21.5273C7.23896 20.3655 3 17.6294 3 11.9914V10.4167Z\" fill=\"currentColor\"></path> <path d=\"M13.5 15C13.5 15.5523 13.0523 16 12.5 16H11.5C10.9477 16 10.5 15.5523 10.5 15V13.5987C9.6033 13.0799 9 12.1104 9 11C9 9.34315 10.3431 8 12 8C13.6569 8 15 9.34315 15 11C15 12.1104 14.3967 13.0799 13.5 13.5987V15Z\" fill=\"currentColor\"></path> </g> </svg> </div> <!--heart --> <div class=\"circle heart\"> <svg viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"> <g > <path opacity=\"0.8\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12 1.25C12.4142 1.25 12.75 1.58579 12.75 2V4C12.75 4.41421 12.4142 4.75 12 4.75C11.5858 4.75 11.25 4.41421 11.25 4V2C11.25 1.58579 11.5858 1.25 12 1.25ZM1.25 12C1.25 11.5858 1.58579 11.25 2 11.25H4C4.41421 11.25 4.75 11.5858 4.75 12C4.75 12.4142 4.41421 12.75 4 12.75H2C1.58579 12.75 1.25 12.4142 1.25 12ZM19.25 12C19.25 11.5858 19.5858 11.25 20 11.25H22C22.4142 11.25 22.75 11.5858 22.75 12C22.75 12.4142 22.4142 12.75 22 12.75H20C19.5858 12.75 19.25 12.4142 19.25 12ZM12 19.25C12.4142 19.25 12.75 19.5858 12.75 20V22C12.75 22.4142 12.4142 22.75 12 22.75C11.5858 22.75 11.25 22.4142 11.25 22V20C11.25 19.5858 11.5858 19.25 12 19.25Z\" fill=\"currentColor\"></path> <g opacity=\"0.5\"> <path class=\"heart-short\" d=\"M5.46967 5.46967C5.76256 5.17678 6.23744 5.17678 6.53033 5.46967L6.87359 5.81293C7.16648 6.10583 7.16648 6.5807 6.87359 6.87359C6.5807 7.16648 6.10583 7.16648 5.81293 6.87359L5.46967 6.53033C5.17678 6.23744 5.17678 5.76256 5.46967 5.46967Z\" fill=\"currentColor\"></path> <path d=\"M18.5303 5.46967C18.8232 5.76256 18.8232 6.23744 18.5303 6.53033L18.1871 6.87359C17.8942 7.16648 17.4193 7.16648 17.1264 6.87359C16.8335 6.5807 16.8335 6.10583 17.1264 5.81293L17.4697 5.46967C17.7626 5.17678 18.2374 5.17678 18.5303 5.46967Z\" fill=\"currentColor\"></path> <path class=\"heart-short\" d=\"M6.87338 17.1266C7.16627 17.4195 7.16627 17.8944 6.87338 18.1873L6.53033 18.5303C6.23744 18.8232 5.76256 18.8232 5.46967 18.5303C5.17678 18.2374 5.17678 17.7626 5.46967 17.4697L5.81272 17.1266C6.10561 16.8337 6.58048 16.8337 6.87338 17.1266Z\" fill=\"currentColor\"></path> <path class=\"heart-short\" d=\"M17.1266 17.1266C17.4195 16.8337 17.8944 16.8337 18.1873 17.1266L18.5303 17.4697C18.8232 17.7626 18.8232 18.2374 18.5303 18.5303C18.2374 18.8232 17.7626 18.8232 17.4697 18.5303L17.1266 18.1873C16.8337 17.8944 16.8337 17.4195 17.1266 17.1266Z\" fill=\"currentColor\"></path> </g> <path d=\"M7 11.0595C7 13.6018 9.00971 14.9566 10.4809 16.1692C11 16.5971 11.5 17 12 17C12.5 17 13 16.5971 13.5191 16.1692C14.9903 14.9566 17 13.6018 17 11.0595C17 8.51718 14.2499 6.71421 12 9.15837C9.75008 6.71421 7 8.51718 7 11.0595Z\" fill=\"currentColor\"></path> </g> </svg> </div> <!-- battery --> <div class=\"circle battery\"> <svg viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"> <g> <path opacity=\"0.5\" d=\"M3.17157 5.17157C2 6.34315 2 8.22876 2 12C2 15.7712 2 17.6569 3.17157 18.8284C4.34315 20 6.22876 20 10 20H11.5C15.2712 20 17.1569 20 18.3284 18.8284C19.5 17.6569 19.5 15.7712 19.5 12C19.5 8.22876 19.5 6.34315 18.3284 5.17157C17.1569 4 15.2712 4 11.5 4H10C6.22876 4 4.34315 4 3.17157 5.17157Z\" fill=\"currentColor\"></path> <path d=\"M19.4912 14C19.4999 13.3993 19.4999 12.7355 19.4999 12C19.4999 11.2645 19.4999 10.6007 19.4912 10H19.9997C20.9425 10 21.4139 10 21.7068 10.2929C21.9997 10.5858 21.9997 11.0572 21.9997 12C21.9997 12.9428 21.9997 13.4142 21.7068 13.7071C21.4139 14 20.9425 14 19.9997 14H19.4912Z\" fill=\"currentColor\"></path> <path d=\"M6.6359 8.34452C6.99799 8.14336 7.45459 8.27382 7.65575 8.6359L7.00014 9.00014C7.65575 8.6359 7.65648 8.63722 7.65648 8.63722L7.65725 8.63861L7.65892 8.64166L7.66277 8.64877L7.6724 8.66712C7.67965 8.6812 7.68852 8.69895 7.69877 8.72046C7.71925 8.76349 7.7452 8.82149 7.77462 8.89503C7.83348 9.04219 7.90606 9.25113 7.97663 9.52635C8.1179 10.0773 8.25014 10.89 8.25014 12.0001C8.25014 13.1103 8.1179 13.923 7.97663 14.4739C7.90606 14.7491 7.83348 14.9581 7.77462 15.1052C7.7452 15.1788 7.71925 15.2368 7.69877 15.2798C7.68852 15.3013 7.67965 15.3191 7.6724 15.3331L7.66277 15.3515L7.65892 15.3586L7.65725 15.3617L7.65648 15.3631L7.65575 15.3644C7.45459 15.7265 6.99799 15.8569 6.6359 15.6558C6.27689 15.4563 6.14559 15.0057 6.33947 14.6451L6.34448 14.6349C6.35133 14.6205 6.36445 14.5918 6.3819 14.5482C6.41679 14.4609 6.46921 14.3136 6.52364 14.1014C6.63237 13.6773 6.75014 12.99 6.75014 12.0001C6.75014 11.0103 6.63237 10.323 6.52364 9.89892C6.46921 9.68664 6.41679 9.53933 6.3819 9.45212C6.36445 9.40848 6.35133 9.37976 6.34448 9.36536L6.33947 9.35513C6.14559 8.99455 6.27689 8.54397 6.6359 8.34452Z\" fill=\"currentColor\"></path> <path d=\"M11.1558 8.6359C10.9546 8.27382 10.498 8.14336 10.1359 8.34452C9.77689 8.54397 9.64559 8.99455 9.83947 9.35513L9.84448 9.36536C9.85133 9.37976 9.86445 9.40848 9.8819 9.45212C9.91679 9.53933 9.96921 9.68664 10.0236 9.89892C10.1324 10.323 10.2501 11.0103 10.2501 12.0001C10.2501 12.99 10.1324 13.6773 10.0236 14.1014C9.96921 14.3136 9.91679 14.4609 9.8819 14.5482C9.86445 14.5918 9.85133 14.6205 9.84448 14.6349L9.83947 14.6451C9.64559 15.0057 9.77689 15.4563 10.1359 15.6558C10.498 15.8569 10.9546 15.7265 11.1558 15.3644L10.5001 15.0001C11.1558 15.3644 11.1565 15.3631 11.1565 15.3631L11.1573 15.3617L11.1589 15.3586L11.1628 15.3515L11.1724 15.3331C11.1797 15.3191 11.1885 15.3013 11.1988 15.2798C11.2193 15.2368 11.2452 15.1788 11.2746 15.1052C11.3335 14.9581 11.4061 14.7491 11.4766 14.4739C11.6179 13.923 11.7501 13.1103 11.7501 12.0001C11.7501 10.89 11.6179 10.0773 11.4766 9.52635C11.4061 9.25113 11.3335 9.04219 11.2746 8.89503C11.2452 8.82149 11.2193 8.76349 11.1988 8.72046C11.1885 8.69895 11.1797 8.6812 11.1724 8.66712L11.1628 8.64877L11.1589 8.64166L11.1573 8.63861L11.1565 8.63722L11.1558 8.6359Z\" fill=\"currentColor\"></path> <path d=\"M13.6359 8.34452C13.998 8.14336 14.4546 8.27382 14.6558 8.6359L14.0001 9.00014C14.6558 8.6359 14.6565 8.63722 14.6565 8.63722L14.6573 8.63861L14.6589 8.64166L14.6628 8.64877L14.6724 8.66712C14.6797 8.6812 14.6885 8.69895 14.6988 8.72046C14.7193 8.76349 14.7452 8.82149 14.7746 8.89503C14.8335 9.04219 14.9061 9.25113 14.9766 9.52635C15.1179 10.0773 15.2501 10.89 15.2501 12.0001C15.2501 13.1103 15.1179 13.923 14.9766 14.4739C14.9061 14.7491 14.8335 14.9581 14.7746 15.1052C14.7452 15.1788 14.7193 15.2368 14.6988 15.2798C14.6885 15.3013 14.6797 15.3191 14.6724 15.3331L14.6628 15.3515L14.6589 15.3586L14.6573 15.3617L14.6565 15.3631L14.6558 15.3644C14.4546 15.7265 13.998 15.8569 13.6359 15.6558C13.2769 15.4563 13.1456 15.0057 13.3395 14.6451L13.3445 14.6349C13.3513 14.6205 13.3644 14.5918 13.3819 14.5482C13.4168 14.4609 13.4692 14.3136 13.5236 14.1014C13.6324 13.6773 13.7501 12.99 13.7501 12.0001C13.7501 11.0103 13.6324 10.323 13.5236 9.89892C13.4692 9.68664 13.4168 9.53933 13.3819 9.45212C13.3644 9.40848 13.3513 9.37976 13.3445 9.36536L13.3395 9.35513C13.1456 8.99455 13.2769 8.54397 13.6359 8.34452Z\" fill=\"currentColor\"></path> </g> </svg> </div> <!-- parcel --> <div class=\"circle parcel\"> <svg viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"> <g id=\"SVGRepo_iconCarrier\"> <path d=\"M8.42229 20.6181C10.1779 21.5395 11.0557 22.0001 12 22.0001V12.0001L2.63802 7.07275C2.62423 7.09491 2.6107 7.11727 2.5974 7.13986C2 8.15436 2 9.41678 2 11.9416V12.0586C2 14.5834 2 15.8459 2.5974 16.8604C3.19479 17.8749 4.27063 18.4395 6.42229 19.5686L8.42229 20.6181Z\" fill=\"currentColor\"></path> <path opacity=\"0.7\" d=\"M17.5774 4.43152L15.5774 3.38197C13.8218 2.46066 12.944 2 11.9997 2C11.0554 2 10.1776 2.46066 8.42197 3.38197L6.42197 4.43152C4.31821 5.53552 3.24291 6.09982 2.6377 7.07264L11.9997 12L21.3617 7.07264C20.7564 6.09982 19.6811 5.53552 17.5774 4.43152Z\" fill=\"currentColor\"></path> <path opacity=\"0.5\" d=\"M21.4026 7.13986C21.3893 7.11727 21.3758 7.09491 21.362 7.07275L12 12.0001V22.0001C12.9443 22.0001 13.8221 21.5395 15.5777 20.6181L17.5777 19.5686C19.7294 18.4395 20.8052 17.8749 21.4026 16.8604C22 15.8459 22 14.5834 22 12.0586V11.9416C22 9.41678 22 8.15436 21.4026 7.13986Z\" fill=\"currentColor\"></path> <path d=\"M6.32334 4.48382C6.35617 4.46658 6.38926 4.44922 6.42261 4.43172L7.91614 3.64795L17.0169 8.65338L21.0406 6.64152C21.1783 6.79745 21.298 6.96175 21.4029 7.13994C21.5525 7.39396 21.6646 7.66352 21.7487 7.96455L17.7503 9.96373V13.0002C17.7503 13.4144 17.4145 13.7502 17.0003 13.7502C16.5861 13.7502 16.2503 13.4144 16.2503 13.0002V10.7137L12.7503 12.4637V21.9042C12.4934 21.9682 12.2492 22.0002 12.0003 22.0002C11.7515 22.0002 11.5072 21.9682 11.2503 21.9042V12.4637L2.25195 7.96455C2.33601 7.66352 2.44813 7.39396 2.59771 7.13994C2.70264 6.96175 2.82232 6.79745 2.96001 6.64152L12.0003 11.1617L15.3865 9.46857L6.32334 4.48382Z\" fill=\"currentColor\"></path> </g> </svg> </div> <div class=\"circle notes\"> <svg viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"> <g id=\"SVGRepo_iconCarrier\"> <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5.87868 2.87868C5 3.75736 5 5.17157 5 8V16C5 18.8284 5 20.2426 5.87868 21.1213C6.75736 22 8.17157 22 11 22H13C15.8284 22 17.2426 22 18.1213 21.1213C19 20.2426 19 18.8284 19 16V8C19 5.17157 19 3.75736 18.1213 2.87868C17.2426 2 15.8284 2 13 2H11C8.17157 2 6.75736 2 5.87868 2.87868ZM8.25 17C8.25 16.5858 8.58579 16.25 9 16.25H12C12.4142 16.25 12.75 16.5858 12.75 17C12.75 17.4142 12.4142 17.75 12 17.75H9C8.58579 17.75 8.25 17.4142 8.25 17ZM9 12.25C8.58579 12.25 8.25 12.5858 8.25 13C8.25 13.4142 8.58579 13.75 9 13.75H15C15.4142 13.75 15.75 13.4142 15.75 13C15.75 12.5858 15.4142 12.25 15 12.25H9ZM8.25 9C8.25 8.58579 8.58579 8.25 9 8.25H15C15.4142 8.25 15.75 8.58579 15.75 9C15.75 9.41421 15.4142 9.75 15 9.75H9C8.58579 9.75 8.25 9.41421 8.25 9Z\" fill=\"currentColor\"></path> <path opacity=\"0.5\" d=\"M5.23525 4.05811C5 4.94139 5 6.17689 5 7.99985V15.9999C5 17.8229 5 19.0584 5.23527 19.9417L5 19.9238C4.02491 19.8279 3.36857 19.6111 2.87868 19.1212C2 18.2425 2 16.8283 2 13.9999V9.99991C2 7.17148 2 5.75726 2.87868 4.87859C3.36857 4.3887 4.02491 4.17194 5 4.07602L5.23525 4.05811Z\" fill=\"currentColor\"></path> <path opacity=\"0.5\" d=\"M18.7646 19.9417C18.9999 19.0584 18.9999 17.8229 18.9999 15.9999V7.99985C18.9999 6.17689 18.9999 4.94139 18.7647 4.05811L18.9999 4.07602C19.975 4.17194 20.6314 4.3887 21.1212 4.87859C21.9999 5.75726 21.9999 7.17148 21.9999 9.99991V13.9999C21.9999 16.8283 21.9999 18.2425 21.1212 19.1212C20.6314 19.6111 19.975 19.8279 18.9999 19.9238L18.7646 19.9417Z\" fill=\"currentColor\"></path> </g> </svg> </div> <!-- scooter --> <div class=\"circle scooter\"> <svg viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"> <g id=\"SVGRepo_iconCarrier\"> <path d=\"M16.6312 4.76853C16.3898 4.75049 16.0785 4.75 15.6088 4.75H14.381C13.9667 4.75 13.631 4.41421 13.631 4C13.631 3.58579 13.9667 3.25 14.381 3.25H15.6357H15.6357C16.0714 3.24999 16.4391 3.24998 16.743 3.2727C17.0624 3.29657 17.365 3.34825 17.6605 3.47926C18.1166 3.68148 18.5069 4.00766 18.7852 4.42132C18.966 4.69002 19.0682 4.979 19.1449 5.28811C19.2178 5.58157 19.2784 5.94079 19.3499 6.36477L19.3499 6.36484L20.3586 12.3459C20.3953 12.5635 20.3343 12.7863 20.1918 12.9548C20.0493 13.1234 19.8398 13.2206 19.619 13.2206C17.1319 13.2206 15.131 15.2107 15.131 17.6471C15.131 18.0613 14.7952 18.3971 14.381 18.3971H7.42003C7.08088 19.7531 5.84304 20.75 4.38095 20.75C2.66017 20.75 1.25 19.3691 1.25 17.6471C1.25 15.925 2.66017 14.5441 4.38095 14.5441C5.84304 14.5441 7.08088 15.541 7.42003 16.8971H13.6784C14.0147 14.2579 16.1026 12.1673 18.7426 11.7837L17.8754 6.64136C17.7981 6.18308 17.7466 5.8808 17.6892 5.64959C17.6341 5.42779 17.5857 5.32551 17.5407 5.25874C17.4211 5.08096 17.2522 4.93904 17.0526 4.85054C16.9761 4.81665 16.8634 4.78588 16.6312 4.76853Z\" fill=\"currentColor\"></path> <path opacity=\"0.5\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M16.4883 17.6469C16.4883 15.9248 17.8984 14.5439 19.6192 14.5439C21.34 14.5439 22.7502 15.9248 22.7502 17.6469C22.7502 19.3689 21.34 20.7498 19.6192 20.7498C17.8984 20.7498 16.4883 19.3689 16.4883 17.6469Z\" fill=\"currentColor\"></path> </g> </svg> </div> <!-- Moving dot --> <div class=\"dot\"></div> </div>\nstyle.css: body { background: #0b0b0b; display: flex; justify-content: center; align-items: center; height: 100vh; } .container { --animation-duration: 5s; --circle-bg-clr: #111; --ellipse-perimeter: 314; /* approximate perimeter of your ellipse */ --line-length: 5; /* visible segment */ /* calculate line dash based on radius and line length */ --line-dash: calc(var(--ellipse-perimeter) - var(--line-length)); width: 600px; height: 400px; position: relative; } svg { width: 100%; height: 100%; display: block; } .oval { fill: none; stroke: #0ff2; stroke-width: .5; } .path-line { fill: none; stroke: #0ff; stroke-width: 1; stroke-linecap: round; stroke-dasharray: var(--line-length) var(--line-dash); stroke-dashoffset: 0; animation: moveLine var(--animation-duration) linear infinite; } /* clearly this would be simpler done in JS but I like a challenge */ @keyframes moveLine { 0%,8% { stroke-dashoffset: -12; } /* pause at 1st circle */ 15%,23% { stroke-dashoffset: -52; } /* 2nd circle */ 33%,41% { stroke-dashoffset: -110; } /* 3rd circle */ 51%,59% { stroke-dashoffset: -170; } /* 4th circle */ 67%,75% { stroke-dashoffset: -210; } /* 5th circle */ 85%,93% { stroke-dashoffset: -270; } /* 6th circle */ 100% { stroke-dashoffset: -324; } /* end */ } /* HTML circles (content placeholders) */ .circle { position: absolute; top: var(--circle-y); left: var(--circle-x); translate: -50% -50%; width: 100px; aspect-ratio: 1; background-color: var(--circle-bg-clr); /*opacity: .5;*/ border: 2px solid #333; color: white; border-radius: 50%; /* Use calculated delay per circle */ animation: pulse var(--animation-duration) linear infinite; } .circle:nth-of-type(1) { --circle-x: 30%; --circle-y: 15%; --stop-index: 0; } .circle:nth-of-type(2) { --circle-x: 70%; --circle-y: 15%; --stop-index: 1; } .circle:nth-of-type(3) { --circle-x: 99%; --circle-y: 50%; --stop-index: 2; } .circle:nth-of-type(4) { --circle-x: 70%; --circle-y: 85%; --stop-index: 3; } .circle:nth-of-type(5) { --circle-x: 30%; --circle-y: 85%; --stop-index: 4; } .circle:nth-of-type(6) { --circle-x: 1%; --circle-y: 50%; --stop-index: 5; } /* Calculate animation-delay */ .circle { animation-delay: calc((var(--animation-duration) * var(--stop-index) / 6) - 250ms); & svg{ /* opacity: var(--icon-opacity,.5);*/ scale: var(--icon-scale, .5); transition-property: opacity,scale; transition-duration:150ms; transition-timing-function: ease-in-out; } &.heart > svg{ color:red; } &.battery > svg{ color: green; } &.notes > svg{ color: dodgerblue; } &.parcel > svg{ color: yellow; } &.scooter > svg{ color: orange } &.security > svg{ color: purple; } } @keyframes pulse { 5%,13% { scale: 1.2; border-color:#0ff; background-color: rgb(5, 51, 69); --icon-opacity: 1; --icon-scale: .8; } 15% { scale: 1; border-color:#222; background-color: var(--circle-bg-clr); --icon-opacity: .5; --icon-scale: .5; } }\nscript.js: ",
    "id": "animated-svg-path-with-stops"
  },
  {
    "title": "WebGL Fluid Simulation With Your Text",
    "description": "",
    "code": "index.html: <canvas></canvas> <script type=\"x-shader/x-fragment\" id=\"vertShader\"> precision highp float; varying vec2 vUv; attribute vec2 a_position; varying vec2 vL; varying vec2 vR; varying vec2 vT; varying vec2 vB; uniform vec2 u_texel; void main () { vUv = .5 * (a_position + 1.); vL = vUv - vec2(u_texel.x, 0.); vR = vUv + vec2(u_texel.x, 0.); vT = vUv + vec2(0., u_texel.y); vB = vUv - vec2(0., u_texel.y); gl_Position = vec4(a_position, 0., 1.); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShaderAdvection\"> precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D u_velocity_texture; uniform sampler2D u_input_texture; uniform vec2 u_texel; uniform float u_dt; uniform float u_use_text; uniform sampler2D u_text_texture; vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) { vec2 st = uv / tsize - 0.5; vec2 iuv = floor(st); vec2 fuv = fract(st); vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize); vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize); vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize); vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize); return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y); } void main () { vec2 coord = vUv - u_dt * bilerp(u_velocity_texture, vUv, u_texel).xy * u_texel; float text = texture2D(u_text_texture, vec2(vUv.x, 1. - vUv.y)).r; float dissipation = (.96 + text * .04 * u_use_text); gl_FragColor = dissipation * bilerp(u_input_texture, coord, u_texel); gl_FragColor.a = 1.; } </script> <script type=\"x-shader/x-fragment\" id=\"fragShaderDivergence\"> precision highp float; precision highp sampler2D; varying highp vec2 vUv; varying highp vec2 vL; varying highp vec2 vR; varying highp vec2 vT; varying highp vec2 vB; uniform sampler2D u_velocity_texture; void main () { float L = texture2D(u_velocity_texture, vL).x; float R = texture2D(u_velocity_texture, vR).x; float T = texture2D(u_velocity_texture, vT).y; float B = texture2D(u_velocity_texture, vB).y; float div = .6 * (R - L + T - B); gl_FragColor = vec4(div, 0., 0., 1.); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShaderPressure\"> precision highp float; precision highp sampler2D; varying highp vec2 vUv; varying highp vec2 vL; varying highp vec2 vR; varying highp vec2 vT; varying highp vec2 vB; uniform sampler2D u_pressure_texture; uniform sampler2D u_divergence_texture; uniform sampler2D u_text_texture; void main () { float text = texture2D(u_text_texture, vec2(vUv.x, 1. - vUv.y)).r; float L = texture2D(u_pressure_texture, vL).x; float R = texture2D(u_pressure_texture, vR).x; float T = texture2D(u_pressure_texture, vT).x; float B = texture2D(u_pressure_texture, vB).x; float C = texture2D(u_pressure_texture, vUv).x; float divergence = texture2D(u_divergence_texture, vUv).x; float pressure = (L + R + B + T - divergence) * 0.25; pressure += (.2 * text); gl_FragColor = vec4(pressure, 0., 0., 1.); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShaderGradientSubtract\"> precision highp float; precision highp sampler2D; varying highp vec2 vUv; varying highp vec2 vL; varying highp vec2 vR; varying highp vec2 vT; varying highp vec2 vB; uniform sampler2D u_pressure_texture; uniform sampler2D u_velocity_texture; uniform sampler2D u_text_texture; void main () { float L = texture2D(u_pressure_texture, vL).x; float R = texture2D(u_pressure_texture, vR).x; float T = texture2D(u_pressure_texture, vT).x; float B = texture2D(u_pressure_texture, vB).x; vec2 velocity = texture2D(u_velocity_texture, vUv).xy; velocity.xy -= vec2(R - L, T - B); gl_FragColor = vec4(velocity, 0., 1.); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShaderPoint\"> precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D u_input_texture; uniform float u_ratio; uniform vec3 u_point_value; uniform vec2 u_point; uniform float u_point_size; uniform sampler2D u_text_texture; void main () { vec2 p = vUv - u_point.xy; p.x *= u_ratio; vec3 splat = pow(2., -dot(p, p) / u_point_size) * u_point_value; float text = texture2D(u_text_texture, vec2(vUv.x, 1. - vUv.y)).r; splat *= (.7 + .2 * text); vec3 base = texture2D(u_input_texture, vUv).xyz; gl_FragColor = vec4(base + splat, 1.); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShaderOutputShader\"> precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D u_output_texture; uniform sampler2D u_text_texture; void main () { vec3 C = texture2D(u_output_texture, vUv).rgb; float text = texture2D(u_text_texture, vec2(vUv.x, 1. - vUv.y)).r; gl_FragColor = vec4(vec3(1.) - C, 1.); } </script>\nstyle.css: body, html { padding: 0; margin: 0; } canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; } .lil-gui { --width: 450px; max-width: 90%; --widget-height: 20px; font-size: 15px; --input-font-size: 15px; --padding: 10px; --spacing: 10px; --slider-knob-width: 5px; --background-color: rgba(5, 0, 15, .8); --widget-color: rgba(255, 255, 255, .3); --focus-color: rgba(255, 255, 255, .4); --hover-color: rgba(255, 255, 255, .5); --font-family: monospace; }\nscript.js: import GUI from \"https://cdn.jsdelivr.net/npm/lil-gui@0.18.2/+esm\" const canvasEl = document.querySelector(\"canvas\"); const textureEl = document.createElement(\"canvas\"); const textureCtx = textureEl.getContext(\"2d\"); const fontOptions = { \"Arial\": \"Arial, sans-serif\", \"Verdana\": \"Verdana, sans-serif\", \"Tahoma\": \"Tahoma, sans-serif\", \"Times New Roman\": \"Times New Roman, serif\", \"Georgia\": \"Georgia, serif\", \"Garamond\": \"Garamond, serif\", \"Courier New\": \"Courier New, monospace\", \"Brush Script MT\": \"Brush Script MT, cursive\" } const params = { fontName: \"Verdana\", isBold: false, fontSize: 80, text: \"fluid\", pointerSize: null, color: {r: 1., g: .0, b: .5} }; const pointer = { x: 0, y: 0, dx: 0, dy: 0, moved: false, }; let outputColor, velocity, divergence, pressure, canvasTexture; let isPreview = true; const gl = canvasEl.getContext(\"webgl\"); gl.getExtension(\"OES_texture_float\"); const vertexShader = createShader( document.getElementById(\"vertShader\").innerHTML, gl.VERTEX_SHADER); const splatProgram = createProgram(\"fragShaderPoint\"); const divergenceProgram = createProgram(\"fragShaderDivergence\"); const pressureProgram = createProgram(\"fragShaderPressure\"); const gradientSubtractProgram = createProgram(\"fragShaderGradientSubtract\"); const advectionProgram = createProgram(\"fragShaderAdvection\"); const outputShaderProgram = createProgram(\"fragShaderOutputShader\"); gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer()); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1, -1, -1, 1, 1, 1, 1, -1 ]), gl.STATIC_DRAW); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer()); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW); gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(0); createTextCanvasTexture(); initFBOs(); createControls(); setupEvents(); resizeCanvas(); window.addEventListener(\"resize\", resizeCanvas); render(); function createTextCanvasTexture() { canvasTexture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, canvasTexture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); } function updateTextCanvas() { textureCtx.fillStyle = \"black\"; textureCtx.fillRect(0, 0, textureEl.width, textureEl.height); textureCtx.font = (params.isBold ? \"bold\" : \"normal\") + \" \" + (params.fontSize * devicePixelRatio) + \"px \" + fontOptions[params.fontName]; textureCtx.fillStyle = \"#ffffff\"; textureCtx.textAlign = \"center\"; textureCtx.filter = \"blur(3px)\"; const textBox = textureCtx.measureText(params.text); textureCtx.fillText(params.text, .5 * textureEl.width, .5 * textureEl.height + .5 * textBox.actualBoundingBoxAscent); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, canvasTexture); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureEl); } function createProgram(elId) { const shader = createShader( document.getElementById(elId).innerHTML, gl.FRAGMENT_SHADER); const program = createShaderProgram(vertexShader, shader); const uniforms = getUniforms(program); return { program, uniforms } } function createShaderProgram(vertexShader, fragmentShader) { const program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error(\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program)); return null; } return program; } function getUniforms(program) { let uniforms = []; let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); for (let i = 0; i < uniformCount; i++) { let uniformName = gl.getActiveUniform(program, i).name; uniforms[uniformName] = gl.getUniformLocation(program, uniformName); } return uniforms; } function createShader(sourceCode, type) { const shader = gl.createShader(type); gl.shaderSource(shader, sourceCode); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; } return shader; } function blit(target) { if (target == null) { gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); gl.bindFramebuffer(gl.FRAMEBUFFER, null); } else { gl.viewport(0, 0, target.width, target.height); gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo); } gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); } function initFBOs() { const fboSize = [ Math.floor(.5 * window.innerWidth), Math.floor(.5 * window.innerHeight), ] outputColor = createDoubleFBO(fboSize[0], fboSize[1]); velocity = createDoubleFBO(fboSize[0], fboSize[1], gl.RG); divergence = createFBO(fboSize[0], fboSize[1], gl.RGB); pressure = createDoubleFBO(fboSize[0], fboSize[1], gl.RGB); } function createFBO(w, h, type = gl.RGBA) { gl.activeTexture(gl.TEXTURE0); const texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texImage2D(gl.TEXTURE_2D, 0, type, w, h, 0, type, gl.FLOAT, null); const fbo = gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER, fbo); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); gl.viewport(0, 0, w, h); gl.clear(gl.COLOR_BUFFER_BIT); return { fbo, width: w, height: h, attach(id) { gl.activeTexture(gl.TEXTURE0 + id); gl.bindTexture(gl.TEXTURE_2D, texture); return id; } }; } function createDoubleFBO(w, h, type) { let fbo1 = createFBO(w, h, type); let fbo2 = createFBO(w, h, type); return { width: w, height: h, texelSizeX: 1. / w, texelSizeY: 1. / h, read: () => { return fbo1; }, write: () => { return fbo2; }, swap() { let temp = fbo1; fbo1 = fbo2; fbo2 = temp; } } } function render(t) { const dt = 1 / 60; if (t && isPreview) { updateMousePosition( (.5 - .45 * Math.sin(.003 * t - 2)) * window.innerWidth, (.5 + .1 * Math.sin(.0025 * t) + .1 * Math.cos(.002 * t)) * window.innerHeight ); } if (pointer.moved) { if (!isPreview) { pointer.moved = false; } gl.useProgram(splatProgram.program); gl.uniform1i(splatProgram.uniforms.u_input_texture, velocity.read().attach(1)); gl.uniform1f(splatProgram.uniforms.u_ratio, canvasEl.width / canvasEl.height); gl.uniform2f(splatProgram.uniforms.u_point, pointer.x / canvasEl.width, 1 - pointer.y / canvasEl.height); gl.uniform3f(splatProgram.uniforms.u_point_value, pointer.dx, -pointer.dy, 1); gl.uniform1f(splatProgram.uniforms.u_point_size, params.pointerSize); blit(velocity.write()); velocity.swap(); gl.uniform1i(splatProgram.uniforms.u_input_texture, outputColor.read().attach(1)); gl.uniform3f(splatProgram.uniforms.u_point_value, 1. - params.color.r, 1. - params.color.g, 1. - params.color.b); blit(outputColor.write()); outputColor.swap(); } gl.useProgram(divergenceProgram.program); gl.uniform2f(divergenceProgram.uniforms.u_texel, velocity.texelSizeX, velocity.texelSizeY); gl.uniform1i(divergenceProgram.uniforms.u_velocity_texture, velocity.read().attach(1)); blit(divergence); gl.useProgram(pressureProgram.program); gl.uniform2f(pressureProgram.uniforms.u_texel, velocity.texelSizeX, velocity.texelSizeY); gl.uniform1i(pressureProgram.uniforms.u_divergence_texture, divergence.attach(1)); for (let i = 0; i < 10; i++) { gl.uniform1i(pressureProgram.uniforms.u_pressure_texture, pressure.read().attach(2)); blit(pressure.write()); pressure.swap(); } gl.useProgram(gradientSubtractProgram.program); gl.uniform2f(gradientSubtractProgram.uniforms.u_texel, velocity.texelSizeX, velocity.texelSizeY); gl.uniform1i(gradientSubtractProgram.uniforms.u_pressure_texture, pressure.read().attach(1)); gl.uniform1i(gradientSubtractProgram.uniforms.u_velocity_texture, velocity.read().attach(2)); blit(velocity.write()); velocity.swap(); gl.useProgram(advectionProgram.program); gl.uniform1f(advectionProgram.uniforms.u_use_text, 0); gl.uniform2f(advectionProgram.uniforms.u_texel, velocity.texelSizeX, velocity.texelSizeY); gl.uniform1i(advectionProgram.uniforms.u_velocity_texture, velocity.read().attach(1)); gl.uniform1i(advectionProgram.uniforms.u_input_texture, velocity.read().attach(1)); gl.uniform1f(advectionProgram.uniforms.u_dt, dt); blit(velocity.write()); velocity.swap(); gl.useProgram(advectionProgram.program); gl.uniform1f(advectionProgram.uniforms.u_use_text, 1); gl.uniform2f(advectionProgram.uniforms.u_texel, outputColor.texelSizeX, outputColor.texelSizeY); gl.uniform1i(advectionProgram.uniforms.u_input_texture, outputColor.read().attach(2)); blit(outputColor.write()); outputColor.swap(); gl.useProgram(outputShaderProgram.program); gl.uniform1i(outputShaderProgram.uniforms.u_output_texture, outputColor.read().attach(1)); gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); gl.bindFramebuffer(gl.FRAMEBUFFER, null); gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); requestAnimationFrame(render); } function resizeCanvas() { params.pointerSize = 4 / window.innerHeight; canvasEl.width = textureEl.width = window.innerWidth; canvasEl.height = textureEl.height = window.innerHeight; \t initFBOs(); updateTextCanvas(); } function setupEvents() { canvasEl.addEventListener(\"mousemove\", (e) => { isPreview = false; updateMousePosition(e.pageX, e.pageY); }); canvasEl.addEventListener(\"touchmove\", (e) => { e.preventDefault(); isPreview = false; updateMousePosition(e.targetTouches[0].pageX, e.targetTouches[0].pageY); }); } function updateMousePosition(eX, eY) { pointer.moved = true; pointer.dx = 5 * (eX - pointer.x); pointer.dy = 5 * (eY - pointer.y); pointer.x = eX; pointer.y = eY; } function createControls() { const gui = new GUI(); \t gui.close(); \t gui .add(params, \"text\") .onChange(updateTextCanvas); gui .add(params, \"fontSize\", 10, 300) .onChange(updateTextCanvas) .name(\"font size, px\"); gui .add(params, \"isBold\") .onChange(updateTextCanvas) .name(\"bold\"); gui .add(params, \"fontName\", Object.keys(fontOptions)) .onChange(updateTextCanvas) .name(\"font\"); gui .addColor(params, \"color\"); }",
    "id": "webgl-fluid-simulation-with-your-text"
  },
  {
    "title": "cg-tunnel",
    "code": {
      "version1/index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>3D Tunnel Using Shaders | mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <nav>\n      <div class=\"nav-items\">\n        <a href=\"#\">Works</a>\n        <a href=\"#\">Archive</a>\n      </div>\n      <div class=\"logo\">\n        <a href=\"#\">Tunnel Vision</a>\n      </div>\n      <div class=\"nav-items\">\n        <a href=\"#\">Info</a>\n        <a href=\"#\">Contact</a>\n      </div>\n    </nav>\n\n    <footer>\n      <p>Watch Showreel</p>\n      <p>Launching 2024</p>\n    </footer>\n\n    <div class=\"container\">\n      <h1>\n        A Journey Through Neon Tunnels <br />\n        and Digital Couture Awaits\n      </h1>\n    </div>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script id=\"vertexShader\" type=\"x-shader/x-vertex\">\n      void main() {\n          gl_Position = vec4(position, 1.0);\n      }\n    </script>\n    <script id=\"fragmentShader\" type=\"x-shader/x-fragment\">\n      uniform vec2 iResolution;\n      uniform float iTime;\n      uniform float scrollOffset;\n\n      void mainImage( out vec4 o, vec2 I ) {\n          I -= o.zw = iResolution.xy / 2.;\n          float t = iTime * 5.0 + scrollOffset * 0.1;\n          o = 1. - vec4(.5,1,9,0) *\n              ( sin(atan(I.y,I.x)/.1) * sin(20.*(o.w/=length(I))+t) - 1. + o.w );\n      }\n\n      void main() {\n          mainImage(gl_FragColor, gl_FragCoord.xy);\n      }\n    </script>\n    <script>\n      const scene = new THREE.Scene();\n      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n      const renderer = new THREE.WebGLRenderer();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      document.body.appendChild(renderer.domElement);\n\n      const geometry = new THREE.PlaneGeometry(2, 2);\n      const uniforms = {\n        iTime: { value: 0 },\n        iResolution: {\n          value: new THREE.Vector2(window.innerWidth, window.innerHeight),\n        },\n        scrollOffset: { value: 0 },\n      };\n\n      const material = new THREE.ShaderMaterial({\n        uniforms: uniforms,\n        vertexShader: document.getElementById(\"vertexShader\").textContent,\n        fragmentShader: document.getElementById(\"fragmentShader\").textContent,\n      });\n\n      const mesh = new THREE.Mesh(geometry, material);\n      scene.add(mesh);\n\n      let scrollVelocity = 0;\n      const scrollDamping = 0.92;\n      const scrollSensitivity = 0.025;\n\n      function handleScroll(event) {\n        event.preventDefault();\n        scrollVelocity += event.deltaY * scrollSensitivity;\n      }\n\n      window.addEventListener(\"wheel\", handleScroll, { passive: false });\n\n      function animate(time) {\n        requestAnimationFrame(animate);\n        uniforms.iTime.value = time * 0.001;\n\n        uniforms.scrollOffset.value += scrollVelocity;\n\n        scrollVelocity *= scrollDamping;\n\n        renderer.render(scene, camera);\n      }\n\n      animate();\n\n      window.addEventListener(\"resize\", onWindowResize, false);\n\n      function onWindowResize() {\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        renderer.setSize(width, height);\n        uniforms.iResolution.value.set(width, height);\n      }\n    </script>\n  </body>\n</html>\n",
      "version1/styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n}\n\ncanvas {\n  display: block;\n}\n\na,\np {\n  color: #fff;\n  text-decoration: none;\n  text-transform: uppercase;\n  font-family: \"Akkurat Mono\", Arial, sans-serif;\n  font-size: 12px;\n  font-weight: 500;\n}\n\nnav,\nfooter {\n  position: fixed;\n  width: 100%;\n  padding: 2em;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  mix-blend-mode: exclusion;\n  z-index: 2;\n}\n\nnav {\n  top: 0;\n}\n\nfooter {\n  bottom: 0;\n}\n\nnav > div {\n  flex: 1;\n  display: flex;\n  gap: 2em;\n}\n\n.logo {\n  display: flex;\n  justify-content: center;\n}\n\n.logo a {\n  font-family: \"Druk Wide Trial\";\n  font-size: 18px;\n  font-weight: lighter;\n}\n\n.nav-items:nth-child(3) {\n  justify-content: flex-end;\n}\n\n.container {\n  width: 100%;\n  height: 100%;\n}\n\nh1 {\n  width: 90%;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  text-transform: uppercase;\n  text-align: center;\n  font-family: \"Druk Wide Trial\";\n  font-size: 1.5vw;\n  color: #fff;\n  mix-blend-mode: difference;\n  z-index: 2;\n}\n",
      "version2/data.js": "export const slides = [\n  {\n    title: \"Neon\",\n    id: \"CG30128\",\n  },\n  {\n    title: \"Volt\",\n    id: \"CG39102\",\n  },\n  {\n    title: \"Echo\",\n    id: \"CG84729\",\n  },\n  {\n    title: \"Glitch\",\n    id: \"CG67215\",\n  },\n  {\n    title: \"Pulse\",\n    id: \"CG48391\",\n  },\n  {\n    title: \"Cipher\",\n    id: \"CG15938\",\n  },\n  {\n    title: \"Nova\",\n    id: \"CG92457\",\n  },\n  {\n    title: \"Synth\",\n    id: \"CG54283\",\n  },\n  {\n    title: \"Flux\",\n    id: \"CG61872\",\n  },\n  {\n    title: \"Vapor\",\n    id: \"CG73190\",\n  },\n];\n",
      "version2/index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>3D Tunnel Image Slider Carousel | mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <nav>\n      <div class=\"nav-items\">\n        <a href=\"#\">Works</a>\n        <a href=\"#\">Archive</a>\n      </div>\n      <div class=\"logo\">\n        <a href=\"#\">Tunnel Vision</a>\n      </div>\n      <div class=\"nav-items\">\n        <a href=\"#\">Info</a>\n        <a href=\"#\">Contact</a>\n      </div>\n    </nav>\n\n    <footer>\n      <p>Watch Showreel</p>\n      <p>Launching 2024</p>\n    </footer>\n\n    <div class=\"container\">\n      <div class=\"overlay\"></div>\n      <div class=\"slider\"></div>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js\"></script>\n    <script src=\"https://unpkg.com/lenis@1.1.13/dist/lenis.min.js\"></script>\n    <script id=\"vertexShader\" type=\"x-shader/x-vertex\">\n      void main() {\n          gl_Position = vec4(position, 1.0);\n      }\n    </script>\n    <script id=\"fragmentShader\" type=\"x-shader/x-fragment\">\n      uniform vec2 iResolution;\n      uniform float iTime;\n      uniform float scrollOffset;\n\n      void mainImage(out vec4 o, vec2 I) {\n          I -= o.zw = iResolution.xy / 2.0;\n          float t = iTime * 5.0 + scrollOffset * 200.0;\n          float pattern = sin(atan(I.y, I.x) / 0.1) * sin(20.0 * (o.w /= length(I)) + t) - 1.0 + o.w;\n\n          float monochrome = 1.0 - pattern * 0.5;\n\n          float invertedMonochrome = 1.0 - monochrome;\n\n          o = vec4(invertedMonochrome, invertedMonochrome, invertedMonochrome, 1.0);\n      }\n\n      void main() {\n          mainImage(gl_FragColor, gl_FragCoord.xy);\n      }\n    </script>\n    <script type=\"module\">\n      import { slides } from \"./data.js\";\n\n      const lenis = new Lenis();\n      lenis.on(\"scroll\", ScrollTrigger.update);\n      gsap.ticker.add((time) => {\n        lenis.raf(time * 1000);\n      });\n      gsap.ticker.lagSmoothing(0);\n\n      const scene = new THREE.Scene();\n      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n      const renderer = new THREE.WebGLRenderer();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      document.body.appendChild(renderer.domElement);\n\n      const geometry = new THREE.PlaneGeometry(2, 2);\n      const uniforms = {\n        iTime: { value: 0 },\n        iResolution: {\n          value: new THREE.Vector2(window.innerWidth, window.innerHeight),\n        },\n        scrollOffset: { value: 0 },\n      };\n\n      const material = new THREE.ShaderMaterial({\n        uniforms: uniforms,\n        vertexShader: document.getElementById(\"vertexShader\").textContent,\n        fragmentShader: document.getElementById(\"fragmentShader\").textContent,\n      });\n\n      const mesh = new THREE.Mesh(geometry, material);\n      scene.add(mesh);\n\n      let lastTime = 0;\n      function animateTunnel(time) {\n        const deltaTime = time - lastTime;\n        lastTime = time;\n        uniforms.iTime.value += deltaTime * 0.001;\n        renderer.render(scene, camera);\n        requestAnimationFrame(animateTunnel);\n      }\n\n      animateTunnel(0);\n\n      window.addEventListener(\"resize\", () => {\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        renderer.setSize(width, height);\n        uniforms.iResolution.value.set(width, height);\n      });\n\n      gsap.registerPlugin(ScrollTrigger);\n\n      const totalSlides = 10;\n      const zStep = 2500;\n      const initialZ = -22500;\n\n      function generateSlides() {\n        const slider = document.querySelector(\".slider\");\n        slider.innerHTML = \"\";\n\n        for (let i = 1; i <= totalSlides; i++) {\n          const slide = document.createElement(\"div\");\n          slide.className = \"slide\";\n          slide.id = `slide-${i}`;\n\n          const slideImg = document.createElement(\"div\");\n          slideImg.className = \"slide-img\";\n\n          const img = document.createElement(\"img\");\n          img.src = `./assets/img${i}.jpg`;\n          img.alt = \"\";\n\n          const slideCopy = document.createElement(\"div\");\n          slideCopy.classList.add(\"slide-copy\");\n          slideCopy.innerHTML = `<p>${slides[i - 1].title}</p><p>${\n            slides[i - 1].id\n          }</p>`;\n\n          slideImg.appendChild(img);\n          slide.appendChild(slideImg);\n          slide.appendChild(slideCopy);\n          slider.appendChild(slide);\n\n          const zPosition = initialZ + (i - 1) * zStep;\n          const xPosition = i % 2 === 0 ? \"30%\" : \"70%\";\n          const opacity = i === totalSlides ? 1 : i === totalSlides - 1 ? 0 : 0;\n\n          gsap.set(slide, {\n            top: \"50%\",\n            left: xPosition,\n            xPercent: -50,\n            yPercent: -50,\n            z: zPosition,\n            opacity: opacity,\n          });\n        }\n      }\n\n      window.addEventListener(\"load\", function () {\n        generateSlides();\n\n        const slides = gsap.utils.toArray(\".slide\");\n\n        function getInitialTranslateZ(slide) {\n          return gsap.getProperty(slide, \"z\");\n        }\n\n        function mapRange(value, inMin, inMax, outMin, outMax) {\n          return (\n            ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin\n          );\n        }\n\n        ScrollTrigger.create({\n          trigger: \".container\",\n          start: \"top top\",\n          end: \"bottom bottom\",\n          scrub: 1,\n          onUpdate: (self) => {\n            uniforms.scrollOffset.value = self.progress;\n          },\n        });\n\n        slides.forEach((slide, index) => {\n          const initialZ = getInitialTranslateZ(slide);\n\n          ScrollTrigger.create({\n            trigger: \".container\",\n            start: \"top top\",\n            end: \"bottom bottom\",\n            scrub: 1,\n            onUpdate: (self) => {\n              const progress = self.progress;\n              const zIncrement = progress * 22500;\n              const currentZ = initialZ + zIncrement;\n\n              let opacity;\n              if (currentZ >= -2500) {\n                opacity = mapRange(currentZ, -2500, 0, 0, 1);\n              } else {\n                opacity = mapRange(currentZ, -5000, -2500, 0, 0);\n              }\n\n              slide.style.opacity = opacity;\n              slide.style.transform = `translateX(-50%) translateY(-50%) translateZ(${currentZ}px)`;\n            },\n          });\n        });\n      });\n    </script>\n  </body>\n</html>\n",
      "version2/styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  width: 100%;\n  height: 100%;\n  background: #000;\n  overflow-x: hidden;\n}\n\ncanvas {\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: -1;\n}\n\nimg {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\na,\np {\n  color: #fff;\n  text-decoration: none;\n  text-transform: uppercase;\n  font-family: \"Akkurat Mono\", Arial, sans-serif;\n  font-size: 12px;\n  font-weight: 500;\n}\n\nnav,\nfooter {\n  position: fixed;\n  width: 100%;\n  padding: 2em;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  mix-blend-mode: exclusion;\n  z-index: 2;\n}\n\nnav {\n  top: 0;\n}\n\nfooter {\n  bottom: 0;\n}\n\nnav > div {\n  flex: 1;\n  display: flex;\n  gap: 2em;\n}\n\n.logo {\n  display: flex;\n  justify-content: center;\n}\n\n.logo a {\n  font-family: \"Timmons NY 2.005\", Arial, sans-serif;\n  font-size: 48px;\n  font-weight: lighter;\n}\n\n.nav-items:nth-child(3) {\n  justify-content: flex-end;\n}\n\n.container {\n  width: 100%;\n  height: 2000vh;\n}\n\n.slider {\n  position: fixed;\n  top: 0;\n  width: 100vw;\n  height: 100vh;\n  transform-style: preserve-3d;\n  perspective: 500px;\n  overflow: hidden;\n  z-index: 2;\n}\n\n.slide {\n  position: absolute;\n  width: 400px;\n  height: 500px;\n  will-change: transform, opacity;\n}\n\n.slide-img {\n  width: 100%;\n  height: 100%;\n  padding: 0.5em;\n  background-color: rgba(255, 255, 255, 0.1);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  backdrop-filter: blur(20px);\n}\n\n.slide-copy {\n  position: absolute;\n  width: 100%;\n  bottom: -24px;\n  display: flex;\n  justify-content: space-between;\n}\n\n.overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: rgb(0, 0, 0);\n  background: radial-gradient(\n    circle,\n    rgba(0, 0, 0, 0) 60%,\n    rgba(0, 0, 0, 1) 100%\n  );\n}\n\n.lenis.lenis-smooth {\n  scroll-behavior: auto !important;\n}\n\n.lenis.lenis-smooth [data-lenis-prevent] {\n  overscroll-behavior: contain;\n}\n\n.lenis.lenis-stopped {\n  overflow: hidden;\n}\n\n.lenis.lenis-smooth iframe {\n  pointer-events: none;\n}\n"
    }
  },
  {
    "title": "WebGL liquid masking",
    "description": "",
    "code": "index.html: <div class=\"content\"> <img src=\"https://ksenia-k.com/img/ksenia.jpg\"/> </div> <canvas></canvas> <div class=\"overlay\"> Liquid content reveal </div> <script type=\"x-shader/x-fragment\" id=\"vertShader\"> precision highp float; attribute vec2 aPosition; varying vec2 vUv; varying vec2 vL; varying vec2 vR; varying vec2 vT; varying vec2 vB; uniform vec2 u_vertex_texel; void main () { vUv = aPosition * .5 + .5; vL = vUv - vec2(u_vertex_texel.x, 0.); vR = vUv + vec2(u_vertex_texel.x, 0.); vT = vUv + vec2(0., u_vertex_texel.y); vB = vUv - vec2(0., u_vertex_texel.y); gl_Position = vec4(aPosition, 0., 1.); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShaderAdvection\"> precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D u_velocity_txr; uniform sampler2D u_input_txr; uniform vec2 u_vertex_texel; uniform vec2 u_output_textel; uniform float u_dt; uniform float u_dissipation; vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) { vec2 st = uv / tsize - 0.5; vec2 iuv = floor(st); vec2 fuv = fract(st); vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize); vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize); vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize); vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize); return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y); } void main () { vec2 coord = vUv - u_dt * bilerp(u_velocity_txr, vUv, u_vertex_texel).xy * u_vertex_texel; gl_FragColor = u_dissipation * bilerp(u_input_txr, coord, u_output_textel); gl_FragColor.a = 1.; } </script> <script type=\"x-shader/x-fragment\" id=\"fragShaderDivergence\"> precision highp float; precision highp sampler2D; varying highp vec2 vUv; varying highp vec2 vL; varying highp vec2 vR; varying highp vec2 vT; varying highp vec2 vB; uniform sampler2D u_velocity_txr; void main () { float L = texture2D(u_velocity_txr, vL).x; float R = texture2D(u_velocity_txr, vR).x; float T = texture2D(u_velocity_txr, vT).y; float B = texture2D(u_velocity_txr, vB).y; float div = .5 * (R - L + T - B); gl_FragColor = vec4(div, 0., 0., 1.); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShaderPressure\"> precision highp float; precision highp sampler2D; varying highp vec2 vUv; varying highp vec2 vL; varying highp vec2 vR; varying highp vec2 vT; varying highp vec2 vB; uniform sampler2D u_pressure_txr; uniform sampler2D u_divergence_txr; void main () { float L = texture2D(u_pressure_txr, vL).x; float R = texture2D(u_pressure_txr, vR).x; float T = texture2D(u_pressure_txr, vT).x; float B = texture2D(u_pressure_txr, vB).x; float C = texture2D(u_pressure_txr, vUv).x; float divergence = texture2D(u_divergence_txr, vUv).x; float pressure = (L + R + B + T - divergence) * 0.25; gl_FragColor = vec4(pressure, 0., 0., 1.); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShaderGradientSubtract\"> precision highp float; precision highp sampler2D; varying highp vec2 vUv; varying highp vec2 vL; varying highp vec2 vR; varying highp vec2 vT; varying highp vec2 vB; uniform sampler2D u_pressure_txr; uniform sampler2D u_velocity_txr; void main () { float L = texture2D(u_pressure_txr, vL).x; float R = texture2D(u_pressure_txr, vR).x; float T = texture2D(u_pressure_txr, vT).x; float B = texture2D(u_pressure_txr, vB).x; vec2 velocity = texture2D(u_velocity_txr, vUv).xy; velocity.xy -= vec2(R - L, T - B); gl_FragColor = vec4(velocity, 0., 1.); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShaderPoint\"> precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D u_input_txr; uniform float u_ratio; uniform vec3 u_point_value; uniform vec2 u_point; uniform float u_point_size; void main () { vec2 p = vUv - u_point.xy; p.x *= u_ratio; vec3 splat = pow(2., -dot(p, p) / u_point_size) * u_point_value; vec3 base = texture2D(u_input_txr, vUv).xyz; gl_FragColor = vec4(base + splat, 1.); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShaderDisplay\"> precision highp float; precision highp sampler2D; varying vec2 vUv; uniform sampler2D u_output_texture; void main () { vec3 C = texture2D(u_output_texture, vUv).rgb; float a = max(C.r, max(C.g, C.b)); a = pow(.1 * a, .1); a = clamp(a, 0., 1.); gl_FragColor = vec4(1. - C, 1. - a); } </script>\nstyle.css: html, body { overflow: hidden; padding: 0; margin: 0; } canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; } .content { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; } img { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); height: 115%; width: auto; opacity: 0; } @media (min-aspect-ratio: 4/3) { img { height: auto; width: 100%; } } @media (max-aspect-ratio: 3/5) { img { left: 30%; } } .overlay { position: fixed; top: 50%; left: 30%; max-width: 50%; transform: translate(-50%, -50%); font-family: sans-serif; font-size: 10vh; font-weight: bold; pointer-events: none; text-transform: uppercase; } @media (max-aspect-ratio: 1/1) { .overlay { left: 50%; width: 90%; max-width: 90%; } } @media (max-aspect-ratio: 3/5) { .overlay { font-size: 5vh; } }\nscript.js: const canvas = document.getElementsByTagName(\"canvas\")[0]; const image = document.getElementsByTagName(\"img\")[0]; canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; const params = { SIM_RESOLUTION: 128, DYE_RESOLUTION: 1024, DENSITY_DISSIPATION: .995, VELOCITY_DISSIPATION: .9, PRESSURE_ITERATIONS: 10, SPLAT_RADIUS: 3 / window.innerHeight, color: {r: .8, g: .5, b: .2} }; const pointer = { x: .65 * window.innerWidth, y: .5 * window.innerHeight, dx: 0, dy: 0, moved: false, firstMove: false // for codepen preview }; window.setTimeout(() => { pointer.firstMove = true; }, 3000); let prevTimestamp = Date.now(); const gl = canvas.getContext(\"webgl\"); gl.getExtension(\"OES_texture_float\"); let outputColor, velocity, divergence, pressure; const vertexShader = createShader( document.getElementById(\"vertShader\").innerHTML, gl.VERTEX_SHADER); const splatProgram = createProgram(\"fragShaderPoint\"); const divergenceProgram = createProgram(\"fragShaderDivergence\"); const pressureProgram = createProgram(\"fragShaderPressure\"); const gradientSubtractProgram = createProgram(\"fragShaderGradientSubtract\"); const advectionProgram = createProgram(\"fragShaderAdvection\"); const displayProgram = createProgram(\"fragShaderDisplay\"); initFBOs(); render(); image.style.opacity = \"1\"; window.addEventListener(\"resize\", () => { params.SPLAT_RADIUS = 5 / window.innerHeight; canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }); canvas.addEventListener(\"click\", (e) => { pointer.dx = 10; pointer.dy = 10; pointer.x = e.pageX; pointer.y = e.pageY; pointer.firstMove = true; }); canvas.addEventListener(\"mousemove\", (e) => { pointer.moved = true; pointer.dx = 5 * (e.pageX - pointer.x); pointer.dy = 5 * (e.pageY - pointer.y); pointer.x = e.pageX; pointer.y = e.pageY; pointer.firstMove = true; }); canvas.addEventListener(\"touchmove\", (e) => { e.preventDefault(); pointer.moved = true; pointer.dx = 8 * (e.targetTouches[0].pageX - pointer.x); pointer.dy = 8 * (e.targetTouches[0].pageY - pointer.y); pointer.x = e.targetTouches[0].pageX; pointer.y = e.targetTouches[0].pageY; pointer.firstMove = true; }); function createProgram(elId) { const shader = createShader( document.getElementById(elId).innerHTML, gl.FRAGMENT_SHADER); const program = createShaderProgram(vertexShader, shader); const uniforms = getUniforms(program); return { program, uniforms } } function createShaderProgram(vertexShader, fragmentShader) { const program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error(\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program)); return null; } return program; } function getUniforms(program) { let uniforms = []; let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); for (let i = 0; i < uniformCount; i++) { let uniformName = gl.getActiveUniform(program, i).name; uniforms[uniformName] = gl.getUniformLocation(program, uniformName); } return uniforms; } function createShader(sourceCode, type) { const shader = gl.createShader(type); gl.shaderSource(shader, sourceCode); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; } return shader; } function blit(target) { gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer()); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1, -1, -1, 1, 1, 1, 1, -1 ]), gl.STATIC_DRAW); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer()); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW); gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(0); if (target == null) { gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); gl.bindFramebuffer(gl.FRAMEBUFFER, null); } else { gl.viewport(0, 0, target.width, target.height); gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo); } gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); } function initFBOs() { const simRes = getResolution(params.SIM_RESOLUTION); const dyeRes = getResolution(params.DYE_RESOLUTION); outputColor = createDoubleFBO(dyeRes.width, dyeRes.height); velocity = createDoubleFBO(simRes.width, simRes.height); divergence = createFBO(simRes.width, simRes.height, gl.RGB); pressure = createDoubleFBO(simRes.width, simRes.height, gl.RGB); } function getResolution(resolution) { let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight; if (aspectRatio < 1) aspectRatio = 1. / aspectRatio; let min = Math.round(resolution); let max = Math.round(resolution * aspectRatio); if (gl.drawingBufferWidth > gl.drawingBufferHeight) return {width: max, height: min}; else return {width: min, height: max}; } function createFBO(w, h, type = gl.RGBA) { gl.activeTexture(gl.TEXTURE0); const texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texImage2D(gl.TEXTURE_2D, 0, type, w, h, 0, type, gl.FLOAT, null); const fbo = gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER, fbo); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); gl.viewport(0, 0, w, h); gl.clear(gl.COLOR_BUFFER_BIT); return { fbo, width: w, height: h, attach(id) { gl.activeTexture(gl.TEXTURE0 + id); gl.bindTexture(gl.TEXTURE_2D, texture); return id; } }; } function createDoubleFBO(w, h, type) { let fbo1 = createFBO(w, h, type); let fbo2 = createFBO(w, h, type); return { width: w, height: h, texelSizeX: 1. / w, texelSizeY: 1. / h, read: () => { return fbo1; }, write: () => { return fbo2; }, swap() { let temp = fbo1; fbo1 = fbo2; fbo2 = temp; } } } function render() { const dt = (Date.now() - prevTimestamp) / 1000; prevTimestamp = Date.now(); if (!pointer.firstMove) { pointer.moved = true; const newX = (.65 + .2 * Math.cos(.006 * prevTimestamp) * Math.sin(.008 * prevTimestamp)) * window.innerWidth; const newY = (.5 + .12 * Math.sin(.01 * prevTimestamp)) * window.innerHeight; pointer.dx = 10 * (newX - pointer.x); pointer.dy = 10 * (newY - pointer.y); pointer.x = newX; pointer.y = newY; } if (pointer.moved) { pointer.moved = false; gl.useProgram(splatProgram.program); gl.uniform1i(splatProgram.uniforms.u_input_txr, velocity.read().attach(0)); gl.uniform1f(splatProgram.uniforms.u_ratio, canvas.width / canvas.height); gl.uniform2f(splatProgram.uniforms.u_point, pointer.x / canvas.width, 1 - pointer.y / canvas.height); gl.uniform3f(splatProgram.uniforms.u_point_value, pointer.dx, -pointer.dy, 1); gl.uniform1f(splatProgram.uniforms.u_point_size, params.SPLAT_RADIUS); blit(velocity.write()); velocity.swap(); gl.uniform1i(splatProgram.uniforms.u_input_txr, outputColor.read().attach(0)); gl.uniform3f(splatProgram.uniforms.u_point_value, 1. - params.color.r, 1. - params.color.g, 1. - params.color.b); blit(outputColor.write()); outputColor.swap(); } gl.useProgram(divergenceProgram.program); gl.uniform2f(divergenceProgram.uniforms.u_vertex_texel, velocity.texelSizeX, velocity.texelSizeY); gl.uniform1i(divergenceProgram.uniforms.u_velocity_txr, velocity.read().attach(0)); blit(divergence); gl.useProgram(pressureProgram.program); gl.uniform2f(pressureProgram.uniforms.u_vertex_texel, velocity.texelSizeX, velocity.texelSizeY); gl.uniform1i(pressureProgram.uniforms.u_divergence_txr, divergence.attach(0)); for (let i = 0; i < params.PRESSURE_ITERATIONS; i++) { gl.uniform1i(pressureProgram.uniforms.u_pressure_txr, pressure.read().attach(1)); blit(pressure.write()); pressure.swap(); } gl.useProgram(gradientSubtractProgram.program); gl.uniform2f(gradientSubtractProgram.uniforms.u_vertex_texel, velocity.texelSizeX, velocity.texelSizeY); gl.uniform1i(gradientSubtractProgram.uniforms.u_pressure_txr, pressure.read().attach(0)); gl.uniform1i(gradientSubtractProgram.uniforms.u_velocity_txr, velocity.read().attach(1)); blit(velocity.write()); velocity.swap(); gl.useProgram(advectionProgram.program); gl.uniform2f(advectionProgram.uniforms.u_vertex_texel, velocity.texelSizeX, velocity.texelSizeY); gl.uniform2f(advectionProgram.uniforms.u_output_textel, velocity.texelSizeX, velocity.texelSizeY); gl.uniform1i(advectionProgram.uniforms.u_velocity_txr, velocity.read().attach(0)); gl.uniform1i(advectionProgram.uniforms.u_input_txr, velocity.read().attach(0)); gl.uniform1f(advectionProgram.uniforms.u_dt, dt); gl.uniform1f(advectionProgram.uniforms.u_dissipation, params.VELOCITY_DISSIPATION); blit(velocity.write()); velocity.swap(); gl.uniform2f(advectionProgram.uniforms.u_output_textel, outputColor.texelSizeX, outputColor.texelSizeY); gl.uniform1i(advectionProgram.uniforms.u_velocity_txr, velocity.read().attach(0)); gl.uniform1i(advectionProgram.uniforms.u_input_txr, outputColor.read().attach(1)); gl.uniform1f(advectionProgram.uniforms.u_dissipation, params.DENSITY_DISSIPATION); blit(outputColor.write()); outputColor.swap(); gl.useProgram(displayProgram.program); gl.uniform1i(displayProgram.uniforms.u_output_texture, outputColor.read().attach(0)); blit(); requestAnimationFrame(render); }",
    "id": "webgl-liquid-masking"
  },
  {
    "title": "Colored, Glowing Edge Card",
    "description": "",
    "code": "index.html: <main id=\"app\"> <div class=\"card\"> <span class=\"glow\"></span> <div class=\"inner\"> <header> <svg class=\"sun\" viewBox=\"0 0 24 24\"><g fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"4\"/><path d=\"M12 2v2m0 16v2M4.93 4.93l1.41 1.41m11.32 11.32l1.41 1.41M2 12h2m16 0h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41\"/></g></svg> <h2>Colored, Glowing Edges</h2> <svg class=\"moon\" viewBox=\"0 0 24 24\"><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M20.985 12.486a9 9 0 1 1-9.473-9.472c.405-.022.617.46.402.803a6 6 0 0 0 8.268 8.268c.344-.215.825-.004.803.401\"/></svg> </header> <footer class=\"content\"> <p>This is <em>somewhat different</em> to the usual colored, glowing cards you may have seen before!</p> <p>Building off my <a href=\"https://codepen.io/simeydotme/pen/QwjEgmq\" target=\"_blank\">previous Codepen (Gradient Pulse)</a>, I wanted to create a card with glowing edges, and a subtle coloured border.</p> <p> I'm using <strong>a mesh gradient background</strong>, which is masked with radial gradients to create the edge colors. Then it's <em>masked again with a conic-gradient that follows the direction of the pointer</em>. The glow increases in opacity as the pointer gets closer to the edge.</p> <p>This effect feels a lot better in my opinion, than a simple radial-gradient mask that follows the pointer, as the glow is stuck to the edge more naturally.</p> </footer> </div> </div> </main> <!-- social icons --> <a class=\"social-icon codepen\" href=\"https://codepen.io/simeydotme\" title=\"view my codepens\"> Made by Simey </a> <a class=\"social-icon twitter\" href=\"https://twitter.com/simeydotme\"> <svg viewBox=\"0 0 24 24\"> <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path> <path d=\"M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z\"></path> </svg> </a> <a class=\"social-icon github\" href=\"https://github.com/simeydotme\"> <svg viewBox=\"0 0 24 24\"> <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path> <path d=\"M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5\"></path> </svg> </a>\nstyle.css: :root { /* vars */ --glow-sens: 30; --card-bg: linear-gradient(8deg,var(--dark) 75%, color-mix(in hsl, var(--dark), white 2.5%) 75.5%); --blend: soft-light; --glow-blend: plus-lighter; --glow-color: 40deg 80% 80%; --glow-boost: 0%; } .light .card { --card-bg: linear-gradient(8deg,color-mix(in hsl, hsl(260, 25%, 95%), var(--dark) 2.5%) 75%, hsl(260, 25%, 95%) 75.5%); --blend: darken; --glow-blend: luminosity; --glow-color: 280deg 90% 95%; --glow-boost: 15%; --fg: black; color: var(--fg); } body.light { background-image: linear-gradient( 180deg, hsl(var(--h), 8%, 58%), hsl(var(--h), 15%, 42%) ); } .card { --pads: 40px; --color-sens: calc(var(--glow-sens) + 20); --pointer-¬∞: 45deg; position: relative; width: clamp(320px, calc(100svw - calc(var(--pads) * 2)), 600px); height: calc(100svh - calc(var(--pads) * 2)); max-height: 600px; border-radius: 1.768em; isolation: isolate; transform: translate3d(0, 0, 0.01px); display: grid; border: 1px solid rgb(255 255 255 / 25%); background: var(--card-bg); background-repeat: no-repeat; &::before, &::after, & > .glow { content: \"\"; position: absolute; inset: 0; border-radius: inherit; transition: opacity 0.25s ease-out; z-index: -1; } &:not(:hover):not(.animating) { &::before, &::after, & > .glow { opacity: 0; transition: opacity 0.75s ease-in-out; } } &::before { /* mesh gradient border */ border: 1px solid transparent; background: linear-gradient(var(--card-bg) 0 100%) padding-box, linear-gradient(rgb(255 255 255 / 0%) 0% 100%) border-box, radial-gradient(at 80% 55%, hsla(268,100%,76%,1) 0px, transparent 50%) border-box, radial-gradient(at 69% 34%, hsla(349,100%,74%,1) 0px, transparent 50%) border-box, radial-gradient(at 8% 6%, hsla(136,100%,78%,1) 0px, transparent 50%) border-box, radial-gradient(at 41% 38%, hsla(192,100%,64%,1) 0px, transparent 50%) border-box, radial-gradient(at 86% 85%, hsla(186,100%,74%,1) 0px, transparent 50%) border-box, radial-gradient(at 82% 18%, hsla(52,100%,65%,1) 0px, transparent 50%) border-box, radial-gradient(at 51% 4%, hsla(12,100%,72%,1) 0px, transparent 50%) border-box, linear-gradient(#c299ff 0 100%) border-box; /* opacity increases as pointer gets near edge */ opacity: calc((var(--pointer-d) - var(--color-sens)) / (100 - var(--color-sens))); /* border is masked to a cone, originating from the center towards the pointer */ mask-image: conic-gradient( from var(--pointer-¬∞) at center, black 25%, transparent 40%, transparent 60%, black 75% ); } &::after { /* mesh gradient background */ border: 1px solid transparent; background: radial-gradient(at 80% 55%, hsla(268,100%,76%,1) 0px, transparent 50%) padding-box, radial-gradient(at 69% 34%, hsla(349,100%,74%,1) 0px, transparent 50%) padding-box, radial-gradient(at 8% 6%, hsla(136,100%,78%,1) 0px, transparent 50%) padding-box, radial-gradient(at 41% 38%, hsla(192,100%,64%,1) 0px, transparent 50%) padding-box, radial-gradient(at 86% 85%, hsla(186,100%,74%,1) 0px, transparent 50%) padding-box, radial-gradient(at 82% 18%, hsla(52,100%,65%,1) 0px, transparent 50%) padding-box, radial-gradient(at 51% 4%, hsla(12,100%,72%,1) 0px, transparent 50%) padding-box, linear-gradient(#c299ff 0 100%) padding-box; /* 5 radial masks to create a squircle-cut-out, and then a cone-gradient originating from the center towards the pointer to highlight the edges */ mask-image: linear-gradient( to bottom, black, black ), radial-gradient( ellipse at 50% 50%, black 40%, transparent 65% ), radial-gradient( ellipse at 66% 66%, black 5%, transparent 40% ), radial-gradient( ellipse at 33% 33%, black 5%, transparent 40% ), radial-gradient( ellipse at 66% 33%, black 5%, transparent 40% ), radial-gradient( ellipse at 33% 66%, black 5%, transparent 40% ), conic-gradient( from var(--pointer-¬∞) at center, transparent 5%, black 15%, black 85%, transparent 95% ); mask-composite: subtract,add,add,add,add,add; /* opacity increases as pointer gets near edge */ opacity: calc((var(--pointer-d) - var(--color-sens)) / (100 - var(--color-sens))); mix-blend-mode: var(--blend); } & > .glow { /* glowing border edges */ --outset: var(--pads); /* outer padding so the glow can overflow the element without being masked */ inset: calc(var(--outset) * -1); pointer-events: none; z-index: 1; /* glow is masked to a cone, originating from the center towards the pointer */ mask-image: conic-gradient( from var(--pointer-¬∞) at center, black 2.5%, transparent 10%, transparent 90%, black 97.5% ); /* opacity increases as pointer gets near edge */ opacity: calc((var(--pointer-d) - var(--glow-sens)) / (100 - var(--glow-sens))); mix-blend-mode: var(--glow-blend); &::before { content: \"\"; position: absolute; inset: var(--outset); border-radius: inherit; box-shadow: inset 0 0 0 1px hsl( var(--glow-color) / 100%), inset 0 0 1px 0 hsl( var(--glow-color) / calc(var(--glow-boost) + 60%)), inset 0 0 3px 0 hsl( var(--glow-color) / calc(var(--glow-boost) + 50%)), inset 0 0 6px 0 hsl( var(--glow-color) / calc(var(--glow-boost) + 40%)), inset 0 0 15px 0 hsl( var(--glow-color) / calc(var(--glow-boost) + 30%)), inset 0 0 25px 2px hsl( var(--glow-color) / calc(var(--glow-boost) + 20%)), inset 0 0 50px 2px hsl( var(--glow-color) / calc(var(--glow-boost) + 10%)), 0 0 1px 0 hsl( var(--glow-color) / calc(var(--glow-boost) + 60%)), 0 0 3px 0 hsl( var(--glow-color) / calc(var(--glow-boost) + 50%)), 0 0 6px 0 hsl( var(--glow-color) / calc(var(--glow-boost) + 40%)), 0 0 15px 0 hsl( var(--glow-color) / calc(var(--glow-boost) + 30%)), 0 0 25px 2px hsl( var(--glow-color) / calc(var(--glow-boost) + 20%)), 0 0 50px 2px hsl( var(--glow-color) / calc(var(--glow-boost) + 10%)); ; } } } .card { box-shadow: rgba(0, 0, 0, 0.1) 0px 1px 2px, rgba(0, 0, 0, 0.1) 0px 2px 4px, rgba(0, 0, 0, 0.1) 0px 4px 8px, rgba(0, 0, 0, 0.1) 0px 8px 16px, rgba(0, 0, 0, 0.1) 0px 16px 32px, rgba(0, 0, 0, 0.1) 0px 32px 64px; } .inner { text-align: center; h2 { color: inherit; font-weight: 500; font-size: 1.25em; margin-block: 0.5em; } header { display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em; } svg { height: 24px; } } h2 { } .card .inner { display: flex; flex-direction: column; justify-content: space-between; container-type: inline-size; position: relative; overflow: auto; z-index: 1; } .card .content { padding: 1em; font-weight: 300; text-align: left; line-height: 1.4; color: color-mix(var(--fg), transparent 60%); overflow: auto; scrollbar-width: none; mask-image: linear-gradient( to top, transparent 5px, black 2em); & em, & strong { color: color-mix(var(--fg), transparent 40%); } & p { opacity: 0; animation: fadeContent 1.5s ease-in-out 2s both; &:nth-child(2) { animation-delay: 2.25s; } &:nth-child(3) { animation-delay: 2.5s; } &:nth-child(4) { animation-delay: 2.75s; } } } @keyframes fadeContent { to { opacity: 1; } } body, html { height: 100svh; overflow: auto; background: hsl(var(--h), 18%, 12%); } main { justify-items: center; align-content: center; min-height: 100%; } .sun { opacity: 0.25; &:hover { opacity: 1; } } .moon { opacty: 1; } .sun, .moon { transition: all 0.2s ease; } .light { --link: hsl(var(--canvas), 90%, 50%); --linkh: hsl(150, 85%, 40%); & .sun { opacity: 1; } & .moon { opacity: 0.25; &:hover { opacity: 1; } } h2 { text-shadow: 0 1px 1px lightslategray; } }\nscript.js: const $card = document.querySelector(\".card\"); const cardUpdate = (e) => { const position = pointerPositionRelativeToElement( $card, e ); const [px,py] = position.pixels; const [perx, pery] = position.percent; const [dx,dy] = distanceFromCenter( $card, px, py ); const edge = closenessToEdge( $card, px, py ); const angle = angleFromPointerEvent( $card, dx, dy ); $card.style.setProperty('--pointer-x', `${round(perx)}%`); $card.style.setProperty('--pointer-y', `${round(pery)}%`); $card.style.setProperty('--pointer-¬∞', `${round(angle)}deg`); $card.style.setProperty('--pointer-d', `${round(edge * 100)}`); $card.classList.remove('animating'); }; $card.addEventListener(\"pointermove\", cardUpdate); const centerOfElement = ($el) => { const { left, top, width, height } = $el.getBoundingClientRect(); return [ width/2, height/2 ]; } const pointerPositionRelativeToElement = ($el, e) => { const pos = [e.clientX, e.clientY]; const { left, top, width, height } = $el.getBoundingClientRect(); const x = pos[0] - left; const y = pos[1] - top; const px = clamp((100 / width) * x); const py = clamp((100 / height) * y); return { pixels: [x,y], percent: [px,py] } } const angleFromPointerEvent = ($el, dx, dy ) => { // in degrees let angleRadians = 0; let angleDegrees = 0; if ( dx !== 0 || dy !== 0 ) { angleRadians = Math.atan2(dy, dx); angleDegrees = angleRadians * (180 / Math.PI) + 90; if (angleDegrees < 0) { angleDegrees += 360; } } return angleDegrees; } const distanceFromCenter = ( $card, x, y ) => { // in pixels const [cx,cy] = centerOfElement( $card ); return [ x - cx, y - cy ]; } const closenessToEdge = ( $card, x, y ) => { // in fraction (0,1) const [cx,cy] = centerOfElement( $card ); const [dx,dy] = distanceFromCenter( $card, x, y ); let k_x = Infinity; let k_y = Infinity; if (dx !== 0) { k_x = cx / Math.abs(dx); } if (dy !== 0) { k_y = cy / Math.abs(dy); } return clamp((1 / Math.min(k_x, k_y)), 0, 1); } const round = (value, precision = 3) => parseFloat(value.toFixed(precision)); const clamp = (value, min = 0, max = 100) => Math.min(Math.max(value, min), max); /** code for the intro animation, not related to teh interaction */ const playAnimation = () => { const angleStart = 110; const angleEnd = 465; $card.style.setProperty('--pointer-¬∞', `${angleStart}deg`); $card.classList.add('animating'); animateNumber({ ease: easeOutCubic, duration: 500, onUpdate: (v) => { $card.style.setProperty('--pointer-d', v); } }); animateNumber({ ease: easeInCubic, delay: 0, duration: 1500, endValue: 50, onUpdate: (v) => { const d = (angleEnd - angleStart) * (v / 100) + angleStart; $card.style.setProperty('--pointer-¬∞', `${d}deg`); } }); animateNumber({ ease: easeOutCubic, delay: 1500, duration: 2250, startValue: 50, endValue: 100, onUpdate: (v) => { const d = (angleEnd - angleStart) * (v / 100) + angleStart; $card.style.setProperty('--pointer-¬∞', `${d}deg`); } }); animateNumber({ ease: easeInCubic, duration: 1500, delay: 2500, startValue: 100, endValue: 0, onUpdate: (v) => { $card.style.setProperty('--pointer-d', v); }, onEnd: () => { $card.classList.remove('animating'); } }); } setTimeout(() => { playAnimation(); }, 500); function easeOutCubic(x) { return 1 - Math.pow(1 - x, 3); } function easeInCubic(x) { return x * x * x; } function animateNumber(options) { const { startValue = 0, endValue = 100, duration = 1000, delay = 0, onUpdate = () => {}, ease = (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2, onStart = () => {}, onEnd = () => {}, } = options; const startTime = performance.now() + delay; function update() { const currentTime = performance.now(); const elapsed = currentTime - startTime; const t = Math.min(elapsed / duration, 1); // Normalize to [0, 1] const easedValue = startValue + (endValue - startValue) * ease(t); // Apply easing onUpdate(easedValue); if (t < 1) { requestAnimationFrame(update); // Continue the animation } else if (t >= 1) { onEnd(); } } setTimeout(() => { onStart(); requestAnimationFrame(update); // Start the animation after the delay }, delay); } /* theme switching */ const $app = document.querySelector('#app'); const $moon = document.querySelector(\".moon\"); const $sun = document.querySelector(\".sun\"); $moon.addEventListener('click', () => { document.body.classList.remove('light'); $app.classList.remove('light'); }) $sun.addEventListener('click', () => { document.body.classList.add('light'); $app.classList.add('light'); })",
    "id": "colored-glowing-edge-card"
  },
  {
    "title": "Flair Confetti!",
    "description": "",
    "code": "index.html: <p>click and drag</p> <section class=\"hero pricing-hero\" data-block=\"pricing-hero\"> <div class=\"container\"> <div class=\"pricing-hero__content\"> <div class=\"pricing-hero__flair\"> <div class=\"pricing-hero__hand\"> <img class=\"pricing-hero__drag\" src=\"https://assets.codepen.io/16327/hand-drag.png\" alt=\"\"> <img class=\"pricing-hero__rock\" src=\"https://assets.codepen.io/16327/hand-rock.png\" alt=\"\"> <img class=\"pricing-hero__handle\" src=\"https://assets.codepen.io/16327/2D-circle.png\" alt=\"\"> <small>drag me</small> </div> <div class=\"image-preload\" aria-hidden=\"true\"> <img data-key=\"combo\" src=\"https://assets.codepen.io/16327/3D-combo.png\" width=\"1\" height=\"1\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"cone\" src=\"https://assets.codepen.io/16327/3D-cone.png\" width=\"1\" height=\"1\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"hoop\" src=\"https://assets.codepen.io/16327/3D-hoop.png\" width=\"1\" height=\"1\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"keyframe\" src=\"https://assets.codepen.io/16327/3D-keyframe.png\" width=\"1\" height=\"1\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"semi\" src=\"https://assets.codepen.io/16327/3D-semi.png\" width=\"1\" height=\"1\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"spiral\" src=\"https://assets.codepen.io/16327/3D-spiral.png\" width=\"1\" height=\"1\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"squish\" src=\"https://assets.codepen.io/16327/3D-squish.png\" width=\"1\" height=\"1\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"triangle\" src=\"https://assets.codepen.io/16327/3D-triangle.png\" width=\"1\" height=\"1\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"tunnel\" src=\"https://assets.codepen.io/16327/3D-tunnel.png\" width=\"1\" height=\"1\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"wat\" src=\"https://assets.codepen.io/16327/3D-poly.png\" width=\"1\" height=\"1\" style=\"position: absolute; left: -9999px;\" /> </div> <div class=\"explosion-preload\" aria-hidden=\"true\"> <img data-key=\"blue-circle\" src=\"https://assets.codepen.io/16327/2D-circles.png\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"green-keyframe\" src=\"https://assets.codepen.io/16327/2D-keyframe.png\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"orange-lightning\" src=\"https://assets.codepen.io/16327/2D-lightning.png\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"orange-star\" src=\"https://assets.codepen.io/16327/2D-star.png\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"purple-flower\" src=\"https://assets.codepen.io/16327/2D-flower.png\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"cone\" src=\"https://assets.codepen.io/16327/3D-cone.png\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"keyframe\" src=\"https://assets.codepen.io/16327/3D-spiral.png\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"spiral\" src=\"https://assets.codepen.io/16327/3D-spiral.png\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"tunnel\" src=\"https://assets.codepen.io/16327/3D-tunnel.png\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"hoop\" src=\"https://assets.codepen.io/16327/3D-hoop.png\" style=\"position: absolute; left: -9999px;\" /> <img data-key=\"semi\" src=\"https://assets.codepen.io/16327/3D-semi.png\" style=\"position: absolute; left: -9999px;\" /> </div> </div> </div> <svg class=\"pricing-hero__canvas\"></svg> <div class=\"pricing-hero__proxy\"></div> </div> </section>\nstyle.css: p { position: fixed; top: 48%; left: 0; right: 0; width: 100%; text-align: center; z-index: 999; pointer-events: none; } .pricing-hero { align-items: center; background: var(--color-just-black); display: flex; flex-direction: column; justify-content: center; max-width: 100vw; min-height: 100vh; overflow: hidden; position: relative; width: 100%; z-index: 2; } img { max-width 100%; } .pricing-hero .subtitle { color: var(--color-surface-white); display: inline-block; z-index: 2; } .pricing-hero__flair { display: block; margin: max(2rem, min(2.0712vw + 1.51456rem, 4rem)) auto max(2rem, min(6.21359vw + 0.543689rem, 8rem)); width: 100%; } .pricing-hero__content { padding-bottom: max(4rem, min(10.7443vw + 1.4818rem, 14.375rem)); padding-top: max(4rem, min(10.7443vw + 1.4818rem, 14.375rem)); text-align: center; width: 100%; } .pricing-hero__heading-container { position: relative; width: 100%; } .pricing-hero__heading--free { left: 0; opacity: 0; position: absolute; top: 0; width: 100%; } .pricing-hero__heading { line-height: 1.13 !important; margin: 0; } .pricing-hero__heading > * { -webkit-text-fill-color: transparent; background: var(--color-ui-gradient); -webkit-background-clip: text; background-clip: text; will-change: transform; } .pricing-hero__hand { left: 0; opacity: 0; pointer-events: none; position: fixed; top: 0; width: 30px; z-index: 4; } .pricing-hero__hand small { left: -60%; position: absolute; top: 20px; width: 200%; } .pricing-hero__drag, .pricing-hero__rock { position: absolute; z-index: 4; } .pricing-hero__rock, .pricing-hero__drag { max-width: 141%; opacity: 0; right: 1px; top: -22px; width: 131%; } .pricing-hero__drag { opacity: 1; } .pricing-hero__handle { left: 0; opacity: 0; position: absolute; right: 0; top: -40px; width: 100%; } .pricing-hero__canvas { z-index: -1; } .pricing-hero__canvas, .pricing-hero__proxy { bottom: 0; height: 100vh; left: 0; position: absolute; right: 0; top: 0; width: 100vw; } .pricing-hero__proxy { z-index: 3; } .explosion-img { will-change: transform; } .pricing-intro { align-items: center; background: var(--color-ui-blue-lt); color: var(--color-just-black); overflow: hidden; padding-top: max(4rem, min(7.63754vw + 2.20995rem, 11.375rem)); position: relative; z-index: 2; } @media only screen and (min-width: 77.5rem) { .pricing-intro { padding-bottom: max(2rem, min(9.64401vw - 0.260316rem, 11.3125rem)); } } .pricing-intro .heading-r { -webkit-text-fill-color: transparent; background: var(--color-ui-text-gradient); -webkit-background-clip: text; background-clip: text; line-height: 1.2; margin-bottom: max(1rem, min(1.0356vw + 0.757282rem, 2rem)); } .pricing-intro:after { background-image: url(/tf-assets/noise-e82662fe.png); bottom: 0; content: \"\"; display: block; height: 100%; left: 0; opacity: 0.2; pointer-events: none; position: absolute; right: 0; top: 0; width: 100%; } .pricing-intro__heading { margin-bottom: max(2rem, min(2.0712vw + 1.51456rem, 4rem)); } .pricing-intro__flair { margin-bottom: 0; margin-top: 64px; } .pricing-intro__flair svg { margin: 0 auto; max-width: max(16.875rem, min(17.4757vw + 12.7791rem, 33.75rem)); width: 100%; } .explosion-img { \twill-change: transform; }\nscript.js: gsap.registerPlugin( Observer, CustomEase, CustomWiggle, Physics2DPlugin, ScrollTrigger ); class confettiCannon { constructor(el) { this.el = el; } init() { const hero = this.el; this.hero = hero; const el = { hand: hero.querySelector(\".pricing-hero__hand\"), instructions: hero.querySelector(\".pricing-hero__hand small\"), rock: hero.querySelector(\".pricing-hero__rock\"), drag: hero.querySelector(\".pricing-hero__drag\"), handle: hero.querySelector(\".pricing-hero__handle\"), canvas: hero.querySelector(\".pricing-hero__canvas\"), proxy: hero.querySelector(\".pricing-hero__proxy\"), preloadImages: hero.querySelectorAll(\".image-preload img\"), xplodePreloadImages: hero.querySelectorAll(\".explosion-preload img\") }; this.el = el; this.isDrawing = false; this.imageMap = {}; this.imageKeys = []; this.el.preloadImages.forEach((img) => { const key = img.dataset.key; this.imageMap[key] = img; this.imageKeys.push(key); }); this.explosionMap = {}; this.explosionKeys = []; this.el.xplodePreloadImages.forEach((img) => { const key = img.dataset.key; this.explosionMap[key] = img; this.explosionKeys.push(key); }); this.currentLine = null; this.startImage = null; this.circle = null; this.startX = 0; this.startY = 0; this.lastDistance = 0; this.animationIsOk = window.matchMedia( \"(prefers-reduced-motion: no-preference)\" ).matches; this.wiggle = CustomWiggle.create(\"myWiggle\", { wiggles: 6 }); this.clamper = gsap.utils.clamp(1, 100); this.xSetter = gsap.quickTo(this.el.hand, \"x\", { duration: 0.1 }); this.ySetter = gsap.quickTo(this.el.hand, \"y\", { duration: 0.1 }); this.setpricingMotion(); this.initObserver(); this.initEvents(); } initEvents() { if (!this.animationIsOk || ScrollTrigger.isTouch === 1) return; this.hero.style.cursor = \"none\"; this.hero.addEventListener(\"mouseenter\", (e) => { gsap.set(this.el.hand, { opacity: 1 }); this.xSetter(e.x, e.x); this.ySetter(e.y, e.y); }); this.hero.addEventListener(\"mouseleave\", (e) => { gsap.set(this.el.hand, { opacity: 0 }); }); this.hero.addEventListener(\"mousemove\", (e) => { this.xSetter(e.x); this.ySetter(e.y); }); gsap.delayedCall(1, (e) => { this.createExplosion(window.innerWidth/2, window.innerHeight/2, 600); }) } setpricingMotion() { gsap.set(this.el.hand, { xPercent: -50, yPercent: -50 }); } initObserver() { if (!this.animationIsOk) return; if (ScrollTrigger.isTouch === 1) { Observer.create({ target: this.el.proxy, type: \"touch\", onPress: (e) => { this.createExplosion(e.x, e.y, 400); } }); } else { Observer.create({ target: this.el.proxy, type: \"pointer\", onPress: (e) => this.startDrawing(e), onDrag: (e) => this.isDrawing && this.updateDrawing(e), onDragEnd: (e) => this.clearDrawing(e), onRelease: (e) => this.clearDrawing(e) }); } } startDrawing(e) { this.isDrawing = true; gsap.set(this.el.instructions, { opacity: 0 }); this.startX = e.x; this.startY = e.y + window.scrollY; // Create line this.currentLine = document.createElementNS( \"http://www.w3.org/2000/svg\", \"line\" ); this.currentLine.setAttribute(\"x1\", this.startX); this.currentLine.setAttribute(\"y1\", this.startY); this.currentLine.setAttribute(\"x2\", this.startX); this.currentLine.setAttribute(\"y2\", this.startY); this.currentLine.setAttribute(\"stroke\", \"#fffce1\"); this.currentLine.setAttribute(\"stroke-width\", \"2\"); this.currentLine.setAttribute(\"stroke-dasharray\", \"4\"); this.circle = document.createElementNS( \"http://www.w3.org/2000/svg\", \"circle\" ); this.circle.setAttribute(\"cx\", this.startX); this.circle.setAttribute(\"cy\", this.startY); this.circle.setAttribute(\"r\", \"30\"); this.circle.setAttribute(\"fill\", \"#0e100f\"); // Create image at start point const randomKey = gsap.utils.random(this.imageKeys); const original = this.imageMap[randomKey]; const clone = document.createElementNS( \"http://www.w3.org/2000/svg\", \"image\" ); clone.setAttribute(\"x\", this.startX - 25); clone.setAttribute(\"y\", this.startY - 25); clone.setAttribute(\"width\", \"50\"); clone.setAttribute(\"height\", \"50\"); clone.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", original.src); this.startImage = clone; this.el.canvas.appendChild(this.currentLine); this.el.canvas.appendChild(this.circle); this.el.canvas.appendChild(this.startImage); gsap.set(this.el.drag, { opacity: 1 }); gsap.set(this.el.handle, { opacity: 1 }); gsap.set(this.el.rock, { opacity: 0 }); } updateDrawing(e) { if (!this.currentLine || !this.startImage) return; let cursorX = e.x; let cursorY = e.y + window.scrollY; let dx = cursorX - this.startX; let dy = cursorY - this.startY; let distance = Math.sqrt(dx * dx + dy * dy); let shrink = (distance - 30) / distance; let x2 = this.startX + dx * shrink; let y2 = this.startY + dy * shrink; if (distance < 30) { x2 = this.startX; y2 = this.startY; } let angle = Math.atan2(dy, dx) * (180 / Math.PI); gsap.to(this.currentLine, { attr: { x2, y2 }, duration: 0.1, ease: \"none\" }); // Eased scale (starts fast, slows down) let raw = distance / 100; let eased = Math.pow(raw, 0.5); let clamped = this.clamper(eased); gsap.set([this.startImage, this.circle], { scale: clamped, rotation: `${angle + -45}_short`, transformOrigin: \"center center\" }); // Move & rotate hand gsap.to(this.el.hand, { rotation: `${angle + -90}_short`, duration: 0.1, ease: \"none\" }); this.lastDistance = distance; } createExplosion(x, y, distance = 100) { const count = Math.round(gsap.utils.clamp(3, 100, distance / 20)); const angleSpread = Math.PI * 2; const explosion = gsap.timeline(); const gravity = 5; const speed = gsap.utils.mapRange(0, 500, 0.3, 1.5, distance); const sizeRange = gsap.utils.mapRange(0, 500, 20, 60, distance); for (let i = 0; i < count; i++) { const randomKey = gsap.utils.random(this.explosionKeys); const original = this.explosionMap[randomKey]; const img = original.cloneNode(true); img.className = \"explosion-img\"; img.style.position = \"absolute\"; img.style.pointerEvents = \"none\"; img.style.height = `${gsap.utils.random(20, sizeRange)}px`; img.style.left = `${x}px`; img.style.top = `${y}px`; img.style.zIndex = 4; this.hero.appendChild(img); const angle = Math.random() * angleSpread; const velocity = gsap.utils.random(500, 1500) * speed; explosion .to( img, { physics2D: { angle: angle * (180 / Math.PI), velocity: velocity, gravity: 3000 }, rotation: gsap.utils.random(-180, 180), duration: 1 + Math.random() }, 0 ) .to( img, { opacity: 0, duration: 0.2, ease: \"power1.out\", onComplete: () => img.remove() }, 1 ); } return explosion; } clearDrawing(e) { if (!this.isDrawing) return; this.createExplosion(this.startX, this.startY, this.lastDistance); gsap.set(this.el.drag, { opacity: 0 }); gsap.set(this.el.handle, { opacity: 0 }); gsap.set(this.el.rock, { opacity: 1 }); gsap.to(this.el.rock, { duration: 0.4, rotation: \"+=30\", ease: \"myWiggle\", onComplete: () => { gsap.set(this.el.rock, { opacity: 0 }); gsap.set(this.el.hand, { rotation: 0, overwrite: \"auto\" }); gsap.to(this.el.instructions, { opacity: 1 }); gsap.set(this.el.drag, { opacity: 1 }); } }); this.isDrawing = false; // Clear all elements from SVG and reset references this.el.canvas.innerHTML = \"\"; this.currentLine = null; this.startImage = null; } } const cannon = new confettiCannon(document.body); cannon.init();",
    "id": "flair-confetti"
  },
  {
    "title": "Gradient Pulse animation",
    "description": "",
    "code": "index.html: <main id=\"app\"> <section class=\"card\"> <div class=\"gradient-mask\"> <!-- using two layers of mask here, instead of a single mask with a subtract composite, as it costs 2x the performance when animating composite masks --> <div class=\"gradient\" style=\"opacity: 0;\"> </div> </div> <div class=\"inner\"> <div role=\"button\" tabindex=\"0\" class=\"check\" title=\"click to restart the animation!\"> <svg tick viewBox=\"0 0 24 24\"><g fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"><path d=\"M21.801 10A10 10 0 1 1 17 3.335\"/><path d=\"m9 11l3 3L22 4\"/></g></svg> <svg clock viewBox=\"0 0 24 24\"><path fill=\"currentColor\" d=\"M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,20a9,9,0,1,1,9-9A9,9,0,0,1,12,21Z\"/><rect width=\"2\" height=\"7\" x=\"11\" y=\"6\" fill=\"currentColor\" rx=\"1\"><animateTransform attributeName=\"transform\" dur=\"9s\" repeatCount=\"indefinite\" type=\"rotate\" values=\"0 12 12;360 12 12\"/></rect><rect width=\"2\" height=\"9\" x=\"11\" y=\"11\" fill=\"currentColor\" rx=\"1\"><animateTransform attributeName=\"transform\" dur=\"0.75s\" repeatCount=\"indefinite\" type=\"rotate\" values=\"0 12 12;360 12 12\"/></rect></svg> </div> <header> <svg viewBox=\"0 0 24 24\"><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"m15 18l-6-6l6-6\"/></svg> <h2>Gradient Pulse</h2> <svg viewBox=\"0 0 24 24\"><path fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M18 6L6 18M6 6l12 12\"/></svg> </header> <div class=\"inline-ranges\" title=\"play with the colors!\"> <input type=range id=\"h2\" min=0 max=360 value=222 /> <input type=range id=\"h1\" min=0 max=360 value=255 /> </div> <footer class=\"content\"> <p>Inspired by the <a href=\"https://x.com/Jakubantalik/status/1947960379356897396\" target=\"_blank\">tweet from @Jakubantalik</a></p> </footer> </div> </section> </main> <!-- social icons --> <a class=\"social-icon codepen\" href=\"https://codepen.io/simeydotme\" title=\"view my codepens\"> Made by Simey </a> <a class=\"social-icon twitter\" href=\"https://twitter.com/simeydotme\"> <svg viewBox=\"0 0 24 24\"> <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path> <path d=\"M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z\"></path> </svg> </a> <a class=\"social-icon github\" href=\"https://github.com/simeydotme\"> <svg viewBox=\"0 0 24 24\"> <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path> <path d=\"M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5\"></path> </svg> </a> <svg class=\"arrow\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 320 512\"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d=\"M0 55.2L0 426c0 12.2 9.9 22 22 22c6.3 0 12.4-2.7 16.6-7.5L121.2 346l58.1 116.3c7.9 15.8 27.1 22.2 42.9 14.3s22.2-27.1 14.3-42.9L179.8 320l118.1 0c12.2 0 22.1-9.9 22.1-22.1c0-6.3-2.7-12.3-7.4-16.5L38.6 37.9C34.3 34.1 28.9 32 23.2 32C10.4 32 0 42.4 0 55.2z\"/></svg>\nstyle.css: :root { /* vars */ --hue1: 123; --hue2: 145; } @property --opc { syntax: \"<percentage>\"; inherits: false; initial-value: 100%; } @property --gradient-h { syntax: \"<percentage>\"; inherits: false; initial-value: 150%; } @property --gradient-w { syntax: \"<percentage>\"; inherits: false; initial-value: 100%; } @property --gradient-inner-opacity { syntax: \"<percentage>\"; inherits: false; initial-value: 0%; } @property --gradient-middle-opacity { syntax: \"<percentage>\"; inherits: false; initial-value: 100%; } @property --gradient-outer-opacity { syntax: \"<percentage>\"; inherits: false; initial-value: 100%; } @property --radial-center { syntax: \"<percentage>\"; inherits: false; initial-value: 40%; } @property --conic-rotate { syntax: \"<angle>\"; inherits: false; initial-value: 0deg; } .card { --gradient-height: 450px; position: relative; width: clamp(320px, calc(100svw - calc(var(--pads) * 3)), 600px); height: calc(100svh - calc(var(--pads) * 3)); max-height: 600px; border-radius: 1.768em; background: hsl(260, 25%, 95%); isolation: isolate; display: grid; overflow: hidden; } .inner { color: black; text-align: center; header { display: flex; justify-content: space-between; align-items: center; padding: 0.5em 1em; } svg { height: 24px; } } .check { display: flex; justify-content: center; align-items: center; position: absolute; left: 50%; top: 0; padding: 0; margin-top: 26%; translate: -50% -50%; aspect-ratio: 1; width: 2.5em; border-radius: 99vw; color: white; transition: scale 1s ease-in-out; background: oklch(0.7 0.05 var(--hue2) / 75%); &:focus-visible { outline: 2px solid oklch(0.6 0.7 var(--hue1) / 75%); box-shadow: 0 0 0 2px white inset; } &.animate { background: oklch(0.7 0.3 var(--hue2) / 75%); transition-delay: 0.1s; } & svg { position: absolute; opacity: 0; transition: opacity 0.33s ease-in-out; transition-delay: 0.1s; } & [clock] { opacity: 1; } &.animate [tick] { opacity: 1; } &.animate [clock] { opacity: 0; } } ::selection { background: oklch(0.87 0.2 var(--hue1) / 60%); } .gradient-mask { position: absolute; inset: 0; aspect-ratio: 1.3; border-radius: inherit; border-bottom-left-radius: 0px; border-bottom-right-radius: 0px; transform: translate3d(0,0,0.01px); mask-image: linear-gradient(to top, transparent 30%, black 90%); } .gradient { --opc: 100%; --gradient-h: 150%; --gradient-w: 100%; --gradient-inner-opacity: 0%; --gradient-middle-opacity: 100%; --gradient-outer-opacity: 100%; --radial-center: 40%; border-radius: inherit; position: absolute; inset: 0; background-color: transparent; background-image: radial-gradient( circle at 50% var(--radial-center), oklch(0.87 0.28 var(--hue2) / var(--opc)) 10%, oklch(0.87 0.25 var(--hue1) / 0%) 66% ), conic-gradient( from var(--conic-rotate) at 50% var(--radial-center), oklch(0.87 0.25 var(--hue1) / var(--opc)) 15%, oklch(0.87 0.28 var(--hue2) / var(--opc)) 57%, oklch(0.87 0.25 var(--hue1) / var(--opc)) 100% ); background-blend-mode: color; mask-image: radial-gradient( var(--gradient-w) var(--gradient-h) at 50% var(--radial-center), rgb(0 0 0 / var(--gradient-inner-opacity)) 20%, rgb(0 0 0 / var(--gradient-middle-opacity)) 40%, rgb(0 0 0 / var(--gradient-middle-opacity)) 50%, rgb(0 0 0 / var(--gradient-outer-opacity)) 75% ); mask-size: cover; mask-position: center; mask-repeat: no-repeat; z-index: -1; transition: opacity 0.15s ease-in; } .check.animate { animation: scaleCheck 0.8s linear(0, 0.444 4.1%, 0.727 7.6%, 0.894 11%, 0.934 12.7%, 0.947 14.4%, 0.937 15.9%, 0.904 17.5%, 0.77 21%, -0.117 36.2%, -0.244 39.8%, -0.31 43.3%, -0.325 46.5%, -0.299 50%, -0.05 63.7%, -0.002 67.3%, 0.026 70.9%, 0.038 77.1%, 0.006 90.7%, 0) both; } .gradient.animate { animation: gradient 2.2s cubic-bezier(0.278, 0.001, 0.393, 1) both; } @keyframes gradient { 0% { --radial-center: 30%; --conic-rotate: -100deg; --opc: 50%; --gradient-h: 0%; --gradient-w: 0%; --gradient-inner-opacity: 0%; --gradient-middle-opacity: 30%; --gradient-outer-opacity: 0%; } 75% { --radial-center: 60%; --gradient-h: 180%; --gradient-w: 140%; --gradient-outer-opacity: 0%; } 100% { --opc: 80%; --radial-center: 60%; --conic-rotate: 50deg; --gradient-h: 180%; --gradient-w: 180%; --gradient-inner-opacity: 0%; --gradient-middle-opacity: 55%; --gradient-outer-opacity: 55%; } } @keyframes scaleCheck { to { scale: 1.4; } } @keyframes fadeIn { to { opacity: 1; } } body, html { height: 100svh; overflow: auto; font-family: \"Asap\"; background-image: linear-gradient( 180deg, hsl(var(--h), 8%, 58%), hsl(var(--h), 15%, 32%) ); } main { justify-items: center; align-content: center; min-height: 100%; } h2 { color: inherit; text-shadow: none; text-align: center; font-family: \"Asap\"; font-style: normal; font-weight: 500; font-size: 1em; } .card .inner { display: flex; flex-direction: column; justify-content: space-between; container-type: inline-size; position: relative; z-index: 1; } .card .content { font-size: 0.75em; } .card a { color: color-mix(in hsl, var(--link) 60%, black); &:hover { color: color-mix(in hsl, var(--linkh) 60%, black); } } .card { box-shadow: rgba(0, 0, 0, 0.1) 0px 1px 2px, rgba(0, 0, 0, 0.1) 0px 2px 4px, rgba(0, 0, 0, 0.1) 0px 4px 8px, rgba(0, 0, 0, 0.1) 0px 8px 16px, rgba(0, 0, 0, 0.1) 0px 16px 32px, rgba(0, 0, 0, 0.1) 0px 32px 64px; } .inline-ranges { --bor: hsl(var(--h), var(--s), 85%); --bg: var(--light); --fg: var(--dark); display: flex; flex-direction: column; align-items: center; margin-top: auto; margin-bottom: 3em; padding-inline: 2em; gap: 1em; & input { margin: 0!important; --tint: oklch(0.86 0.28 var(--hue2) / 66%); --tint2: oklch(0.88 0.25 var(--hue1) / 66%); } & #h1 { --tint: oklch(0.88 0.25 var(--hue1) / 66%); --tint2: oklch(0.88 0.25 var(--hue1) / 66%); --hue: var(--hue1); width: 320px; &:not(:focus) { --fg: var(--tint); } } & #h2 { --tint: oklch(0.86 0.28 var(--hue2) / 66%); --tint2: oklch(0.86 0.28 var(--hue2) / 66%); --hue: var(--hue2); width: 320px; &:not(:focus) { --fg: var(--tint); } } opacity: 0; animation: fadeIn 2s ease 2s forwards; } @container (width > 500px) { .inline-ranges { flex-direction: row; } } .arrow { position: absolute; left: 50%; top: 30%; fill: white; color: white; width: 40px; height: 40px; stroke: black; stroke-width: 20; translate: 0px 0px; filter: invert(1) drop-shadow(0 2px 3px rgba(0,0,0,0.25)) drop-shadow(0 4px 8px rgba(0,0,0,0.15)); animation: arrow 3.2s ease both; z-index: 99; } @keyframes arrow { 0% { opacity: 0; translate: 10vw 10vh; } 35%, 49% { scale: 1; translate: 1vw 10vh; opacity: 1; } 38% { scale: 0.75; translate: 0.5vw 9.5vh; } 73% { translate: 2vw 9vh; opacity: 1; } 100% { translate: 20vw -20vh; opacity: 0; } }\nscript.js: const $card = document.querySelector('.card'); const $gradient = $card.querySelector('.gradient'); const $check = $card.querySelector('.check'); $card.addEventListener('pointerdown', async (e) => { if(e.target.matches('input')) return; $check.classList.remove('animate'); $check.style.transitionDuration = '1s'; repaint(() => { $check.style.scale = '1.4'; }); stopPulse(); }); $card.addEventListener('pointerup', async (e) => { if(e.target.matches('input')) return; $check.classList.add('animate'); $check.style.transitionDuration = '0.25s'; $check.style.scale = ''; restartPulse(); }); $check.addEventListener('keypress', async (e) => { stopPulse(); repaint(() => { replayBounce(); restartPulse(); }, 100); }); async function repaint(cb, delay = 0) { requestAnimationFrame(() => { setTimeout(cb, delay); }); } async function stopPulse() { $gradient.style.opacity = 0; repaint(() => { $gradient.classList.remove('animate'); },150); } function restartPulse() { $gradient.style.opacity = 0; repaint(() => { $gradient.style.opacity = 1; $gradient.classList.add('animate'); }, 150); } async function replayBounce() { $check.classList.remove('animate'); repaint(() => { $check.classList.add('animate'); }) } repaint(() => { replayBounce(); restartPulse(); }, 1000); const $hue1 = document.querySelector('#h1'); const $hue2 = document.querySelector('#h2'); // ---------------------------------------- // change colors as the slider moves // ---------------------------------------- $hue1.addEventListener( 'input', (event) => { requestAnimationFrame(() => { document.body.style.setProperty('--hue1', event.target.value ); }) }); $hue2.addEventListener( 'input', (event) => { requestAnimationFrame(() => { document.body.style.setProperty('--hue2', event.target.value ); }) }); // ---------------------------------------- // replay animation when the sliders stop // ---------------------------------------- $hue1.addEventListener('change', () => { stopPulse(); repaint(() => { replayBounce(); restartPulse(); }, 500); }); $hue2.addEventListener('change', () => { stopPulse(); repaint(() => { replayBounce(); restartPulse(); }, 500); }); // ---------------------------------------- // randomise colors on load // ---------------------------------------- const hueDiff = 50; const rand1 = Math.floor(Math.random() * (360 - hueDiff)); const rand2 = Math.floor(rand1 + ( (hueDiff / 2) + ( Math.random() * hueDiff ) / 2 ) ); $hue1.value = rand1; $hue2.value = rand2; document.body.style.setProperty('--hue1', rand1 ); document.body.style.setProperty('--hue2', rand2 );",
    "id": "gradient-pulse-animation"
  },
  {
    "title": "Dashboard GSAP Animation",
    "description": "",
    "code": "index.html: <svg class=\"dashboard\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"500px\" height=\"459.3px\" viewBox=\"0 0 500 459.3\" style=\"enable-background:new 0 0 500 459.3;\" xml:space=\"preserve\"> \t<style type=\"text/css\"> \t\t.body{fill:white;} \t\t.st0{fill:#eaecf2;} \t\t.st1{fill:#5E7EBE;} \t\t.st2{opacity:0.5;fill:#FFFFFF;} \t\t.st3{fill:#FFFFFF;} \t\t.st4{opacity:0.5;fill:#B9BCC1;} \t\t.st5{opacity:0.1;fill:#5E7EBE;} \t\t.st6{fill:none;stroke:#5E7EBE;stroke-miterlimit:10;} \t\t.st7{fill:#FFFFFF;stroke:#5E7EBE;stroke-miterlimit:10;} \t\t.st8{fill:none;stroke:#4DC4D0;stroke-miterlimit:10;} \t\t.st9{opacity:0.1;fill:#4DC4D0;} \t\t.st10{fill:#FFFFFF;stroke:#4DC4D0;stroke-miterlimit:10;} \t\t.st11{fill:none;stroke:#5E7EBE;stroke-width:18;stroke-miterlimit:10;} \t\t.st12{fill:none;stroke:#4DC4D0;stroke-width:18;stroke-miterlimit:10;} \t\t.st13{fill:none;stroke:#384E72;stroke-width:18;stroke-miterlimit:10;} \t\t.st14{fill:#4DC4D0;} \t\t.st15{fill:#384E72;} \t</style> \t<g> \t\t<rect x=\"0\" y=\"0\" class=\"body\" width=\"500\" height=\"459.3\"/> \t</g> \t<g class=\"main\"> \t\t<rect x=\"82.7\" y=\"50.5\" class=\"st0\" width=\"417.3\" height=\"408.8\"/> \t</g> \t<g class=\"data-block-1 data-block\"> \t\t<rect class=\"background st1\" x=\"90.3\" y=\"60\" width=\"95.3\" height=\"53.3\"/> \t\t<rect x=\"97.3\" y=\"66.3\" class=\"st2\" width=\"27.1\" height=\"5.2\"/> \t\t<rect x=\"97.3\" y=\"98.7\" class=\"st2\" width=\"69.6\" height=\"3\"/> \t\t<rect x=\"97.3\" y=\"104.7\" class=\"st2\" width=\"23.3\" height=\"3\"/> \t\t<rect x=\"97.3\" y=\"80\" class=\"st2\" width=\"44.7\" height=\"10.3\"/> \t</g> \t<g class=\"data-block-white data-block\"> \t\t<rect class=\"background st3\" x=\"90.3\" y=\"127\" width=\"95.3\" height=\"53.3\"/> \t\t<rect x=\"90.3\" y=\"127\" class=\"st1\" width=\"2.2\" height=\"53.3\"/> \t\t<rect x=\"97.3\" y=\"133.3\" class=\"st4\" width=\"27.1\" height=\"5.2\"/> \t\t<rect x=\"97.3\" y=\"165.7\" class=\"st4\" width=\"69.6\" height=\"3\"/> \t\t<rect x=\"97.3\" y=\"171.7\" class=\"st4\" width=\"23.3\" height=\"3\"/> \t\t<rect x=\"97.3\" y=\"147\" class=\"st4\" width=\"44.7\" height=\"10.3\"/> \t</g> \t<g class=\"data-block-white data-block\"> \t\t<rect class=\"background st3\" x=\"90.3\" y=\"194\" width=\"95.3\" height=\"53.3\"/> \t\t<rect x=\"90.3\" y=\"194\" class=\"st1\" width=\"2.2\" height=\"53.3\"/> \t\t<rect x=\"97.3\" y=\"200.3\" class=\"st4\" width=\"27.1\" height=\"5.2\"/> \t\t<rect x=\"97.3\" y=\"232.7\" class=\"st4\" width=\"69.6\" height=\"3\"/> \t\t<rect x=\"97.3\" y=\"238.7\" class=\"st4\" width=\"23.3\" height=\"3\"/> \t\t<rect x=\"97.3\" y=\"214\" class=\"st4\" width=\"44.7\" height=\"10.3\"/> \t</g> \t<g class=\"data-block-2 data-block\"> \t\t<rect class=\"background st1\" x=\"90.3\" y=\"260\" width=\"95.3\" height=\"53.3\"/> \t\t<rect x=\"97.3\" y=\"266.3\" class=\"st2\" width=\"27.1\" height=\"5.2\"/> \t\t<rect x=\"97.3\" y=\"298.7\" class=\"st2\" width=\"69.6\" height=\"3\"/> \t\t<rect x=\"97.3\" y=\"304.7\" class=\"st2\" width=\"23.3\" height=\"3\"/> \t\t<rect x=\"97.3\" y=\"280\" class=\"st2\" width=\"44.7\" height=\"10.3\"/> \t</g> \t<g class=\"data-block-white data-block\"> \t\t<rect class=\"background st3\" x=\"90.3\" y=\"327\" width=\"95.3\" height=\"53.3\"/> \t\t<rect x=\"90.3\" y=\"327\" class=\"st1\" width=\"2.2\" height=\"53.3\"/> \t\t<rect x=\"97.3\" y=\"333.3\" class=\"st4\" width=\"27.1\" height=\"5.2\"/> \t\t<rect x=\"97.3\" y=\"365.7\" class=\"st4\" width=\"69.6\" height=\"3\"/> \t\t<rect x=\"97.3\" y=\"371.7\" class=\"st4\" width=\"23.3\" height=\"3\"/> \t\t<rect x=\"97.3\" y=\"347\" class=\"st4\" width=\"44.7\" height=\"10.3\"/> \t</g> \t<g class=\"data-block-white data-block\"> \t\t<rect class=\"background st3\" x=\"90.3\" y=\"394\" width=\"95.3\" height=\"53.3\"/> \t\t<rect x=\"90.3\" y=\"394\" class=\"st1\" width=\"2.2\" height=\"53.3\"/> \t\t<rect x=\"97.3\" y=\"400.3\" class=\"st4\" width=\"27.1\" height=\"5.2\"/> \t\t<rect x=\"97.3\" y=\"432.7\" class=\"st4\" width=\"69.6\" height=\"3\"/> \t\t<rect x=\"97.3\" y=\"438.7\" class=\"st4\" width=\"23.3\" height=\"3\"/> \t\t<rect x=\"97.3\" y=\"414\" class=\"st4\" width=\"44.7\" height=\"10.3\"/> \t</g> \t<g class=\"line-graphs chart\"> \t\t<rect class=\"background st3\" x=\"197.3\" y=\"59.4\" width=\"290.7\" height=\"187.5\"/> \t\t<g class=\"line-graph\"> \t\t\t<path class=\"line st6\" d=\"M206.3,184.3 242.2,148.5 258.6,164.9 295.6,127.9 335,167.2 387.4,114.8 408.6,135.9 424.6,119.9 \t\t\t\t457.7,153 479.7,131 \t\t\"/> \t\t\t<polygon class=\"area st5\" points=\"206.3,184.3 242.2,148.5 258.6,164.9 295.6,127.9 335,167.2 387.4,114.8 408.6,135.9 424.6,119.9 \t\t\t\t457.7,153 479.7,131 479.7,236.3 206.3,236.3 \t\t\"/> \t\t\t<circle class=\"dot st7\" cx=\"241.8\" cy=\"150.4\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"294.9\" cy=\"128.4\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"334\" cy=\"167.2\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"387.4\" cy=\"114.8\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"408.6\" cy=\"135.9\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"424.7\" cy=\"121\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"457.7\" cy=\"151.3\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"258.3\" cy=\"165.7\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"241.8\" cy=\"150.4\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"294.9\" cy=\"128.4\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"334\" cy=\"167.2\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"387.4\" cy=\"114.8\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"408.6\" cy=\"135.9\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"424.7\" cy=\"121\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"457.7\" cy=\"151.3\" r=\"2.7\"/> \t\t\t<circle class=\"dot st7\" cx=\"258.3\" cy=\"165.7\" r=\"2.7\"/> \t\t</g> \t\t<g class=\"line-graph\"> \t\t\t<path class=\"line st8\" d=\"M206.3,232.7 228.3,210.7 235.5,217.8 294.9,158.4 311.6,175.1 348,138.7 380.3,138.7 417.8,101.2 \t\t\t\t443.7,127 478.7,92 \t\t\"/> \t\t\t<polygon class=\"area st9\" points=\"478.7,92 443.7,127 417.8,101.2 380.3,138.7 348,138.7 311.6,175.1 294.9,158.4 235.5,217.8 \t\t\t\t228.3,210.7 206.3,232.7 206.3,236.3 479.7,236.3 478.7,92 \t\t\"/> \t\t\t<circle class=\"dot st10\" cx=\"294.9\" cy=\"158.4\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"312.3\" cy=\"174.3\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"349\" cy=\"138.3\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"379\" cy=\"138.3\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"417.8\" cy=\"101.2\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"443\" cy=\"125.7\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"236.3\" cy=\"217.3\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"228\" cy=\"211.9\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"294.9\" cy=\"158.4\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"312.3\" cy=\"174.3\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"349\" cy=\"138.3\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"379\" cy=\"138.3\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"417.8\" cy=\"101.2\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"443\" cy=\"125.7\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"236.3\" cy=\"217.3\" r=\"2.7\"/> \t\t\t<circle class=\"dot st10\" cx=\"228\" cy=\"211.9\" r=\"2.7\"/> \t\t</g> \t</g> \t<g class=\"chart\"> \t\t<rect class=\"background st3\" x=\"197.3\" y=\"259.4\" width=\"290.7\" height=\"187.5\"/> \t\t<g class=\"donut-chart\"> \t\t\t<circle class=\"st11\" cx=\"411.3\" cy=\"355.3\" r=\"54.7\"/> \t\t\t<path class=\"st12\" d=\"M372.6,394c-21.4-21.4-21.4-56,0-77.4s56-21.4,77.4,0s21.4,56,0,77.4\"/> \t\t\t<path class=\"st13\" d=\"M372.6,394c-15.5-15.5-19.8-37.9-12.8-57.3c2.6-7.4,6.9-14.3,12.8-20.2c14.4-14.4,35-19.1,53.3-14.1\"/> \t\t</g> \t\t<g class=\"donut-chart\"> \t\t\t<circle class=\"st13\" cx=\"273.3\" cy=\"355.3\" r=\"54.7\"/> \t\t\t<path class=\"st12\" d=\"M273.3,410.1c-30.2,0-54.7-24.5-54.7-54.7s24.5-54.7,54.7-54.7s54.7,24.5,54.7,54.7\"/> \t\t\t<path class=\"st11\" d=\"M273.3,410.1c-21.9,0-40.8-12.9-49.5-31.4c-3.3-7.1-5.2-15-5.2-23.3c0-20.4,11.2-38.3,27.8-47.7\"/> \t\t</g> \t</g> \t<g class=\"header\"> \t\t<rect class=\"background st14\" x=\"82.7\" y=\"26\" width=\"417.3\" height=\"24.5\"/> \t\t<rect class=\"box-right st3\" x=\"433.5\" y=\"32\" width=\"54.5\" height=\"11.5\"/> \t\t<rect class=\"box-left st3\" x=\"369.5\" y=\"32\" width=\"54.5\" height=\"11.5\"/> \t\t<rect class=\"title st2\" x=\"97.3\" y=\"36\" width=\"81.8\" height=\"5.2\"/> \t\t<rect class=\"heading st4\" x=\"97.3\" y=\"9.1\" width=\"60.2\" height=\"8.2\"/> \t</g> \t<g class=\"menu\"> \t\t<rect class=\"background st15\" width=\"82.7\" height=\"459.3\"/> \t\t<rect x=\"9.3\" y=\"37.7\" class=\"st2\" width=\"36.9\" height=\"3\"/> \t\t<rect x=\"9.3\" y=\"57.7\" class=\"st2\" width=\"60.8\" height=\"3\"/> \t\t<rect x=\"9.3\" y=\"77.7\" class=\"st2\" width=\"41.5\" height=\"3\"/> \t\t<rect x=\"9.3\" y=\"97.7\" class=\"st2\" width=\"46.8\" height=\"3\"/> \t\t<rect x=\"9.3\" y=\"117.7\" class=\"st2\" width=\"30.4\" height=\"3\"/> \t\t<rect x=\"9.3\" y=\"137.7\" class=\"st2\" width=\"49.5\" height=\"3\"/> \t\t<rect x=\"9.3\" y=\"157.7\" class=\"st2\" width=\"36.9\" height=\"3\"/> \t\t<rect x=\"9.3\" y=\"177.7\" class=\"st2\" width=\"54\" height=\"3\"/> \t\t<rect x=\"9.3\" y=\"197.7\" class=\"st2\" width=\"46.8\" height=\"3\"/> \t\t<rect class=\"heading st2\" x=\"9.3\" y=\"9.1\" width=\"60.2\" height=\"8.2\"/> \t</g> </svg> <div class=\"buttons\"> \t<button class=\"reverse\">Reverse</button> \t<button class=\"restart\">Restart</button> </div>\nstyle.css: body { \ttext-align: center; \tbackground-color: #efefef; } .dashboard { \tmargin: 0 auto; \tborder-radius: 5px; }\nscript.js: document.addEventListener('DOMContentLoaded', function() { \t// Hoisting \tvar svgElement = $(\".dashboard\"), \t\ttimeline = new TimelineMax(), \t \tbody = svgElement.find('.body'), \t\tmain = svgElement.find(\".main\"), \t\theader = svgElement.find(\".header\"), \t\theaderBackground = header.find(\".background\"), \t\theaderBoxes = header.find(\".box-right, .box-left\"), \t\theaderText = header.find(\".heading, .title\"), \t\tmenu = svgElement.find(\".menu\"), \t\tmenuBackground = menu.find(\".background\"), \t\tmenuElements = menu.find(\":not(.background)\"), \t\tdataBlocks = svgElement.find(\".data-block\"), \t\tcharts = svgElement.find(\".chart\"), \t\tdonutCharts = svgElement.find(\".donut-chart *\"), \t\tlineGraphLines = svgElement.find(\".line-graph .line\"), \t\tlineGraphDots = svgElement.find(\".line-graph .dot\"), \t\tlineGraphAreas = svgElement.find(\".line-graph .area\"); \t// Set initial state \ttimeline.set([main, charts], { transformOrigin: '100% 100%' }) \t\t.set([menuBackground, body], { transformOrigin: '0% 0%'}) \t\t.set(headerBackground, { transformOrigin: '100% 100%'}) \t\t.set([headerBoxes, dataBlocks, donutCharts], { transformOrigin: '50% 50%'}); \t// Animate element \ttimeline.from([main, body], 0.3, { scaleY: '0%', ease: Back.easeOut.config(1.7) }) \t\t.staggerFrom(dataBlocks, 0.3, { scale: '0%', y: 100, ease: Back.easeOut.config(1.7) }, 0.2) \t\t.staggerFrom(charts, 0.3, { scaleY: '0%', ease: Back.easeOut.config(1.7) }, 0.2) \t\t.from(lineGraphLines, 0.75, { drawSVG: 0, ease: Power1.easeOut }) \t\t.from(lineGraphAreas, 0.75, { opacity: 0, ease: Back.easeOut.config(1.7) }, '-=1.5') \t\t.staggerFrom(lineGraphDots, 0.3, { scale: 0, ease: Back.easeOut.config(1.7) }, 0.1, '-=1') \t\t.staggerFrom(donutCharts, 0.5, { drawSVG: 0, ease: Power1.easeOut }, 0.2, '-=3.5') \t\t.from(menuBackground, 0.3, { scaleX: '0%', ease: Back.easeOut.config(1.7) }, '-=5') \t\t.staggerFrom(menuElements, 0.3, { scaleX: '0%', ease: Back.easeOut.config(1.7) }, 0.1, '-=3.25') \t\t.from(headerBackground, 0.5, { scaleX: '0%', ease: Power1.easeOut }, '-=4.5') \t\t.staggerFrom(headerBoxes, 0.3, { scale: '0%', ease: Back.easeOut.config(1.7) }, 0.1, '-=4.5') \t\t.staggerFrom(headerText, 0.4, { scaleX: '0%', ease: Back.easeOut.config(1.7) }, 0.2, '-=4'); \t \t// Pause on first frame and wait for waypoint \t// timeline.pause(); \t \t// Animate on waypoint \tsvgElementWaypoint = new Waypoint({ \t\telement: svgElement, \t\thandler: function(direction) { \t\t\tif(direction == 'down') { \t\t\t\ttimeline.play();\t \t\t\t} else { \t\t\t\ttimeline.reverse(); \t\t\t} \t\t}, \t\toffset: '50%' \t}); \t \t$(\".restart\").on('click', function(){ \t\ttimeline.seek(0).play(); \t}); \t \t$(\".reverse\").on('click', function(){ \t\ttimeline.reverse(); \t}); });",
    "id": "dashboard-gsap-animation"
  },
  {
    "title": "falling-2d-objects-matterjs",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\">script>\n\nStep 1: Add HTML\n\n<section class=\"section-resource\">\n  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" viewbox=\"0 0 1340 257\" fill=\"none\" class=\"resource-name__svg\"><path d=\"M51.3731 251H0.952148V5.7551H66.8082L124.775 175.54H125.461L183.428 5.7551H249.627V251H198.863V84.3021H198.177L144.669 251H105.91L52.0592 84.3021H51.3731V251Z\" fill=\"currentColor\">path><path d=\"M325.377 256.145C290.734 256.145 268.782 235.908 268.782 205.381C268.782 167.994 298.623 154.617 338.411 146.728C360.363 142.269 383.687 139.182 383.687 122.032C383.687 111.056 376.141 103.167 356.59 103.167C332.923 103.167 323.319 112.085 321.604 131.636H276.328C278.043 98.0221 301.71 69.8961 358.648 69.8961C402.209 69.8961 429.306 87.7321 429.306 138.153V210.869C429.306 221.502 430.678 226.304 436.509 226.304C437.881 226.304 438.91 226.304 440.968 225.961V249.971C431.707 251.686 422.446 252.715 415.586 252.715C395.692 252.715 387.117 245.169 384.716 228.362H384.03C372.025 244.826 351.788 256.145 325.377 256.145ZM342.527 222.531C367.566 222.531 383.687 205.038 383.687 181.028V162.506C377.17 165.936 366.537 168.68 350.759 172.453C326.406 177.598 317.145 186.173 317.145 200.922C317.145 215.328 326.063 222.531 342.527 222.531Z\" fill=\"currentColor\">path><path d=\"M533.926 217.729C539.414 217.729 542.158 217.386 548.675 216.357V250.657C538.042 253.058 529.81 254.087 520.206 254.087C485.22 254.087 468.413 238.995 468.413 196.806V111.742H443.717V75.7271H468.413V23.9341H515.404V75.7271H546.96V111.742H515.404V196.463C515.404 214.985 521.921 217.729 533.926 217.729Z\" fill=\"currentColor\">path><path d=\"M645.307 217.729C650.795 217.729 653.539 217.386 660.056 216.357V250.657C649.423 253.058 641.191 254.087 631.587 254.087C596.601 254.087 579.794 238.995 579.794 196.806V111.742H555.098V75.7271H579.794V23.9341H626.785V75.7271H658.341V111.742H626.785V196.463C626.785 214.985 633.302 217.729 645.307 217.729Z\" fill=\"currentColor\">path><path d=\"M843.213 165.936V175.883H713.902C714.245 201.951 731.395 220.473 757.12 220.473C780.787 220.473 790.391 207.439 793.821 197.492H841.498C831.894 232.478 804.111 256.488 755.748 256.488C699.496 256.488 666.568 217.729 666.568 163.192C666.568 110.37 698.81 69.8961 755.748 69.8961C813.029 69.8961 843.213 105.225 843.213 165.936ZM713.902 144.67H795.536C795.536 120.317 780.101 105.225 755.405 105.225C732.081 105.225 715.96 119.974 713.902 144.67Z\" fill=\"currentColor\">path><path d=\"M953.806 73.3261C958.951 73.3261 963.41 73.3261 969.241 74.3551V116.544C964.782 115.858 961.695 115.515 957.922 115.515C930.825 115.515 908.53 134.037 908.53 165.936V251H861.539V75.7271H908.53V105.911H909.216C918.134 86.3601 932.883 73.3261 953.806 73.3261Z\" fill=\"currentColor\">path><path d=\"M1032.5 256.145C968.703 256.145 952.239 216.357 952.239 171.424V154.617H1000.26V171.424C1000.26 196.463 1005.4 212.584 1030.1 212.584C1054.8 212.584 1059.94 196.463 1059.94 171.424V5.7551H1113.11V171.424C1113.11 216.357 1096.3 256.145 1032.5 256.145Z\" fill=\"currentColor\">path><path d=\"M1244.79 256.145C1181.34 256.145 1134.69 223.903 1133.66 167.994H1187.51C1188.54 197.835 1209.46 212.927 1244.1 212.927C1272.92 212.927 1284.92 200.922 1284.92 184.458C1284.92 159.762 1260.57 154.617 1222.84 143.984C1181.68 131.979 1142.23 116.887 1142.23 72.2971C1142.23 22.9051 1180.65 0.610107 1233.47 0.610107C1290.41 0.610107 1331.91 30.1081 1334.31 79.8431H1280.81C1277.38 56.8621 1261.6 43.8281 1233.47 43.8281C1210.49 43.8281 1196.43 51.7171 1196.43 68.5241C1196.43 89.1041 1214.61 94.5921 1245.82 103.51C1292.81 116.544 1339.12 128.892 1339.12 179.999C1339.12 225.275 1306.19 256.145 1244.79 256.145Z\" fill=\"currentColor\">path>svg>\n  <div class=\"canvas-matter\">\n    <div class=\"canvas-matter__before\">div>\n    <div id=\"canvas-target\" class=\"canvas-matter__target\">div>\n  div>\nsection>\n\nStep 2: Add CSS\n\n.section-resource {\n  justify-content: center;\n  align-items: flex-start;\n  width: 100%;\n  height: 100svh;\n  padding: 2vw;\n  display: flex;\n  overflow: hidden;\n  position: relative;\n}\n\n.resource-name__svg {\n  width: 100%;\n}\n\n.canvas-matter {\n  width: 100%;\n  margin-bottom: 0;\n  position: absolute;\n  bottom: 0%;\n  left: 0%;\n  overflow: hidden;\n  pointer-events: none;\n}\n\n.canvas-matter__before {\n  padding-top: 100%;\n}\n\n.canvas-matter__target {\n  transform: scale3d(1none, 1none, 1none);\n  transform-style: preserve-3d;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n#canvas-target canvas {\n  position: relative;\n  top: -1px;\n  left: -1px;\n  right: -1px;\n  bottom: -1px;\n  max-width: unset;\n  pointer-events: all;\n  max-width: calc(100% + 2px);\n  max-height: calc(100% + 2px);\n  min-width: calc(100% + 2px);\n  min-height: calc(100% + 2px);\n}\n\nStep 2: Add custom Javascript\n\nfunction initFalling2DMatterJS() {\n\n  const canvas = document.querySelector(\"#canvas-target\");\n\n  // Check if canvas is on page\n  if (!canvas) {\n    return;\n  }\n\n  const canvasWidth = canvas.clientWidth + 2;\n  const canvasHeight = canvas.clientHeight + 2;\n  const canvasWallDepth = canvasWidth / 4;\n  const smileyAmount = 15; // Amount of objects added to the canvas\n  const smileySize = canvasWidth / 7.5; // Size of objects\n  const smileySizeTexture = 256; // Size of object texture in pixels\n  const smileySizeScale = smileySize / smileySizeTexture;\n  const smileyRestitution = 0.75; // Bounciness\n  const worldGravity = 2; // Gravity\n\n  // Modules\n  let { Engine, Render, Runner, Bodies, Composite, Mouse, MouseConstraint } = Matter;\n\n  // Create an engine\n  let engine = Engine.create();\n  engine.world.gravity.y = worldGravity;\n  \n  // Create a renderer\n  let render = Render.create({\n    element: canvas,\n    engine: engine,\n    options: {\n      background: \"transparent\",\n      wireframes: false,\n      width: canvasWidth,\n      height: canvasHeight,\n      pixelRatio: 2,\n      border: \"none\",\n    }\n  });\n\n  // Generate a random number between min (inclusive) and max (exclusive)\n  function getRandomNumber(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n\n  let min = smileySize / 2; // min value\n  let max = canvasWidth - (smileySize / 2); // max value\n\n  // Textures\n  let textureArray = [\n    'https://cdn.prod.website-files.com/67f388c94c43e20cfb7ca732/67f394c931c1e6fc303e12ec_smiley-1.svg',\n    'https://cdn.prod.website-files.com/67f388c94c43e20cfb7ca732/67f394c9718ec3640accf3d4_smiley-2.svg',\n    'https://cdn.prod.website-files.com/67f388c94c43e20cfb7ca732/67f394c940dfb6d33af4c6d6_smiley-3.svg',\n    'https://cdn.prod.website-files.com/67f388c94c43e20cfb7ca732/67f394c9ab4fc0301d56d8c5_smiley-4.svg',\n    'https://cdn.prod.website-files.com/67f388c94c43e20cfb7ca732/67f394c9d9ee6112fdb67b89_smiley-5.svg'\n  ];\n  \n  // Function to loop trough all textures\n  let textureIndex = 0;\n  function getNextTexture() {\n    const texture = textureArray[textureIndex];\n    textureIndex = (textureIndex + 1) % textureArray.length;\n    return texture;\n  }\n\n  // Function to get a random texture\n  function getRandomTexture() {\n    const randomIndex = Math.floor(Math.random() * textureArray.length);\n    return textureArray[randomIndex];\n  }\n\n  // Create smiley\n  const smileyCreate = () => {\n    let smiley = Bodies.rectangle(getRandomNumber(min, max), smileySize, smileySize,\n      smileySize, {\n        chamfer: { \n          radius: smileySize / 2\n        },\n        restitution: smileyRestitution,\n        render: {\n          sprite: {\n            texture: getNextTexture(), // Replace with \"getRandomTexture()\" to get random textures\n            xScale: smileySizeScale,\n            yScale: smileySizeScale\n          }\n        }\n      });\n    Composite.add(engine.world, smiley);\n  };\n\n  // Create a box with rectangle(x, y, width, height)\n  let boxTop = Bodies.rectangle(canvasWidth / 2 + (canvasWallDepth * 2), canvasHeight +\n    canvasWallDepth, canvasWidth + (canvasWallDepth * 4), (canvasWallDepth * 2), {\n      isStatic: true\n    });\n\n  let boxLeft = Bodies.rectangle((canvasWallDepth * -1), canvasHeight / 2, (canvasWallDepth * 2),\n    canvasHeight, {\n      isStatic: true\n    });\n\n  let boxRight = Bodies.rectangle(canvasWidth + canvasWallDepth, canvasHeight / 2, (\n    canvasWallDepth * 2), canvasHeight, {\n    isStatic: true\n  });\n\n  let boxBottom = Bodies.rectangle(canvasWidth / 2 + (canvasWallDepth * 2), (canvasWallDepth * -1),\n    canvasWidth + (canvasWallDepth * 4), (canvasWallDepth * 2), {\n      isStatic: true\n    });\n\n  // Add all of the bodies to the world\n  Composite.add(engine.world, [boxTop, boxLeft, boxRight, boxBottom]);\n\n  // Run the renderer\n  Render.run(render);\n\n  // Create runner\n  let runner = Runner.create();\n\n  // Run the engine\n  Matter.Runner.run(runner, engine);\n\n  // Custom Function: \n  // To run the function X amount of times\n  function repeatedFunction(count, maxCount) {\n    if (count < maxCount) {\n      smileyCreate();\n      setTimeout(() => {\n        repeatedFunction(count + 1, maxCount);\n      }, 100); // Delay in milliseconds\n    }\n  }\n  repeatedFunction(0, smileyAmount);\n\n  // Create mouse\n  let mouse = Mouse.create(render.canvas);\n  let mouseConstraint = MouseConstraint.create(engine, {\n    mouse: mouse,\n    constraint: {\n      stiffness: 0.2,\n      render: {\n        visible: false\n      }\n    }\n  });\n\n  Composite.add(engine.world, mouseConstraint);\n\n  // Fix: Allow native page scroll\n  mouseConstraint.mouse.element.removeEventListener(\"mousewheel\", mouseConstraint.mouse.mousewheel);\n  mouseConstraint.mouse.element.removeEventListener(\"DOMMouseScroll\", mouseConstraint.mouse.mousewheel);\n  \n  // Fix: Scroll on touch devices\n  mouseConstraint.mouse.element.removeEventListener('touchstart', mouseConstraint.mouse.mousedown);\n  mouseConstraint.mouse.element.removeEventListener('touchmove', mouseConstraint.mouse.mousemove);\n  mouseConstraint.mouse.element.removeEventListener('touchend', mouseConstraint.mouse.mouseup);\n\n  mouseConstraint.mouse.element.addEventListener('touchstart', mouseConstraint.mouse.mousedown, { passive: true });\n  mouseConstraint.mouse.element.addEventListener('touchmove', (e) => {\n    if (mouseConstraint.body) {\n      mouseConstraint.mouse.mousemove(e);\n    }\n  });\n  mouseConstraint.mouse.element.addEventListener('touchend', (e) => {\n    if (mouseConstraint.body) {\n      mouseConstraint.mouse.mouseup(e);\n    }\n  });\n}\n\n// Initialize Falling 2D Elements (Matter.js)\ndocument.addEventListener('DOMContentLoaded', function() {\n  initFalling2DMatterJS();\n});\n\nImplementation\n\nCanvas\nThe script looks for #canvas-target and injects a  into it, so make sure that element exists on your page. We also use a .canvas-matter__before element to maintain a consistent 1:1 aspect ratio for the canvas.\n\nTextures\nWe used a set of 5 different smileys, but you can replace them with any visuals you like. This resource is designed for images with a 1:1 aspect ratio.\nYou have the ability to choose between a random texture or select the next in line. Use one of the two below:\n\n- Random texture: getRandomTexture()\n- Loop trough array: getNextTexture()\n\nCustomization options\n- smileyAmount Amount of objects added to the canvas\n- smileySize Size of objects\n- smileySizeTexture Size of object texture in pixels\n- smileyRestitution Set Bounciness of the falling objects\n- worldGravity Set world gravity\nChanging the size, aspect ratio, or roundness of the objects is more advanced. To keep this resource simple, we recommend checking the official Matter.js Documentation for all available options.",
    "id": "falling-2d-objects-matterjs"
  },
  {
    "title": "cg-chromatic-aberration-gallery",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>\n      Chromatic Aberration - Lens Distortion Using Shaders | mukta\n    </title>\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n  </head>\n  <body>\n    <div class=\"viewport\">\n      <div class=\"container\"></div>\n    </div>\n    <canvas></canvas>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "const container = document.querySelector(\".container\");\nlet program;\nlet mouseX = window.innerWidth / 2;\nlet mouseY = window.innerHeight / 2;\nlet targetMouseX = mouseX;\nlet targetMouseY = mouseY;\nlet texture = null;\nlet targetX = 0;\nlet targetY = 0;\nlet currentX = 0;\nlet currentY = 0;\n\nconst imgSources = Array.from(\n  { length: 25 },\n  (_, i) => `./assets/img${i + 1}.jpg`\n);\n\nfunction getRandomImage() {\n  return imgSources[Math.floor(Math.random() * imgSources.length)];\n}\n\nfunction createImageGrid() {\n  for (let i = 0; i < 300; i++) {\n    const wrapper = document.createElement(\"div\");\n    wrapper.className = \"img-wrapper\";\n\n    const img = document.createElement(\"img\");\n    img.src = getRandomImage();\n    img.alt = \"Grid item\";\n\n    wrapper.appendChild(img);\n    container.appendChild(wrapper);\n  }\n}\n\nfunction updatePan(mouseX, mouseY) {\n  const maxX = container.offsetWidth - window.innerWidth;\n  const maxY = container.offsetHeight - window.innerHeight;\n\n  targetX = -((mouseX / window.innerWidth) * maxX * 0.75);\n  targetY = -((mouseY / window.innerHeight) * maxY * 0.75);\n}\n\nfunction animatePan() {\n  const ease = 0.035;\n  currentX += (targetX - currentX) * ease;\n  currentY += (targetY - currentY) * ease;\n\n  container.style.transform = `translate(${currentX}px, ${currentY}px)`;\n  requestAnimationFrame(animatePan);\n}\n\nconst canvas = document.querySelector(\"canvas\");\nconst gl = canvas.getContext(\"webgl\", {\n  preserveDrawingBuffer: false,\n  antialias: true,\n  alpha: true,\n});\n\nfunction setupWebGL() {\n  gl.enable(gl.BLEND);\n  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n}\n\nfunction createShader(type, source) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(\"Shader compilation error:\", gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\n\nasync function loadShaders() {\n  try {\n    const [vertexResponse, fragmentResponse] = await Promise.all([\n      fetch(\"./shaders/vertex.glsl\"),\n      fetch(\"./shaders/fragment.glsl\"),\n    ]);\n\n    const vertexSource = await vertexResponse.text();\n    const fragmentSource = await fragmentResponse.text();\n\n    return { vertexSource, fragmentSource };\n  } catch (error) {\n    console.error(\"Error loading shaders:\", error);\n    throw error;\n  }\n}\n\nasync function initWebGL() {\n  setupWebGL();\n\n  const { vertexSource, fragmentSource } = await loadShaders();\n  const vertexShader = createShader(gl.VERTEX_SHADER, vertexSource);\n  const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSource);\n\n  program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  gl.useProgram(program);\n\n  const vertices = new Float32Array([\n    -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0,\n  ]);\n  const vertexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n\n  const positionLocation = gl.getAttribLocation(program, \"aPosition\");\n  gl.enableVertexAttribArray(positionLocation);\n  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n  texture = gl.createTexture();\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const iChannel0Location = gl.getUniformLocation(program, \"iChannel0\");\n  gl.uniform1i(iChannel0Location, 0);\n}\n\nfunction updateTexture() {\n  const tempCanvas = document.createElement(\"canvas\");\n  const scale = 4;\n  tempCanvas.width = Math.floor(window.innerWidth * scale);\n  tempCanvas.height = Math.floor(window.innerHeight * scale);\n  const tempCtx = tempCanvas.getContext(\"2d\");\n\n  tempCtx.imageSmoothingEnabled = true;\n  tempCtx.imageSmoothingQuality = \"high\";\n  tempCtx.fillStyle = \"white\";\n  tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);\n\n  const viewportRect = container.getBoundingClientRect();\n  const matrix = new DOMMatrix(getComputedStyle(container).transform);\n\n  tempCtx.setTransform(\n    matrix.a,\n    matrix.b,\n    matrix.c,\n    matrix.d,\n    matrix.e * scale,\n    matrix.f * scale\n  );\n\n  const images = container.getElementsByTagName(\"img\");\n  for (let img of images) {\n    const rect = img.getBoundingClientRect();\n    const parent = img.parentElement.getBoundingClientRect();\n\n    tempCtx.drawImage(\n      img,\n      (parent.left - viewportRect.left) * scale,\n      (parent.top - viewportRect.top) * scale,\n      parent.width * scale,\n      parent.height * scale\n    );\n  }\n\n  tempCtx.setTransform(1, 0, 0, 1, 0, 0);\n\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    0,\n    gl.RGBA,\n    gl.RGBA,\n    gl.UNSIGNED_BYTE,\n    tempCanvas\n  );\n\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n}\n\nfunction render() {\n  const ease = 0.1;\n  mouseX += (targetMouseX - mouseX) * ease;\n  mouseY += (targetMouseY - mouseY) * ease;\n\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n  gl.viewport(0, 0, canvas.width, canvas.height);\n\n  updateTexture();\n\n  const resolutionLocation = gl.getUniformLocation(program, \"iResolution\");\n  const mouseLocation = gl.getUniformLocation(program, \"iMouse\");\n\n  gl.uniform2f(resolutionLocation, canvas.width, canvas.height);\n  gl.uniform2f(mouseLocation, mouseX, canvas.height - mouseY);\n\n  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  requestAnimationFrame(render);\n}\n\nfunction setupEventListeners() {\n  document.addEventListener(\"mousemove\", (e) => {\n    targetMouseX = e.clientX;\n    targetMouseY = e.clientY;\n    updatePan(e.clientX, e.clientY);\n  });\n\n  window.addEventListener(\"resize\", () => {\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    gl.viewport(0, 0, canvas.width, canvas.height);\n\n    targetMouseX = window.innerWidth / 2;\n    targetMouseY = window.innerHeight / 2;\n    mouseX = targetMouseX;\n    mouseY = targetMouseY;\n\n    targetX = 0;\n    targetY = 0;\n    currentX = 0;\n    currentY = 0;\n  });\n}\n\nasync function init() {\n  createImageGrid();\n\n  const firstImage = container.querySelector(\"img\");\n\n  await new Promise((resolve) => {\n    if (firstImage.complete) {\n      resolve();\n    } else {\n      firstImage.onload = resolve;\n    }\n  });\n\n  await initWebGL();\n  setupEventListeners();\n  animatePan();\n  render();\n}\n\ninit();\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\n.viewport {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n}\n\n.container {\n  position: absolute;\n  width: 200vw;\n  height: 200vh;\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));\n  gap: 4px;\n  padding: 4px;\n  transform: translate(0, 0);\n  will-change: transform;\n}\n\n.img-wrapper {\n  position: relative;\n  width: 100%;\n  padding-bottom: 100%;\n  overflow: hidden;\n}\n\nimg {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\ncanvas {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  z-index: 1000;\n}\n",
      "shaders/fragment.glsl": "precision highp float;\nuniform vec2 iResolution;\nuniform vec2 iMouse;\nuniform sampler2D iChannel0;\nvarying vec2 fragCoord;\n\nvec2 getDistortedUv(vec2 uv, vec2 direction, float factor) {\n    vec2 scaledDirection = direction;\n    scaledDirection.y *= 2.0;\n    return uv - scaledDirection * factor;\n}\n\nstruct DistortedLens {\n    vec2 uv_R;\n    vec2 uv_G;\n    vec2 uv_B;\n    float focusSdf;\n    float speherSdf;\n    float inside;\n};\n\nvec2 fixRotation(vec2 uv, vec2 center) {\n    vec2 centered = uv - center;\n    centered.y = -centered.y;\n    return centered + center;\n}\n\nDistortedLens getLensDistortion(\n    vec2 p,\n    vec2 uv,\n    vec2 sphereCenter,\n    float sphereRadius,\n    float focusFactor,\n    float chromaticAberrationFactor\n) {\n    vec2 distortionDirection = normalize(p - sphereCenter);\n    float focusRadius = sphereRadius * focusFactor;\n    float focusStrength = sphereRadius / 5000.0;\n    float focusSdf = length(sphereCenter - p) - focusRadius;\n    float speherSdf = length(sphereCenter - p) - sphereRadius;\n    float inside = smoothstep(0.0, 1.0, -speherSdf / (sphereRadius * 0.001));\n    \n    float magnifierFactor = focusSdf / (sphereRadius - focusRadius);\n    float mFactor = clamp(magnifierFactor * inside, 0.0, 1.0);\n    mFactor = pow(mFactor, 5.0);\n    \n    vec3 distortionFactors = vec3(\n        mFactor * focusStrength * (1.0 + chromaticAberrationFactor),\n        mFactor * focusStrength,\n        mFactor * focusStrength * (1.0 - chromaticAberrationFactor)\n    );\n    \n    vec2 uv_R = getDistortedUv(uv, distortionDirection, distortionFactors.r);\n    vec2 uv_G = getDistortedUv(uv, distortionDirection, distortionFactors.g);\n    vec2 uv_B = getDistortedUv(uv, distortionDirection, distortionFactors.b);\n    \n    vec2 sphereCenterUv = sphereCenter / iResolution;\n    uv_R = fixRotation(uv_R, sphereCenterUv);\n    uv_G = fixRotation(uv_G, sphereCenterUv);\n    uv_B = fixRotation(uv_B, sphereCenterUv);\n    \n    return DistortedLens(\n        uv_R,\n        uv_G,\n        uv_B,\n        focusSdf,\n        speherSdf,\n        inside\n    );\n}\n\nvec2 zoomUV(vec2 uv, vec2 center, float zoom) {\n    float zoomFactor = 1.0 / zoom;\n    vec2 centeredUV = uv - center;\n    centeredUV *= zoomFactor;\n    return centeredUV + center;\n}\n\nvoid main() {\n    vec2 p = fragCoord * iResolution;\n    vec2 vUv = fragCoord;\n    \n    vec2 textureSize = iResolution;\n    vec2 sphereCenter = iMouse.xy;\n    vec2 spehereCenterUv = sphereCenter / textureSize;\n    float sphereRadius = iResolution.y * 0.3;\n    float focusFactor = 0.25;\n    float chromaticAberrationFactor = 0.25;\n    float zoom = 1.75;\n    \n    vec2 zoomedUv = zoomUV(vUv, spehereCenterUv, zoom);\n    \n    DistortedLens distortion = getLensDistortion(\n        p, zoomedUv, sphereCenter, sphereRadius, focusFactor, chromaticAberrationFactor\n    );\n\n    vec4 baseTexture = texture2D(iChannel0, vUv);\n    vec3 imageDistorted = vec3(\n        texture2D(iChannel0, distortion.uv_R).r,\n        texture2D(iChannel0, distortion.uv_G).g,\n        texture2D(iChannel0, distortion.uv_B).b\n    );\n    \n    vec3 result = mix(baseTexture.rgb, imageDistorted, distortion.inside);\n    float alpha = distortion.inside;\n    \n    gl_FragColor = vec4(result, alpha);\n}",
      "shaders/vertex.glsl": "attribute vec4 aPosition;\nvarying vec2 fragCoord;\n\nvoid main() {\n    gl_Position = aPosition;\n    fragCoord = (aPosition.xy * 0.5 + 0.5);\n}"
    }
  },
  {
    "title": "Align text to a gradient mask on image",
    "description": "",
    "code": "index.html: <section> \t<h2>Align text to a gradient mask on image</h2> \t<img id=\"gradient-shape\" src=\"https://assets.codepen.io/4787486/peacock-1.png\" alt=\"\"> \t<p>Color is the visual perception produced by the activation of the different types of cone cells in the eye caused by light. Though color is not an inherent property of matter, color perception is related to an object's light absorption, emission, reflection and transmission. For most humans, visible wavelengths of light are the ones perceived in the visible light spectrum, with three types of cone cells.</p> \t<p class=\"more\">See: <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/shape-image-threshold\" target=\"_blank\">MDN</a> for more info</p> </section>\nstyle.css: #gradient-shape { \t/* you can also use hard stops to give the mask a clean edge */ \tmask-image: radial-gradient( \t\tcircle 30vw at 0% 0%, \t\twhite 60%, \t\ttransparent 95%, \t\ttransparent \t); \t/* the magic bit */ \t/* alternatively you can use a linear-gradient */ \tfloat: left; \tshape-outside: radial-gradient( \t\tcircle 30vw at 0% 0%, \t\twhite 60%, \t\ttransparent 95%, \t\ttransparent \t); \t/* adjust the shape-image-threshold to see what it does */ \tshape-image-threshold: 0.35; } section { \twidth: 70vw; \tmin-width: 350px; \tmax-width: 600px; } h2 { \ttext-align: center; \tline-height: 1; \tmargin-block-end: 1lh; } p { \tline-height: 1.3; \tmargin-block-end: 1lh; } .more { \tfont-size: 0.75em; \ttext-align: center; } img { \tmax-width: 70%; } * { \tpadding: 0; \tmargin: 0; \tbox-sizing: border-box; } body { \tdisplay: grid; \tplace-content: center; \tmin-height: 100vh; \tfont-family: system-ui, sans-serif; \tfont-size: 16pt; }\nscript.js: ",
    "id": "align-text-to-a-gradient-mask-on-image"
  }
]