[
  {
    "title": "Full-Screen WebGL Shader Background Canvas",
    "description": "Full-width/height canvas that runs a GPU fragment shader to render animated, rotating concentric rings. Auto-resizes with viewport and sits behind content, making it a dynamic decorative background for hero sections, landing pages, or interactive sites. Uses Tailwind utility classes.",
    "code": "<canvas id=\"shader-canvas\" class=\"w-full h-full absolute top-0 left-0 -z-10\">\n    <script>\n    window.onload = function() {\n      const canvas = document.getElementById('shader-canvas');\n      const gl = canvas.getContext('webgl');\n      function resize() {\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      }\n      resize();\n      window.addEventListener('resize', resize);\n\n      const vertexShaderSource = `\n        attribute vec2 aPosition;\n        void main() {\n          gl_Position = vec4(aPosition, 0.0, 1.0);\n        }\n      `;\n      const fragmentShaderSource = `\n        precision highp float;\n        uniform float iTime;\n        uniform vec2 iResolution;\n        mat2 rotate2d(float angle){\n          float c = cos(angle), s = sin(angle);\n          return mat2(c, -s, s, c);\n        }\n        float variation(vec2 v1, vec2 v2, float strength, float speed) {\n          return sin(\n              dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n          ) / 100.0;\n        }\n        vec3 paintCircle (vec2 uv, vec2 center, float rad, float width) {\n          vec2 diff = center-uv;\n          float len = length(diff);\n          len += variation(diff, vec2(0.0, 1.0), 5.0, 2.0);\n          len -= variation(diff, vec2(1.0, 0.0), 5.0, 2.0);\n          float circle = smoothstep(rad-width, rad, len) - smoothstep(rad, rad+width, len);\n          return vec3(circle);\n        }\n        void main() {\n          vec2 uv = gl_FragCoord.xy / iResolution.xy;\n          uv.x *= 1.5;\n          uv.x -= 0.25;\n          vec3 color = vec3(0.0);\n          float radius = 0.35;\n          vec2 center = vec2(0.5);\n          color += paintCircle(uv, center, radius, 0.035);\n          color += paintCircle(uv, center, radius - 0.018, 0.01);\n          color += paintCircle(uv, center, radius + 0.018, 0.005);\n          vec2 v = rotate2d(iTime) * uv;\n          color *= vec3(v.x, v.y, 0.7-v.y*v.x);\n          color += paintCircle(uv, center, radius, 0.003);\n          gl_FragColor = vec4(color, 1.0);\n        }\n      `;\n      function compileShader(type, source) {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n          throw new Error(gl.getShaderInfoLog(shader));\n        }\n        return shader;\n      }\n      const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);\n      const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);\n      const program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        throw new Error(gl.getProgramInfoLog(program));\n      }\n      gl.useProgram(program);\n      const buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        -1, -1,\n         1, -1,\n        -1,  1,\n        -1,  1,\n         1, -1,\n         1,  1,\n      ]), gl.STATIC_DRAW);\n      const aPosition = gl.getAttribLocation(program, 'aPosition');\n      gl.enableVertexAttribArray(aPosition);\n      gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n      const iTimeLoc = gl.getUniformLocation(program, 'iTime');\n      const iResLoc = gl.getUniformLocation(program, 'iResolution');\n      function render(time) {\n        gl.uniform1f(iTimeLoc, time * 0.001);\n        gl.uniform2f(iResLoc, canvas.width, canvas.height);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        requestAnimationFrame(render);\n      }\n      requestAnimationFrame(render);\n    };\n    </script>\n</canvas>",
    "id": "full-screen-webgl-shader-background-canvas"
  },
  {
    "title": "Torus Glass",
    "description": "",
    "code": "index.html: <script type=\"importmap\"> \t{ \t\t\"imports\": { \t\t\t\"three\": \"https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js\", \t\t\t\t\"jsm/\": \"https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/\" \t\t} \t} </script> <canvas class=\"webgl\"></canvas>\nstyle.css: body { \tmargin: 0; \tpadding: 0; \toverflow: hidden; \tbackground-color: #000; } .webgl { \tposition: fixed; \ttop: 0; \tleft: 0; \twidth: 100%; \theight: 100%; }\nscript.js: import * as THREE from \"three\"; import { GUI } from \"jsm/libs/lil-gui.module.min.js\"; import { FontLoader } from \"jsm/loaders/FontLoader.js\"; import { TextGeometry } from \"jsm/geometries/TextGeometry.js\"; const gui = new GUI(); const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera( \t75, \twindow.innerWidth / window.innerHeight, \t0.1, \t1000 ); camera.position.z = 5; const renderer = new THREE.WebGLRenderer({ \tcanvas: document.querySelector(\".webgl\"), \tantialias: true, }); renderer.setSize(window.innerWidth, window.innerHeight); //textures const textureLoader = new THREE.TextureLoader(); //fonts const fontLoader = new FontLoader(); fontLoader.load( \t\"https://raw.githubusercontent.com/danielyl123/person/refs/heads/main/fonts/helvetiker_regular.typeface.json\", \t(font) => { \t\tconst textGeometry = new TextGeometry(\"CODEPEN\", { \t\t\tfont, \t\t\tsize: 1, \t\t\tdepth: 0, \t\t\tcurveSegments: 5, \t\t\tbevelEnabled: true, \t\t\tbevelThickness: 0, \t\t\tbevelSize: 0, \t\t\tbevelOffset: 0, \t\t\tbevelSegments: 4, \t\t}); \t\ttextGeometry.computeBoundingBox(); \t\ttextGeometry.center(); \t\tconst textMaterial = new THREE.MeshBasicMaterial(); \t\ttextMaterial.wireframe = false; \t\tconst text = new THREE.Mesh(textGeometry, textMaterial); \t\tscene.add(text); \t} ); const torusGeometry = new THREE.TorusGeometry(0.7, 0.4, 100, 60); const torusMaterial = new THREE.MeshPhysicalMaterial(); torusMaterial.metalness = 0; torusMaterial.roughness = 0; torusMaterial.iridescence = 1; torusMaterial.iridescenceIOR = 1.5; torusMaterial.iridescenceThicknessRange = [100, 324]; torusMaterial.transmission = 1; torusMaterial.ior = 1.2; torusMaterial.thickness = 0.8; const torus = new THREE.Mesh(torusGeometry, torusMaterial); torus.position.z = 1; scene.add(torus); //lights const ambientLight = new THREE.AmbientLight(0xffffff, 10); scene.add(ambientLight); const pointLight = new THREE.PointLight(0xffffff, 10); pointLight.position.set(-1, 2, 0); scene.add(pointLight); const pointLight2 = new THREE.PointLight(0xffffff, 10); pointLight2.position.set(-1, -2, 0); scene.add(pointLight2); const pointLight3 = new THREE.PointLight(0xffffff, 10); pointLight3.position.set(1, -2, 0); scene.add(pointLight3); const pointLight4 = new THREE.PointLight(0xffffff, 10); pointLight4.position.set(1, 2, 0); scene.add(pointLight4); gui.add(torusMaterial, \"metalness\").min(0).max(1).step(0.001); gui.add(torusMaterial, \"roughness\").min(0).max(1).step(0.001); gui.add(torusMaterial, \"iridescence\").min(0).max(1).step(0.001); gui.add(torusMaterial, \"iridescenceIOR\").min(1).max(2.333).step(0.001); gui.add(torusMaterial.iridescenceThicknessRange, \"0\").min(0).max(1000).step(1); gui.add(torusMaterial.iridescenceThicknessRange, \"1\").min(0).max(1000).step(1); gui.add(torusMaterial, \"transmission\").min(0).max(1).step(0.001); gui.add(torusMaterial, \"ior\").min(1).max(10).step(0.001); gui.add(torusMaterial, \"thickness\").min(0).max(10).step(0.001); const clock = new THREE.Clock(); const tick = () => { \tconst elapsedTime = clock.getElapsedTime(); \trenderer.render(scene, camera); \ttorus.rotation.x = elapsedTime * 0.5; \ttorus.rotation.y = elapsedTime * 0.1; \trequestAnimationFrame(tick); }; tick(); window.addEventListener(\"resize\", () => { \tcamera.aspect = window.innerWidth / window.innerHeight; \tcamera.updateProjectionMatrix(); \trenderer.setSize(window.innerWidth, window.innerHeight); });",
    "id": "torus-glass"
  },
  {
    "title": "VortexChill",
    "description": "",
    "code": "index.html: <div class=\"container\"> \t<h1 class=\"title\"> \t\t<span>THE</span> \t\t<span>VORTEX CHILL</span> \t\t<span>By Daniel mu√±oz</span> \t</h1> </div> <script type=\"importmap\"> \t{ \t\t\"imports\": { \t\t\t\"three\": \"https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js\", \t\t\t\t\"jsm/\": \"https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/\" \t\t} \t} </script>\nstyle.css: @import url(\"https://fonts.googleapis.com/css2?family=Orbitron:wght@300;400;700;900&family=Rajdhani:wght@300;700&display=swap\"); :root { \t--font-orbitron: \"Orbitron\", sans-serif; \t--font-rajdhani: \"Rajdhani\", sans-serif; } body { \tmargin: 0; \tbackground: black; \toverflow: hidden; } .container { \tposition: absolute; \tbottom: 20vh; \tleft: 0; \tright: 0; \tmargin: 0 auto; \twidth: 100%; \tmax-width: 1100px; \tz-index: 1; \tcolor: white; \ttext-align: center; \tfont-family: var(--font-orbitron); \tfont-size: 24px; \tfont-weight: bold; \tpadding: 0 40px; } .title { \twidth: 100%; \tfont-size: clamp(30px, 5vw, 60px); \ttext-align: left; \tspan { \t\tdisplay: block; \t} \tspan:nth-child(1) { \t\tfont-size: 20px; \t\tcolor: #50ffff; \t} \tspan:nth-child(3) { \t\tfont-size: 13px; \t\tcolor: #50ffff; \t} }\nscript.js: import * as THREE from \"three\"; const w = window.innerWidth; const h = window.innerHeight; const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000); camera.position.z = 5; const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(w, h); document.body.appendChild(renderer.domElement); const pointLight2 = new THREE.PointLight(0xffffff, 100, 300, 0.9); pointLight2.position.set(1.3, 1.3, 1.3); scene.add(pointLight2); const canvas = document.createElement(\"canvas\"); const ctx = canvas.getContext(\"2d\"); canvas.width = 4096; canvas.height = 4096; ctx.imageSmoothingEnabled = false; ctx.fillStyle = \"#000000\"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = \"#ffffff\"; ctx.lineWidth = 0.5; const horizontalLines = 60; const spacingH = canvas.height / horizontalLines; for (let i = 0; i <= horizontalLines; i++) { \tconst y = Math.round(i * spacingH); \tctx.beginPath(); \tctx.moveTo(0, y); \tctx.lineTo(canvas.width, y); \tctx.stroke(); } ctx.strokeStyle = \"#ffffff\"; ctx.lineWidth = 0.5; const lateralLines = 80; const spacingV = canvas.width / lateralLines; for (let i = 0; i <= lateralLines; i++) { \tconst x = Math.round(i * spacingV); \tctx.beginPath(); \tctx.moveTo(x, 0); \tctx.lineTo(x, canvas.height); \tctx.stroke(); } const lineTexture = new THREE.CanvasTexture(canvas); lineTexture.colorSpace = THREE.SRGBColorSpace; lineTexture.wrapS = THREE.RepeatWrapping; lineTexture.wrapT = THREE.RepeatWrapping; lineTexture.repeat.set(0.5, 0.5); lineTexture.minFilter = THREE.NearestFilter; lineTexture.magFilter = THREE.NearestFilter; const blackHole = new THREE.TorusGeometry(3.5, 1.7, 1000, 1000); const blackHoleMaterial = new THREE.MeshStandardMaterial({ \tcolor: 0xffffff, \tmap: lineTexture, \tside: THREE.DoubleSide, \ttransparent: true, \talphaTest: 0, \troughness: 0, \tmetalness: 0, }); const blackHoleMesh = new THREE.Mesh(blackHole, blackHoleMaterial); blackHoleMesh.rotation.x = (Math.PI / -5.9) * 2; blackHoleMesh.rotation.y = (Math.PI / 18) * 2; scene.add(blackHoleMesh); const pointLight = new THREE.PointLight(0x0099ff, 1000000, 100); pointLight.position.set(-1.3, -4, -1.3); scene.add(pointLight); const helperPointLight = new THREE.PointLightHelper(pointLight, 1); function animate() { \trequestAnimationFrame(animate); \trenderer.render(scene, camera); \tlineTexture.offset.x += -0.00005; \tlineTexture.offset.y += -0.00005; } animate(); window.addEventListener(\"resize\", () => { \trenderer.setSize(window.innerWidth, window.innerHeight); \tcamera.aspect = window.innerWidth / window.innerHeight; \tcamera.updateProjectionMatrix(); });",
    "id": "vortexchill"
  },
  {
    "title": "Animated WebGL Starfield Shader Background",
    "description": "Full-screen canvas component that renders an animated starfield via GLSL fragment shader. Uses WebGL, resizes with viewport, and suits dynamic page headers, hero sections, or interactive backgrounds.",
    "code": "<canvas id=\"shader-canvas\" class=\"absolute inset-0 -z-10\">\n  <script id=\"fragShader\" type=\"x-shader/x-fragment\">\n    precision highp float;\n\nuniform vec2 iResolution;\nuniform float iTime;\n\nvec3 hash( vec3 p ) {\n  p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n            dot(p,vec3(269.5,183.3,246.1)),\n            dot(p,vec3(113.5,271.9,124.6)));\n  return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p ) {\n  vec3 i = floor( p );\n  vec3 f = fract( p );\n  vec3 u = f*f*(3.0-2.0*f);\n  return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ),\n                      dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                 mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ),\n                      dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n            mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ),\n                      dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                 mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ),\n                      dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec3 stars_direction = normalize(vec3(uv * 2.0 - 1.0, 1.0));\n  float stars_threshold = 8.0;\n  float stars_exposure = 200.0;\n  float stars = pow(clamp(noise(stars_direction * 200.0), 0.0, 1.0), stars_threshold) * stars_exposure;\n  stars *= mix(0.4, 1.4, noise(stars_direction * 100.0 + vec3(iTime)));\n  gl_FragColor = vec4(vec3(stars),1.0);\n}\n</script>\n  <script>\n    const canvas = document.getElementById('shader-canvas');\nconst gl = canvas.getContext('webgl');\n\nfunction resize() {\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n}\nwindow.addEventListener('resize', resize);\nresize();\n\nfunction compileShader(gl, source, type) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    throw new Error(gl.getShaderInfoLog(shader));\n  }\n  return shader;\n}\n\nconst vertSrc = `\nattribute vec2 position;\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\nconst fragSrc = document.getElementById('fragShader').textContent;\n\nconst vertShader = compileShader(gl, vertSrc, gl.VERTEX_SHADER);\nconst fragShader = compileShader(gl, fragSrc, gl.FRAGMENT_SHADER);\n\nconst program = gl.createProgram();\ngl.attachShader(program, vertShader);\ngl.attachShader(program, fragShader);\ngl.linkProgram(program);\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n  throw new Error(gl.getProgramInfoLog(program));\n}\ngl.useProgram(program);\n\nconst posLoc = gl.getAttribLocation(program, 'position');\nconst buffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer);\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n  -1, -1, 1, -1, -1, 1,\n  -1, 1, 1, -1, 1, 1,\n]), gl.STATIC_DRAW);\ngl.enableVertexAttribArray(posLoc);\ngl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);\n\nconst iResolution = gl.getUniformLocation(program, 'iResolution');\nconst iTime = gl.getUniformLocation(program, 'iTime');\n\nfunction render(time) {\n  gl.uniform2f(iResolution, canvas.width, canvas.height);\n  gl.uniform1f(iTime, time * 0.001);\n  gl.drawArrays(gl.TRIANGLES, 0, 6);\n  requestAnimationFrame(render);\n}\nrequestAnimationFrame(render);\n  </script>\n</canvas>",
    "id": "animated-webgl-starfield-shader-background"
  },
  {
    "title": "üåå ‡§∏‡•Ç‡§∞‡•ç‡§Ø GLSL",
    "description": "",
    "code": "index.html: <div id=\"ui\"> <strong>‡§∏‡•Ç‡§∞‡•ç‡§Ø GLSL Demo</strong><br> <label>Speed <input id=\"speed\" type=\"range\" min=\"0\" max=\"4\" step=\"0.01\" value=\"1\"></label> <div id=\"err\"></div> </div> <canvas id=\"glcanvas\"></canvas>\nstyle.css: html,body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; } #ui { \tposition:fixed; top:10px; left:10px; z-index:20; \tbackground:rgba(0,0,0,0.5); padding:10px 14px; border-radius:8px; \tcolor:#eee; font-family:system-ui, sans-serif; font-size:14px; } label { display:block; margin:6px 0 2px; color:#ccc; } canvas { width:100vw; height:100vh; display:block; } #err { margin-top:8px; white-space:pre; color:#ffb; font-family:monospace; display:none;}\nscript.js: (() => { const canvas = document.getElementById(\"glcanvas\"); const gl = canvas.getContext(\"webgl\"); const errEl = document.getElementById(\"err\"); const speedEl = document.getElementById(\"speed\"); function resize() { \tconst d = window.devicePixelRatio || 1; \tcanvas.width = innerWidth * d; \tcanvas.height = innerHeight * d; \tcanvas.style.width = innerWidth+\"px\"; \tcanvas.style.height = innerHeight+\"px\"; \tgl.viewport(0,0,canvas.width,canvas.height); } resize(); addEventListener(\"resize\", resize); const vert = ` \tattribute vec2 pos; \tvoid main() { \t gl_Position = vec4(pos, 0.0, 1.0); \t} `; // Your shader, adapted to WebGL1 const frag = ` \tprecision highp float; \tuniform vec2 u_res; \tuniform float u_time; \tuniform float u_speed; \tvoid main() { \t vec2 FC = gl_FragCoord.xy; \t float t = u_time * u_speed; \t vec2 r = u_res; \t vec2 p = (FC * 2.0 - r) / r.y; \t vec3 c = vec3(0.0); \t for (float i = 0.0; i < 42.0; i++) { \t\tfloat a = i / 1.5 + t * 0.5; \t\tvec2 q = p; \t\tq.x = q.x + sin(q.y * 19.0 + t * 2.0 + i) * \t\t\t 29.0 * smoothstep(0.0, -2.0, q.y); \t\tfloat d = length(q - vec2(cos(a), sin(a)) * \t\t\t\t\t\t (0.4 * smoothstep(0.0, 0.5, -q.y))); \t\tc = c + vec3(0.34, 0.30, 0.24) * (0.015 / d); \t } \t vec3 col = c * c + 0.05; \t gl_FragColor = vec4(col, 1.0); \t} `; function compile(src, type) { \tconst s = gl.createShader(type); \tgl.shaderSource(s, src); \tgl.compileShader(s); \tif (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) { \t const msg = gl.getShaderInfoLog(s); \t throw new Error(msg); \t} \treturn s; } function link(vs, fs) { \tconst p = gl.createProgram(); \tgl.attachShader(p, vs); \tgl.attachShader(p, fs); \tgl.bindAttribLocation(p, 0, \"pos\"); \tgl.linkProgram(p); \tif (!gl.getProgramParameter(p, gl.LINK_STATUS)) { \t throw new Error(gl.getProgramInfoLog(p)); \t} \treturn p; } let program; try { \tconst vs = compile(vert, gl.VERTEX_SHADER); \tconst fs = compile(frag, gl.FRAGMENT_SHADER); \tprogram = link(vs, fs); } catch (e) { \terrEl.style.display = \"block\"; \terrEl.textContent = e.message; \tconsole.error(e); \treturn; } gl.useProgram(program); const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ \t-1,-1, 3,-1, -1,3 ]), gl.STATIC_DRAW); gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0); const u_res = gl.getUniformLocation(program, \"u_res\"); const u_time = gl.getUniformLocation(program, \"u_time\"); const u_speed = gl.getUniformLocation(program, \"u_speed\"); let start = performance.now(); function draw() { \tconst now = performance.now(); \tconst t = (now - start) * 0.001; \tgl.uniform2f(u_res, canvas.width, canvas.height); \tgl.uniform1f(u_time, t); \tgl.uniform1f(u_speed, parseFloat(speedEl.value)); \tgl.drawArrays(gl.TRIANGLES, 0, 3); \trequestAnimationFrame(draw); } draw(); })();",
    "id": "--glsl"
  },
  {
    "title": "duo",
    "description": "",
    "code": "index.html: <a href='//twitter.com/ycwhk' target='_blank'>duo</a>\nstyle.css: canvas { width: 100%; height: 100vh; display: block; cursor: grab; } body { height: 100vh; } a { position: fixed; top: 0; left: 0 ; padding: 5vmin; }\nscript.js: import * as $ from '//unpkg.com/three@0.120.0/build/three.module.js' import { OrbitControls } from '//unpkg.com/three@0.120.0/examples/jsm/controls/OrbitControls.js' // ---- // Boot // ---- const renderer = new $.WebGLRenderer({ alpha: true }); const scene = new $.Scene(); const camera = new $.PerspectiveCamera(75, 2, .1, 100); const controls = new OrbitControls(camera, renderer.domElement); window.addEventListener('resize', () => { const { clientWidth, clientHeight } = renderer.domElement; renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(clientWidth, clientHeight, false); camera.aspect = clientWidth / clientHeight; camera.updateProjectionMatrix(); }); document.body.prepend(renderer.domElement); window.dispatchEvent(new Event('resize')); renderer.setAnimationLoop(t => { renderer.render(scene, camera); controls.update(); }); // ---- // Main // ---- const W = 10, H = 10, SW = W * 20, SH = H * 20; const IMG_URLS = [ \"https://images.unsplash.com/photo-1522075469751-3a6694fb2f61?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=600&q=60\", \"https://images.unsplash.com/flagged/photo-1575494539155-6af0f84aa076?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=800&q=80\", ]; camera.position.set(0, 0, 8); for (const { color, intensity, x, y, z } of [ { color: 'white', intensity: 1, x: -W, y: 0, z: 0 }, { color: 'white', intensity: 1, x: W, y: 0, z: 0 }, ]) { const L = new $.SpotLight(color, intensity, W, Math.PI / 2, 0, 0); L.position.set(x, y, z); scene.add(L); } const vs = []; for (let i = 0, I = SH; i < I; ++i) { vs[i] = []; const nY = i / (I - 1); for (let j = 0, J = SW; j < J; ++j) { const nX = j / (J - 1); vs[i][j] = { uv: [nX, nY], xyz: [(nX - 0.5) * W, (nY - 0.5) * H, (i + 1) % 2 * (j % 2) * 0.5 - 0.25] }; } } //// Make Geometry - 2 Sets const geoms = []; for (let k = 0; k <= 1; ++k) { const geom = new $.BufferGeometry(); const N = ((SW - k) >> 1) * (SH - 1); const pos = new Float32Array(N * 3 * 6); // six (x,y,z) const uv = new Float32Array(N * 2 * 6); // six (u,v) let n = 0; for (let i = 0, I = SH - 1; i < I; ++i) { for (let j = k, J = SW - 1; j < J; j += 2) { let v = vs[i][j]; pos.set(v.xyz, n * 3); uv.set(v.uv, n * 2); ++n; v = vs[i][j + 1]; pos.set(v.xyz, n * 3); uv.set(v.uv, n * 2); ++n; v = vs[i + 1][j]; pos.set(v.xyz, n * 3); uv.set(v.uv, n * 2); ++n; v = vs[i][j + 1]; pos.set(v.xyz, n * 3); uv.set(v.uv, n * 2); ++n; v = vs[i + 1][j + 1]; pos.set(v.xyz, n * 3); uv.set(v.uv, n * 2); ++n; v = vs[i + 1][j]; pos.set(v.xyz, n * 3); uv.set(v.uv, n * 2); ++n; } } geom.setAttribute('position', new $.Float32BufferAttribute(pos, 3)); geom.setAttribute('uv', new $.Float32BufferAttribute(uv, 2)); geom.computeVertexNormals(); geoms.push(geom); } //// Make Meshes const g = new $.Group(); for (const [i, geom] of geoms.entries()) { const map = new $.TextureLoader().load(IMG_URLS[i]); const mat = new $.MeshLambertMaterial({ map, side: $.DoubleSide }); const mesh = new $.Mesh(geoms[i], mat); g.add(mesh); } scene.add(g); //// Animate const k = Math.PI / 5; gsap.timeline({ defaults: { duration: .35 }, repeat: 1, yoyo: true }) .to(g.rotation, { x: -k/2, y: k }) .to(g.rotation, { x: -k/2, y: -k }) .to(g.rotation, { x: 0, y: 0 })",
    "id": "duo"
  },
  {
    "title": "WebGL Smoke",
    "description": "",
    "code": "index.html: \nstyle.css: * { margin: 0; padding: 0; outline: 0; } html, body { width: 100%; height: 100%; overflow: hidden; }\nscript.js: var camera, scene, renderer, geometry, material, mesh; init(); animate(); function init() { stats = new Stats(); stats.setMode(0); stats.domElement.style.position = 'absolute'; stats.domElement.style.left = '0px'; stats.domElement.style.top = '0px'; document.body.appendChild(stats.domElement); clock = new THREE.Clock(); renderer = new THREE.WebGLRenderer(); renderer.setSize( window.innerWidth, window.innerHeight ); scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 ); camera.position.z = 1000; scene.add( camera ); geometry = new THREE.CubeGeometry( 200, 200, 200 ); material = new THREE.MeshLambertMaterial( { color: 0xaa6666, wireframe: false } ); mesh = new THREE.Mesh( geometry, material ); //scene.add( mesh ); cubeSineDriver = 0; textGeo = new THREE.PlaneGeometry(300,300); THREE.ImageUtils.crossOrigin = ''; //Need this to pull in crossdomain images from AWS textTexture = THREE.ImageUtils.loadTexture('https://s3-us-west-2.amazonaws.com/s.cdpn.io/95637/quickText.png'); textMaterial = new THREE.MeshLambertMaterial({color: 0x00ffff, opacity: 1, map: textTexture, transparent: true, blending: THREE.AdditiveBlending}) text = new THREE.Mesh(textGeo,textMaterial); text.position.z = 800; scene.add(text); light = new THREE.DirectionalLight(0xffffff,0.5); light.position.set(-1,0,1); scene.add(light); smokeTexture = THREE.ImageUtils.loadTexture('https://s3-us-west-2.amazonaws.com/s.cdpn.io/95637/Smoke-Element.png'); smokeMaterial = new THREE.MeshLambertMaterial({color: 0x00dddd, map: smokeTexture, transparent: true}); smokeGeo = new THREE.PlaneGeometry(300,300); smokeParticles = []; for (p = 0; p < 150; p++) { var particle = new THREE.Mesh(smokeGeo,smokeMaterial); particle.position.set(Math.random()*500-250,Math.random()*500-250,Math.random()*1000-100); particle.rotation.z = Math.random() * 360; scene.add(particle); smokeParticles.push(particle); } document.body.appendChild( renderer.domElement ); } function animate() { // note: three.js includes requestAnimationFrame shim stats.begin(); delta = clock.getDelta(); requestAnimationFrame( animate ); evolveSmoke(); render(); stats.end(); } function evolveSmoke() { var sp = smokeParticles.length; while(sp--) { smokeParticles[sp].rotation.z += (delta * 0.2); } } function render() { mesh.rotation.x += 0.005; mesh.rotation.y += 0.01; cubeSineDriver += .01; mesh.position.z = 100 + (Math.sin(cubeSineDriver) * 500); renderer.render( scene, camera ); }",
    "id": "webgl-smoke"
  },
  {
    "title": "Liquid Effect",
    "description": "",
    "code": "index.html: <div id=\"app\"> <canvas id=\"canvas\"></canvas> <a target=\"_blank\" href=\"https://www.framer.com/@kevin-levron/\">Framer Component</a> </div>\nstyle.css: body, html, #app { margin: 0; width: 100%; height: 100%; } body { touch-action: none; } #app { height: 100%; font-family: \"Montserrat\", serif; } #canvas { position: fixed; top: 0; right: 0; bottom: 0; left: 0; overflow: hidden; } a { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); color: #fff; text-decoration: none; text-shadow: 1px 1px 2px black; }\nscript.js: // Licence CC BY-NC-SA 4.0 // Attribution ‚Äî You must give appropriate credit. // Non Commercial ‚Äî You may not use the material for commercial purposes. import LiquidBackground from 'https://cdn.jsdelivr.net/npm/threejs-components@0.0.27/build/backgrounds/liquid1.min.js' const app = LiquidBackground(document.getElementById('canvas')) app.loadImage('https://assets.codepen.io/33787/liquid.webp') app.liquidPlane.material.metalness = 0.75 app.liquidPlane.material.roughness = 0.25 app.liquidPlane.uniforms.displacementScale.value = 5 app.setRain(false)",
    "id": "liquid-effect"
  },
  {
    "title": "Animated Waves Background with Vanta.js",
    "description": "Absolute-positioned component that renders interactive, customizable wave animations via Vanta.js and Three.js. Adds a dynamic, responsive backdrop ideal for hero sections, full-page backgrounds, or overlays.",
    "code": "<div id=\"vanta-bg\" class=\"absolute inset-0 z-0 opacity-60\">\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js\"></script>\n  <script src=\"https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.waves.min.js\"></script>\n  <script>\n    document.addEventListener('DOMContentLoaded', function() {\n      VANTA.WAVES({\n        el: \"#vanta-bg\",\n        mouseControls: true,\n        touchControls: true,\n        gyroControls: false,\n        minHeight: 200.00,\n        minWidth: 200.00,\n        scale: 1.00,\n        scaleMobile: 1.00,\n        color: 0x0055ff,\n        shininess: 35.00,\n        waveHeight: 15.00,\n        waveSpeed: 0.75,\n        zoom: 0.65\n      });\n    });\n  </script>\n</div>",
    "id": "animated-waves-background-with-vantajs"
  }
]