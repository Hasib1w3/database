[
  {
    "title": "Particle Cylinder Shockwave",
    "description": "",
    "code": "index.html: <script src=\"https://cdn.tailwindcss.com\"></script> <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"> <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin> <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap\" rel=\"stylesheet\"> <style> body { margin: 0; padding: 0; box-sizing: border-box; background-color: #000000; overflow: hidden; font-family: 'Inter', sans-serif; color: #eee; } canvas { display: block; width: 100%; height: 100vh; cursor: pointer; } .theme-button.active { border-color: #ffffff; transform: scale(1.15); box-shadow: 0 0 10px rgba(255, 255, 255, 0.5); } </style> <canvas id=\"particleCanvas\"></canvas> <div id=\"instructions-container\" class=\"absolute bottom-5 left-5 p-4 bg-black/30 backdrop-blur-md rounded-lg border border-white/20 shadow-lg text-center text-sm text-gray-200 max-w-[180px]\"> Move mouse to interact<br>Click or Tap for shockwave </div> <div id=\"theme-selector\" class=\"absolute top-5 right-5 p-2 flex gap-3 bg-black/30 backdrop-blur-md rounded-full border border-white/20 shadow-lg\"> <button class=\"theme-button w-8 h-8 rounded-full border-2 border-white/30 cursor-pointer transition-all duration-200 ease-in-out hover:scale-110 hover:border-white/70 focus:outline-none\" id=\"theme-1\" data-theme-index=\"0\"></button> <button class=\"theme-button w-8 h-8 rounded-full border-2 border-white/30 cursor-pointer transition-all duration-200 ease-in-out hover:scale-110 hover:border-white/70 focus:outline-none active\" id=\"theme-2\" data-theme-index=\"1\"></button> <button class=\"theme-button w-8 h-8 rounded-full border-2 border-white/30 cursor-pointer transition-all duration-200 ease-in-out hover:scale-110 hover:border-white/70 focus:outline-none\" id=\"theme-3\" data-theme-index=\"2\"></button> </div> <script type=\"importmap\"> { \"imports\": { \"three\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js\", \"three/addons/\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/\" } } </script> <script type=\"module\"> import * as THREE from 'three'; import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js'; import { RenderPass } from 'three/addons/postprocessing/RenderPass.js'; import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js'; import { OutputPass } from 'three/addons/postprocessing/OutputPass.js'; let mainFormation, energySphere; const clock = new THREE.Clock(); let activePaletteIndex = 1; let pointer = new THREE.Vector2(); let mouseWorldPos = new THREE.Vector3(0, 0, 0); let isMouseActive = false; const PARTICLE_COUNT_MAIN = 75000; const PARTICLE_COUNT_SPHERE = 10000; const CYLINDER_RADIUS = 15; const CYLINDER_HEIGHT = 30; const FORMATION_RADIUS = 25; const ENERGY_SPHERE_RADIUS = 6 * 0.6; const SHOCKWAVE_SPEED = 40.0; const SHOCKWAVE_THICKNESS = 5.0; const BLOOM_PARAMS = { strength: 0.09, radius: 0.45, threshold: 0.85 }; const MOUSE_REPEL_RADIUS = 8.0; const MOUSE_REPEL_STRENGTH = 1.5; const colorPalettes = [ [ new THREE.Color(0xff00ff), new THREE.Color(0x00ffff), new THREE.Color(0x00ff00), new THREE.Color(0xffff00), new THREE.Color(0x0077ff) ], [ new THREE.Color(0xff2200), new THREE.Color(0xff8800), new THREE.Color(0xffdd00), new THREE.Color(0x880000), new THREE.Color(0x440000) ], [ new THREE.Color(0x00ffaa), new THREE.Color(0x00ddff), new THREE.Color(0xaaff00), new THREE.Color(0x0088cc), new THREE.Color(0x006644) ] ]; const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, 35, 0); camera.lookAt(0, 0, 0); const canvas = document.getElementById('particleCanvas'); const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, powerPreference: \"high-performance\" }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(0x000000); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); renderer.outputColorSpace = THREE.SRGBColorSpace; const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.rotateSpeed = 0.5; controls.minDistance = 5; controls.maxDistance = 100; controls.target.set(0, 0, 0); controls.update(); const composer = new EffectComposer(renderer); composer.addPass(new RenderPass(scene, camera)); const bloomPass = new UnrealBloomPass( new THREE.Vector2(window.innerWidth, window.innerHeight), BLOOM_PARAMS.strength, BLOOM_PARAMS.radius, BLOOM_PARAMS.threshold ); composer.addPass(bloomPass); const outputPass = new OutputPass(); composer.addPass(outputPass); const raycaster = new THREE.Raycaster(); const interactionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); const interactionPoint = new THREE.Vector3(); const mouseInteractionPoint = new THREE.Vector3(); const outerInteractionUniforms = { uOuterClickPos: { value: new THREE.Vector3(0, 0, 0) }, uOuterClickTime: { value: -1000.0 }, uWaveSpeed: { value: SHOCKWAVE_SPEED }, uWaveThickness: { value: SHOCKWAVE_THICKNESS }, uMousePos: { value: new THREE.Vector3(0, 0, 0) }, uMouseActive: { value: 0.0 }, uMouseRepelRadius: { value: MOUSE_REPEL_RADIUS }, uMouseRepelStrength: { value: MOUSE_REPEL_STRENGTH } }; const noiseFunctionsGLSL = ` vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); } vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; } float snoise(vec3 v) { const vec2 C = vec2(1.0/6.0, 1.0/3.0) ; const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx); vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy); vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy; i = mod289(i); vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 )); float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z); vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_ ); vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4( x.xy, y.xy ); vec4 b1 = vec4( x.zw, y.zw ); vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ; vec3 p0 = vec3(a0.xy,h.x); vec3 p1 = vec3(a0.zw,h.y); vec3 p2 = vec3(a1.xy,h.z); vec3 p3 = vec3(a1.zw,h.w); vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0); m = m * m; return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) ); } float fbm(vec3 p, float time) { float value = 0.0; float amplitude = 0.5; float frequency = 0.8; int octaves = 3; for (int i = 0; i < octaves; i++) { value += amplitude * snoise(p * frequency + time * 0.10 * frequency); amplitude *= 0.5; frequency *= 2.0; } return value; } `; const step = (edge, x) => new THREE.Vector3( x.x < edge.x ? 0.0 : 1.0, x.y < edge.y ? 0.0 : 1.0, x.z < edge.z ? 0.0 : 1.0 ); const step4 = (edge, x) => new THREE.Vector4( x.x < edge.x ? 0.0 : 1.0, x.y < edge.y ? 0.0 : 1.0, x.z < edge.z ? 0.0 : 1.0, x.w < edge.w ? 0.0 : 1.0 ); const abs4 = (v) => new THREE.Vector4( Math.abs(v.x), Math.abs(v.y), Math.abs(v.z), Math.abs(v.w) ); const _mod289_3 = (x) => x.sub(x.clone().multiplyScalar(1.0 / 289.0).floor().multiplyScalar(289.0)); const _mod289_4 = (x) => x.sub(x.clone().multiplyScalar(1.0 / 289.0).floor().multiplyScalar(289.0)); const _permute_4 = (x) => _mod289_4(x.clone().multiplyScalar(34.0).addScalar(1.0).multiply(x)); const _taylorInvSqrt_4 = (r) => r.clone().multiplyScalar(-0.85373472095314).addScalar(1.79284291400159); const _snoise_3 = (v) => { const C = new THREE.Vector2(1.0 / 6.0, 1.0 / 3.0); const D = new THREE.Vector4(0.0, 0.5, 1.0, 2.0); const v_dot_Cyyy = v.dot(new THREE.Vector3(C.y, C.y, C.y)); let i = v.clone().add(new THREE.Vector3(v_dot_Cyyy, v_dot_Cyyy, v_dot_Cyyy)).floor(); const i_dot_Cxxx = i.dot(new THREE.Vector3(C.x, C.x, C.x)); let x0 = v.clone().sub(i).add(new THREE.Vector3(i_dot_Cxxx, i_dot_Cxxx, i_dot_Cxxx)); let g = step(x0.clone().set(x0.y, x0.z, x0.x), x0); let l = new THREE.Vector3(1.0, 1.0, 1.0).sub(g); let i1 = g.clone().min(l.clone().set(l.z, l.x, l.y)); let i2 = g.clone().max(l.clone().set(l.z, l.x, l.y)); let x1 = x0.clone().sub(i1).addScalar(C.x); let x2 = x0.clone().sub(i2).addScalar(C.y); let x3 = x0.clone().subScalar(D.y); i = _mod289_3(i); let p = _permute_4(_permute_4(_permute_4(new THREE.Vector4(0.0, i1.z, i2.z, 1.0).addScalar(i.z)).add(new THREE.Vector4(0.0, i1.y, i2.y, 1.0).addScalar(i.y))).add(new THREE.Vector4(0.0, i1.x, i2.x, 1.0).addScalar(i.x))); let n_ = 0.142857142857; let nsVec = new THREE.Vector3(D.w, D.y, D.z); let ns = nsVec.clone().multiplyScalar(n_).sub(new THREE.Vector3(D.x, D.z, D.x)); let j = p.clone().sub(p.clone().multiplyScalar(ns.z * ns.z).floor().multiplyScalar(49.0)); let x_ = j.clone().multiplyScalar(ns.z).floor(); let y_ = j.clone().sub(x_.clone().multiplyScalar(7.0)).floor(); let x = x_.clone().multiplyScalar(ns.x).addScalar(ns.y); let y = y_.clone().multiplyScalar(ns.x).addScalar(ns.y); let h = new THREE.Vector4(1.0, 1.0, 1.0, 1.0).sub(abs4(x)).sub(abs4(y)); let b0 = new THREE.Vector4(x.x, x.y, y.x, y.y); let b1 = new THREE.Vector4(x.z, x.w, y.z, y.w); let s0 = b0.clone().floor().multiplyScalar(2.0).addScalar(1.0); let s1 = b1.clone().floor().multiplyScalar(2.0).addScalar(1.0); let sh = step4(new THREE.Vector4(0.0, 0.0, 0.0, 0.0), h).multiplyScalar(-1.0); let a0 = b0.clone().set(b0.x, b0.z, b0.y, b0.w).add(s0.clone().set(s0.x, s0.z, s0.y, s0.w).multiply(sh.clone().set(sh.x, sh.x, sh.y, sh.y))); let a1 = b1.clone().set(b1.x, b1.z, b1.y, b1.w).add(s1.clone().set(s1.x, s1.z, s1.y, s1.w).multiply(sh.clone().set(sh.z, sh.z, sh.w, sh.w))); let p0 = new THREE.Vector3(a0.x, a0.y, h.x); let p1 = new THREE.Vector3(a0.z, a0.w, h.y); let p2 = new THREE.Vector3(a1.x, a1.y, h.z); let p3 = new THREE.Vector3(a1.z, a1.w, h.w); let norm = _taylorInvSqrt_4(new THREE.Vector4(p0.dot(p0), p1.dot(p1), p2.dot(p2), p3.dot(p3))); p0.multiplyScalar(norm.x); p1.multiplyScalar(norm.y); p2.multiplyScalar(norm.z); p3.multiplyScalar(norm.w); let m = new THREE.Vector4(x0.dot(x0), x1.dot(x1), x2.dot(x2), x3.dot(x3)).multiplyScalar(-1.0).addScalar(0.6).max(new THREE.Vector4(0.0, 0.0, 0.0, 0.0)); m.multiply(m); return 42.0 * m.dot(new THREE.Vector4(p0.dot(x0), p1.dot(x1), p2.dot(x2), p3.dot(x3))); }; const _fbm_3 = (p) => { let value = 0.0; let amplitude = 0.5; let frequency = 0.8; const octaves = 3; for (let i = 0; i < octaves; i++) { value += amplitude * _snoise_3(p.clone().multiplyScalar(frequency)); amplitude *= 0.5; frequency *= 2.0; } return value; }; const particleShader = { vertexShader: ` attribute float size; attribute float originalHue; varying vec3 vColor; varying float vDistance; varying vec3 vWorldPosition; varying vec3 vNormal; varying float vWaveFactor; varying float vOriginalHue; uniform float time; uniform vec3 uOuterClickPos; uniform float uOuterClickTime; uniform float uWaveSpeed; uniform float uWaveThickness; uniform vec3 uMousePos; uniform float uMouseActive; uniform float uMouseRepelRadius; uniform float uMouseRepelStrength; ${noiseFunctionsGLSL} void main() { vColor = color; vNormal = normal; vWaveFactor = 0.0; vOriginalHue = originalHue; vec3 pos = position; float t = time; float noiseScale = 0.4; float noiseStrength = 1.2; float displacement = fbm(position * noiseScale * 0.1, t * 0.3) * noiseStrength; vec3 animatedModulation = vNormal * displacement; vec3 shockwavePushForce = vec3(0.0); float shockwaveSizeIncrease = 0.0; if (uOuterClickTime > 0.0) { float timeSinceClick = t - uOuterClickTime; if(timeSinceClick >= 0.0 && timeSinceClick < 2.5) { float waveRadius = timeSinceClick * uWaveSpeed; vec4 worldPos4Base = modelMatrix * vec4(position, 1.0); vec3 worldPosBase = worldPos4Base.xyz / worldPos4Base.w; float distToClick = length(worldPosBase - uOuterClickPos); float waveProximity = abs(distToClick - waveRadius); vWaveFactor = smoothstep(uWaveThickness, 0.0, waveProximity); if (vWaveFactor > 0.0) { float shockwaveStrength = 7.0; vec3 pushDir = normalize(worldPosBase - uOuterClickPos); if (length(pushDir) < 0.001) { pushDir = vNormal; } shockwavePushForce = pushDir * vWaveFactor * shockwaveStrength; shockwaveSizeIncrease = vWaveFactor * 1.5; } } } vec3 mouseRepelForce = vec3(0.0); if (uMouseActive > 0.5) { vec4 worldPos4Current = modelMatrix * vec4(position + animatedModulation, 1.0); vec3 worldPosCurrent = worldPos4Current.xyz / worldPos4Current.w; vec3 diff = worldPosCurrent - uMousePos; float distToMouse = length(diff); if (distToMouse < uMouseRepelRadius) { float repelFactor = smoothstep(uMouseRepelRadius, 0.0, distToMouse); mouseRepelForce = normalize(diff) * repelFactor * uMouseRepelStrength; } } pos += animatedModulation + shockwavePushForce + mouseRepelForce; vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0); vDistance = length(mvPosition.xyz); vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz; float sizeModulation = size * (1.0 + sin(t * 2.5 + length(position) * 0.1) * 0.3); gl_PointSize = (sizeModulation + shockwaveSizeIncrease) * (1500.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; } `, fragmentShader: ` varying vec3 vColor; varying float vDistance; varying vec3 vWorldPosition; varying vec3 vNormal; varying float vWaveFactor; varying float vOriginalHue; uniform float time; uniform float uFormationRadius; vec3 gradientMix(vec3 c1, vec3 c2, vec3 c3, float t) { return mix(mix(c1, c2, smoothstep(0.0, 0.5, t)), mix(c2, c3, smoothstep(0.5, 1.0, t)), step(0.5, t)); } void main() { vec2 uv = gl_PointCoord; vec2 cxy = 2.0 * uv - 1.0; float r2 = dot(cxy, cxy); if (r2 > 1.0) discard; float r = sqrt(r2); float coreSharpness = 0.1; float glowFalloff = 0.6; float coreIntensity = smoothstep(coreSharpness, 0.0, r); float glowIntensity = smoothstep(glowFalloff, coreSharpness, r); float alpha = coreIntensity + glowIntensity * (1.0 - coreIntensity); vec3 baseColor = vColor; if (vWaveFactor > 0.0) { vec3 fieryColor1 = vec3(1.0, 1.0, 0.9); vec3 fieryColor2 = vec3(1.0, 0.7, 0.0); vec3 fieryColor3 = vec3(0.9, 0.2, 0.0); float gradientT = vWaveFactor; vec3 fieryColor = gradientMix(fieryColor3, fieryColor2, fieryColor1, gradientT); baseColor = mix(baseColor, fieryColor, vWaveFactor * 0.85); baseColor *= (1.0 + vWaveFactor * 1.5); } float distanceFade = smoothstep(uFormationRadius * 1.8, uFormationRadius * 0.9, vDistance); alpha *= distanceFade; baseColor = clamp(baseColor, 0.0, 3.5); gl_FragColor = vec4(baseColor, alpha); } ` }; function createParticleSystem(count, radius, creationFunc, isOuterLayer = false) { const geometry = creationFunc(count, radius, colorPalettes[activePaletteIndex]); if (!geometry || !geometry.attributes.position || geometry.attributes.position.count === 0) { console.error(\"Geometry creation failed or resulted in empty geometry.\"); return null; } let materialUniforms = { time: { value: 0 } }; if (isOuterLayer) { materialUniforms = { ...materialUniforms, ...THREE.UniformsUtils.clone(outerInteractionUniforms), uFormationRadius: { value: FORMATION_RADIUS }, uMousePos: outerInteractionUniforms.uMousePos, uMouseActive: outerInteractionUniforms.uMouseActive, uMouseRepelRadius: outerInteractionUniforms.uMouseRepelRadius, uMouseRepelStrength: outerInteractionUniforms.uMouseRepelStrength }; } const material = new THREE.ShaderMaterial({ uniforms: materialUniforms, vertexShader: particleShader.vertexShader, fragmentShader: particleShader.fragmentShader, vertexColors: true, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }); return new THREE.Points(geometry, material); } function createCylinderGeometry(particleCount, cylinderRadius, palette) { const geometry = new THREE.BufferGeometry(); const positions = []; const colors = []; const sizes = []; const normals = []; const originalHues = []; const tempPos = new THREE.Vector3(); const normal = new THREE.Vector3(); const tempColor = new THREE.Color(); const baseHSL = {}; const cylinderHeight = 30; const displacementStrength = 3.0; for (let i = 0; i < particleCount; i++) { const phi = Math.random() * Math.PI * 2; const h = (Math.random() - 0.5) * cylinderHeight; const x = cylinderRadius * Math.cos(phi); const z = cylinderRadius * Math.sin(phi); const y = h; tempPos.set(x, y, z); normal.set(x, 0, z).normalize(); const noiseInput = tempPos.clone().multiplyScalar(1.0 / cylinderRadius * 1.2); const displacement = _fbm_3(noiseInput) * displacementStrength; tempPos.addScaledVector(normal, displacement); positions.push(tempPos.x, tempPos.y, tempPos.z); normals.push(normal.x, normal.y, normal.z); const hueProgress = (phi / (Math.PI * 2)) % 1.0; const c1Index = Math.floor(hueProgress * (palette.length - 1)); const c2Index = Math.min(c1Index + 1, palette.length - 1); tempColor.lerpColors(palette[c1Index], palette[c2Index], (hueProgress * (palette.length - 1)) % 1); tempColor.getHSL(baseHSL); originalHues.push(baseHSL.h); tempColor.offsetHSL(Math.random() * 0.02 - 0.01, Math.random() * 0.05 - 0.02, Math.random() * 0.05 - 0.02); colors.push(tempColor.r, tempColor.g, tempColor.b); const sizeFactor = 1.0 - Math.abs(displacement) / (displacementStrength + 1e-6); sizes.push(Math.max(0.3, sizeFactor) * (Math.random() * 0.4 + 0.7)); } geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3)); geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1)); geometry.setAttribute('originalHue', new THREE.Float32BufferAttribute(originalHues, 1)); return geometry; } function createEnergySphereGeometry(particleCount, radius, palette) { const geometry = new THREE.BufferGeometry(); const positions = []; const colors = []; const sizes = []; const normals = []; const hslData = []; const phiGolden = (1 + Math.sqrt(5)) / 2; const coreBaseColor = colorPalettes[activePaletteIndex][1]; const baseHsl = {}; coreBaseColor.getHSL(baseHsl); for (let i = 0; i < particleCount; i++) { const y = 1 - (i / (particleCount - 1)) * 2; const radiusAtY = Math.sqrt(1 - y * y); const theta = (2 * Math.PI * i) / phiGolden; const x = Math.cos(theta) * radiusAtY * radius; const z = Math.sin(theta) * radiusAtY * radius; const finalY = y * radius; positions.push(x, finalY, z); const normal = new THREE.Vector3(x, finalY, z).normalize(); normals.push(normal.x, normal.y, normal.z); const initialHue = (baseHsl.h + Math.random() * 0.1 - 0.05) % 1.0; const initialSat = Math.max(0.7, baseHsl.s + Math.random() * 0.2 - 0.05); const initialLight = Math.min(0.9, baseHsl.l + Math.random() * 0.15); hslData.push({ h: initialHue, s: initialSat, l: initialLight }); const color = new THREE.Color().setHSL(initialHue, initialSat, initialLight); colors.push(color.r, color.g, color.b); sizes.push(Math.random() * 0.5 + 0.5); } geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3)); geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1)); geometry.userData.hslData = hslData; return geometry; } mainFormation = createParticleSystem(PARTICLE_COUNT_MAIN, CYLINDER_RADIUS, createCylinderGeometry, true); energySphere = createParticleSystem(PARTICLE_COUNT_SPHERE, ENERGY_SPHERE_RADIUS, createEnergySphereGeometry, false); if (mainFormation) scene.add(mainFormation); if (energySphere) scene.add(energySphere); function updateTheme(newPaletteIndex) { if (newPaletteIndex === activePaletteIndex) return; activePaletteIndex = newPaletteIndex; const newPalette = colorPalettes[activePaletteIndex]; if (mainFormation?.geometry) { const geometry = mainFormation.geometry; const colorsAttribute = geometry.attributes.color; const huesAttribute = geometry.attributes.originalHue; if (colorsAttribute && huesAttribute) { const particleCount = colorsAttribute.count; const tempColor = new THREE.Color(); const baseHSL = {}; for (let i = 0; i < particleCount; i++) { const originalHueProgress = huesAttribute.getX(i); const c1Index = Math.floor(originalHueProgress * (newPalette.length - 1)); const c2Index = Math.min(c1Index + 1, newPalette.length - 1); tempColor.lerpColors(newPalette[c1Index], newPalette[c2Index], (originalHueProgress * (newPalette.length - 1)) % 1); tempColor.getHSL(baseHSL); tempColor.offsetHSL(Math.random() * 0.02 - 0.01, Math.random() * 0.05 - 0.02, Math.random() * 0.05 - 0.02); colorsAttribute.setXYZ(i, tempColor.r, tempColor.g, tempColor.b); } colorsAttribute.needsUpdate = true; } } if (energySphere?.geometry) { const geometry = energySphere.geometry; const colorsAttribute = geometry.attributes.color; const hslData = geometry.userData.hslData; if (colorsAttribute && hslData) { const particleCount = colorsAttribute.count; const coreBaseColor = newPalette[1]; const baseHsl = {}; coreBaseColor.getHSL(baseHsl); const tempColor = new THREE.Color(); for (let i = 0; i < particleCount; i++) { const initialHue = (baseHsl.h + Math.random() * 0.1 - 0.05) % 1.0; const initialSat = hslData[i]?.s ?? (Math.max(0.7, baseHsl.s + Math.random() * 0.2 - 0.05)); const initialLight = hslData[i]?.l ?? (Math.min(0.9, baseHsl.l + Math.random() * 0.15)); if(hslData[i]) { hslData[i] = {h: initialHue, s: initialSat, l: initialLight}; } else { hslData.push({h: initialHue, s: initialSat, l: initialLight}); } tempColor.setHSL(initialHue, initialSat, initialLight); colorsAttribute.setXYZ(i, tempColor.r, tempColor.g, tempColor.b); } colorsAttribute.needsUpdate = true; } } document.querySelectorAll('.theme-button').forEach(btn => { btn.classList.toggle('active', parseInt(btn.dataset.themeIndex) === activePaletteIndex); }); } function animate() { requestAnimationFrame(animate); const elapsedTime = clock.getElapsedTime(); const deltaTime = clock.getDelta(); if (isMouseActive && mainFormation?.material?.uniforms?.uMousePos) { interactionPlane.normal.copy(camera.position).normalize(); interactionPlane.constant = 0; raycaster.setFromCamera(pointer, camera); if (raycaster.ray.intersectPlane(interactionPlane, mouseInteractionPoint)) { outerInteractionUniforms.uMousePos.value.copy(mouseInteractionPoint); } outerInteractionUniforms.uMouseActive.value = 1.0; } else if (mainFormation?.material?.uniforms?.uMouseActive) { outerInteractionUniforms.uMouseActive.value = 0.0; } if (mainFormation?.material?.uniforms?.time) mainFormation.material.uniforms.time.value = elapsedTime; if (energySphere?.material?.uniforms?.time) energySphere.material.uniforms.time.value = elapsedTime; if (energySphere?.geometry) { const sphereGeometry = energySphere.geometry; const sphereColors = sphereGeometry.attributes.color; const sphereHslData = sphereGeometry.userData.hslData; if (sphereColors && sphereHslData) { const particleCount = sphereColors.count; const tempColor = new THREE.Color(); for (let i = 0; i < particleCount; i++) { const hsl = sphereHslData[i]; if (hsl) { const currentHue = (hsl.h + elapsedTime * 0.15) % 1.0; tempColor.setHSL(currentHue, hsl.s, hsl.l); sphereColors.setXYZ(i, tempColor.r, tempColor.g, tempColor.b); } } sphereColors.needsUpdate = true; } energySphere.rotation.y -= 0.002; const sphereScale = 1.0 + Math.sin(elapsedTime * 2.5) * 0.1; energySphere.scale.set(sphereScale, sphereScale, sphereScale); } if (mainFormation?.geometry) { mainFormation.rotation.y += 0.0003; mainFormation.rotation.x += 0.0005; mainFormation.rotation.z -= 0.0002; } controls.update(); composer.render(deltaTime); } function triggerShockwave(clientX, clientY) { if (!mainFormation?.material?.uniforms?.uOuterClickPos) return; pointer.x = (clientX / window.innerWidth) * 2 - 1; pointer.y = -(clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(pointer, camera); interactionPlane.normal.copy(camera.position).normalize(); interactionPlane.constant = 0; if (raycaster.ray.intersectPlane(interactionPlane, interactionPoint)) { const currentTime = clock.getElapsedTime(); mainFormation.material.uniforms.uOuterClickPos.value.copy(interactionPoint); mainFormation.material.uniforms.uOuterClickTime.value = currentTime; } else { console.warn(\"Raycaster did not intersect interaction plane for shockwave.\"); } } function onMouseMove(event) { pointer.x = (event.clientX / window.innerWidth) * 2 - 1; pointer.y = -(event.clientY / window.innerHeight) * 2 + 1; isMouseActive = true; } function onMouseLeave() { isMouseActive = false; } function onMouseClick(event) { if (event.target.closest('#theme-selector') || event.target.closest('#instructions-container')) return; triggerShockwave(event.clientX, event.clientY); } function onTouchStart(event) { if (event.target.closest('#theme-selector') || event.target.closest('#instructions-container')) return; event.preventDefault(); if (event.touches.length > 0) { triggerShockwave(event.touches[0].clientX, event.touches[0].clientY); } } function onWindowResize() { const width = window.innerWidth; const height = window.innerHeight; camera.aspect = width / height; camera.updateProjectionMatrix(); renderer.setSize(width, height); composer.setSize(width, height); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); } document.getElementById('theme-1').style.background = `linear-gradient(45deg, #ff00ff, #00ffff, #00ff00)`; document.getElementById('theme-2').style.background = `linear-gradient(45deg, #ff2200, #ff8800, #ffdd00)`; document.getElementById('theme-3').style.background = `linear-gradient(45deg, #00ffaa, #00ddff, #aaff00)`; window.addEventListener('mousemove', onMouseMove); canvas.addEventListener('mouseleave', onMouseLeave); window.addEventListener('click', onMouseClick); window.addEventListener('touchstart', onTouchStart, { passive: false }); window.addEventListener('resize', onWindowResize); document.querySelectorAll('.theme-button').forEach(button => { button.addEventListener('click', () => { updateTheme(parseInt(button.dataset.themeIndex)); }); }); updateTheme(1); window.onload = () => { animate(); } </script>\nstyle.css: \nscript.js: ",
    "id": "particle-cylinder-shockwave"
  },
  {
    "title": "[threejs] ‚ùç Interactive Particles with Image Mapping",
    "description": "",
    "code": "index.html: <div id=\"container\"></div> <!-- Image to be used for particles --> <img id=\"source-image\" src=\"https://images.unsplash.com/photo-1568283661163-c90193fd13f1?q=80&w=2340\" crossorigin=\"anonymous\" style=\"display: none;\">\nstyle.css: /* Based on the great article on Codrops https://tympanus.net/codrops/2019/01/17/interactive-particles-with-three-js/ */ * { margin: 0; padding: 0; box-sizing: border-box; } html, body { width: 100%; height: 100%; overflow: hidden; background-color: #000; } #container { position: fixed; width: 100%; height: 100%; left: 0; top: 0; } /* Stats.js panel styling */ #stats { position: absolute; top: 0; left: 0; z-index: 100; }\nscript.js: import * as THREE from \"https://esm.sh/three@0.175.0\"; import { GUI } from \"https://esm.sh/dat.gui@0.7.9\"; import Stats from \"https://esm.sh/stats.js@0.17.0\"; import { EffectComposer } from \"https://esm.sh/three@0.175.0/examples/jsm/postprocessing/EffectComposer.js\"; import { RenderPass } from \"https://esm.sh/three@0.175.0/examples/jsm/postprocessing/RenderPass.js\"; import { UnrealBloomPass } from \"https://esm.sh/three@0.175.0/examples/jsm/postprocessing/UnrealBloomPass.js\"; // Shaders const vertexShader = ` precision highp float; // Attributes attribute vec3 position; attribute vec2 uv; attribute float pindex; attribute vec3 offset; attribute float angle; // Uniforms uniform mat4 modelViewMatrix; uniform mat4 projectionMatrix; uniform float uTime; uniform float uRandom; uniform float uDepth; uniform float uSize; uniform vec2 uTextureSize; uniform sampler2D uTexture; uniform sampler2D uTouch; uniform vec2 uMouse; uniform float uMouseSize; uniform float uMouseForce; uniform float uEasingFactor; uniform float uIdleMovement; uniform float uIdleSpeed; uniform float uIdleIntensity; uniform float uParticleSpring; // Varying varying vec2 vPUv; varying vec2 vUv; varying float vGrey; varying float vDistance; // Function to generate random value float random(float n) { return fract(sin(n) * 43758.5453123); } // Simplex noise function vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); } float snoise_1_2(vec2 v) { const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i = floor(v + dot(v, C.yy) ); vec2 x0 = v - i + dot(i, C.xx); vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod289(i); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 )); vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); m = m*m; m = m*m; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ); vec3 g; g.x = a0.x * x0.x + h.x * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g); } // Cubic easing function float easeCubicOut(float t) { float f = t - 1.0; return f * f * f + 1.0; } // Exponential easing function float easeExpoOut(float t) { return t == 1.0 ? 1.0 : 1.0 - pow(2.0, -10.0 * t); } // Elastic easing function (more natural) float easeElasticOut(float t) { float p = 0.3; return pow(2.0, -10.0 * t) * sin((t - p / 4.0) * (2.0 * 3.14159) / p) + 1.0; } void main() { vUv = uv; // Pixel UV coordinates within the texture vec2 puv = offset.xy / uTextureSize; vPUv = puv; // Sample the image pixel color vec4 colA = texture2D(uTexture, puv); float grey = colA.r * 0.21 + colA.g * 0.71 + colA.b * 0.07; vGrey = grey; // Original position (home position) vec3 homePosition = vec3(offset.xy, 0.0); // Displacement vec3 displaced = homePosition; // Randomize position slightly displaced.xy += vec2(random(pindex) - 0.5, random(offset.x + pindex) - 0.5) * uRandom; // Calculate random z value for depth variation float rndz = (random(pindex) + snoise_1_2(vec2(pindex * 0.1, uTime * 0.1))); displaced.z += rndz * (random(pindex) * 2.0 * uDepth); // Apply touch interaction from texture float t = texture2D(uTouch, puv).r; displaced.z += t * 10.0 * rndz; displaced.x += cos(angle) * t * 10.0 * rndz; displaced.y += sin(angle) * t * 10.0 * rndz; // IDLE ANIMATION - subtle movement when no mouse interaction // Each particle moves in a unique pattern based on its index if (uIdleMovement > 0.0) { float idleTime = uTime * uIdleSpeed; float noise1 = snoise_1_2(vec2(pindex * 0.01, idleTime * 0.1)); float noise2 = snoise_1_2(vec2(pindex * 0.02, idleTime * 0.15 + 100.0)); float noise3 = snoise_1_2(vec2(pindex * 0.03, idleTime * 0.05 + 300.0)); // Create a breathing effect float breathe = sin(idleTime * 0.2 + pindex * 0.01) * 0.5 + 0.5; // Apply subtle movement displaced.x += noise1 * uIdleIntensity * uIdleMovement * (1.0 - min(1.0, t * 2.0)); displaced.y += noise2 * uIdleIntensity * uIdleMovement * (1.0 - min(1.0, t * 2.0)); displaced.z += noise3 * uIdleIntensity * 2.0 * uIdleMovement * breathe * (1.0 - min(1.0, t * 2.0)); } // DIRECT MOUSE INTERACTION // Calculate distance from this particle to mouse position float dist = distance(offset.xy, uMouse * uTextureSize); vDistance = dist; // If within mouse influence radius, apply force if (dist < uMouseSize) { // Calculate force based on distance (closer = stronger) float forceFactor = 1.0 - dist/uMouseSize; // Apply easing for smoother effect float easedForce = easeExpoOut(forceFactor) * uMouseForce; // Get direction from mouse to particle (for pushing away effect) vec2 dir = normalize(offset.xy - uMouse * uTextureSize); // Apply force with spring-like behavior float springFactor = uParticleSpring; float dampingFactor = 0.6; // Create a more organic movement with noise float uniqueness = snoise_1_2(vec2(pindex * 0.1, uTime * 0.2)); float organicFactor = 0.8 + uniqueness * 0.4; // Apply force with organic variation displaced.x += dir.x * easedForce * 8.0 * organicFactor; displaced.y += dir.y * easedForce * 8.0 * organicFactor; // Z-axis movement for depth effect float zForce = easedForce * 15.0 * rndz * organicFactor; // Particles closer to the center move more in Z float centerFactor = 1.0 - min(1.0, dist / (uMouseSize * 0.5)); displaced.z += zForce * (0.5 + centerFactor * 0.5); } // Calculate particle size with subtle variation float psize = (snoise_1_2(vec2(uTime * 0.3, pindex) * 0.5) * 0.3 + 1.7); psize *= max(grey, 0.2); psize *= uSize; // Position of the vertex within the particle quad vec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0); mvPosition.xyz += position * psize; gl_Position = projectionMatrix * mvPosition; } `; const fragmentShader = ` precision highp float; uniform sampler2D uTexture; uniform float uTime; uniform float uMouseSize; uniform vec2 uMouse; uniform vec2 uTextureSize; uniform float uGlowStrength; uniform float uColorVariation; varying vec2 vPUv; varying vec2 vUv; varying float vGrey; varying float vDistance; void main() { // Sample the pixel color from the original image vec4 colA = texture2D(uTexture, vPUv); // Convert to greyscale using luminosity method float grey = vGrey; // Add subtle color variation based on time and position float r = grey; float g = grey; float b = grey; if (uColorVariation > 0.0) { float colorNoise = sin(vPUv.x * 10.0 + uTime * 0.2) * sin(vPUv.y * 8.0 - uTime * 0.1) * 0.5 + 0.5; float colorShift = colorNoise * uColorVariation; // Subtle color tinting r = grey * (1.0 + colorShift * 0.1); g = grey * (1.0 + colorShift * 0.05); b = grey * (1.0 + colorShift * 0.15); } vec4 colB = vec4(r, g, b, 1.0); // Create circle shape for the particle with soft edge float border = 0.35; float radius = 0.5; float dist = radius - distance(vUv, vec2(0.5)); float t = smoothstep(0.0, border, dist); // Add subtle glow effect near mouse float mouseProximity = 1.0 - min(1.0, vDistance / uMouseSize); float glow = mouseProximity * uGlowStrength; // Final color with glow vec4 color = colB; color.rgb += glow * 0.2; // Subtle brightness increase near mouse color.a = t; gl_FragColor = color; } `; class App { constructor() { this.container = document.getElementById(\"container\"); this.camera = null; this.scene = null; this.renderer = null; this.composer = null; this.width = window.innerWidth; this.height = window.innerHeight; this.mouse = new THREE.Vector2(0.5, 0.5); // Center of screen this.targetMouse = new THREE.Vector2(0.5, 0.5); // For smooth mouse movement this.mouseVelocity = new THREE.Vector2(0, 0); this.lastMouse = new THREE.Vector2(0.5, 0.5); this.mouseSpeed = 0; this.image = document.getElementById(\"source-image\"); this.imageTexture = null; this.imageWidth = 320; this.imageHeight = 180; this.numPoints = this.imageWidth * this.imageHeight; this.numVisiblePoints = 0; this.threshold = 34; this.touchCanvas = null; this.touchContext = null; this.touchTexture = null; this.time = 0; this.isRunning = true; this.isMouseMoving = false; this.mouseMovingTimeout = null; this.stats = new Stats(); this.stats.showPanel(0); this.container.appendChild(this.stats.dom); this.gui = null; this.guiParams = { particleSize: 1.0, randomness: 0.6, // Reduced for more subtle effect depth: 3.0, mouseSize: 80, // Increased for wider influence mouseForce: 0.8, // Reduced for subtlety mouseSmoothing: 0.12, // Smoother movement idleMovement: 0.4, // Subtle movement when idle idleSpeed: 0.5, idleIntensity: 0.8, particleSpring: 0.7, // Spring-like behavior glowStrength: 0.3, // Subtle glow effect colorVariation: 0.15, // Subtle color variation fadeSpeed: 0.08, // Slower fade for smoother trails debug: false }; this.init(); } init() { this.initRenderer(); this.initScene(); this.initCamera(); this.initLights(); this.initPostprocessing(); this.loadTexture(); this.initGUI(); this.initTouchTexture(); this.addListeners(); this.animate(); } initRenderer() { this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); this.renderer.setSize(this.width, this.height); this.renderer.setPixelRatio(window.devicePixelRatio); this.container.appendChild(this.renderer.domElement); } initScene() { this.scene = new THREE.Scene(); } initCamera() { const fov = 45; const aspect = this.width / this.height; const near = 1; const far = 1000; this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far); this.camera.position.set(0, 0, 300); } initLights() { const ambientLight = new THREE.AmbientLight(0xffffff, 1); this.scene.add(ambientLight); } initPostprocessing() { this.composer = new EffectComposer(this.renderer); const renderPass = new RenderPass(this.scene, this.camera); this.composer.addPass(renderPass); const bloomPass = new UnrealBloomPass( new THREE.Vector2(this.width, this.height), 1.2, // strength (reduced for subtlety) 0.5, // radius (increased for smoother bloom) 0.85 // threshold ); this.composer.addPass(bloomPass); } initGUI() { this.gui = new GUI(); this.gui .add(this.guiParams, \"particleSize\", 0.1, 3.0) .name(\"Particle Size\"); this.gui.add(this.guiParams, \"randomness\", 0.0, 5.0).name(\"Randomness\"); this.gui.add(this.guiParams, \"depth\", 1.0, 10.0).name(\"Depth\"); this.gui.add(this.guiParams, \"mouseSize\", 20, 150).name(\"Mouse Radius\"); this.gui.add(this.guiParams, \"mouseForce\", 0.1, 3.0).name(\"Mouse Force\"); this.gui .add(this.guiParams, \"mouseSmoothing\", 0.01, 0.5) .name(\"Mouse Smoothing\"); // New parameters const advancedFolder = this.gui.addFolder(\"Advanced\"); advancedFolder .add(this.guiParams, \"idleMovement\", 0.0, 1.0) .name(\"Idle Movement\"); advancedFolder .add(this.guiParams, \"idleSpeed\", 0.1, 2.0) .name(\"Idle Speed\"); advancedFolder .add(this.guiParams, \"idleIntensity\", 0.1, 2.0) .name(\"Idle Intensity\"); advancedFolder .add(this.guiParams, \"particleSpring\", 0.1, 2.0) .name(\"Spring Effect\"); advancedFolder .add(this.guiParams, \"glowStrength\", 0.0, 1.0) .name(\"Glow Strength\"); advancedFolder .add(this.guiParams, \"colorVariation\", 0.0, 0.5) .name(\"Color Variation\"); advancedFolder .add(this.guiParams, \"fadeSpeed\", 0.01, 0.3) .name(\"Fade Speed\"); this.gui.add(this.guiParams, \"debug\").name(\"Debug Mode\"); } loadTexture() { this.image.onload = () => { this.imageTexture = new THREE.Texture(this.image); this.imageTexture.needsUpdate = true; this.initParticles(); }; // If image is already loaded if (this.image.complete) { this.imageTexture = new THREE.Texture(this.image); this.imageTexture.needsUpdate = true; this.initParticles(); } } initTouchTexture() { this.touchCanvas = document.createElement(\"canvas\"); this.touchCanvas.width = this.imageWidth; this.touchCanvas.height = this.imageHeight; this.touchContext = this.touchCanvas.getContext(\"2d\"); // Create grayscale image this.touchContext.fillStyle = \"black\"; this.touchContext.fillRect(0, 0, this.imageWidth, this.imageHeight); // Create texture this.touchTexture = new THREE.Texture(this.touchCanvas); this.touchTexture.minFilter = THREE.LinearFilter; this.touchTexture.magFilter = THREE.LinearFilter; this.touchTexture.needsUpdate = true; // Debug: Add canvas to body to see what's happening if (this.guiParams.debug) { this.touchCanvas.style.position = \"absolute\"; this.touchCanvas.style.top = \"0\"; this.touchCanvas.style.left = \"0\"; this.touchCanvas.style.zIndex = \"9999\"; this.touchCanvas.style.border = \"1px solid red\"; this.touchCanvas.style.width = \"320px\"; this.touchCanvas.style.height = \"180px\"; document.body.appendChild(this.touchCanvas); } } initParticles() { // Filter image pixels to keep only those above threshold let originalColors; let numVisible = 0; const imgData = this.getImageData(); originalColors = Float32Array.from(imgData.data); for (let i = 0; i < this.numPoints; i++) { if (originalColors[i * 4] > this.threshold) numVisible++; } this.numVisiblePoints = numVisible; // Create geometry const geometry = new THREE.InstancedBufferGeometry(); // Positions (vertices of quad) const positions = new THREE.BufferAttribute(new Float32Array(4 * 3), 3); positions.setXYZ(0, -0.5, 0.5, 0.0); positions.setXYZ(1, 0.5, 0.5, 0.0); positions.setXYZ(2, -0.5, -0.5, 0.0); positions.setXYZ(3, 0.5, -0.5, 0.0); geometry.setAttribute(\"position\", positions); // UVs const uvs = new THREE.BufferAttribute(new Float32Array(4 * 2), 2); uvs.setXY(0, 0.0, 0.0); uvs.setXY(1, 1.0, 0.0); uvs.setXY(2, 0.0, 1.0); uvs.setXY(3, 1.0, 1.0); geometry.setAttribute(\"uv\", uvs); // Index geometry.setIndex( new THREE.BufferAttribute(new Uint16Array([0, 2, 1, 2, 3, 1]), 1) ); // Instanced attributes const indices = new Uint16Array(this.numVisiblePoints); const offsets = new Float32Array(this.numVisiblePoints * 3); const angles = new Float32Array(this.numVisiblePoints); for (let i = 0, j = 0; i < this.numPoints; i++) { if (originalColors[i * 4] <= this.threshold) continue; offsets[j * 3 + 0] = i % this.imageWidth; offsets[j * 3 + 1] = Math.floor(i / this.imageWidth); offsets[j * 3 + 2] = 0; indices[j] = i; angles[j] = Math.random() * Math.PI; j++; } geometry.setAttribute( \"pindex\", new THREE.InstancedBufferAttribute(indices, 1, false) ); geometry.setAttribute( \"offset\", new THREE.InstancedBufferAttribute(offsets, 3, false) ); geometry.setAttribute( \"angle\", new THREE.InstancedBufferAttribute(angles, 1, false) ); // Material const uniforms = { uTime: { value: 0 }, uRandom: { value: this.guiParams.randomness }, uDepth: { value: this.guiParams.depth }, uSize: { value: this.guiParams.particleSize }, uTextureSize: { value: new THREE.Vector2(this.imageWidth, this.imageHeight) }, uTexture: { value: this.imageTexture }, uTouch: { value: this.touchTexture }, uMouse: { value: new THREE.Vector2(0.5, 0.5) }, uMouseSize: { value: this.guiParams.mouseSize }, uMouseForce: { value: this.guiParams.mouseForce }, uEasingFactor: { value: 0.2 }, uIdleMovement: { value: this.guiParams.idleMovement }, uIdleSpeed: { value: this.guiParams.idleSpeed }, uIdleIntensity: { value: this.guiParams.idleIntensity }, uParticleSpring: { value: this.guiParams.particleSpring }, uGlowStrength: { value: this.guiParams.glowStrength }, uColorVariation: { value: this.guiParams.colorVariation } }; const material = new THREE.RawShaderMaterial({ uniforms, vertexShader, fragmentShader, depthTest: false, transparent: true }); // Create mesh this.particles = new THREE.Mesh(geometry, material); this.scene.add(this.particles); // Center the particles this.particles.position.x = -this.imageWidth / 2; this.particles.position.y = -this.imageHeight / 2; } getImageData() { const canvas = document.createElement(\"canvas\"); const ctx = canvas.getContext(\"2d\"); canvas.width = this.imageWidth; canvas.height = this.imageHeight; ctx.scale(1, -1); // Flip y ctx.drawImage(this.image, 0, 0, this.imageWidth, this.imageHeight * -1); return ctx.getImageData(0, 0, canvas.width, canvas.height); } updateTouchTexture() { // Clear canvas with fade effect for smoother trails this.touchContext.fillStyle = `rgba(0, 0, 0, ${this.guiParams.fadeSpeed})`; this.touchContext.fillRect(0, 0, this.imageWidth, this.imageHeight); // Draw mouse position with velocity-based intensity const x = this.mouse.x * this.imageWidth; const y = this.mouse.y * this.imageHeight; const size = this.guiParams.mouseSize; // Calculate intensity based on mouse speed const speedFactor = Math.min(1, this.mouseSpeed * 15); const intensity = this.isMouseMoving ? 0.7 + speedFactor * 0.3 : 0.5; // Create gradient with more natural falloff const gradient = this.touchContext.createRadialGradient( x, y, 0, x, y, size ); gradient.addColorStop(0, `rgba(255, 255, 255, ${intensity})`); gradient.addColorStop(0.3, `rgba(255, 255, 255, ${intensity * 0.6})`); gradient.addColorStop(0.7, `rgba(255, 255, 255, ${intensity * 0.2})`); gradient.addColorStop(1, \"rgba(255, 255, 255, 0.0)\"); this.touchContext.fillStyle = gradient; this.touchContext.beginPath(); this.touchContext.arc(x, y, size, 0, Math.PI * 2); this.touchContext.fill(); // Add a smaller, more intense center for better definition if (this.isMouseMoving) { const centerGradient = this.touchContext.createRadialGradient( x, y, 0, x, y, size * 0.3 ); centerGradient.addColorStop(0, `rgba(255, 255, 255, ${intensity * 1.2})`); centerGradient.addColorStop(1, \"rgba(255, 255, 255, 0.0)\"); this.touchContext.fillStyle = centerGradient; this.touchContext.beginPath(); this.touchContext.arc(x, y, size * 0.3, 0, Math.PI * 2); this.touchContext.fill(); } this.touchTexture.needsUpdate = true; } animate() { if (!this.isRunning) return; this.stats.begin(); this.time += 0.05; // Calculate mouse velocity this.mouseVelocity.x = this.targetMouse.x - this.lastMouse.x; this.mouseVelocity.y = this.targetMouse.y - this.lastMouse.y; this.mouseSpeed = Math.sqrt( this.mouseVelocity.x * this.mouseVelocity.x + this.mouseVelocity.y * this.mouseVelocity.y ); this.lastMouse.copy(this.targetMouse); // Smooth mouse movement with adaptive smoothing // Faster mouse movement = less smoothing for more responsive feel const adaptiveSmoothing = this.guiParams.mouseSmoothing * (1 - Math.min(0.8, this.mouseSpeed * 5)); this.mouse.x += (this.targetMouse.x - this.mouse.x) * adaptiveSmoothing; this.mouse.y += (this.targetMouse.y - this.mouse.y) * adaptiveSmoothing; // Update touch texture for traditional method this.updateTouchTexture(); if (this.particles) { // Update uniforms this.particles.material.uniforms.uTime.value = this.time; this.particles.material.uniforms.uRandom.value = this.guiParams.randomness; this.particles.material.uniforms.uDepth.value = this.guiParams.depth; this.particles.material.uniforms.uSize.value = this.guiParams.particleSize; // Direct mouse uniforms this.particles.material.uniforms.uMouse.value.copy(this.mouse); this.particles.material.uniforms.uMouseSize.value = this.guiParams.mouseSize; this.particles.material.uniforms.uMouseForce.value = this.guiParams.mouseForce; this.particles.material.uniforms.uIdleMovement.value = this.guiParams.idleMovement; this.particles.material.uniforms.uIdleSpeed.value = this.guiParams.idleSpeed; this.particles.material.uniforms.uIdleIntensity.value = this.guiParams.idleIntensity; this.particles.material.uniforms.uParticleSpring.value = this.guiParams.particleSpring; this.particles.material.uniforms.uGlowStrength.value = this.guiParams.glowStrength; this.particles.material.uniforms.uColorVariation.value = this.guiParams.colorVariation; } this.composer.render(); this.stats.end(); requestAnimationFrame(this.animate.bind(this)); } addListeners() { window.addEventListener(\"resize\", this.onResize.bind(this)); window.addEventListener(\"mousemove\", this.onMouseMove.bind(this)); window.addEventListener(\"touchmove\", this.onTouchMove.bind(this), { passive: false }); // Track when mouse is moving vs idle window.addEventListener(\"mousemove\", () => { this.isMouseMoving = true; // Clear any existing timeout if (this.mouseMovingTimeout) { clearTimeout(this.mouseMovingTimeout); } // Set timeout to detect when mouse stops moving this.mouseMovingTimeout = setTimeout(() => { this.isMouseMoving = false; }, 100); }); // Debug: Toggle debug view when GUI changes if (this.gui) { this.gui.__controllers.forEach((controller) => { if (controller.property === \"debug\") { controller.onChange((value) => { if (value && this.touchCanvas) { document.body.appendChild(this.touchCanvas); this.touchCanvas.style.position = \"absolute\"; this.touchCanvas.style.top = \"0\"; this.touchCanvas.style.left = \"0\"; this.touchCanvas.style.zIndex = \"9999\"; this.touchCanvas.style.border = \"1px solid red\"; this.touchCanvas.style.width = \"320px\"; this.touchCanvas.style.height = \"180px\"; } else if (this.touchCanvas && this.touchCanvas.parentNode) { document.body.removeChild(this.touchCanvas); } }); } }); } } onResize() { this.width = window.innerWidth; this.height = window.innerHeight; this.camera.aspect = this.width / this.height; this.camera.updateProjectionMatrix(); this.renderer.setSize(this.width, this.height); this.composer.setSize(this.width, this.height); } onMouseMove(e) { const canvasBounds = this.renderer.domElement.getBoundingClientRect(); // Project onto 3D scene const mouseX = ((e.clientX - canvasBounds.left) / canvasBounds.width) * 2 - 1; const mouseY = -((e.clientY - canvasBounds.top) / canvasBounds.height) * 2 + 1; // Create raycaster and set it from camera const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), this.camera); // Define a plane at z=0 const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Find intersection point const intersection = new THREE.Vector3(); raycaster.ray.intersectPlane(plane, intersection); // Convert to image space (0-1) const imgX = (intersection.x + this.imageWidth / 2) / this.imageWidth; const imgY = (intersection.y + this.imageHeight / 2) / this.imageHeight; // Update target mouse position this.targetMouse.set( Math.max(0, Math.min(1, imgX)), Math.max(0, Math.min(1, imgY)) ); // Debug output if (this.guiParams.debug) { console.log( `Mouse: ${this.targetMouse.x.toFixed(2)}, ${this.targetMouse.y.toFixed( 2 )}` ); } } onTouchMove(e) { e.preventDefault(); const touch = e.touches[0]; this.onMouseMove(touch); } } // Initialize when everything is loaded window.addEventListener(\"load\", () => { new App(); });",
    "id": "threejs--interactive-particles-with-image-mapping"
  },
  {
    "title": "Space Anomaly",
    "description": "",
    "code": "index.html: <canvas id=\"canvas\"></canvas> <textarea id=\"codeEditor\" class=\"editor\" spellcheck=\"false\" autocorrect=\"off\" autocapitalize=\"off\" translate=\"no\" oninput=\"render()\"></textarea> <pre id=\"error\"></pre> <div id=\"indicator\"></div> <div id=\"controls\"> <div class=\"controls\"> <input id=\"btnToggleView\" class=\"icon\" type=\"checkbox\" name=\"toggleView\" onclick=\"toggleView()\"> <input id=\"btnToggleResolution\" class=\"icon\" type=\"checkbox\" name=\"toggleResolution\" onchange=\"toggleResolution()\"> <input id=\"btnReset\" class=\"icon\" type=\"checkbox\" name=\"reset\" onclick=\"reset()\"> </div> </div> <script type=\"x-shader/x-fragment\">#version 300 es /********* * made by Matthias Hurrle (@atzedent) */ precision highp float; out vec4 O; uniform float time; uniform vec2 resolution; uniform vec2 move; #define FC gl_FragCoord.xy #define R resolution #define T time #define N normalize #define S smoothstep #define MN min(R.x,R.y) #define rot(a) mat2(cos((a)-vec4(0,11,33,0))) #define csqr(a) vec2(a.x*a.x-a.y*a.y,2.*a.x*a.y) float rnd(vec3 p) { \tp=fract(p*vec3(12.9898,78.233,156.34)); \tp+=dot(p,p+34.56); \treturn fract(p.x*p.y*p.z); } float swirls(in vec3 p) { \tfloat d=.0; \tvec3 c=p; \tfor(float i=min(.0,time); i<9.; i++) { \t\tp=.7*abs(p)/dot(p,p)-.7; \t\tp.yz=csqr(p.yz); \t\tp=p.zxy; \t\td+=exp(-19.*abs(dot(p,c))); \t} \treturn d; } vec3 march(in vec3 p, vec3 rd) { \tfloat d=.2, t=.0, c=.0, k=mix(.9,1.,rnd(rd)), \tmaxd=length(p)-1.; \tvec3 col=vec3(0); \tfor(float i=min(.0,time); i<120.; i++) { \t\tt+=d*exp(-2.*c)*k; \t\tc=swirls(p+rd*t); \t\tif (t<5e-2 || t>maxd) break; \t\tcol+=vec3(c*c,c/1.05,c)*8e-3; \t} \treturn col; } float rnd(vec2 p) { \tp=fract(p*vec2(12.9898,78.233)); \tp+=dot(p,p+34.56); \treturn fract(p.x*p.y); } vec3 sky(vec2 p, bool anim) { \tp.x-=.17-(anim?2e-4*T:.0); \tp*=500.; \tvec2 id=floor(p), gv=fract(p)-.5; \tfloat n=rnd(id), d=length(gv); \tif (n<.975) return vec3(0); \treturn vec3(S(3e-2*n,1e-3*n,d*d)); } void cam(inout vec3 p) { \tp.yz*=rot(move.y*6.3/MN-T*.05); \tp.xz*=rot(-move.x*6.3/MN+T*.025); } void main() { \tvec2 uv=(FC-.5*R)/MN; \tvec3 col=vec3(0), \tp=vec3(0,0,-16), \trd=N(vec3(uv,1)), rdd=rd; \tcam(p); cam(rd); \tcol=march(p,rd); \tcol=S(-.2,.9,col); \tvec2 sn=.5+vec2(atan(rdd.x,rdd.z),atan(length(rdd.xz),rdd.y))/6.28318; \tcol=max(col,vec3(sky(sn,true)+sky(2.+sn*2.,true))); \tfloat t=min((time-.5)*.3,1.); \tuv=FC/R*2.-1.; \tuv*=.7; \tfloat v=pow(dot(uv,uv),1.8); \tcol=mix(col,vec3(0),v); \tcol=mix(vec3(0),col,t); \tcol=max(col,.08); O=vec4(col,1); }</script>\nstyle.css: ::-webkit-scrollbar { width: 0.625rem; height: 0.625rem; } ::-webkit-scrollbar-thumb { background: #111; border-radius: 0.3125rem; box-shadow: inset 0.125rem 0.125rem 0.125rem rgba(255, 255, 255, 0.25), inset -0.125rem -0.125rem 0.125rem rgba(0, 0, 0, 0.25); cursor: default; } ::-webkit-scrollbar-track { background: #333; } ::selection { background: #fff; color: #333; } html, body { height: 100vh; height: 100dvh; margin: 0; overflow: hidden; } body { display: grid; grid-template-rows: calc(100dvh - 4rem) 4rem; font-family: system-ui, sans-serif; } canvas, .editor, #controls { grid-row: 1; grid-column: 1; } canvas { --canvas-z-index: -1; width: 100%; height: auto; object-fit: contain; background: black; touch-action: none; z-index: var(--canvas-z-index); } .editor, .overlay, #error { font-family: 'Courier New', Courier, monospace; background: repeating-linear-gradient(0deg, #000a, #1119, #000a .25rem); padding: 1em; } .editor { color: #fefefe; tab-size: 2; border: none; resize: none; } .editor:focus { outline: none; } #error { grid-row: 2; grid-column: 1; margin: 0; padding-block: 0; padding-top: .5em; color: firebrick; overflow: auto; text-wrap: pretty; } #indicator { visibility: hidden; position: absolute; top: calc(var(--top, 0px) - var(--scroll-top, 0px)); width: 0; height: 0; border-top: 10px solid transparent; border-bottom: 10px solid transparent; border-left: 10px solid firebrick; transform: translateY(-25%); } .overlay { position: absolute; top: 0; left: 0; right: 0; margin: 0; } .editor, .overlay { font-size: 1rem; line-height: 1.2; white-space: pre; } #controls { position: fixed; top: 1em; right: 2em; } .controls { position: relative; display: flex; gap: 1.5em; padding: .5em 1.25em; background: #1111; border-radius: 4px; } .controls::before, .controls::after { content: ''; position: absolute; z-index: -1; inset: 0; transform: scale(.95); border-radius: inherit; opacity: 0; } .controls::before { background: #aef; animation: pulse 2s infinite; } .controls::after { background: #fefefe66; transition: transform 200ms ease-in-out; } .controls:hover::before, .controls:hover::after { opacity: 1; } .controls:hover::before { transform: scale(.98); filter: blur(2px); } .controls:hover::after { transform: scale(1.025, 1.1); } .controls:hover { background: #111f; } @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.0125); } 100% { transform: scale(1); } } .hidden { display: none !important; } .opaque { opacity: 1 !important; background: #111 !important; } input { all: unset; opacity: .2; filter: saturate(0) invert(1); cursor: pointer; transition: opacity 200ms ease-in-out; padding: .25em .5em; } input:hover { opacity: 1; } .icon { text-align: center; line-height: 1; } #btnToggleView { width: 1.25em; } #btnToggleView::after { content: 'üëÅ'; } #btnToggleView:checked::after { content: '‚úèÔ∏è'; } #btnToggleResolution::after { content: '1Ô∏è‚É£'; } #btnToggleResolution:checked::after { content: '2Ô∏è‚É£'; } #btnReset::after { content: '‚èÆÔ∏è'; }\nscript.js: /********* * made by Matthias Hurrle (@atzedent) */ let editMode = false // set to false to hide the code editor on load let resolution = .5 // set 1 for full resolution or to .5 to start with half resolution on load let renderDelay = 1000 // delay in ms before rendering the shader after a change let dpr = Math.max(1, resolution * window.devicePixelRatio) let frm, source, editor, store, renderer, pointers const shaderId = 'oggKrGW' window.onload = init function resize() { const { innerWidth: width, innerHeight: height } = window canvas.width = width * dpr canvas.height = height * dpr if (renderer) { renderer.updateScale(dpr) } } function toggleView() { editor.hidden = btnToggleView.checked canvas.style.setProperty('--canvas-z-index', btnToggleView.checked ? 0 : -1) } function reset() { let shader = source editor.text = shader ? shader.textContent : renderer.defaultSource store.putShaderSource(shaderId, editor.text) renderThis() } function toggleResolution() { resolution = btnToggleResolution.checked ? .5 : 1 dpr = Math.max(1, resolution * window.devicePixelRatio) pointers.updateScale(dpr) resize() } function loop(now) { renderer.updateMouse(pointers.first) renderer.updatePointerCount(pointers.count) renderer.updatePointerCoords(pointers.coords) renderer.updateMove(pointers.move) renderer.render(now) frm = requestAnimationFrame(loop) } function renderThis() { editor.clearError() store.putShaderSource(shaderId, editor.text) const result = renderer.test(editor.text) if (result) { editor.setError(result) } else { renderer.updateShader(editor.text) } cancelAnimationFrame(frm) // Always cancel the previous frame! loop(0) } const debounce = (fn, delay) => { let timerId return (...args) => { clearTimeout(timerId) timerId = setTimeout(() => fn.apply(this, args), delay) } } const render = debounce(renderThis, renderDelay) function init() { source = document.querySelector(\"script[type='x-shader/x-fragment']\") document.title = \"Sketchy, But Keeps Spinning\" renderer = new Renderer(canvas, dpr) pointers = new PointerHandler(canvas, dpr) store = new Store(window.location) editor = new Editor(codeEditor, error, indicator) editor.text = source.textContent renderer.setup() renderer.init() if (!editMode) { btnToggleView.checked = true toggleView() } if (resolution === .5) { btnToggleResolution.checked = true toggleResolution() } canvas.addEventListener('shader-error', e => editor.setError(e.detail)) resize() if (renderer.test(source.textContent) === null) { renderer.updateShader(source.textContent) } loop(0) window.onresize = resize window.addEventListener(\"keydown\", e => { if (e.key === \"L\" && e.ctrlKey) { e.preventDefault() btnToggleView.checked = !btnToggleView.checked toggleView() } }) } class Renderer { #vertexSrc = \"#version 300 es\\nprecision highp float;\\nin vec4 position;\\nvoid main(){gl_Position=position;}\" #fragmtSrc = \"#version 300 es\\nprecision highp float;\\nout vec4 O;\\nuniform float time;\\nuniform vec2 resolution;\\nvoid main() {\\n\\tvec2 uv=gl_FragCoord.xy/resolution;\\n\\tO=vec4(uv,sin(time)*.5+.5,1);\\n}\" #vertices = [-1, 1, -1, -1, 1, 1, 1, -1] constructor(canvas, scale) { this.canvas = canvas this.scale = scale this.gl = canvas.getContext(\"webgl2\") this.gl.viewport(0, 0, canvas.width * scale, canvas.height * scale) this.shaderSource = this.#fragmtSrc this.mouseMove = [0, 0] this.mouseCoords = [0, 0] this.pointerCoords = [0, 0] this.nbrOfPointers = 0 } get defaultSource() { return this.#fragmtSrc } updateShader(source) { this.reset() this.shaderSource = source this.setup() this.init() } updateMove(deltas) { this.mouseMove = deltas } updateMouse(coords) { this.mouseCoords = coords } updatePointerCoords(coords) { this.pointerCoords = coords } updatePointerCount(nbr) { this.nbrOfPointers = nbr } updateScale(scale) { this.scale = scale this.gl.viewport(0, 0, this.canvas.width * scale, this.canvas.height * scale) } compile(shader, source) { const gl = this.gl gl.shaderSource(shader, source) gl.compileShader(shader) if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(shader)) this.canvas.dispatchEvent(new CustomEvent('shader-error', { detail: gl.getShaderInfoLog(shader) })) } } test(source) { let result = null const gl = this.gl const shader = gl.createShader(gl.FRAGMENT_SHADER) gl.shaderSource(shader, source) gl.compileShader(shader) if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { result = gl.getShaderInfoLog(shader) } if (gl.getShaderParameter(shader, gl.DELETE_STATUS)) { gl.deleteShader(shader) } return result } reset() { const { gl, program, vs, fs } = this if (!program || gl.getProgramParameter(program, gl.DELETE_STATUS)) return if (gl.getShaderParameter(vs, gl.DELETE_STATUS)) { gl.detachShader(program, vs) gl.deleteShader(vs) } if (gl.getShaderParameter(fs, gl.DELETE_STATUS)) { gl.detachShader(program, fs) gl.deleteShader(fs) } gl.deleteProgram(program) } setup() { const gl = this.gl this.vs = gl.createShader(gl.VERTEX_SHADER) this.fs = gl.createShader(gl.FRAGMENT_SHADER) this.compile(this.vs, this.#vertexSrc) this.compile(this.fs, this.shaderSource) this.program = gl.createProgram() gl.attachShader(this.program, this.vs) gl.attachShader(this.program, this.fs) gl.linkProgram(this.program) if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) { console.error(gl.getProgramInfoLog(this.program)) } } init() { const { gl, program } = this this.buffer = gl.createBuffer() gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer) gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.#vertices), gl.STATIC_DRAW) const position = gl.getAttribLocation(program, \"position\") gl.enableVertexAttribArray(position) gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0) program.resolution = gl.getUniformLocation(program, \"resolution\") program.time = gl.getUniformLocation(program, \"time\") program.move = gl.getUniformLocation(program, \"move\") program.touch = gl.getUniformLocation(program, \"touch\") program.pointerCount = gl.getUniformLocation(program, \"pointerCount\") program.pointers = gl.getUniformLocation(program, \"pointers\") } render(now = 0) { const { gl, program, buffer, canvas, mouseMove, mouseCoords, pointerCoords, nbrOfPointers } = this if (!program || gl.getProgramParameter(program, gl.DELETE_STATUS)) return gl.clearColor(0, 0, 0, 1) gl.clear(gl.COLOR_BUFFER_BIT) gl.useProgram(program) gl.bindBuffer(gl.ARRAY_BUFFER, buffer) gl.uniform2f(program.resolution, canvas.width, canvas.height) gl.uniform1f(program.time, now * 1e-3) gl.uniform2f(program.move, ...mouseMove) gl.uniform2f(program.touch, ...mouseCoords) gl.uniform1i(program.pointerCount, nbrOfPointers) gl.uniform2fv(program.pointers, pointerCoords) gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4) } } class Store { constructor(key) { this.key = key this.store = window.localStorage } #ownShadersKey = 'ownShaders' #StorageType = Object.freeze({ shader: 'fragmentSource', config: 'config' }) #getKeyPrefix(type) { return `${type}${btoa(this.key)}` } #getKey(type, name) { return `${this.#getKeyPrefix(type)}${btoa(name)}` } putShaderSource(name, source) { const storageType = this.#StorageType.shader this.store.setItem(this.#getKey(storageType, name), source) } getShaderSource(name) { const storageType = this.#StorageType.shader return this.store.getItem(this.#getKey(storageType, name)) } deleteShaderSource(name) { const storageType = this.#StorageType.shader this.store.removeItem(this.#getKey(storageType, name)) } /** @returns {{title:string, uuid:string}[]} */ getOwnShaders() { const storageType = this.#StorageType.config const result = this.store.getItem(this.#getKey(storageType, this.#ownShadersKey)) return result ? JSON.parse(result) : [] } /** @param {{title:string, uuid:string}[]} shader */ putOwnShader(shader) { const ownShaders = this.getOwnShaders() const storageType = this.#StorageType.config const index = ownShaders.findIndex((s) => s.uuid === shader.uuid) if (index === -1) { ownShaders.push(shader) } else { ownShaders[index] = shader } this.store.setItem(this.#getKey(storageType, this.#ownShadersKey), JSON.stringify(ownShaders)) } deleteOwnShader(uuid) { const ownShaders = this.getOwnShaders() const storageType = this.#StorageType.config this.store.setItem(this.#getKey(storageType, this.#ownShadersKey), JSON.stringify(ownShaders.filter((s) => s.uuid !== uuid) )) this.deleteShaderSource(uuid) } /** @param {string[]} keep The names of the shaders to keep*/ cleanup(keep=[]) { const storageType = this.#StorageType.shader const ownShaders = this.getOwnShaders().map((s) => this.#getKey(storageType, s.uuid)) const premadeShaders = keep.map((name) => this.#getKey(storageType, name)) const keysToKeep = [...ownShaders, ...premadeShaders] const result = [] for (let i = 0; i < this.store.length; i++) { const key = this.store.key(i) if (key.startsWith(this.#getKeyPrefix(this.#StorageType.shader)) && !keysToKeep.includes(key)) { result.push(key) } } result.forEach((key) => this.store.removeItem(key)) } } class PointerHandler { constructor(element, scale) { this.scale = scale this.active = false this.pointers = new Map() this.lastCoords = [0,0] this.moves = [0,0] const map = (element, scale, x, y) => [x * scale, element.height - y * scale] element.addEventListener(\"pointerdown\", (e) => { this.active = true this.pointers.set(e.pointerId, map(element, this.getScale(), e.clientX, e.clientY)) }) element.addEventListener(\"pointerup\", (e) => { if (this.count === 1) { this.lastCoords = this.first } this.pointers.delete(e.pointerId) this.active = this.pointers.size > 0 }) element.addEventListener(\"pointerleave\", (e) => { if (this.count === 1) { this.lastCoords = this.first } this.pointers.delete(e.pointerId) this.active = this.pointers.size > 0 }) element.addEventListener(\"pointermove\", (e) => { if (!this.active) return this.lastCoords = [e.clientX, e.clientY] this.pointers.set(e.pointerId, map(element, this.getScale(), e.clientX, e.clientY)) this.moves = [this.moves[0]+e.movementX, this.moves[1]+e.movementY] }) } getScale() { return this.scale } updateScale(scale) { this.scale = scale } reset() { this.pointers.clear() this.active = false this.moves = [0,0] } get count() { return this.pointers.size } get move() { return this.moves } get coords() { return this.pointers.size > 0 ? Array.from(this.pointers.values()).map((p) => [...p]).flat() : [0, 0] } get first() { return this.pointers.values().next().value || this.lastCoords } } class Editor { constructor(textarea, errorfield, errorindicator) { this.textarea = textarea this.errorfield = errorfield this.errorindicator = errorindicator textarea.addEventListener('keydown', this.handleKeydown.bind(this)) textarea.addEventListener('scroll', this.handleScroll.bind(this)) } get hidden() { return this.textarea.classList.contains('hidden') } set hidden(value) { value ? this.#hide() : this.#show() } get text() { return this.textarea.value } set text(value) { this.textarea.value = value } get scrollTop() { return this.textarea.scrollTop } set scrollTop(value) { this.textarea.scrollTop = value } setError(message) { this.errorfield.innerHTML = message this.errorfield.classList.add('opaque') const match = message.match(/ERROR: \\d+:(\\d+):/) const lineNumber = match ? parseInt(match[1]) : 0 const overlay = document.createElement('pre') overlay.classList.add('overlay') overlay.textContent = '\\n'.repeat(lineNumber) document.body.appendChild(overlay) const offsetTop = parseInt(getComputedStyle(overlay).height) this.errorindicator.style.setProperty('--top', offsetTop + 'px') this.errorindicator.style.visibility = 'visible' document.body.removeChild(overlay) } clearError() { this.errorfield.textContent = '' this.errorfield.classList.remove('opaque') this.errorfield.blur() this.errorindicator.style.visibility = 'hidden' } focus() { this.textarea.focus() } #hide() { for (const el of [this.errorindicator, this.errorfield, this.textarea]) { el.classList.add('hidden') } } #show() { for (const el of [this.errorindicator, this.errorfield, this.textarea]) { el.classList.remove('hidden') } this.focus() } handleScroll() { this.errorindicator.style.setProperty('--scroll-top', `${this.textarea.scrollTop}px`) } handleKeydown(event) { if (event.key === \"Tab\") { event.preventDefault() this.handleTabKey(event.shiftKey) } else if (event.key === \"Enter\") { event.preventDefault() this.handleEnterKey() } } handleTabKey(shiftPressed) { if (this.#getSelectedText() !== \"\") { if (shiftPressed) { this.#unindentSelectedText() return } this.#indentSelectedText() } else { this.#indentAtCursor() } } #getSelectedText() { const editor = this.textarea const start = editor.selectionStart const end = editor.selectionEnd return editor.value.substring(start, end) } #indentAtCursor() { const editor = this.textarea const cursorPos = editor.selectionStart document.execCommand('insertText', false, '\\t') editor.selectionStart = editor.selectionEnd = cursorPos + 1 } #indentSelectedText() { const editor = this.textarea const cursorPos = editor.selectionStart const selectedText = this.#getSelectedText() const lines = selectedText.split('\\n') const indentedText = lines.map(line => '\\t' + line).join('\\n') document.execCommand('insertText', false, indentedText) editor.selectionStart = cursorPos } #unindentSelectedText() { const editor = this.textarea const cursorPos = editor.selectionStart const selectedText = this.#getSelectedText() const lines = selectedText.split('\\n') const indentedText = lines.map(line => line.replace(/^\\t/, '').replace(/^ /, '')).join('\\n') document.execCommand('insertText', false, indentedText) editor.selectionStart = cursorPos } handleEnterKey() { const editor = this.textarea const visibleTop = editor.scrollTop const cursorPosition = editor.selectionStart let start = cursorPosition - 1 while (start >= 0 && editor.value[start] !== '\\n') { start-- } let newLine = '' while (start < cursorPosition - 1 && (editor.value[start + 1] === ' ' || editor.value[start + 1] === '\\t')) { newLine += editor.value[start + 1] start++ } document.execCommand('insertText', false, '\\n' + newLine) editor.selectionStart = editor.selectionEnd = cursorPosition + 1 + newLine.length editor.scrollTop = visibleTop // Prevent the editor from scrolling const lineHeight = editor.scrollHeight / editor.value.split('\\n').length const line = editor.value.substring(0, cursorPosition).split('\\n').length // Do the actual layout calculation in order to get the correct scroll position const visibleBottom = editor.scrollTop + editor.clientHeight const lineTop = lineHeight * (line - 1) const lineBottom = lineHeight * (line + 2) // If the cursor is outside the visible range, scroll the editor if (lineTop < visibleTop) editor.scrollTop = lineTop if (lineBottom > visibleBottom) editor.scrollTop = lineBottom - editor.clientHeight } }",
    "id": "space-anomaly"
  },
  {
    "title": "Three.js Black Hole with Shaders",
    "description": "",
    "code": "index.html: <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Black Hole Visualization</title> <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap\" rel=\"stylesheet\"> <style> body { margin: 0; overflow: hidden; background: radial-gradient(ellipse at center, #0a0a1a 0%, #000002 70%); color: #e0e0ff; font-family: 'Inter', sans-serif; } canvas { display: block; width: 100%; height: 100%; } #info { position: absolute; top: 20px; width: 100%; text-align: center; color: rgba(220, 220, 255, 0.9); font-size: 18px; letter-spacing: 0.5px; pointer-events: none; z-index: 100; text-shadow: 0 1px 5px rgba(0, 0, 0, 0.7); transition: opacity 2s ease-in-out 1s; } .ui-panel { position: absolute; background-image: linear-gradient(145deg, rgba(20, 25, 45, 0.85), rgba(10, 15, 30, 0.9)); backdrop-filter: blur(10px) saturate(160%); -webkit-backdrop-filter: blur(10px) saturate(160%); padding: 15px 20px; border-radius: 10px; border: 1px solid rgba(180, 180, 220, 0.15); color: rgba(225, 225, 255, 0.9); font-size: 14px; user-select: none; z-index: 50; transition: opacity 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease; box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(180,180,220,0.07) inset; box-sizing: border-box; opacity: 0; transform: translateY(15px); animation: panelFadeIn 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.2s forwards; } @keyframes panelFadeIn { to { opacity: 1; transform: translateY(0); } } .ui-panel:hover { box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(180,180,220,0.09) inset; } #controls { bottom: 20px; right: 20px; } #autoRotateToggle { cursor: pointer; padding: 8px 5px; display: flex; align-items: center; gap: 8px; color: inherit; font-size: inherit; transition: color 0.2s ease; } #autoRotateToggle:hover { color: #fff; } #autoRotateToggle span { vertical-align: middle; } .rotate-icon { width: 1.1em; height: 1.1em; stroke: currentColor; stroke-width: 1.8; fill: none; stroke-linecap: round; stroke-linejoin: round; vertical-align: middle; } @media (max-width: 640px) { .ui-panel { padding: 10px 12px; border-radius: 8px; } #controls { max-width: 150px; } #info { font-size: 16px; top: 15px; } #info span { font-size: 12px; } } </style> <script type=\"importmap\"> { \"imports\": { \"three\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js\", \"three/addons/\": \"https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/\" } } </script> <div id=\"info\"> Black Hole<br> <span style=\"font-size: 14px; opacity: 0.8;\">Click and drag to rotate view</span> </div> <div id=\"controls\" class=\"ui-panel\"> <div id=\"autoRotateToggle\" title=\"Toggle automatic rotation\"></div> </div> <script type=\"module\"> import * as THREE from 'three'; import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js'; import { RenderPass } from 'three/addons/postprocessing/RenderPass.js'; import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js'; import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js'; const BLACK_HOLE_RADIUS = 1.3; const DISK_INNER_RADIUS = BLACK_HOLE_RADIUS + 0.2; const DISK_OUTER_RADIUS = 8.0; const DISK_TILT_ANGLE = Math.PI / 3.0; const scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x020104, 0.025); const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000); camera.position.set(-6.5, 5.0, 6.5); const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: \"high-performance\" }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); renderer.outputColorSpace = THREE.SRGBColorSpace; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.2; document.body.appendChild(renderer.domElement); const composer = new EffectComposer(renderer); composer.addPass(new RenderPass(scene, camera)); const bloomPass = new UnrealBloomPass( new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.7, 0.8 ); composer.addPass(bloomPass); const lensingShader = { uniforms: { \"tDiffuse\": { value: null }, \"blackHoleScreenPos\": { value: new THREE.Vector2(0.5, 0.5) }, \"lensingStrength\": { value: 0.12 }, \"lensingRadius\": { value: 0.3 }, \"aspectRatio\": { value: window.innerWidth / window.innerHeight }, \"chromaticAberration\": { value: 0.005 } }, vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`, fragmentShader: ` uniform sampler2D tDiffuse; uniform vec2 blackHoleScreenPos; uniform float lensingStrength; uniform float lensingRadius; uniform float aspectRatio; uniform float chromaticAberration; varying vec2 vUv; void main() { vec2 screenPos = vUv; vec2 toCenter = screenPos - blackHoleScreenPos; toCenter.x *= aspectRatio; float dist = length(toCenter); float distortionAmount = lensingStrength / (dist * dist + 0.003); distortionAmount = clamp(distortionAmount, 0.0, 0.7); float falloff = smoothstep(lensingRadius, lensingRadius * 0.3, dist); distortionAmount *= falloff; vec2 offset = normalize(toCenter) * distortionAmount; offset.x /= aspectRatio; vec2 distortedUvR = screenPos - offset * (1.0 + chromaticAberration); vec2 distortedUvG = screenPos - offset; vec2 distortedUvB = screenPos - offset * (1.0 - chromaticAberration); float r = texture2D(tDiffuse, distortedUvR).r; float g = texture2D(tDiffuse, distortedUvG).g; float b = texture2D(tDiffuse, distortedUvB).b; gl_FragColor = vec4(r, g, b, 1.0); }` }; const lensingPass = new ShaderPass(lensingShader); composer.addPass(lensingPass); const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.035; controls.rotateSpeed = 0.4; controls.autoRotate = false; controls.autoRotateSpeed = 0.1; controls.target.set(0, 0, 0); controls.minDistance = 2.5; controls.maxDistance = 100; controls.enablePan = false; controls.update(); let autoRotateEnabled = false; const autoRotateToggle = document.getElementById('autoRotateToggle'); const rotateIconSVG = `<svg class=\"rotate-icon\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M23 4v6h-6\"></path><path d=\"M1 20v-6h6\"></path><path d=\"M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15\"></path></svg>`; updateAutoRotateText(); autoRotateToggle.addEventListener('click', () => { autoRotateEnabled = !autoRotateEnabled; controls.autoRotate = autoRotateEnabled; updateAutoRotateText(); }); function updateAutoRotateText() { autoRotateToggle.innerHTML = rotateIconSVG + `<span>Auto-Rotate: ${autoRotateEnabled ? \"ON\" : \"OFF\"}</span>`; } const starGeometry = new THREE.BufferGeometry(); const starCount = 150000; const starPositions = new Float32Array(starCount * 3); const starColors = new Float32Array(starCount * 3); const starSizes = new Float32Array(starCount); const starTwinkle = new Float32Array(starCount); const starFieldRadius = 2000; const starPalette = [ new THREE.Color(0x88aaff), new THREE.Color(0xffaaff), new THREE.Color(0xaaffff), new THREE.Color(0xffddaa), new THREE.Color(0xffeecc), new THREE.Color(0xffffff), new THREE.Color(0xff8888), new THREE.Color(0x88ff88), new THREE.Color(0xffff88), new THREE.Color(0x88ffff) ]; for (let i = 0; i < starCount; i++) { const i3 = i * 3; const phi = Math.acos(-1 + (2 * i) / starCount); const theta = Math.sqrt(starCount * Math.PI) * phi; const radius = Math.cbrt(Math.random()) * starFieldRadius + 100; starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta); starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta); starPositions[i3 + 2] = radius * Math.cos(phi); const starColor = starPalette[Math.floor(Math.random() * starPalette.length)].clone(); starColor.multiplyScalar(Math.random() * 0.7 + 0.3); starColors[i3] = starColor.r; starColors[i3 + 1] = starColor.g; starColors[i3 + 2] = starColor.b; starSizes[i] = THREE.MathUtils.randFloat(0.6, 3.0); starTwinkle[i] = Math.random() * Math.PI * 2; } starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3)); starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3)); starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1)); starGeometry.setAttribute('twinkle', new THREE.BufferAttribute(starTwinkle, 1)); const starMaterial = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0 }, uPixelRatio: { value: renderer.getPixelRatio() } }, vertexShader: ` uniform float uTime; uniform float uPixelRatio; attribute float size; attribute float twinkle; varying vec3 vColor; varying float vTwinkle; void main() { vColor = color; vTwinkle = sin(uTime * 2.5 + twinkle) * 0.5 + 0.5; vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); gl_PointSize = size * uPixelRatio * (300.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; } `, fragmentShader: ` varying vec3 vColor; varying float vTwinkle; void main() { float dist = distance(gl_PointCoord, vec2(0.5)); if (dist > 0.5) discard; float alpha = 1.0 - smoothstep(0.0, 0.5, dist); alpha *= (0.2 + vTwinkle * 0.8); gl_FragColor = vec4(vColor, alpha); } `, transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false }); const stars = new THREE.Points(starGeometry, starMaterial); scene.add(stars); const eventHorizonGeom = new THREE.SphereGeometry(BLACK_HOLE_RADIUS * 1.05, 128, 64); const eventHorizonMat = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0 }, uCameraPosition: { value: camera.position } }, vertexShader: ` varying vec3 vNormal; varying vec3 vPosition; void main() { vNormal = normalize(normalMatrix * normal); vPosition = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `, fragmentShader: ` uniform float uTime; uniform vec3 uCameraPosition; varying vec3 vNormal; varying vec3 vPosition; void main() { vec3 viewDirection = normalize(uCameraPosition - vPosition); float fresnel = 1.0 - abs(dot(vNormal, viewDirection)); fresnel = pow(fresnel, 2.5); vec3 glowColor = vec3(1.0, 0.4, 0.1); float pulse = sin(uTime * 2.5) * 0.15 + 0.85; gl_FragColor = vec4(glowColor * fresnel * pulse, fresnel * 0.4); } `, transparent: true, blending: THREE.AdditiveBlending, side: THREE.BackSide }); const eventHorizon = new THREE.Mesh(eventHorizonGeom, eventHorizonMat); scene.add(eventHorizon); const blackHoleGeom = new THREE.SphereGeometry(BLACK_HOLE_RADIUS, 128, 64); const blackHoleMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); const blackHoleMesh = new THREE.Mesh(blackHoleGeom, blackHoleMat); blackHoleMesh.renderOrder = 0; scene.add(blackHoleMesh); const diskGeometry = new THREE.RingGeometry(DISK_INNER_RADIUS, DISK_OUTER_RADIUS, 256, 128); const diskMaterial = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0.0 }, uColorHot: { value: new THREE.Color(0xffffff) }, uColorMid1: { value: new THREE.Color(0xff7733) }, uColorMid2: { value: new THREE.Color(0xff4477) }, uColorMid3: { value: new THREE.Color(0x7744ff) }, uColorOuter: { value: new THREE.Color(0x4477ff) }, uNoiseScale: { value: 2.5 }, uFlowSpeed: { value: 0.22 }, uDensity: { value: 1.3 } }, vertexShader: ` varying vec2 vUv; varying float vRadius; varying float vAngle; void main() { vUv = uv; vRadius = length(position.xy); vAngle = atan(position.y, position.x); gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `, fragmentShader: ` uniform float uTime; uniform vec3 uColorHot; uniform vec3 uColorMid1; uniform vec3 uColorMid2; uniform vec3 uColorMid3; uniform vec3 uColorOuter; uniform float uNoiseScale; uniform float uFlowSpeed; uniform float uDensity; varying vec2 vUv; varying float vRadius; varying float vAngle; vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); } vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; } float snoise(vec3 v) { const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); vec3 i = floor(v + dot(v, C.yyy) ); vec3 x0 = v - i + dot(i, C.xxx) ; vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min( g.xyz, l.zxy ); vec3 i2 = max( g.xyz, l.zxy ); vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy; i = mod289(i); vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 )); float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z); vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_ ); vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4( x.xy, y.xy ); vec4 b1 = vec4( x.zw, y.zw ); vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ; vec3 p0 = vec3(a0.xy,h.x); vec3 p1 = vec3(a0.zw,h.y); vec3 p2 = vec3(a1.xy,h.z); vec3 p3 = vec3(a1.zw,h.w); vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0); m = m * m; return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) ); } void main() { float normalizedRadius = smoothstep(${DISK_INNER_RADIUS.toFixed(2)}, ${DISK_OUTER_RADIUS.toFixed(2)}, vRadius); float spiral = vAngle * 3.0 - (1.0 / (normalizedRadius + 0.1)) * 2.0; vec2 noiseUv = vec2(vUv.x + uTime * uFlowSpeed * (2.0 / (vRadius * 0.3 + 1.0)) + sin(spiral) * 0.1, vUv.y * 0.8 + cos(spiral) * 0.1); float noiseVal1 = snoise(vec3(noiseUv * uNoiseScale, uTime * 0.15)); float noiseVal2 = snoise(vec3(noiseUv * uNoiseScale * 3.0 + 0.8, uTime * 0.22)); float noiseVal3 = snoise(vec3(noiseUv * uNoiseScale * 6.0 + 1.5, uTime * 0.3)); float noiseVal = (noiseVal1 * 0.45 + noiseVal2 * 0.35 + noiseVal3 * 0.2); noiseVal = (noiseVal + 1.0) * 0.5; vec3 color = uColorOuter; color = mix(color, uColorMid3, smoothstep(0.0, 0.25, normalizedRadius)); color = mix(color, uColorMid2, smoothstep(0.2, 0.55, normalizedRadius)); color = mix(color, uColorMid1, smoothstep(0.5, 0.75, normalizedRadius)); color = mix(color, uColorHot, smoothstep(0.7, 0.95, normalizedRadius)); color *= (0.5 + noiseVal * 1.0); float brightness = pow(1.0 - normalizedRadius, 1.0) * 3.5 + 0.5; brightness *= (0.3 + noiseVal * 2.2); float pulse = sin(uTime * 1.8 + normalizedRadius * 12.0 + vAngle * 2.0) * 0.15 + 0.85; brightness *= pulse; float alpha = uDensity * (0.2 + noiseVal * 0.9); alpha *= smoothstep(0.0, 0.15, normalizedRadius); alpha *= (1.0 - smoothstep(0.85, 1.0, normalizedRadius)); alpha = clamp(alpha, 0.0, 1.0); gl_FragColor = vec4(color * brightness, alpha); } `, transparent: true, side: THREE.DoubleSide, depthWrite: false, blending: THREE.AdditiveBlending }); const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial); accretionDisk.rotation.x = DISK_TILT_ANGLE; accretionDisk.renderOrder = 1; scene.add(accretionDisk); setTimeout(() => { const info = document.getElementById('info'); if (info) info.style.opacity = '0'; }, 5000); let resizeTimeout; window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); bloomPass.resolution.set(window.innerWidth, window.innerHeight); lensingPass.uniforms.aspectRatio.value = window.innerWidth / window.innerHeight; renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); }, 150); }); const clock = new THREE.Clock(); const blackHoleScreenPosVec3 = new THREE.Vector3(); function animate() { requestAnimationFrame(animate); const elapsedTime = clock.getElapsedTime(); const deltaTime = clock.getDelta(); diskMaterial.uniforms.uTime.value = elapsedTime; starMaterial.uniforms.uTime.value = elapsedTime; eventHorizonMat.uniforms.uTime.value = elapsedTime; eventHorizonMat.uniforms.uCameraPosition.value.copy(camera.position); blackHoleScreenPosVec3.copy(blackHoleMesh.position).project(camera); lensingPass.uniforms.blackHoleScreenPos.value.set( (blackHoleScreenPosVec3.x + 1) / 2, (blackHoleScreenPosVec3.y + 1) / 2 ); controls.update(); stars.rotation.y += deltaTime * 0.003; stars.rotation.x += deltaTime * 0.001; accretionDisk.rotation.z += deltaTime * 0.005; composer.render(deltaTime); } animate(); </script>\nstyle.css: \nscript.js: ",
    "id": "threejs-black-hole-with-shaders"
  },
  {
    "title": "WebGL Lava Background",
    "description": "A high-performance WebGL shader creating a fluid, organic lava lamp background effect. Features multiple presets (Lava, Plasma, Pulse) via a custom noise implementation and fragment shader.",
    "code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Lava Background</title>\n    <style>\n        :root {\n            --bg: #050505;\n        }\n\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        body {\n            background-color: var(--bg);\n            width: 100vw;\n            height: 100vh;\n            overflow: hidden;\n        }\n\n        #canvas {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            z-index: 0;\n        }\n\n        .noise {\n            position: absolute;\n            inset: 0;\n            background-image: url(\"https://framerusercontent.com/images/g0QcWrxr87K0ufOxIUFBakwYA8.png\");\n            background-size: 200px;\n            background-repeat: repeat;\n            opacity: 0.25;\n            pointer-events: none;\n            z-index: 1;\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"canvas\"></canvas>\n    <div class=\"noise\"></div>\n\n    <script>\n        const vertexShaderSource = `#version 300 es\n        layout(location = 0) in vec4 a_position;\n        void main() {\n            gl_Position = a_position;\n        }\n        `;\n\n        const fragmentShaderSource = `#version 300 es\n        precision highp float;\n\n        uniform float u_time;\n        uniform float u_pixelRatio;\n        uniform vec2 u_resolution;\n\n        uniform float u_scale;\n        uniform float u_rotation;\n        uniform vec4 u_color1;\n        uniform vec4 u_color2;\n        uniform vec4 u_color3;\n        uniform float u_proportion;\n        uniform float u_softness;\n        uniform float u_shape; // 0: Checks, 1: Stripes, 2: Edge\n        uniform float u_shapeScale;\n        uniform float u_distortion;\n        uniform float u_swirl;\n        uniform float u_swirlIterations;\n\n        out vec4 fragColor;\n\n        #define TWO_PI 6.28318530718\n        #define PI 3.14159265358979323846\n\n        vec2 rotate(vec2 uv, float th) {\n            return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n        }\n\n        float random(vec2 st) {\n            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n        }\n\n        float noise(vec2 st) {\n            vec2 i = floor(st);\n            vec2 f = fract(st);\n            float a = random(i);\n            float b = random(i + vec2(1.0, 0.0));\n            float c = random(i + vec2(0.0, 1.0));\n            float d = random(i + vec2(1.0, 1.0));\n            vec2 u = f * f * (3.0 - 2.0 * f);\n            float x1 = mix(a, b, u.x);\n            float x2 = mix(c, d, u.x);\n            return mix(x1, x2, u.y);\n        }\n\n        vec4 blend_colors(vec4 c1, vec4 c2, vec4 c3, float mixer, float edgesWidth, float edge_blur) {\n            vec3 color1 = c1.rgb * c1.a;\n            vec3 color2 = c2.rgb * c2.a;\n            vec3 color3 = c3.rgb * c3.a;\n\n            float r1 = smoothstep(.0 + .35 * edgesWidth, .7 - .35 * edgesWidth + .5 * edge_blur, mixer);\n            float r2 = smoothstep(.3 + .35 * edgesWidth, 1. - .35 * edgesWidth + edge_blur, mixer);\n\n            vec3 blended_color_2 = mix(color1, color2, r1);\n            float blended_opacity_2 = mix(c1.a, c2.a, r1);\n\n            vec3 c = mix(blended_color_2, color3, r2);\n            float o = mix(blended_opacity_2, c3.a, r2);\n            return vec4(c, o);\n        }\n\n        void main() {\n            vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n            \n            float t = .5 * u_time;\n            float noise_scale = .0005 + .006 * u_scale;\n\n            uv -= .5;\n            uv *= (noise_scale * u_resolution);\n            uv = rotate(uv, u_rotation * .5 * PI);\n            uv /= u_pixelRatio;\n            uv += .5;\n\n            float n1 = noise(uv * 1. + t);\n            float n2 = noise(uv * 2. - t);\n            float angle = n1 * TWO_PI;\n            uv.x += 4. * u_distortion * n2 * cos(angle);\n            uv.y += 4. * u_distortion * n2 * sin(angle);\n\n            float iterations_number = ceil(clamp(u_swirlIterations, 1., 30.));\n            for (float i = 1.; i <= iterations_number; i++) {\n                uv.x += clamp(u_swirl, 0., 2.) / i * cos(t + i * 1.5 * uv.y);\n                uv.y += clamp(u_swirl, 0., 2.) / i * cos(t + i * 1. * uv.x);\n            }\n\n            float proportion = clamp(u_proportion, 0., 1.);\n            float shape = 0.;\n            float mixer = 0.;\n\n            if (u_shape < .5) {\n                // Checks\n                vec2 checks_shape_uv = uv * (.5 + 3.5 * u_shapeScale);\n                shape = .5 + .5 * sin(checks_shape_uv.x) * cos(checks_shape_uv.y);\n                mixer = shape + .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);\n            } else if (u_shape < 1.5) {\n                // Stripes\n                vec2 stripes_shape_uv = uv * (.25 + 3. * u_shapeScale);\n                float f = fract(stripes_shape_uv.y);\n                shape = smoothstep(.0, .55, f) * smoothstep(1., .45, f);\n                mixer = shape + .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);\n            } else {\n                // Edge\n                float sh = 1. - uv.y;\n                sh -= .5;\n                sh /= (noise_scale * u_resolution.y);\n                sh += .5;\n                float shape_scaling = .2 * (1. - u_shapeScale);\n                shape = smoothstep(.45 - shape_scaling, .55 + shape_scaling, sh + .3 * (proportion - .5));\n                mixer = shape;\n            }\n\n            vec4 color_mix = blend_colors(u_color1, u_color2, u_color3, mixer, 1. - clamp(u_softness, 0., 1.), .01 + .01 * u_scale);\n            fragColor = vec4(color_mix.rgb, color_mix.a);\n        }\n        `;\n\n        // WebGL Setup\n        const canvas = document.getElementById('canvas');\n        const gl = canvas.getContext('webgl2', { preserveDrawingBuffer: true });\n\n        if (!gl) {\n            console.error('WebGL2 not supported');\n        }\n\n        function createShader(gl, type, source) {\n            const shader = gl.createShader(type);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                console.error('Shader compile error:', gl.getShaderInfoLog(shader));\n                gl.deleteShader(shader);\n                return null;\n            }\n            return shader;\n        }\n\n        function createProgram(gl, vertexShader, fragmentShader) {\n            const program = gl.createProgram();\n            gl.attachShader(program, vertexShader);\n            gl.attachShader(program, fragmentShader);\n            gl.linkProgram(program);\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                console.error('Program link error:', gl.getProgramInfoLog(program));\n                return null;\n            }\n            return program;\n        }\n\n        const program = createProgram(\n            gl,\n            createShader(gl, gl.VERTEX_SHADER, vertexShaderSource),\n            createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource)\n        );\n\n        const positionAttributeLocation = gl.getAttribLocation(program, \"a_position\");\n        const positionBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n            -1, -1,\n            1, -1,\n            -1, 1,\n            -1, 1,\n            1, -1,\n            1, 1,\n        ]), gl.STATIC_DRAW);\n\n        const vao = gl.createVertexArray();\n        gl.bindVertexArray(vao);\n        gl.enableVertexAttribArray(positionAttributeLocation);\n        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n\n        // Helper Functions\n        function hexToRgba(hex) {\n            hex = hex.replace('#', '');\n            if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');\n            const bigint = parseInt(hex, 16);\n            const r = (bigint >> 16) & 255;\n            const g = (bigint >> 8) & 255;\n            const b = bigint & 255;\n            return [r / 255, g / 255, b / 255, 1.0];\n        }\n\n        function lerp(start, end, amt) {\n            return (1 - amt) * start + amt * end;\n        }\n\n        // Presets Data\n        const SHAPES = { Checks: 0, Stripes: 1, Edge: 2 };\n\n        const rawPresets = {\n            Prism: {\n                color1: \"#050505\", color2: \"#66B3FF\", color3: \"#FFFFFF\",\n                rotation: -50, proportion: 1, scale: 0.01, speed: 30,\n                distortion: 0, swirl: 50, swirlIterations: 16, softness: 47,\n                offset: -299, shape: \"Checks\", shapeSize: 45\n            },\n            Lava: {\n                color1: \"#FF9F21\", color2: \"#FF0303\", color3: \"#000000\",\n                rotation: 114, proportion: 100, scale: 0.52, speed: 30,\n                distortion: 7, swirl: 18, swirlIterations: 20, softness: 100,\n                offset: 717, shape: \"Edge\", shapeSize: 12\n            },\n            Plasma: {\n                color1: \"#B566FF\", color2: \"#000000\", color3: \"#000000\",\n                rotation: 0, proportion: 63, scale: 0.75, speed: 30,\n                distortion: 5, swirl: 61, swirlIterations: 5, softness: 100,\n                offset: -168, shape: \"Checks\", shapeSize: 28\n            },\n            Pulse: {\n                color1: \"#66FF85\", color2: \"#000000\", color3: \"#000000\",\n                rotation: -167, proportion: 92, scale: 0, speed: 20,\n                distortion: 54, swirl: 75, swirlIterations: 3, softness: 28,\n                offset: -813, shape: \"Checks\", shapeSize: 79\n            },\n            Vortex: {\n                color1: \"#000000\", color2: \"#FFFFFF\", color3: \"#000000\",\n                rotation: 50, proportion: 41, scale: 0.4, speed: 20,\n                distortion: 0, swirl: 100, swirlIterations: 3, softness: 5,\n                offset: -744, shape: \"Stripes\", shapeSize: 80\n            },\n            Mist: {\n                color1: \"#050505\", color2: \"#FF66B8\", color3: \"#050505\",\n                rotation: 0, proportion: 33, scale: 0.48, speed: 39,\n                distortion: 4, swirl: 65, swirlIterations: 5, softness: 100,\n                offset: -235, shape: \"Edge\", shapeSize: 48\n            }\n        };\n\n        // Process presets to be interpolation-friendly\n        const presets = {};\n        for (const key in rawPresets) {\n            const p = rawPresets[key];\n            presets[key] = {\n                color1: hexToRgba(p.color1),\n                color2: hexToRgba(p.color2),\n                color3: hexToRgba(p.color3),\n                rotation: p.rotation * (Math.PI / 180),\n                proportion: p.proportion / 100,\n                scale: p.scale,\n                speed: p.speed,\n                distortion: p.distortion / 50,\n                swirl: p.swirl / 100,\n                swirlIterations: p.swirlIterations,\n                softness: p.softness / 100,\n                shape: SHAPES[p.shape],\n                shapeScale: p.shapeSize / 100,\n                offset: p.offset // keep this separate for logic\n            };\n        }\n\n        // State - DEFAULT TO LAVA\n        let targetState = { ...presets.Lava };\n        let currentState = { ...presets.Lava };\n        let totalTime = rawPresets.Lava.offset * 10;\n\n        // Uniform Locations\n        const uniforms = {\n            u_time: gl.getUniformLocation(program, \"u_time\"),\n            u_pixelRatio: gl.getUniformLocation(program, \"u_pixelRatio\"),\n            u_resolution: gl.getUniformLocation(program, \"u_resolution\"),\n            u_scale: gl.getUniformLocation(program, \"u_scale\"),\n            u_rotation: gl.getUniformLocation(program, \"u_rotation\"),\n            u_color1: gl.getUniformLocation(program, \"u_color1\"),\n            u_color2: gl.getUniformLocation(program, \"u_color2\"),\n            u_color3: gl.getUniformLocation(program, \"u_color3\"),\n            u_proportion: gl.getUniformLocation(program, \"u_proportion\"),\n            u_softness: gl.getUniformLocation(program, \"u_softness\"),\n            u_shape: gl.getUniformLocation(program, \"u_shape\"),\n            u_shapeScale: gl.getUniformLocation(program, \"u_shapeScale\"),\n            u_distortion: gl.getUniformLocation(program, \"u_distortion\"),\n            u_swirl: gl.getUniformLocation(program, \"u_swirl\"),\n            u_swirlIterations: gl.getUniformLocation(program, \"u_swirlIterations\"),\n        };\n\n        function resize() {\n            const displayWidth = window.innerWidth;\n            const displayHeight = window.innerHeight;\n            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {\n                canvas.width = displayWidth;\n                canvas.height = displayHeight;\n                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n            }\n        }\n\n        function updateState() {\n            const lerpFactor = 0.05;\n            \n            // Interpolate scalar values\n            currentState.rotation = lerp(currentState.rotation, targetState.rotation, lerpFactor);\n            currentState.proportion = lerp(currentState.proportion, targetState.proportion, lerpFactor);\n            currentState.scale = lerp(currentState.scale, targetState.scale, lerpFactor);\n            currentState.speed = lerp(currentState.speed, targetState.speed, lerpFactor);\n            currentState.distortion = lerp(currentState.distortion, targetState.distortion, lerpFactor);\n            currentState.swirl = lerp(currentState.swirl, targetState.swirl, lerpFactor);\n            currentState.softness = lerp(currentState.softness, targetState.softness, lerpFactor);\n            currentState.shapeScale = lerp(currentState.shapeScale, targetState.shapeScale, lerpFactor);\n            \n            currentState.swirlIterations = lerp(currentState.swirlIterations, targetState.swirlIterations, lerpFactor);\n            \n            currentState.shape = lerp(currentState.shape, targetState.shape, lerpFactor);\n\n            // Interpolate colors\n            for (let i = 0; i < 4; i++) {\n                currentState.color1[i] = lerp(currentState.color1[i], targetState.color1[i], lerpFactor);\n                currentState.color2[i] = lerp(currentState.color2[i], targetState.color2[i], lerpFactor);\n                currentState.color3[i] = lerp(currentState.color3[i], targetState.color3[i], lerpFactor);\n            }\n        }\n\n        function render(now) {\n            updateState();\n            \n            // Increment time\n            totalTime += 0.0005 * currentState.speed;\n\n            gl.useProgram(program);\n            gl.bindVertexArray(vao);\n\n            gl.uniform1f(uniforms.u_time, totalTime);\n            gl.uniform1f(uniforms.u_pixelRatio, window.devicePixelRatio);\n            gl.uniform2f(uniforms.u_resolution, canvas.width, canvas.height);\n            \n            gl.uniform1f(uniforms.u_scale, currentState.scale);\n            gl.uniform1f(uniforms.u_rotation, currentState.rotation);\n            gl.uniform4fv(uniforms.u_color1, currentState.color1);\n            gl.uniform4fv(uniforms.u_color2, currentState.color2);\n            gl.uniform4fv(uniforms.u_color3, currentState.color3);\n            gl.uniform1f(uniforms.u_proportion, currentState.proportion);\n            gl.uniform1f(uniforms.u_softness, currentState.softness);\n            gl.uniform1f(uniforms.u_shape, currentState.shape);\n            gl.uniform1f(uniforms.u_shapeScale, currentState.shapeScale);\n            gl.uniform1f(uniforms.u_distortion, currentState.distortion);\n            gl.uniform1f(uniforms.u_swirl, currentState.swirl);\n            gl.uniform1f(uniforms.u_swirlIterations, currentState.swirlIterations);\n\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n            requestAnimationFrame(render);\n        }\n\n        // Init\n        window.addEventListener('resize', resize);\n        resize();\n        requestAnimationFrame(render);\n    </script>\n</body>\n</html>"
  },
  {
    "title": "Genesis Engine - Solaris",
    "description": "",
    "code": "index.html: <meta charset=\"UTF-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/> <title>Genesis Engine - Solaris</title> <style> * { margin:0; padding:0; box-sizing: border-box; } html, body { height:100%; background:#000; overflow:hidden; font-family: 'Inter', sans-serif; } canvas { width:100%; height:100%; display:block; position:fixed; top:0; left:0; } .overlay { position: fixed; top: 1rem; left: 1rem; color: white; text-shadow: 0 0 5px black; pointer-events: none; opacity: 0.7; } .overlay h1 { font-size: 1.5rem; font-weight: 500; } .overlay p { font-size: 0.9rem; font-weight: 300; } </style> <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"> <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin> <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@300;500&display=swap\" rel=\"stylesheet\"> <div class=\"overlay\"> <h1>Solaris</h1> <p>Drag to orbit. Scroll to zoom.</p> </div> <script type=\"importmap\"> { \"imports\": { \"three\": \"https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js\", \"three/addons/\": \"https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/\" } } </script> <script type=\"module\"> import * as THREE from 'three'; import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js'; import { RenderPass } from 'three/addons/postprocessing/RenderPass.js'; import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js'; import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js'; import { FXAAShader } from 'three/addons/shaders/FXAAShader.js'; import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js'; const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' }); const DPR = Math.min(window.devicePixelRatio || 1, 2); renderer.setPixelRatio(DPR); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(0x000000, 1); renderer.outputColorSpace = THREE.SRGBColorSpace; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.08; document.body.appendChild(renderer.domElement); const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 3000); camera.position.set(0, 14, 80); const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.minDistance = 10; controls.maxDistance = 260; const COLORS = { core: new THREE.Color(1.00, 0.90, 0.70), shell: new THREE.Color(1.00, 0.55, 0.10), diskA: new THREE.Color(1.00, 0.65, 0.10), diskB: new THREE.Color(0.98, 0.25, 0.08), ring: new THREE.Color(1.00, 0.50, 0.18), emberA: new THREE.Color(1.00, 0.95, 0.80), emberB: new THREE.Color(1.00, 0.55, 0.05), prominence: new THREE.Color(1.00, 0.65, 0.10) }; const noiseFunctions = /* glsl */` vec3 mod289(vec3 x){return x - floor(x*(1.0/289.0))*289.0;} vec4 mod289(vec4 x){return x - floor(x*(1.0/289.0))*289.0;} vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);} vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;} float snoise(vec3 v){ const vec2 C=vec2(1.0/6.0,1.0/3.0); const vec4 D=vec4(0.0,0.5,1.0,2.0); vec3 i=floor(v+dot(v,C.yyy)); vec3 x0=v-i+dot(i,C.xxx); vec3 g=step(x0.yzx,x0.xyz); vec3 l=1.0-g; vec3 i1=min(g.xyz,l.zxy); vec3 i2=max(g.xyz,l.zxy); vec3 x1=x0-i1+C.xxx; vec3 x2=x0-i2+C.yyy; vec3 x3=x0-D.yyy; i=mod289(i); vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0)); float n_=0.142857142857; vec3 ns=n_*D.wyz-D.xzx; vec4 j=p-49.0*floor(p*ns.z*ns.z); vec4 x_=floor(j*ns.z); vec4 y_=floor(j-7.0*x_); vec4 x=x_*ns.x+ns.yyyy; vec4 y=y_*ns.x+ns.yyyy; vec4 h=1.0-abs(x)-abs(y); vec4 b0=vec4(x.xy,y.xy); vec4 b1=vec4(x.zw,y.zw); vec4 s0=floor(b0)*2.0+1.0; vec4 s1=floor(b1)*2.0+1.0; vec4 sh=-step(h,vec4(0.0)); vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy; vec4 a1=b1.xzyw+s1.xzyw*sh.zzww; vec3 p0=vec3(a0.xy,h.x); vec3 p1=vec3(a0.zw,h.y); vec3 p2=vec3(a1.xy,h.z); vec3 p3=vec3(a1.zw,h.w); vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3))); p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w; vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0); m=m*m; return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3))); } `; const coreGroup = new THREE.Group(); scene.add(coreGroup); const starGeometry = new THREE.IcosahedronGeometry(4, 5); const starMaterial = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 }, uCore: { value: COLORS.core } }, vertexShader: ` uniform float time; varying vec3 vN; ${noiseFunctions} void main(){ vN = normalize(normal); float displacement = snoise(normal * 3.0 + time * 0.7) * 0.2; vec3 newPosition = position + normal * displacement; gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); } `, fragmentShader: ` uniform float time; uniform vec3 uCore; varying vec3 vN; ${noiseFunctions} void main(){ float pulse = pow(0.5 + 0.5*sin(time*2.15), 1.7); float fres = pow(1.0 - abs(dot(vN, vec3(0,0,1))), 3.0); float surfaceNoise = snoise(vN * 8.0 + time * 1.2); vec3 col = uCore * (0.55 + 2.3*fres) * (0.5 + 1.2*pulse) * (1.0 + 0.3 * surfaceNoise); gl_FragColor = vec4(col, 1.0); } `, blending: THREE.AdditiveBlending, depthWrite: false }); coreGroup.add(new THREE.Mesh(starGeometry, starMaterial)); const shellGeometry = new THREE.IcosahedronGeometry(8, 5); const shellMaterial = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 }, uShell: { value: COLORS.shell } }, vertexShader: ` uniform float time; varying vec3 vN; varying vec2 vUv; ${noiseFunctions} void main(){ vN = normalize(normal); vUv = uv; float displacement = snoise(position * 1.5 + time * 0.4) * 0.8; vec3 newPosition = position + normal * displacement; gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition,1.0); } `, fragmentShader: ` uniform float time; uniform vec3 uShell; varying vec3 vN; varying vec2 vUv; ${noiseFunctions} void main(){ float fres = pow(1.0 - abs(dot(vN, vec3(0,0,1))), 0.6); float n = snoise(vec3(vUv*7.0 + vec2(time*0.22, 0.0), time*0.25)); float fil = smoothstep(0.55, 0.82, n) * pow(abs(vUv.y*2.0 - 1.0), 14.0); vec3 color = uShell * (0.08 + 1.7*fil + 0.6*fres); float alpha = clamp(0.06 + 0.5*fres + 0.55*fil, 0.0, 0.9); gl_FragColor = vec4(color, alpha); } `, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }); coreGroup.add(new THREE.Mesh(shellGeometry, shellMaterial)); const ringGeom = new THREE.TorusGeometry(60, 2, 4, 128); const ringMat = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 }, uRing: { value: COLORS.ring } }, vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`, fragmentShader: ` uniform float time; uniform vec3 uRing; varying vec2 vUv; ${noiseFunctions} void main() { float n1 = snoise(vec3(vUv.x * 8.0 - time * 0.1, vUv.y * 2.0, time * 0.15)); float n2 = snoise(vec3(vUv.x * 6.0 + time * 0.05, vUv.y * 3.0, time * 0.1)); float combinedNoise = smoothstep(0.3, 0.7, n1) * 0.6 + smoothstep(0.4, 0.6, n2) * 0.4; float opacity = pow(combinedNoise, 2.0) * 0.8; gl_FragColor = vec4(uRing * (0.5 + combinedNoise * 1.5), opacity); } `, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide }); const ring1 = new THREE.Mesh(ringGeom, ringMat); ring1.rotation.x = Math.PI * 0.51; scene.add(ring1); const ring2 = ring1.clone(); ring2.scale.set(0.8, 0.8, 0.8); ring2.rotation.y = Math.PI * 0.1; scene.add(ring2); const particleCount = 30000; const diskPositions = new Float32Array(particleCount * 3); const diskSeeds = new Float32Array(particleCount); const diskBands = new Float32Array(particleCount); for (let i = 0; i < particleCount; i++) { const r = 10 + Math.random()*35; const theta = Math.random()*Math.PI*2; diskPositions[i*3] = Math.cos(theta)*r; diskPositions[i*3 + 1] = (Math.random() - 0.5) * 4.0; diskPositions[i*3 + 2] = Math.sin(theta)*r; diskSeeds[i] = Math.random()*1000.0; diskBands[i] = (r - 10.0) / 35.0; } const diskGeom = new THREE.BufferGeometry(); diskGeom.setAttribute('position', new THREE.BufferAttribute(diskPositions, 3)); diskGeom.setAttribute('aSeed', new THREE.BufferAttribute(diskSeeds, 1)); diskGeom.setAttribute('aBand', new THREE.BufferAttribute(diskBands, 1)); const diskMat = new THREE.ShaderMaterial({ uniforms: { uColorA: { value: COLORS.diskA }, uColorB: { value: COLORS.diskB }, time: { value: 0 } }, vertexShader: ` uniform float time; attribute float aSeed; attribute float aBand; varying float vMix; varying float vAlpha; vec2 rot(vec2 p, float a){ float c=cos(a), s=sin(a); return vec2(c*p.x - s*p.y, s*p.x + c*p.y); } void main(){ vec3 p = position; float r = length(p.xz); float speed = (14.5 / max(16.0, r*r)); float angle = -time * speed; vec2 xz = rot(p.xz, angle); float breathe = 1.0 + 0.011*sin(time*0.8 + aSeed); p.xz = xz * breathe; p.y *= (1.0 + 0.2*sin(time*1.4 + aSeed*2.0 + r*0.2)); vec4 mvp = modelViewMatrix * vec4(p, 1.0); gl_Position = projectionMatrix * mvp; gl_PointSize = (45.0 / -mvp.z) * (1.0 - aBand); vMix = aBand; vAlpha = 0.4 + 0.4 * sin(time*3.0 + aSeed); } `, fragmentShader: ` uniform vec3 uColorA; uniform vec3 uColorB; varying float vMix; varying float vAlpha; void main(){ if (length(gl_PointCoord - vec2(0.5)) > 0.5) discard; vec3 col = mix(uColorA, uColorB, vMix); gl_FragColor = vec4(col, vAlpha); } `, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }); scene.add(new THREE.Points(diskGeom, diskMat)); const emberCount = 5000; const emberPos = new Float32Array(emberCount * 3); const emberSeeds = new Float32Array(emberCount * 4); for (let i = 0; i < emberCount; i++) { emberPos.set([0,0,0], i*3); emberSeeds.set([Math.random(), 0.1 + Math.random()*0.9, Math.random()*10, 0.5 + Math.random()], i*4); } const emberGeom = new THREE.BufferGeometry(); emberGeom.setAttribute('position', new THREE.BufferAttribute(emberPos, 3)); emberGeom.setAttribute('aSeed', new THREE.BufferAttribute(emberSeeds, 4)); const emberMat = new THREE.ShaderMaterial({ uniforms: { uEmberA: { value: COLORS.emberA }, uEmberB: { value: COLORS.emberB }, time: { value: 0 }}, vertexShader: ` uniform float time; attribute vec4 aSeed; varying float vLife; void main() { float life = mod(time * aSeed.y * 0.3 + aSeed.x, 1.0); vec3 p = normalize(vec3( sin(aSeed.z * 1.2), cos(aSeed.z * 1.7), sin(aSeed.z * 1.1) )) * (8.0 + life * 40.0); vec4 mvPosition = modelViewMatrix * vec4(p, 1.0); gl_PointSize = (100.0 / -mvPosition.z) * (1.0 - life) * aSeed.w; gl_Position = projectionMatrix * mvPosition; vLife = life; } `, fragmentShader: ` uniform vec3 uEmberA; uniform vec3 uEmberB; varying float vLife; void main() { if (length(gl_PointCoord - vec2(0.5)) > 0.5) discard; float opacity = pow(1.0 - vLife, 2.0); vec3 col = mix(uEmberA, uEmberB, vLife); gl_FragColor = vec4(col, opacity); } `, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }); scene.add(new THREE.Points(emberGeom, emberMat)); const prominenceCount = 1000; const prominencePos = new Float32Array(prominenceCount * 3); const prominenceSeeds = new Float32Array(prominenceCount * 4); const q = new THREE.Quaternion(); const v = new THREE.Vector3(); for (let i = 0; i < prominenceCount; i++) { prominencePos.set([0, 0, 0], i * 3); prominenceSeeds.set([ Math.random(), 0.1 + Math.random() * 0.4, 5.0 + Math.random() * 15.0, 0.5 + Math.random() * 1.5 ], i * 4); } const prominenceGeom = new THREE.BufferGeometry(); prominenceGeom.setAttribute('position', new THREE.BufferAttribute(prominencePos, 3)); prominenceGeom.setAttribute('aSeed', new THREE.BufferAttribute(prominenceSeeds, 4)); const prominenceMat = new THREE.ShaderMaterial({ uniforms: { uColor: { value: COLORS.prominence }, time: { value: 0 } }, vertexShader: ` uniform float time; attribute vec4 aSeed; varying float vLife; vec4 quat_from_axis_angle(vec3 axis, float angle) { vec4 qr; float half_angle = (angle * 0.5); qr.x = axis.x * sin(half_angle); qr.y = axis.y * sin(half_angle); qr.z = axis.z * sin(half_angle); qr.w = cos(half_angle); return qr; } vec3 rotate_vertex_position(vec3 position, vec4 q) { return position + 2.0 * cross(q.xyz, cross(q.xyz, position) + q.w * position); } void main() { float life = mod(time * aSeed.y + aSeed.x, 1.0); vLife = life; float arc = sin(life * 3.14159); vec3 p = vec3(0.0, 0.0, 0.0); p.y = arc * aSeed.z; p.x = (life - 0.5) * 16.0; vec3 axis = normalize(vec3(aSeed.x - 0.5, aSeed.y - 0.5, aSeed.z - 0.5)); float angle = aSeed.x * 6.28318; vec4 q = quat_from_axis_angle(axis, angle); p = rotate_vertex_position(p, q); p += normalize(p) * 8.0; vec4 mvPosition = modelViewMatrix * vec4(p, 1.0); gl_PointSize = (150.0 / -mvPosition.z) * arc * (1.0 - life) * aSeed.w; gl_Position = projectionMatrix * mvPosition; } `, fragmentShader: ` uniform vec3 uColor; varying float vLife; void main() { if (length(gl_PointCoord - vec2(0.5)) > 0.5) discard; float opacity = pow(sin(vLife * 3.14159), 1.5) * 0.8; gl_FragColor = vec4(uColor, opacity); } `, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }); coreGroup.add(new THREE.Points(prominenceGeom, prominenceMat)); { const count = 2400; const pos = new Float32Array(count * 3); for (let i=0;i<count;i++){ const r = THREE.MathUtils.randFloat(250, 1000); const th = Math.random()*Math.PI*2; const ph = Math.acos(THREE.MathUtils.randFloatSpread(2)); pos[i*3] = r * Math.sin(ph) * Math.cos(th); pos[i*3+1] = r * Math.cos(ph); pos[i*3+2] = r * Math.sin(ph) * Math.sin(th); } const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(pos,3)); const m = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, sizeAttenuation: true, transparent:true, opacity:0.5, depthWrite:false }); scene.add(new THREE.Points(g,m)); } const composer = new EffectComposer(renderer); composer.addPass(new RenderPass(scene, camera)); composer.addPass(new AfterimagePass(0.92)); const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.8, 0.05); composer.addPass(bloomPass); const fxaaPass = new ShaderPass(FXAAShader); fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * DPR); fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * DPR); composer.addPass(fxaaPass); window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * renderer.getPixelRatio()); fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * renderer.getPixelRatio()); }); const clock = new THREE.Clock(); function animate() { requestAnimationFrame(animate); const delta = clock.getDelta(); const time = clock.getElapsedTime(); starMaterial.uniforms.time.value = time; shellMaterial.uniforms.time.value = time; diskMat.uniforms.time.value = time; emberMat.uniforms.time.value = time; ringMat.uniforms.time.value = time; prominenceMat.uniforms.time.value = time; const pulse = 0.5 + 0.5 * Math.sin(time * 2.15); bloomPass.strength = 0.8 + 0.4 * pulse; coreGroup.rotation.y += delta * 0.05; controls.update(); composer.render(); } animate(); </script>\nstyle.css: \nscript.js: ",
    "id": "genesis-engine---solaris"
  },
  {
    "title": "Three.js & GLSL Particle Metamorphosis",
    "description": "",
    "code": "index.html: <meta charset=\"UTF-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> <title>Morphing Shapes</title> <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"> <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin> <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap\" rel=\"stylesheet\"> <style> *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: \"Inter\", sans-serif; overflow: hidden; background: #040307; background-image: radial-gradient(circle at 50% 35%, #1d1431 0%, transparent 65%), linear-gradient(180deg, #000000 0%, #070012 100%); color: #eee; } #container { position: fixed; inset: 0; } .vignette { position: fixed; inset: 0; pointer-events: none; z-index: 9; background: radial-gradient(circle at center, rgba(0,0,0,0) 65%, rgba(0,0,0,.5) 100%); } canvas { display: block; width: 100%; height: 100%; } .instructions { position: fixed; left: 24px; bottom: 24px; transform: none; padding: 10px 20px; font-size: 12px; text-align: left; pointer-events: none; color: #d0b0ff; background: rgba(18, 15, 40, 0.25); border: 1px solid rgba(122, 70, 255, 0.28); border-radius: 12px; backdrop-filter: blur(12px); z-index: 10; box-shadow: 0 4px 20px rgba(0,0,0,.45); } #morphButton { position: fixed; left: 50%; bottom: 24px; transform: translateX(-50%); padding: 12px 30px; font-size: 14px; font-weight: 500; color: rgba(230, 220, 255, 0.9); background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 50px; backdrop-filter: blur(10px) saturate(180%); -webkit-backdrop-filter: blur(10px) saturate(180%); box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37); cursor: pointer; z-index: 10; transition: all 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275); text-shadow: 0 1px 2px rgba(0,0,0,0.2); } #morphButton:hover { background: rgba(255, 255, 255, 0.15); transform: translateX(-50%) scale(1.05); box-shadow: 0 12px 40px 0 rgba(0, 0, 0, 0.45); color: white; } #morphButton:active { transform: translateX(-50%) scale(0.98); } </style> <script type=\"importmap\"> { \"imports\": { \"three\": \"https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js\", \"three/addons/\": \"https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/\" } } </script> <div id=\"container\"></div> <div class=\"vignette\"></div> <div class=\"instructions\">Drag to explore</div> <button id=\"morphButton\">Morph Shape</button> <script type=\"module\"> import * as THREE from \"three\"; import { OrbitControls } from \"three/addons/controls/OrbitControls.js\"; import { EffectComposer } from \"three/addons/postprocessing/EffectComposer.js\"; import { RenderPass } from \"three/addons/postprocessing/RenderPass.js\"; import { UnrealBloomPass } from \"three/addons/postprocessing/UnrealBloomPass.js\"; import { AfterimagePass } from \"three/addons/postprocessing/AfterimagePass.js\"; import { OutputPass } from \"three/addons/postprocessing/OutputPass.js\"; const PARTICLE_COUNT = 15000; const SPARK_COUNT = 2000; const STAR_COUNT = 7000; let scene, camera, renderer, composer, controls; let particles, sparkles, stars; let clock = new THREE.Clock(); let currentPattern = 0, isTrans = false, prog = 0; const morphSpeed = .03; function normalise(points, size) { if (points.length === 0) return []; const box = new THREE.Box3().setFromPoints(points); const maxDim = Math.max(...box.getSize(new THREE.Vector3()).toArray()) || 1; const centre = box.getCenter(new THREE.Vector3()); return points.map(p => p.clone().sub(centre).multiplyScalar(size / maxDim)); } function torusKnot(n) { const geometry = new THREE.TorusKnotGeometry(10, 3, 200, 16, 2, 3); const points = []; const positionAttribute = geometry.attributes.position; for (let i = 0; i < positionAttribute.count; i++) { points.push(new THREE.Vector3().fromBufferAttribute(positionAttribute, i)); } const result = []; for (let i = 0; i < n; i++) { result.push(points[i % points.length].clone()); } return normalise(result, 50); } function halvorsen(n) { const pts = []; let x = 0.1, y = 0, z = 0; const a = 1.89; const dt = 0.005; for (let i = 0; i < n * 25; i++) { const dx = -a * x - 4 * y - 4 * z - y * y; const dy = -a * y - 4 * z - 4 * x - z * z; const dz = -a * z - 4 * x - 4 * y - x * x; x += dx * dt; y += dy * dt; z += dz * dt; if (i > 200 && i % 25 === 0) { pts.push(new THREE.Vector3(x, y, z)); } if (pts.length >= n) break; } while(pts.length < n) pts.push(pts[Math.floor(Math.random()*pts.length)].clone()); return normalise(pts, 60); } function dualHelix(n) { const pts = []; const turns = 5; const radius = 15; const height = 40; for (let i = 0; i < n; i++) { const isSecondHelix = i % 2 === 0; const angle = (i / n) * Math.PI * 2 * turns; const y = (i / n) * height - height / 2; const r = radius + (isSecondHelix ? 5 : -5); const x = Math.cos(angle) * r; const z = Math.sin(angle) * r; pts.push(new THREE.Vector3(x, y, z)); } return normalise(pts, 60); } function deJong(n) { const pts = []; let x = 0.1, y = 0.1; const a = 1.4, b = -2.3, c = 2.4, d = -2.1; for (let i = 0; i < n; i++) { const xn = Math.sin(a * y) - Math.cos(b * x); const yn = Math.sin(c * x) - Math.cos(d * y); x = xn; y = yn; const z = Math.sin(x * y * 0.5); pts.push(new THREE.Vector3(x, y, z)); } return normalise(pts, 55); } const PATTERNS = [torusKnot, halvorsen, dualHelix, deJong]; function createStars(){const geo=new THREE.BufferGeometry();const pos=new Float32Array(STAR_COUNT*3);const col=new Float32Array(STAR_COUNT*3);const size=new Float32Array(STAR_COUNT);const rnd=new Float32Array(STAR_COUNT);const R=900;for(let i=0;i<STAR_COUNT;i++){const i3=i*3,Œ∏=Math.random()*2*Math.PI,œÜ=Math.acos(2*Math.random()-1),r=R*Math.cbrt(Math.random());pos[i3]=r*Math.sin(œÜ)*Math.cos(Œ∏);pos[i3+1]=r*Math.sin(œÜ)*Math.sin(Œ∏);pos[i3+2]=r*Math.cos(œÜ);const c=new THREE.Color().setHSL(Math.random()*.6,.3+.3*Math.random(),.55+.35*Math.random());col[i3]=c.r;col[i3+1]=c.g;col[i3+2]=c.b;size[i]=.25+Math.pow(Math.random(),4)*2.1;rnd[i]=Math.random()*Math.PI*2}geo.setAttribute(\"position\",new THREE.BufferAttribute(pos,3));geo.setAttribute(\"color\",new THREE.BufferAttribute(col,3));geo.setAttribute(\"size\",new THREE.BufferAttribute(size,1));geo.setAttribute(\"random\",new THREE.BufferAttribute(rnd,1));const mat=new THREE.ShaderMaterial({uniforms:{time:{value:0}},vertexShader:`attribute float size;attribute float random; varying vec3 vColor;varying float vRnd; void main(){vColor=color;vRnd=random;vec4 mv=modelViewMatrix*vec4(position,1.);gl_PointSize=size*(250./-mv.z);gl_Position=projectionMatrix*mv;}`,fragmentShader:`uniform float time;varying vec3 vColor;varying float vRnd; void main(){vec2 uv=gl_PointCoord-.5;float d=length(uv);float a=1.-smoothstep(.4,.5,d);a*=.7+.3*sin(time*(.6+vRnd*.3)+vRnd*5.);if(a<.02)discard;gl_FragColor=vec4(vColor,a);}`,transparent:true,depthWrite:false,vertexColors:true,blending:THREE.AdditiveBlending});return new THREE.Points(geo,mat)} function makeParticles(count,palette){ const geo=new THREE.BufferGeometry(); const pos=new Float32Array(count*3); const col=new Float32Array(count*3); const size=new Float32Array(count); const rnd=new Float32Array(count*3); for(let i=0;i<count;i++){ const i3=i*3,base=palette[Math.random()*palette.length|0],hsl={h:0,s:0,l:0}; base.getHSL(hsl); hsl.h+=(Math.random()-.5)*.05; hsl.s=Math.min(1,Math.max(.7,hsl.s+(Math.random()-.5)*.3)); hsl.l=Math.min(.9,Math.max(.5,hsl.l+(Math.random()-.5)*.4)); const c=new THREE.Color().setHSL(hsl.h,hsl.s,hsl.l); col[i3]=c.r;col[i3+1]=c.g;col[i3+2]=c.b; size[i]=.7+Math.random()*1.1; rnd[i3]=Math.random()*10; rnd[i3+1]=Math.random()*Math.PI*2; rnd[i3+2]=.5+.5*Math.random(); } geo.setAttribute(\"position\",new THREE.BufferAttribute(pos,3)); geo.setAttribute(\"color\",new THREE.BufferAttribute(col,3)); geo.setAttribute(\"size\",new THREE.BufferAttribute(size,1)); geo.setAttribute(\"random\",new THREE.BufferAttribute(rnd,3)); const mat=new THREE.ShaderMaterial({ uniforms:{time:{value:0},hueSpeed:{value:0.12}}, vertexShader:`uniform float time;attribute float size;attribute vec3 random; varying vec3 vCol;varying float vR; void main(){ vCol=color;vR=random.z; vec3 p=position; float t=time*.25*random.z; float ax=t+random.y, ay=t*.75+random.x; float amp=(.6+sin(random.x+t*.6)*.3)*random.z; p.x+=sin(ax+p.y*.06+random.x*.1)*amp; p.y+=cos(ay+p.z*.06+random.y*.1)*amp; p.z+=sin(ax*.85+p.x*.06+random.z*.1)*amp; vec4 mv=modelViewMatrix*vec4(p,1.); float pulse=.9+.1*sin(time*1.15+random.y); gl_PointSize=size*pulse*(350./-mv.z); gl_Position=projectionMatrix*mv; }`, fragmentShader:` uniform float time; uniform float hueSpeed; varying vec3 vCol; varying float vR; vec3 hueShift(vec3 c, float h) { const vec3 k = vec3(0.57735); float cosA = cos(h); float sinA = sin(h); return c * cosA + cross(k, c) * sinA + k * dot(k, c) * (1.0 - cosA); } void main() { vec2 uv = gl_PointCoord - 0.5; float d = length(uv); float core = smoothstep(0.05, 0.0, d); float angle = atan(uv.y, uv.x); float flare = pow(max(0.0, sin(angle * 6.0 + time * 2.0 * vR)), 4.0); flare *= smoothstep(0.5, 0.0, d); float glow = smoothstep(0.4, 0.1, d); float alpha = core * 1.0 + flare * 0.5 + glow * 0.2; vec3 color = hueShift(vCol, time * hueSpeed); vec3 finalColor = mix(color, vec3(1.0, 0.95, 0.9), core); finalColor = mix(finalColor, color, flare * 0.5 + glow * 0.5); if (alpha < 0.01) discard; gl_FragColor = vec4(finalColor, alpha); }`, transparent:true,depthWrite:false,vertexColors:true,blending:THREE.AdditiveBlending }); return new THREE.Points(geo,mat); } function createSparkles(count) { const geo = new THREE.BufferGeometry(); const pos = new Float32Array(count * 3); const size = new Float32Array(count); const rnd = new Float32Array(count * 3); for (let i = 0; i < count; i++) { size[i] = 0.5 + Math.random() * 0.8; rnd[i*3] = Math.random() * 10; rnd[i*3+1] = Math.random() * Math.PI * 2; rnd[i*3+2] = 0.5 + 0.5 * Math.random(); } geo.setAttribute('position', new THREE.BufferAttribute(pos, 3)); geo.setAttribute('size', new THREE.BufferAttribute(size, 1)); geo.setAttribute('random', new THREE.BufferAttribute(rnd, 3)); const mat = new THREE.ShaderMaterial({ uniforms: { time: { value: 0 } }, vertexShader: ` uniform float time; attribute float size; attribute vec3 random; void main() { vec3 p = position; float t = time * 0.25 * random.z; float ax = t + random.y, ay = t * 0.75 + random.x; float amp = (0.6 + sin(random.x + t * 0.6) * 0.3) * random.z; p.x += sin(ax + p.y * 0.06 + random.x * 0.1) * amp; p.y += cos(ay + p.z * 0.06 + random.y * 0.1) * amp; p.z += sin(ax * 0.85 + p.x * 0.06 + random.z * 0.1) * amp; vec4 mvPosition = modelViewMatrix * vec4(p, 1.0); gl_PointSize = size * (300.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; }`, fragmentShader: ` uniform float time; void main() { float d = length(gl_PointCoord - vec2(0.5)); float alpha = 1.0 - smoothstep(0.4, 0.5, d); if (alpha < 0.01) discard; gl_FragColor = vec4(1.0, 1.0, 1.0, alpha); }`, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }); return new THREE.Points(geo, mat); } function init() { scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x050203, .012); camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, .1, 2500); camera.position.set(0, 0, 80); renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setPixelRatio(devicePixelRatio); renderer.setSize(innerWidth, innerHeight); document.getElementById(\"container\").appendChild(renderer.domElement); controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = false; controls.minDistance = 20; controls.maxDistance = 200; controls.target.set(0, 0, 0); controls.autoRotate = true; controls.autoRotateSpeed = 0.5; stars = createStars(); scene.add(stars); const palette = [0xff3c78, 0xff8c00, 0xfff200, 0x00cfff, 0xb400ff, 0xffffff, 0xff4040].map(c => new THREE.Color(c)); particles = makeParticles(PARTICLE_COUNT, palette); sparkles = createSparkles(SPARK_COUNT); scene.add(particles); scene.add(sparkles); composer = new EffectComposer(renderer); composer.addPass(new RenderPass(scene, camera)); composer.addPass(new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), .45, .5, .85)); const after = new AfterimagePass(); after.uniforms.damp.value = .92; composer.addPass(after); composer.addPass(new OutputPass()); applyPattern(currentPattern); addEventListener(\"resize\", () => { camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); composer.setSize(innerWidth, innerHeight); }); document.getElementById('morphButton').addEventListener('click', () => { if (!isTrans) { beginMorph(); } }); } function applyPattern(i){ const pts = PATTERNS[i](PARTICLE_COUNT); const particleArr = particles.geometry.attributes.position.array; const sparkleArr = sparkles.geometry.attributes.position.array; for(let j=0; j<PARTICLE_COUNT; j++){ const idx = j*3; const p = pts[j] || new THREE.Vector3(); particleArr[idx] = p.x; particleArr[idx+1] = p.y; particleArr[idx+2] = p.z; if (j < SPARK_COUNT) { sparkleArr[idx] = p.x; sparkleArr[idx+1] = p.y; sparkleArr[idx+2] = p.z; } } particles.geometry.attributes.position.needsUpdate=true; sparkles.geometry.attributes.position.needsUpdate=true; } function beginMorph(){ isTrans=true; prog=0; const next=(currentPattern+1)%PATTERNS.length; const fromPts = particles.geometry.attributes.position.array.slice(); const toPts = PATTERNS[next](PARTICLE_COUNT); const to = new Float32Array(PARTICLE_COUNT*3); if(toPts.length > 0){ for(let j=0; j<PARTICLE_COUNT; j++){ const idx=j*3, p=toPts[j]; to[idx]=p.x; to[idx+1]=p.y; to[idx+2]=p.z; } particles.userData={from: fromPts, to, next}; sparkles.userData={from: fromPts, to, next}; } } function animate() { requestAnimationFrame(animate); const dt = clock.getDelta(), t = clock.getElapsedTime(); controls.update(); particles.material.uniforms.time.value = t; sparkles.material.uniforms.time.value = t; if (isTrans) { prog += morphSpeed; const eased = prog >= 1 ? 1 : 1 - Math.pow(1 - prog, 3); const { from, to } = particles.userData; if (to) { const particleArr = particles.geometry.attributes.position.array; const sparkleArr = sparkles.geometry.attributes.position.array; for (let i = 0; i < particleArr.length; i++) { const val = from[i] + (to[i] - from[i]) * eased; particleArr[i] = val; if (i < sparkleArr.length) { sparkleArr[i] = val; } } particles.geometry.attributes.position.needsUpdate = true; sparkles.geometry.attributes.position.needsUpdate = true; } if (prog >= 1) { currentPattern = particles.userData.next; isTrans = false; } } composer.render(dt); } init(); animate(); </script>\nstyle.css: \nscript.js: ",
    "id": "threejs--glsl-particle-metamorphosis"
  },
  {
    "title": "Untitled",
    "description": "",
    "code": "index.html: <script src=\"https://www.healthandliberty.org/js/simplex.js\"></script> <canvas id=\"c\"></canvas> <script id=\"shader-fs\" type=\"x-shader/x-fragment\"> \t\t\t\t#ifdef GL_ES \t\t\t\t precision highp float; \t\t\t\t #endif \t\tvoid main(void) { \t\t gl_FragColor = vec4(0.2, 1, 0.4, 1.0); \t\t} \t\t</script> <script id=\"shader-vs\" type=\"x-shader/x-vertex\"> \tattribute vec3 vertexPosition; \tuniform mat4 modelViewMatrix; \tuniform mat4 perspectiveMatrix; \tvoid main(void) { \t\tgl_Position = perspectiveMatrix * modelViewMatrix * vec4( vertexPosition, 1.0); \t} </script>\nstyle.css: body{ overflow: hidden; margin: 0; } canvas{ width: 100%; height: 100%; }\nscript.js: window.onload = loadScene; var canvas, gl, ratio, vertices, velocities, freqArr, cw, ch, colorLoc, thetaArr, velThetaArr, velRadArr, boldRateArr, drawType = 2, numLines = 15000; var target = []; var randomTargetXArr = [], randomTargetYArr = []; /** * Initialises WebGL and creates the 3D scene. */ function loadScene() { // Get the canvas element canvas = document.getElementById(\"c\"); // Get the WebGL context gl = canvas.getContext(\"experimental-webgl\"); // Check whether the WebGL context is available or not // if it's not available exit if (!gl) { alert(\"There's no WebGL context available.\"); return; } // Set the viewport to the canvas width and height cw = window.innerWidth; ch = window.innerHeight; canvas.width = cw; canvas.height = ch; gl.viewport(0, 0, canvas.width, canvas.height); // Load the vertex shader that's defined in a separate script // block at the top of this page. // More info about shaders: http://en.wikipedia.org/wiki/Shader_Model // More info about GLSL: http://en.wikipedia.org/wiki/GLSL // More info about vertex shaders: http://en.wikipedia.org/wiki/Vertex_shader // Grab the script element var vertexShaderScript = document.getElementById(\"shader-vs\"); var vertexShader = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vertexShader, vertexShaderScript.text); gl.compileShader(vertexShader); if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) { alert(\"Couldn't compile the vertex shader\"); gl.deleteShader(vertexShader); return; } // Load the fragment shader that's defined in a separate script // More info about fragment shaders: http://en.wikipedia.org/wiki/Fragment_shader var fragmentShaderScript = document.getElementById(\"shader-fs\"); var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fragmentShader, fragmentShaderScript.text); gl.compileShader(fragmentShader); if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) { alert(\"Couldn't compile the fragment shader\"); gl.deleteShader(fragmentShader); return; } // Create a shader program. gl.program = gl.createProgram(); gl.attachShader(gl.program, vertexShader); gl.attachShader(gl.program, fragmentShader); gl.linkProgram(gl.program); if (!gl.getProgramParameter(gl.program, gl.LINK_STATUS)) { alert(\"Unable to initialise shaders\"); gl.deleteProgram(gl.program); gl.deleteProgram(vertexShader); gl.deleteProgram(fragmentShader); return; } // Install the program as part of the current rendering state gl.useProgram(gl.program); // Get the vertexPosition attribute from the linked shader program var vertexPosition = gl.getAttribLocation(gl.program, \"vertexPosition\"); // Enable the vertexPosition vertex attribute array. If enabled, the array // will be accessed an used for rendering when calls are made to commands like // gl.drawArrays, gl.drawElements, etc. gl.enableVertexAttribArray(vertexPosition); // Clear the color buffer (r, g, b, a) with the specified color gl.clearColor(0.0, 0.0, 0.0, 1.0); // Clear the depth buffer. The value specified is clamped to the range [0,1]. // More info about depth buffers: http://en.wikipedia.org/wiki/Depth_buffer gl.clearDepth(1.0); // Enable depth testing. This is a technique used for hidden surface removal. // It assigns a value (z) to each pixel that represents the distance from this // pixel to the viewer. When another pixel is drawn at the same location the z // values are compared in order to determine which pixel should be drawn. //gl.enable(gl.DEPTH_TEST); gl.enable(gl.BLEND); gl.disable(gl.DEPTH_TEST); gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // Specify which function to use for depth buffer comparisons. It compares the // value of the incoming pixel against the one stored in the depth buffer. // Possible values are (from the OpenGL documentation): // GL_NEVER - Never passes. // GL_LESS - Passes if the incoming depth value is less than the stored depth value. // GL_EQUAL - Passes if the incoming depth value is equal to the stored depth value. // GL_LEQUAL - Passes if the incoming depth value is less than or equal to the stored depth value. // GL_GREATER - Passes if the incoming depth value is greater than the stored depth value. // GL_NOTEQUAL - Passes if the incoming depth value is not equal to the stored depth value. // GL_GEQUAL - Passes if the incoming depth value is greater than or equal to the stored depth value. // GL_ALWAYS - Always passes. //gl.depthFunc(gl.LEQUAL); // Now create a shape. // First create a vertex buffer in which we can store our data. var vertexBuffer = gl.createBuffer(); // Bind the buffer object to the ARRAY_BUFFER target. gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); // Specify the vertex positions (x, y, z) // ------------------ setup(); // ------------------ vertices = new Float32Array(vertices); velocities = new Float32Array(velocities); thetaArr = new Float32Array(thetaArr); velThetaArr = new Float32Array(velThetaArr); velRadArr = new Float32Array(velRadArr); // Creates a new data store for the vertices array which is bound to the ARRAY_BUFFER. // The third paramater indicates the usage pattern of the data store. Possible values are // (from the OpenGL documentation): // The frequency of access may be one of these: // STREAM - The data store contents will be modified once and used at most a few times. // STATIC - The data store contents will be modified once and used many times. // DYNAMIC - The data store contents will be modified repeatedly and used many times. // The nature of access may be one of these: // DRAW - The data store contents are modified by the application, and used as the source for // GL drawing and image specification commands. // READ - The data store contents are modified by reading data from the GL, and used to return // that data when queried by the application. // COPY - The data store contents are modified by reading data from the GL, and used as the source // for GL drawing and image specification commands. gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW); // Clear the color buffer and the depth buffer gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Define the viewing frustum parameters // More info: http://en.wikipedia.org/wiki/Viewing_frustum // More info: https://knol.google.com/k/view-frustum var fieldOfView = 30.0; var aspectRatio = canvas.width / canvas.height; var nearPlane = 1.0; var farPlane = 10000.0; var top = nearPlane * Math.tan(fieldOfView * Math.PI / 360.0); var bottom = -top; var right = top * aspectRatio; var left = -right; // Create the perspective matrix. The OpenGL function that's normally used for this, // glFrustum() is not included in the WebGL API. That's why we have to do it manually here. // More info: http://www.cs.utk.edu/~vose/c-stuff/opengl/glFrustum.html var a = (right + left) / (right - left); var b = (top + bottom) / (top - bottom); var c = (farPlane + nearPlane) / (farPlane - nearPlane); var d = (2 * farPlane * nearPlane) / (farPlane - nearPlane); var x = (2 * nearPlane) / (right - left); var y = (2 * nearPlane) / (top - bottom); var perspectiveMatrix = [ x, 0, a, 0, 0, y, b, 0, 0, 0, c, d, 0, 0, -1, 0 ]; // Create the modelview matrix // More info about the modelview matrix: http://3dengine.org/Modelview_matrix // More info about the identity matrix: http://en.wikipedia.org/wiki/Identity_matrix var modelViewMatrix = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]; // Get the vertex position attribute location from the shader program var vertexPosAttribLocation = gl.getAttribLocation(gl.program, \"vertexPosition\"); //\t\t\t\tcolorLoc = gl.getVaryingLocation(gl.program, \"vColor\"); //\t\t\t\talert(\"color loc : \" + colorLoc ); // Specify the location and format of the vertex position attribute gl.vertexAttribPointer(vertexPosAttribLocation, 3.0, gl.FLOAT, false, 0, 0); //gl.vertexAttribPointer(colorLoc, 4.0, gl.FLOAT, false, 0, 0); // Get the location of the \"modelViewMatrix\" uniform variable from the // shader program var uModelViewMatrix = gl.getUniformLocation(gl.program, \"modelViewMatrix\"); // Get the location of the \"perspectiveMatrix\" uniform variable from the // shader program var uPerspectiveMatrix = gl.getUniformLocation(gl.program, \"perspectiveMatrix\"); // Set the values gl.uniformMatrix4fv(uModelViewMatrix, false, new Float32Array(perspectiveMatrix)); gl.uniformMatrix4fv(uPerspectiveMatrix, false, new Float32Array(modelViewMatrix)); //\tgl.varyingVector4fv( // Draw the triangles in the vertex buffer. The first parameter specifies what // drawing mode to use. This can be GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, // GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, // GL_QUADS, and GL_POLYGON //gl.drawArrays( gl.LINES, 0, numLines ); //gl.flush(); //setInterval( drawScene, 1000 / 40 ); animate(); setTimeout(timer, 1500); } var count = 0; var cn = 0; function animate() { requestAnimationFrame(animate); drawScene(); } function drawScene() { draw(); gl.lineWidth(1); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); //gl.drawArrays( gl.LINES_STRIP, 0, numLines ); gl.drawArrays(gl.LINES, 0, numLines * 2); //gl.drawArrays( gl.QUAD_STRIP, 0, numLines ); gl.flush(); } // =================================== function setup() { setup2(); } function draw() { switch (drawType) { case 0: draw0(); break; case 1: draw1(); break; case 2: draw2(); break; } } // =================================== function setup1() { vertices = []; velThetaArr = []; velRadArr = []; ratio = cw / ch; velocities = []; // ------------------------------- for (var i = 0; i < numLines; i++) { var rad = Math.random() * 2 + .5; var theta = Math.random() * Math.PI * 2; var velTheta = Math.random() * Math.PI * 2; vertices.push(rad * Math.cos(theta), rad * Math.sin(theta), 1.83);//(Math.random() * 2 - 1)*ratio, Math.random() * 2 - 1, 1.83 ); vertices.push(rad * Math.cos(theta), rad * Math.sin(theta), 1.83); velocities.push((Math.random() * 2 - 1) * .05, (Math.random() * 2 - 1) * .05, .93 + Math.random() * .02); velThetaArr.push(velTheta); velRadArr.push(rad); } } // ------------------------------- function setup2() { vertices = []; velThetaArr = []; velRadArr = []; ratio = cw / ch; velocities = []; thetaArr = []; freqArr = []; boldRateArr = []; // ------------------------------- for (var ii = 0; ii < numLines; ii++) { var rad = ( 0.1 + .2 * Math.random() ); var theta = Math.random() * Math.PI * 2; var velTheta = Math.random() * Math.PI * 2 / 30; var freq = Math.random() * 0.12 + 0.03; var boldRate = Math.random() * .04 + .01; var randomPosX = (Math.random() * 2 - 1) * window.innerWidth / window.innerHeight; var randomPosY = Math.random() * 2 - 1; vertices.push(rad * Math.cos(theta), rad * Math.sin(theta), 1.83); vertices.push(rad * Math.cos(theta), rad * Math.sin(theta), 1.83); thetaArr.push(theta); velThetaArr.push(velTheta); velRadArr.push(rad); freqArr.push(freq); boldRateArr.push(boldRate); randomTargetXArr.push(randomPosX); randomTargetYArr.push(randomPosY); } freqArr = new Float32Array(freqArr); } // ------------------------------- // =================================== function draw0() { var i, n = vertices.length, p, bp; var px, py; var pTheta; var rad; var num; var targetX, targetY; for (i = 0; i < numLines * 2; i += 2) { count += .3; bp = i * 3; vertices[bp] = vertices[bp + 3]; vertices[bp + 1] = vertices[bp + 4]; num = parseInt(i / 2); targetX = randomTargetXArr[num]; targetY = randomTargetYArr[num]; px = vertices[bp + 3]; px += (targetX - px) * (Math.random() * .04 + .06); vertices[bp + 3] = px; //py = (Math.sin(cn) + 1) * .2 * (Math.random() * .5 - .25); py = vertices[bp + 4]; py += (targetY - py) * (Math.random() * .04 + .06); vertices[bp + 4] = py; } } // ------------------------------- function draw1() { var i, n = vertices.length, p, bp; var px, py; var pTheta; var rad; var num; var targetX, targetY; for (i = 0; i < numLines * 2; i += 2) { count += .3; bp = i * 3; vertices[bp] = vertices[bp + 3]; vertices[bp + 1] = vertices[bp + 4]; num = parseInt(i / 2); pTheta = thetaArr[num]; rad = velRadArr[num]; pTheta = pTheta + velThetaArr[num]; thetaArr[num] = pTheta; targetX = rad * Math.cos(pTheta); targetY = rad * Math.sin(pTheta); px = vertices[bp + 3]; px += (targetX - px) * (Math.random() * .1 + .1); vertices[bp + 3] = px; //py = (Math.sin(cn) + 1) * .2 * (Math.random() * .5 - .25); py = vertices[bp + 4]; py += (targetY - py) * (Math.random() * .1 + .1); vertices[bp + 4] = py; } } // ------------------------------- function draw2() { cn += .1; var i, n = vertices.length, p, bp; var px, py; var pTheta; var rad; var num; for (i = 0; i < numLines * 2; i += 2) { count += .3; bp = i * 3; // copy old positions vertices[bp] = vertices[bp + 3]; vertices[bp + 1] = vertices[bp + 4]; num = parseInt(i / 2); pTheta = thetaArr[num]; rad = velRadArr[num];// + Math.cos(pTheta + i * freqArr[i]) * boldRateArr[num]; pTheta = pTheta + velThetaArr[num]; thetaArr[num] = pTheta; px = vertices[bp + 3]; px = rad * Math.cos(pTheta) * 0.1 + px; vertices[bp + 3] = px; //py = (Math.sin(cn) + 1) * .2 * (Math.random() * .5 - .25); py = vertices[bp + 4]; py = py + rad * Math.sin(pTheta) * 0.1; //p *= ( Math.random() -.5); vertices[bp + 4] = py; } } // ------------------------------- function timer() { //drawType = (drawType + 1) % 3; //setTimeout(timer, 1500); }",
    "id": "untitled"
  },
  {
    "title": "cg-webgl-interactive-gradient",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>WebGL Interactive Gradient | mukta</title>\n    <link rel=\"stylesheet\" href=\"/styles.css\" />\n  </head>\n  <body>\n    <nav>\n      <div class=\"logo\">\n        <p>Orbit Studio</p>\n      </div>\n      <div class=\"nav-items\">\n        <p>Index</p>\n        <p>Portfolio</p>\n        <p>Info</p>\n        <p>Contact</p>\n      </div>\n    </nav>\n    <section class=\"hero\">\n      <div class=\"gradient-canvas\"></div>\n\n      <div class=\"hero-logo\">\n        <img src=\"/logo_01.png\" alt=\"\" />\n      </div>\n\n      <div class=\"hero-footer\">\n        <p>Experiment 0469</p>\n        <p>Built by mukta</p>\n      </div>\n    </section>\n    <script type=\"module\" src=\"/shaders.js\"></script>\n    <script type=\"module\" src=\"/script.js\"></script>\n  </body>\n</html>\n",
      "package.json": "{\n  \"name\": \"cg-webgl-interactive-gradient\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"dev\": \"vite\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\",\n  \"dependencies\": {\n    \"leva\": \"^0.10.0\",\n    \"three\": \"^0.178.0\",\n    \"vite\": \"^7.0.2\"\n  }\n}\n",
      "script.js": "import * as THREE from \"three\";\nimport { vertexShader, fluidShader, displayShader } from \"./shaders.js\";\n\nconst config = {\n  brushSize: 25.0,\n  brushStrength: 0.5,\n  distortionAmount: 2.5,\n  fluidDecay: 0.98,\n  trailLength: 0.8,\n  stopDecay: 0.85,\n  color1: \"#b8fff7\",\n  color2: \"#6e3466\",\n  color3: \"#0133ff\",\n  color4: \"#66d1fe\",\n  colorIntensity: 1.0,\n  softness: 1.0,\n};\n\nfunction hexToRgb(hex) {\n  const r = parseInt(hex.slice(1, 3), 16) / 255;\n  const g = parseInt(hex.slice(3, 5), 16) / 255;\n  const b = parseInt(hex.slice(5, 7), 16) / 255;\n  return [r, g, b];\n}\n\nconst camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\nconst renderer = new THREE.WebGLRenderer({ antialias: true });\n\nconst gradientCanvas = document.querySelector(\".gradient-canvas\");\nrenderer.setSize(window.innerWidth, window.innerHeight);\ngradientCanvas.appendChild(renderer.domElement);\n\nconst fluidTarget1 = new THREE.WebGLRenderTarget(\n  window.innerWidth,\n  window.innerHeight,\n  {\n    minFilter: THREE.LinearFilter,\n    magFilter: THREE.LinearFilter,\n    format: THREE.RGBAFormat,\n    type: THREE.FloatType,\n  }\n);\n\nconst fluidTarget2 = new THREE.WebGLRenderTarget(\n  window.innerWidth,\n  window.innerHeight,\n  {\n    minFilter: THREE.LinearFilter,\n    magFilter: THREE.LinearFilter,\n    format: THREE.RGBAFormat,\n    type: THREE.FloatType,\n  }\n);\n\nlet currentFluidTarget = fluidTarget1;\nlet previousFluidTarget = fluidTarget2;\nlet frameCount = 0;\n\nconst fluidMaterial = new THREE.ShaderMaterial({\n  uniforms: {\n    iTime: { value: 0 },\n    iResolution: {\n      value: new THREE.Vector2(window.innerWidth, window.innerHeight),\n    },\n    iMouse: { value: new THREE.Vector4(0, 0, 0, 0) },\n    iFrame: { value: 0 },\n    iPreviousFrame: { value: null },\n    uBrushSize: { value: config.brushSize },\n    uBrushStrength: { value: config.brushStrength },\n    uFluidDecay: { value: config.fluidDecay },\n    uTrailLength: { value: config.trailLength },\n    uStopDecay: { value: config.stopDecay },\n  },\n  vertexShader: vertexShader,\n  fragmentShader: fluidShader,\n});\n\nconst displayMaterial = new THREE.ShaderMaterial({\n  uniforms: {\n    iTime: { value: 0 },\n    iResolution: {\n      value: new THREE.Vector2(window.innerWidth, window.innerHeight),\n    },\n    iFluid: { value: null },\n    uDistortionAmount: { value: config.distortionAmount },\n    uColor1: { value: new THREE.Vector3(...hexToRgb(config.color1)) },\n    uColor2: { value: new THREE.Vector3(...hexToRgb(config.color2)) },\n    uColor3: { value: new THREE.Vector3(...hexToRgb(config.color3)) },\n    uColor4: { value: new THREE.Vector3(...hexToRgb(config.color4)) },\n    uColorIntensity: { value: config.colorIntensity },\n    uSoftness: { value: config.softness },\n  },\n  vertexShader: vertexShader,\n  fragmentShader: displayShader,\n});\n\nconst geometry = new THREE.PlaneGeometry(2, 2);\nconst fluidPlane = new THREE.Mesh(geometry, fluidMaterial);\nconst displayPlane = new THREE.Mesh(geometry, displayMaterial);\n\nlet mouseX = 0,\n  mouseY = 0;\nlet prevMouseX = 0,\n  prevMouseY = 0;\nlet lastMoveTime = 0;\n\ndocument.addEventListener(\"mousemove\", (e) => {\n  const rect = gradientCanvas.getBoundingClientRect();\n  prevMouseX = mouseX;\n  prevMouseY = mouseY;\n  mouseX = e.clientX - rect.left;\n  mouseY = rect.height - (e.clientY - rect.top);\n  lastMoveTime = performance.now();\n  fluidMaterial.uniforms.iMouse.value.set(\n    mouseX,\n    mouseY,\n    prevMouseX,\n    prevMouseY\n  );\n});\n\ndocument.addEventListener(\"mouseleave\", () => {\n  fluidMaterial.uniforms.iMouse.value.set(0, 0, 0, 0);\n});\n\nfunction animate() {\n  requestAnimationFrame(animate);\n\n  const time = performance.now() * 0.001;\n  fluidMaterial.uniforms.iTime.value = time;\n  displayMaterial.uniforms.iTime.value = time;\n  fluidMaterial.uniforms.iFrame.value = frameCount;\n\n  if (performance.now() - lastMoveTime > 100) {\n    fluidMaterial.uniforms.iMouse.value.set(0, 0, 0, 0);\n  }\n\n  fluidMaterial.uniforms.uBrushSize.value = config.brushSize;\n  fluidMaterial.uniforms.uBrushStrength.value = config.brushStrength;\n  fluidMaterial.uniforms.uFluidDecay.value = config.fluidDecay;\n  fluidMaterial.uniforms.uTrailLength.value = config.trailLength;\n  fluidMaterial.uniforms.uStopDecay.value = config.stopDecay;\n\n  displayMaterial.uniforms.uDistortionAmount.value = config.distortionAmount;\n  displayMaterial.uniforms.uColorIntensity.value = config.colorIntensity;\n  displayMaterial.uniforms.uSoftness.value = config.softness;\n  displayMaterial.uniforms.uColor1.value.set(...hexToRgb(config.color1));\n  displayMaterial.uniforms.uColor2.value.set(...hexToRgb(config.color2));\n  displayMaterial.uniforms.uColor3.value.set(...hexToRgb(config.color3));\n  displayMaterial.uniforms.uColor4.value.set(...hexToRgb(config.color4));\n\n  fluidMaterial.uniforms.iPreviousFrame.value = previousFluidTarget.texture;\n  renderer.setRenderTarget(currentFluidTarget);\n  renderer.render(fluidPlane, camera);\n\n  displayMaterial.uniforms.iFluid.value = currentFluidTarget.texture;\n  renderer.setRenderTarget(null);\n  renderer.render(displayPlane, camera);\n\n  const temp = currentFluidTarget;\n  currentFluidTarget = previousFluidTarget;\n  previousFluidTarget = temp;\n\n  frameCount++;\n}\n\nwindow.addEventListener(\"resize\", () => {\n  const width = window.innerWidth;\n  const height = window.innerHeight;\n\n  renderer.setSize(width, height);\n  fluidMaterial.uniforms.iResolution.value.set(width, height);\n  displayMaterial.uniforms.iResolution.value.set(width, height);\n\n  fluidTarget1.setSize(width, height);\n  fluidTarget2.setSize(width, height);\n  frameCount = 0;\n});\n\nanimate();\n",
      "shaders.js": "export const vertexShader = `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n\nexport const fluidShader = `\n  uniform float iTime;\n  uniform vec2 iResolution;\n  uniform vec4 iMouse;\n  uniform int iFrame;\n  uniform sampler2D iPreviousFrame;\n  uniform float uBrushSize;\n  uniform float uBrushStrength;\n  uniform float uFluidDecay;\n  uniform float uTrailLength;\n  uniform float uStopDecay;\n  varying vec2 vUv;\n  \n  vec2 ur, U;\n  \n  float ln(vec2 p, vec2 a, vec2 b) {\n      return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n  }\n  \n  vec4 t(vec2 v, int a, int b) {\n      return texture2D(iPreviousFrame, fract((v+vec2(float(a),float(b)))/ur));\n  }\n  \n  vec4 t(vec2 v) {\n      return texture2D(iPreviousFrame, fract(v/ur));\n  }\n  \n  float area(vec2 a, vec2 b, vec2 c) {\n      float A = length(b-c), B = length(c-a), C = length(a-b), s = 0.5*(A+B+C);\n      return sqrt(s*(s-A)*(s-B)*(s-C));\n  }\n  \n  void main() {\n      U = vUv * iResolution;\n      ur = iResolution.xy;\n      \n      if (iFrame < 1) {\n          float w = 0.5+sin(0.2*U.x)*0.5;\n          float q = length(U-0.5*ur);\n          gl_FragColor = vec4(0.1*exp(-0.001*q*q),0,0,w);\n      } else {\n          vec2 v = U,\n               A = v + vec2( 1, 1),\n               B = v + vec2( 1,-1),\n               C = v + vec2(-1, 1),\n               D = v + vec2(-1,-1);\n          \n          for (int i = 0; i < 8; i++) {\n              v -= t(v).xy;\n              A -= t(A).xy;\n              B -= t(B).xy;\n              C -= t(C).xy;\n              D -= t(D).xy;\n          }\n          \n          vec4 me = t(v);\n          vec4 n = t(v, 0, 1),\n              e = t(v, 1, 0),\n              s = t(v, 0, -1),\n              w = t(v, -1, 0);\n          vec4 ne = .25*(n+e+s+w);\n          me = mix(t(v), ne, vec4(0.15,0.15,0.95,0.));\n          me.z = me.z - 0.01*((area(A,B,C)+area(B,C,D))-4.);\n          \n          vec4 pr = vec4(e.z,w.z,n.z,s.z);\n          me.xy = me.xy + 100.*vec2(pr.x-pr.y, pr.z-pr.w)/ur;\n          \n          me.xy *= uFluidDecay;\n          me.z *= uTrailLength;\n          \n          if (iMouse.z > 0.0) {\n              vec2 mousePos = iMouse.xy;\n              vec2 mousePrev = iMouse.zw;\n              vec2 mouseVel = mousePos - mousePrev;\n              float velMagnitude = length(mouseVel);\n              float q = ln(U, mousePos, mousePrev);\n              vec2 m = mousePos - mousePrev;\n              float l = length(m);\n              if (l > 0.0) m = min(l, 10.0) * m / l;\n              \n              float brushSizeFactor = 1e-4 / uBrushSize;\n              float strengthFactor = 0.03 * uBrushStrength;\n              \n              float falloff = exp(-brushSizeFactor*q*q*q);\n              falloff = pow(falloff, 0.5);\n              \n              me.xyw += strengthFactor * falloff * vec3(m, 10.);\n              \n              if (velMagnitude < 2.0) {\n                  float distToCursor = length(U - mousePos);\n                  float influence = exp(-distToCursor * 0.01);\n                  float cursorDecay = mix(1.0, uStopDecay, influence);\n                  me.xy *= cursorDecay;\n                  me.z *= cursorDecay;\n              }\n          }\n          \n          gl_FragColor = clamp(me, -0.4, 0.4);\n      }\n  }\n`;\n\nexport const displayShader = `\n  uniform float iTime;\n  uniform vec2 iResolution;\n  uniform sampler2D iFluid;\n  uniform float uDistortionAmount;\n  uniform vec3 uColor1;\n  uniform vec3 uColor2;\n  uniform vec3 uColor3;\n  uniform vec3 uColor4;\n  uniform float uColorIntensity;\n  uniform float uSoftness;\n  varying vec2 vUv;\n  \n  void main() {\n    vec2 fragCoord = vUv * iResolution;\n    \n    vec4 fluid = texture2D(iFluid, vUv);\n    vec2 fluidVel = fluid.xy;\n    \n    float mr = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / mr;\n    \n    uv += fluidVel * (0.5 * uDistortionAmount);\n    \n    float d = -iTime * 0.5;\n    float a = 0.0;\n    for (float i = 0.0; i < 8.0; ++i) {\n      a += cos(i - d - a * uv.x);\n      d += sin(uv.y * i + a);\n    }\n    d += iTime * 0.5;\n    \n    float mixer1 = cos(uv.x * d) * 0.5 + 0.5;\n    float mixer2 = cos(uv.y * a) * 0.5 + 0.5;\n    float mixer3 = sin(d + a) * 0.5 + 0.5;\n    \n    float smoothAmount = clamp(uSoftness * 0.1, 0.0, 0.9);\n    mixer1 = mix(mixer1, 0.5, smoothAmount);\n    mixer2 = mix(mixer2, 0.5, smoothAmount);\n    mixer3 = mix(mixer3, 0.5, smoothAmount);\n    \n    vec3 col = mix(uColor1, uColor2, mixer1);\n    col = mix(col, uColor3, mixer2);\n    col = mix(col, uColor4, mixer3 * 0.4);\n    \n    col *= uColorIntensity;\n    \n    gl_FragColor = vec4(col, 1.0);\n  }\n`;\n",
      "styles.css": "@import url(\"https://fonts.googleapis.com/css2?family=Host+Grotesk:ital,wght@0,300..800;1,300..800&display=swap\");\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: \"Host Grotesk\";\n}\n\nimg {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\np {\n  color: #fff;\n  font-size: 0.9rem;\n  font-weight: 450;\n}\n\nnav,\n.hero-footer {\n  position: absolute;\n  left: 0;\n  width: 100vw;\n  padding: 2rem;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  z-index: 2;\n}\n\n.nav-items {\n  display: flex;\n  gap: 4rem;\n}\n\nnav .logo p {\n  font-weight: 700;\n}\n\n.hero-footer {\n  bottom: 0;\n}\n\nsection {\n  position: relative;\n  width: 100vw;\n  height: 100svh;\n  overflow: hidden;\n}\n\n.hero-logo {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 25%;\n}\n\n.gradient-canvas {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n@media (max-width: 1000px) {\n  nav {\n    flex-direction: column;\n    gap: 2rem;\n  }\n}\n"
    }
  },
  {
    "title": "WebGL Shader Hero Design",
    "description": "",
    "code": "index.html: <style> * { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; overflow: hidden; background: #000; } canvas { display: block; width: 100%; height: 100vh; } .content { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; text-align: center; color: white; pointer-events: none; } h1 { font-size: clamp(4.5rem, 13vw, 11rem); font-weight: 900; margin-bottom: 0.5rem; letter-spacing: -0.06em; background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 50%, #ffffff 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; filter: drop-shadow(0 0 40px rgba(255, 255, 255, 0.4)) drop-shadow(0 0 80px rgba(138, 43, 226, 0.3)); animation: glowPulse 3s ease-in-out infinite alternate; } @keyframes glowPulse { from { filter: drop-shadow(0 0 40px rgba(255, 255, 255, 0.4)) drop-shadow(0 0 80px rgba(138, 43, 226, 0.3)); } to { filter: drop-shadow(0 0 60px rgba(255, 255, 255, 0.6)) drop-shadow(0 0 120px rgba(0, 191, 255, 0.4)); } } .tagline { font-size: clamp(0.9rem, 2vw, 1.2rem); font-weight: 300; color: rgba(255, 255, 255, 0.9); letter-spacing: 0.3em; text-transform: uppercase; text-shadow: 0 0 30px rgba(255, 255, 255, 0.5), 0 0 60px rgba(138, 43, 226, 0.3); } .buttons { display: flex; justify-content: center; gap: 24px; margin-top: 40px; pointer-events: auto; } .glass-button { position: relative; padding: 16px 40px; font-size: 1rem; font-weight: 600; letter-spacing: 0.08em; color: #fff; background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.02) 100%); border: 1.5px solid transparent; border-radius: 40px; backdrop-filter: blur(30px); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.2), inset 0 -1px 0 rgba(255, 255, 255, 0.05); overflow: hidden; cursor: pointer; transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); pointer-events: auto; } .glass-button::before { content: ''; position: absolute; inset: 0; border-radius: 40px; padding: 1.5px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.4) 0%, rgba(138, 43, 226, 0.4) 25%, rgba(0, 191, 255, 0.4) 50%, rgba(255, 105, 180, 0.4) 75%, rgba(255, 255, 255, 0.4) 100%); background-size: 200% 200%; -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0); -webkit-mask-composite: xor; mask-composite: exclude; animation: borderFlow 3s linear infinite; opacity: 0.6; transition: opacity 0.5s ease; } @keyframes borderFlow { 0% { background-position: 0% 50%; } 100% { background-position: 200% 50%; } } .glass-button::after { content: ''; position: absolute; inset: 0; border-radius: 40px; background: radial-gradient(circle at var(--x, 50%) var(--y, 50%), rgba(255, 255, 255, 0.2) 0%, transparent 50%); opacity: 0; transition: opacity 0.5s ease; } .glass-button:hover { background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%); box-shadow: 0 12px 48px rgba(138, 43, 226, 0.3), 0 0 80px rgba(0, 191, 255, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3), inset 0 -1px 0 rgba(255, 255, 255, 0.1); transform: translateY(-3px) scale(1.02); } .glass-button:hover::before { opacity: 1; animation-duration: 2s; } .glass-button:hover::after { opacity: 1; } .glass-button:active { transform: translateY(-1px) scale(0.98); box-shadow: 0 6px 24px rgba(138, 43, 226, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3); } .glass-button .shimmer { position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient( 90deg, transparent 0%, rgba(255, 255, 255, 0.1) 45%, rgba(255, 255, 255, 0.3) 50%, rgba(255, 255, 255, 0.1) 55%, transparent 100% ); transform: rotate(30deg); animation: shimmer 3s infinite; pointer-events: none; } @keyframes shimmer { 0% { transform: translateX(-100%) rotate(30deg); } 100% { transform: translateX(100%) rotate(30deg); } } .glass-button:hover .shimmer { animation-duration: 1.5s; } .glass-button span { position: relative; z-index: 1; } </style> <canvas id=\"canvas\"></canvas> <div class=\"content\"> <h1>PRISM</h1> <p class=\"tagline\">Spectrum of Light</p> <div class=\"buttons\"> <button class=\"glass-button\"> <span class=\"shimmer\"></span> <span>Discover</span> </button> <button class=\"glass-button\"> <span class=\"shimmer\"></span> <span>Join Now</span> </button> </div> </div> <script id=\"vertexShader\" type=\"x-shader/x-vertex\"> attribute vec2 position; void main() { gl_Position = vec4(position, 0.0, 1.0); } </script> <script id=\"fragmentShader\" type=\"x-shader/x-fragment\"> precision highp float; uniform float uTime; uniform vec2 uResolution; uniform vec2 uMouse; #define PI 3.14159265359 #define TAU 6.28318530718 #define MAX_STEPS 80 #define MAX_DIST 50.0 #define SURF_DIST 0.001 float hash(float n) { return fract(sin(n) * 43758.5453123); } mat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, -s, s, c); } float sdSphere(vec3 p, float r) { return length(p) - r; } float sdBox(vec3 p, vec3 b) { vec3 q = abs(p) - b; return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0); } float sdOctahedron(vec3 p, float s) { p = abs(p); float m = p.x + p.y + p.z - s; vec3 q; if(3.0 * p.x < m) q = p.xyz; else if(3.0 * p.y < m) q = p.yzx; else if(3.0 * p.z < m) q = p.zxy; else return m * 0.57735027; float k = clamp(0.5 * (q.z - q.y + s), 0.0, s); return length(vec3(q.x, q.y - s + k, q.z - k)); } float sdTriPrism(vec3 p, vec2 h) { vec3 q = abs(p); return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5); } float smin(float a, float b, float k) { float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0); return mix(b, a, h) - k * h * (1.0 - h); } float smax(float a, float b, float k) { return -smin(-a, -b, k); } float map(vec3 p) { vec3 op = p; vec2 m = (uMouse - 0.5) * 2.5; p.xy += m * 0.4; p.xz *= rot(uTime * 0.12); p.xy *= rot(uTime * 0.08); float d = 100.0; vec3 p1 = p; p1.yz *= rot(uTime * 0.15); float core_distort = sin(p1.x * 3.0 + uTime) * sin(p1.y * 3.0 + uTime) * sin(p1.z * 3.0 + uTime) * 0.1; float core = sdOctahedron(p1, 1.6) + core_distort; vec3 p2 = p1; p2.xy *= rot(PI * 0.25 + uTime * 0.2); float prism = sdTriPrism(p2, vec2(1.4, 2.0)); core = smax(core, -prism, 0.2); d = core; float k_blend = 0.2 + 0.15 * (0.5 + 0.5 * sin(uTime * 1.5)); for(int i = 0; i < 4; i++) { float fi = float(i); float angle = fi * TAU / 4.0 + uTime * 0.3; float radius = 3.0 + 0.3 * sin(uTime * 0.4 + fi); vec3 pos = vec3( cos(angle) * radius, sin(angle * 0.7) * 1.0, sin(angle) * radius ); vec3 po = p - pos; po.xy *= rot(uTime * 0.5 + fi); float sat_distort = sin(po.x * 5.0 + fi) * sin(po.y * 5.0 + fi) * sin(po.z * 5.0 + fi) * 0.05; float satellite = sdOctahedron(po, 0.4) + sat_distort; d = smin(d, satellite, k_blend); } return d; } vec3 getNormal(vec3 p) { vec2 e = vec2(0.001, 0.0); return normalize(vec3( map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy), map(p + e.yyx) - map(p - e.yyx) )); } float raymarch(vec3 ro, vec3 rd) { float t = 0.0; for(int i = 0; i < MAX_STEPS; i++) { vec3 p = ro + rd * t; float d = map(p); if(abs(d) < SURF_DIST || t > MAX_DIST) break; t += d * 0.7; } return t; } vec3 getBackground(vec3 rd) { float stars = 0.0; vec3 p = rd * 100.0; float h = hash(dot(p, vec3(12.9898, 78.233, 54.53))); if(h > 0.98) stars = pow(h - 0.98, 10.0) * 20.0; vec3 nebula = vec3(0.0); nebula += vec3(0.3, 0.15, 0.5) * pow(max(0.0, sin(rd.x * 2.0 + uTime * 0.1)), 3.0) * 0.2; nebula += vec3(0.15, 0.3, 0.6) * pow(max(0.0, sin(rd.y * 2.5 + uTime * 0.05)), 3.0) * 0.2; return stars + nebula; } void main() { vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution) / min(uResolution.x, uResolution.y); vec2 m = (uMouse - 0.5) * 0.5; vec3 ro = vec3(m.x * 2.0, m.y * 2.0, 5.5); vec3 rd = normalize(vec3(uv, -1.0)); rd.xy *= rot(m.x * 0.2); rd.yz *= rot(m.y * 0.2); float t = raymarch(ro, rd); vec3 color = vec3(0.0); if(t < MAX_DIST) { vec3 p = ro + rd * t; vec3 normal = getNormal(p); vec3 viewDir = normalize(ro - p); float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0); float ior = 1.5; vec3 refractDir = refract(rd, normal, 1.0 / ior); if(length(refractDir) > 0.0) { float t2 = raymarch(p - normal * 0.01, refractDir); if(t2 < MAX_DIST) { vec3 p2 = p - normal * 0.01 + refractDir * t2; vec3 normal2 = getNormal(p2); vec3 r = refract(refractDir, -normal2, ior - 0.2); vec3 g = refract(refractDir, -normal2, ior); vec3 b = refract(refractDir, -normal2, ior + 0.2); vec3 bgR = getBackground(r) * vec3(1.4, 0.7, 0.7); vec3 bgG = getBackground(g) * vec3(0.7, 1.4, 0.8); vec3 bgB = getBackground(b) * vec3(0.7, 0.8, 1.4); color = vec3(bgR.x, bgG.y, bgB.z); color = pow(color, vec3(0.7)) * 5.0; } else { color = getBackground(refractDir) * 2.0; } } vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0)); vec3 halfDir = normalize(lightDir + viewDir); float spec = pow(max(dot(normal, halfDir), 0.0), 150.0); color += spec * vec3(1.0, 1.0, 1.0) * 3.5; vec3 fresnelColor = vec3( 0.5 + 0.5 * sin(fresnel * TAU + uTime), 0.5 + 0.5 * sin(fresnel * TAU + uTime + TAU / 3.0), 0.5 + 0.5 * sin(fresnel * TAU + uTime + TAU * 2.0 / 3.0) ); color += fresnel * fresnelColor * 1.2; float edge = pow(1.0 - abs(dot(viewDir, normal)), 4.0); color += edge * vec3(0.6, 0.7, 1.0) * 0.7; float sss = pow(max(dot(-normal, lightDir), 0.0), 2.0); color += sss * vec3(1.0, 0.6, 0.8) * 0.5; } else { color = getBackground(rd); } float vignette = 1.0 - length(uv) * 0.4; vignette = smoothstep(0.3, 1.0, vignette); color *= vignette; color *= vec3(0.96, 0.99, 1.06); color = pow(color, vec3(0.88)); color *= 1.12; gl_FragColor = vec4(color, 1.0); } </script> <script> const canvas = document.getElementById('canvas'); const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); if (!gl) { alert('WebGL not supported'); } function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; gl.viewport(0, 0, canvas.width, canvas.height); } resizeCanvas(); window.addEventListener('resize', resizeCanvas); function createShader(gl, type, source) { const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error('Shader compile error:', gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; } return shader; } function createProgram(gl, vertexShader, fragmentShader) { const program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error('Program link error:', gl.getProgramInfoLog(program)); gl.deleteProgram(program); return null; } return program; } const vertexShaderSource = document.getElementById('vertexShader').textContent; const fragmentShaderSource = document.getElementById('fragmentShader').textContent; const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource); const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource); const program = createProgram(gl, vertexShader, fragmentShader); const uTime = gl.getUniformLocation(program, 'uTime'); const uResolution = gl.getUniformLocation(program, 'uResolution'); const uMouse = gl.getUniformLocation(program, 'uMouse'); const positions = new Float32Array([ -1, -1, 1, -1, -1, 1, 1, 1, ]); const positionBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW); const mouse = { x: 0.5, y: 0.5, targetX: 0.5, targetY: 0.5 }; canvas.addEventListener('mousemove', (e) => { mouse.targetX = e.clientX / canvas.width; mouse.targetY = 1.0 - e.clientY / canvas.height; }); document.querySelectorAll('.glass-button').forEach(button => { button.addEventListener('mousemove', (e) => { const rect = button.getBoundingClientRect(); const x = ((e.clientX - rect.left) / rect.width) * 100; const y = ((e.clientY - rect.top) / rect.height) * 100; button.style.setProperty('--x', x + '%'); button.style.setProperty('--y', y + '%'); }); }); let startTime = Date.now(); function render() { const currentTime = (Date.now() - startTime) * 0.001; mouse.x += (mouse.targetX - mouse.x) * 0.05; mouse.y += (mouse.targetY - mouse.y) * 0.05; gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.useProgram(program); gl.uniform1f(uTime, currentTime); gl.uniform2f(uResolution, canvas.width, canvas.height); gl.uniform2f(uMouse, mouse.x, mouse.y); const positionLocation = gl.getAttribLocation(program, 'position'); gl.enableVertexAttribArray(positionLocation); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0); gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); requestAnimationFrame(render); } render(); </script>\nstyle.css: \nscript.js: ",
    "id": "webgl-shader-hero-design"
  },
  {
    "title": "Magic Plasma Sphere - Three.js",
    "description": "",
    "code": "index.html: <script type=\"importmap\"> { \"imports\": { \"three\": \"https://unpkg.com/three@0.160.0/build/three.module.js\", \"three/addons/\": \"https://unpkg.com/three@0.160.0/examples/jsm/\" } } </script>\nstyle.css: body { margin: 0; overflow: hidden; background-color: #000; } canvas { display: block; } /* GUI Container positioning */ .lil-gui.root { position: absolute; bottom: 10px; right: 10px; top: auto !important; }\nscript.js: import * as THREE from 'three'; import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; import { GUI } from 'three/addons/libs/lil-gui.module.min.js'; // --- CONFIGURATION OBJECT --- const params = { // Animation timeScale: 0.78, rotationSpeedX: 0.002, rotationSpeedY: 0.005, // Plasma plasmaScale: 0.1404, // Texture Scale plasmaBrightness: 1.31, // Brightness voidThreshold: 0.072, // Voids colorDeep: 0x001433, // Color Deep colorMid: 0x0084ff, // Color Mid colorBright: 0x00ffe1, // Color Bright // Shell shellColor: 0x0066ff, // Edge Color shellOpacity: 0.41 // Edge Opacity }; // 1. SCENE SETUP const scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000); const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100); camera.position.z = 2.4; const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // TONE MAPPING renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 0.9; document.body.appendChild(renderer.domElement); const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.enablePan = false; controls.minDistance = 1.5; controls.maxDistance = 20; // --- GROUP FOR ROTATION --- const mainGroup = new THREE.Group(); scene.add(mainGroup); // --- GLSL NOISE FUNCTIONS --- const noiseFunctions = ` vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); } vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; } float snoise(vec3 v) { const vec2 C = vec2(1.0/6.0, 1.0/3.0) ; const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); vec3 i = floor(v + dot(v, C.yyy) ); vec3 x0 = v - i + dot(i, C.xxx) ; vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min( g.xyz, l.zxy ); vec3 i2 = max( g.xyz, l.zxy ); vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy; i = mod289(i); vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 )); float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z); vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_ ); vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4( x.xy, y.xy ); vec4 b1 = vec4( x.zw, y.zw ); vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ; vec3 p0 = vec3(a0.xy,h.x); vec3 p1 = vec3(a0.zw,h.y); vec3 p2 = vec3(a1.xy,h.z); vec3 p3 = vec3(a1.zw,h.w); vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0); m = m * m; return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) ); } float fbm(vec3 p) { float total = 0.0; float amplitude = 0.5; float frequency = 1.0; for (int i = 0; i < 3; i++) { total += snoise(p * frequency) * amplitude; amplitude *= 0.5; frequency *= 2.0; } return total; } `; // 2. LIGHTS const pointLight = new THREE.PointLight(0x0088ff, 2.0, 10); mainGroup.add(pointLight); // 3. OUTER SHELL (Glass) const shellGeo = new THREE.SphereGeometry(1.0, 64, 64); const shellShader = { vertexShader: ` varying vec3 vNormal; varying vec3 vViewPosition; void main() { vNormal = normalize(normalMatrix * normal); vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); vViewPosition = -mvPosition.xyz; gl_Position = projectionMatrix * mvPosition; } `, fragmentShader: ` varying vec3 vNormal; varying vec3 vViewPosition; uniform vec3 uColor; uniform float uOpacity; void main() { float fresnel = pow(1.0 - dot(normalize(vNormal), normalize(vViewPosition)), 2.5); gl_FragColor = vec4(uColor, fresnel * uOpacity); } ` }; const shellBackMat = new THREE.ShaderMaterial({ vertexShader: shellShader.vertexShader, fragmentShader: shellShader.fragmentShader, uniforms: { uColor: { value: new THREE.Color(0x000055) }, uOpacity: { value: 0.3 } }, transparent: true, blending: THREE.AdditiveBlending, side: THREE.BackSide, depthWrite: false }); const shellFrontMat = new THREE.ShaderMaterial({ vertexShader: shellShader.vertexShader, fragmentShader: shellShader.fragmentShader, uniforms: { uColor: { value: new THREE.Color(params.shellColor) }, uOpacity: { value: params.shellOpacity } }, transparent: true, blending: THREE.AdditiveBlending, side: THREE.FrontSide, depthWrite: false }); mainGroup.add(new THREE.Mesh(shellGeo, shellBackMat)); mainGroup.add(new THREE.Mesh(shellGeo, shellFrontMat)); // 4. PLASMA (Gas) const plasmaGeo = new THREE.SphereGeometry(0.998, 128, 128); const plasmaMat = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0 }, uScale: { value: params.plasmaScale }, uBrightness: { value: params.plasmaBrightness }, uThreshold: { value: params.voidThreshold }, uColorDeep: { value: new THREE.Color(params.colorDeep) }, uColorMid: { value: new THREE.Color(params.colorMid) }, uColorBright: { value: new THREE.Color(params.colorBright) } }, vertexShader: ` varying vec3 vPosition; varying vec3 vNormal; varying vec3 vViewPosition; void main() { vPosition = position; vNormal = normalize(normalMatrix * normal); vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); vViewPosition = -mvPosition.xyz; gl_Position = projectionMatrix * mvPosition; } `, fragmentShader: ` uniform float uTime; uniform float uScale; uniform float uBrightness; uniform float uThreshold; uniform vec3 uColorDeep; uniform vec3 uColorMid; uniform vec3 uColorBright; varying vec3 vPosition; varying vec3 vNormal; varying vec3 vViewPosition; ${noiseFunctions} void main() { vec3 p = vPosition * uScale; vec3 q = vec3( fbm(p + vec3(0.0, uTime * 0.05, 0.0)), fbm(p + vec3(5.2, 1.3, 2.8) + uTime * 0.05), fbm(p + vec3(2.2, 8.4, 0.5) - uTime * 0.02) ); float density = fbm(p + 2.0 * q); float t = (density + 0.4) * 0.8; float alpha = smoothstep(uThreshold, 0.7, t); vec3 cWhite = vec3(1.0, 1.0, 1.0); vec3 color = mix(uColorDeep, uColorMid, smoothstep(uThreshold, 0.5, t)); color = mix(color, uColorBright, smoothstep(0.5, 0.8, t)); color = mix(color, cWhite, smoothstep(0.8, 1.0, t)); float facing = dot(normalize(vNormal), normalize(vViewPosition)); float depthFactor = (facing + 1.0) * 0.5; float finalAlpha = alpha * (0.02 + 0.98 * depthFactor); gl_FragColor = vec4(color * uBrightness, finalAlpha); } `, transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false }); const plasmaMesh = new THREE.Mesh(plasmaGeo, plasmaMat); mainGroup.add(plasmaMesh); // 5. PARTICLES const pCount = 600; const pPos = new Float32Array(pCount * 3); const pSizes = new Float32Array(pCount); const sphereRadius = 0.95; for(let i = 0; i < pCount; i++) { const r = sphereRadius * Math.cbrt(Math.random()); const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1); pPos[i * 3] = r * Math.sin(phi) * Math.cos(theta); pPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta); pPos[i * 3 + 2] = r * Math.cos(phi); pSizes[i] = Math.random(); } const pGeo = new THREE.BufferGeometry(); pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3)); pGeo.setAttribute('aSize', new THREE.BufferAttribute(pSizes, 1)); const pMat = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0 }, uColor: { value: new THREE.Color(0xffffff) } }, vertexShader: ` uniform float uTime; attribute float aSize; varying float vAlpha; void main() { vec3 pos = position; // Subtle floating pos.y += sin(uTime * 0.2 + pos.x) * 0.02; pos.x += cos(uTime * 0.15 + pos.z) * 0.02; vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0); gl_Position = projectionMatrix * mvPosition; float baseSize = 8.0 * aSize + 4.0; gl_PointSize = baseSize * (1.0 / -mvPosition.z); vAlpha = 0.8 + 0.2 * sin(uTime + aSize * 10.0); } `, fragmentShader: ` uniform vec3 uColor; varying float vAlpha; void main() { vec2 uv = gl_PointCoord - vec2(0.5); float dist = length(uv); if(dist > 0.5) discard; float glow = 1.0 - (dist * 2.0); glow = pow(glow, 1.8); gl_FragColor = vec4(uColor, glow * vAlpha); } `, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }); const particles = new THREE.Points(pGeo, pMat); mainGroup.add(particles); // --- GUI SETUP --- const gui = new GUI({ title: 'Settings' }); // Plasma Folder const folderPlasma = gui.addFolder('Plasma'); folderPlasma.add(params, 'timeScale', 0.0, 2.0).name('Anim Speed'); folderPlasma.add(params, 'plasmaScale', 0.05, 0.5).name('Texture Scale').onChange(v => plasmaMat.uniforms.uScale.value = v); folderPlasma.add(params, 'plasmaBrightness', 0.5, 3.0).name('Brightness').onChange(v => plasmaMat.uniforms.uBrightness.value = v); folderPlasma.add(params, 'voidThreshold', 0.0, 0.8).name('Voids').onChange(v => plasmaMat.uniforms.uThreshold.value = v); folderPlasma.addColor(params, 'colorDeep').name('Color Deep').onChange(v => plasmaMat.uniforms.uColorDeep.value.set(v)); folderPlasma.addColor(params, 'colorMid').name('Color Mid').onChange(v => plasmaMat.uniforms.uColorMid.value.set(v)); folderPlasma.addColor(params, 'colorBright').name('Color Bright').onChange(v => plasmaMat.uniforms.uColorBright.value.set(v)); // Shell Folder const folderShell = gui.addFolder('Shell'); folderShell.addColor(params, 'shellColor').name('Edge Color').onChange(v => shellFrontMat.uniforms.uColor.value.set(v)); folderShell.add(params, 'shellOpacity', 0.0, 1.0).name('Edge Opacity').onChange(v => shellFrontMat.uniforms.uOpacity.value = v); // Rotation Folder const folderRot = gui.addFolder('Rotation'); folderRot.add(params, 'rotationSpeedX', -0.01, 0.01).name('Speed X'); folderRot.add(params, 'rotationSpeedY', -0.01, 0.01).name('Speed Y'); // 6. ANIMATION LOOP const clock = new THREE.Clock(); function animate() { requestAnimationFrame(animate); const t = clock.getElapsedTime(); // Update uniforms plasmaMat.uniforms.uTime.value = t * params.timeScale; pMat.uniforms.uTime.value = t; // Rotation plasmaMesh.rotation.y = t * 0.08; mainGroup.rotation.x += params.rotationSpeedX; mainGroup.rotation.y += params.rotationSpeedY; controls.update(); renderer.render(scene, camera); } // Handle Resize window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }); animate();",
    "id": "magic-plasma-sphere---threejs"
  },
  {
    "title": "WebGL Experiment: interactive noisy ring",
    "description": "",
    "code": "index.html: <div class=\"page\"> <div class=\"title\"> <div>WebGL Experiment:</div> <div>playing with fBm and polar coordinates</div> <div>&nbsp;</div> <div>hover & click</div> </div> <canvas id=\"ring_shape-canvas\"></canvas> </div> <script type=\"x-shader/x-fragment\" id=\"vertShader\"> precision mediump float; varying vec2 vUv; attribute vec2 a_position; void main() { vUv = .5 * (a_position + 1.); gl_Position = vec4(a_position, 0.0, 1.0); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShader\"> precision mediump float; varying vec2 vUv; uniform float u_time; uniform float u_ratio; uniform float u_click_time; uniform vec2 u_pointer; uniform vec2 u_click; #define TWO_PI 6.28318530718 #define PI 3.14159265358979323846 // ------------------------------------------------ // Generic fractional Brownian motion (fBm) noise float rand(vec2 n) { return fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); } float noise(vec2 n) { const vec2 d = vec2(0.0, 1.0); vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n)); return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y); } float fbm(vec2 n) { float total = 0.0, amplitude = .4; for (int i = 0; i < 12; i++) { total += noise(n) * amplitude; n += n; amplitude *= 0.6; } return total; } // ------------------------------------------------ float get_ring_shape(vec2 uv, float innerRadius, float outerRadius) { float distance = length(uv); float line_width = outerRadius - innerRadius; float ringValue = smoothstep(innerRadius, innerRadius + line_width, distance); ringValue -= smoothstep(outerRadius, outerRadius + line_width, distance); return clamp(ringValue, 0., 1.); } float get_dot_shape(vec2 uv, vec2 center, float pwr) { float mouse_center_dist = length(center); float pointer_shape = 1. - length(uv - center); pointer_shape = clamp(pointer_shape, 0., 1.); pointer_shape = pow(pointer_shape, pwr); pointer_shape *= .18; return pointer_shape; } float get_sym_impulse(float v, float pwr) { return 1. - pow(1. - pow(2. * v - 1., 4.), pwr); } // ------------------------------------------------ void main() { vec2 uv = vUv * 2. - 1.; uv.x *= u_ratio; float noise_scale = 4.; // overall speed float t = .0003 * u_time; float t_click = .001 * u_click_time; // timing float expl_duration = 3.5; float t_click_explosion = (1. - step(expl_duration, t_click)) * t_click; t_click_explosion = pow(t_click_explosion, .6); // float atg = atan(uv.y, uv.x); float angle = (atg + PI) / TWO_PI; // radial noise vec2 polar_uv = vec2(atg, t + 2. / pow(length(uv), .5)); polar_uv *= noise_scale; float noise_left = fbm(polar_uv); polar_uv.x = mod(polar_uv.x, noise_scale * TWO_PI); float noise_right = fbm(polar_uv); float noise = mix(noise_right, noise_left, smoothstep(-.2, .2, uv.x)); // cursor coordinates vec2 point = u_pointer * 2. - 1.; point.x *= u_ratio; vec2 click = u_click * 2. - 1.; click.x *= u_ratio; // pointer following the cursor float pointer_shape = 0.; const int points_num = 5; // split it to 5 points on click for (int i = 0; i < points_num; i++) { float a = float(i) / float(points_num) * TWO_PI; a += 4. * t; float sp = 6. * t_click_explosion * max(.2, rand(vec2(float(i)))); float x = sp * cos(a); float y = -sp * sin(a); pointer_shape += get_dot_shape(uv, click + vec2(x, y), 2.); } // keep the constant point size pointer_shape /= float(points_num); pointer_shape *= min(5., 14. * t_click_explosion); pointer_shape += get_dot_shape(uv, point, 4.); // darken in the enter float center_shape = 1. - pow(smoothstep(2., .0, length(uv)), 50.); pointer_shape *= center_shape; // draw ring float radius = .7 + .5 * pointer_shape; float thickness = .1; thickness += .75 * pow(pointer_shape, .6); float ring_shape = get_ring_shape(uv * (.9 + .4 * noise), radius - .8 * thickness, radius + .2 * thickness); // radial gradient to be used for pointer vec3 radial_color = vec3(0.); radial_color.r = .5 + get_sym_impulse(fract(angle + .2 * t), 4.); radial_color.g = 2. * get_sym_impulse(fract(angle + .2 * t), 10.); radial_color.b = smoothstep(4., 0., radial_color.r); // apply shapes to colors vec3 point_color = radial_color; point_color.r *= 60. * pow(pointer_shape, 2.); point_color *= pointer_shape; vec3 ring_color = vec3(1.); ring_color *= ring_shape; // vec3 color = ring_color; color += point_color; gl_FragColor = vec4(color, 1.); } </script>\nstyle.css: body, html { margin: 0; padding: 0; \t background: black; } .page { font-family: sans-serif; color: #eeeeee; } canvas#ring_shape-canvas { display: block; z-index: 2; \t width: 100%; } .title { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2vh; text-align: center; z-index: 2; }\nscript.js: const canvasEl = document.querySelector(\"#ring_shape-canvas\"); const pageEl = document.querySelector(\".page\"); const uniforms = { timeLocation: null, ratioLocation: null, clickTimeLocation: null, pointerLocation: null, clickLocation: null, } let clickTime = 0; const mouseThreshold = .6; let wasClicked = false; let mouse = { x: -.5 * window.innerWidth, y: .5 * window.innerHeight, tX: -.5 * window.innerWidth, tY: .5 * window.innerHeight, } const gl = initShader(); render(); window.addEventListener(\"resize\", resizeCanvas); resizeCanvas(); window.addEventListener(\"mousemove\", e => { updateMousePosition(e.pageX, e.pageY); }); window.addEventListener(\"touchmove\", e => { updateMousePosition(e.targetTouches[0].pageX, e.targetTouches[0].pageY); }); pageEl.addEventListener(\"click\", e => { updateMousePosition(e.pageX, e.pageY); gl.uniform2f(uniforms.clickLocation, mouse.x / window.innerWidth, 1. - mouse.y / window.innerHeight); wasClicked = true; clickTime = performance.now(); }); function updateMousePosition(eX, eY) { mouse.tX = eX; mouse.tY = eY; } function initShader() { const vsSource = document.getElementById(\"vertShader\").innerHTML; const fsSource = document.getElementById(\"fragShader\").innerHTML; const gl = canvasEl.getContext(\"webgl\") || canvasEl.getContext(\"experimental-webgl\"); if (!gl) { alert(\"WebGL is not supported by your browser.\"); } function createShader(gl, sourceCode, type) { const shader = gl.createShader(type); gl.shaderSource(shader, sourceCode); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; } return shader; } const vertexShader = createShader(gl, vsSource, gl.VERTEX_SHADER); const fragmentShader = createShader(gl, fsSource, gl.FRAGMENT_SHADER); function createShaderProgram(gl, vertexShader, fragmentShader) { const program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error(\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program)); return null; } return program; } const shaderProgram = createShaderProgram(gl, vertexShader, fragmentShader); const vertices = new Float32Array([-1., -1., 1., -1., -1., 1., 1., 1.]); const vertexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); gl.useProgram(shaderProgram); const positionLocation = gl.getAttribLocation(shaderProgram, \"a_position\"); gl.enableVertexAttribArray(positionLocation); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0); uniforms.timeLocation = gl.getUniformLocation(shaderProgram, \"u_time\"); uniforms.ratioLocation = gl.getUniformLocation(shaderProgram, \"u_ratio\"); uniforms.clickTimeLocation = gl.getUniformLocation(shaderProgram, \"u_click_time\"); uniforms.pointerLocation = gl.getUniformLocation(shaderProgram, \"u_pointer\"); uniforms.clickLocation = gl.getUniformLocation(shaderProgram, \"u_click\"); return gl; } function render() { const currentTime = performance.now(); gl.uniform1f(uniforms.timeLocation, currentTime); if (wasClicked) { gl.uniform1f(uniforms.clickTimeLocation, currentTime - clickTime); } gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); mouse.x += (mouse.tX - mouse.x) * mouseThreshold; mouse.y += (mouse.tY - mouse.y) * mouseThreshold; gl.uniform2f(uniforms.pointerLocation, mouse.x / window.innerWidth, 1. - mouse.y / window.innerHeight); requestAnimationFrame(render); } function resizeCanvas() { \t canvasEl.width = window.innerWidth * devicePixelRatio; canvasEl.height = window.innerHeight * devicePixelRatio; gl.viewport(0, 0, canvasEl.width, canvasEl.height); gl.uniform1f(uniforms.ratioLocation, window.innerWidth / window.innerHeight); }",
    "id": "webgl-experiment-interactive-noisy-ring"
  },
  {
    "title": "Celestial Ascension",
    "description": "",
    "code": "index.html: <script type=\"importmap\"> \t{ \t\t\"imports\": { \t\t\t\"three\": \"https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js\", \t\t\t\t\"jsm/\": \"https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/\" \t\t} \t} </script>\nstyle.css: body { \tmargin: 0; \tpadding: 0; \toverflow: hidden; \tbackground-color: black; }\nscript.js: import * as THREE from \"three\"; import { OrbitControls } from \"jsm/controls/OrbitControls.js\"; import { EffectComposer } from \"jsm/postprocessing/EffectComposer.js\"; import { RenderPass } from \"jsm/postprocessing/RenderPass.js\"; import { UnrealBloomPass } from \"jsm/postprocessing/UnrealBloomPass.js\"; import { OBJLoader } from \"jsm/loaders/OBJLoader.js\"; const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera( \t75, \twindow.innerWidth / window.innerHeight, \t0.1, \t1000 ); camera.position.x = 1.2; camera.position.z = -0.1; camera.position.y = -0.5; const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.toneMapping = THREE.ReinhardToneMapping; document.body.appendChild(renderer.domElement); const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; const renderScene = new RenderPass(scene, camera); const bloomPass = new UnrealBloomPass( \tnew THREE.Vector2(window.innerWidth, window.innerHeight), \t0.2, \t0.4, // radius \t0.2 // threshold ); bloomPass.strength = 2.5; bloomPass.radius = 0.8; bloomPass.threshold = 0.2; const composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass); const R = 0.9; const r = 0.8; renderer.localClippingEnabled = true; const planeFront = new THREE.Plane(new THREE.Vector3(0, 0, 1), 1); const planeBack = new THREE.Plane(new THREE.Vector3(0, 0, -1), 1); const planeLeft = new THREE.Plane(new THREE.Vector3(1, 0, 0), 1); const planeRight = new THREE.Plane(new THREE.Vector3(-1, 0, 0), 1); const clippingPlanes = [planeFront, planeBack, planeLeft, planeRight]; const lineCount = 90; const segmentsPerLine = 2000; const spiralRevolutions = 0.4; const tornadoGroup = new THREE.Group(); scene.add(tornadoGroup); const linesData = []; function getTorusPoint(u, v, target, rOffset = 0) { \tconst effectiveR = r + rOffset; \tconst x = (R + effectiveR * Math.cos(v)) * Math.cos(u); \tconst y = (R + effectiveR * Math.cos(v)) * Math.sin(u); \tconst z = effectiveR * Math.sin(v); \ttarget.set(x, y, z); } const lineVertexShader = ` varying vec3 vPosition; varying float vDistanceFromCenter; void main() { vPosition = position; float distanceFromCenter = sqrt(position.x * position.x + position.z * position.z); vDistanceFromCenter = distanceFromCenter; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `; const lineFragmentShader = ` uniform vec3 uColor; uniform float uFadeDistance; uniform float uFadeStart; varying vec3 vPosition; varying float vDistanceFromCenter; void main() { float maxDistance = .9; float fadeStart = uFadeStart; float fadeEnd = .9; float normalizedDistance = vDistanceFromCenter / maxDistance; float fade = 1.0; if (normalizedDistance > fadeStart) { fade = 1.0 - smoothstep(fadeStart, fadeEnd, normalizedDistance); } float zFade = 1.0; if (abs(vPosition.z) > 0.5) { zFade = 1.0 - smoothstep(0.5, 0.9, abs(vPosition.z)); } float xFade = 1.0; if (abs(vPosition.x) > 0.5) { xFade = 1.0 - smoothstep(0.5, 0.9, abs(vPosition.x)); } float finalAlpha = fade * zFade * xFade; gl_FragColor = vec4(uColor, finalAlpha); } `; for (let i = 0; i < lineCount; i++) { \tconst geometry = new THREE.BufferGeometry(); \tconst positions = new Float32Array(segmentsPerLine * 3); \tgeometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3)); \tconst phaseOffset = Math.random() * Math.PI * 2; \tconst speed = 0.001 + Math.random() * 0.001; \tconst length = Math.PI * 3 + Math.random() * Math.PI; \tconst material = new THREE.ShaderMaterial({ \t\tvertexShader: lineVertexShader, \t\tfragmentShader: lineFragmentShader, \t\tuniforms: { \t\t\tuColor: { value: new THREE.Vector3(0.4, 0.8, 1.0) }, \t\t\tuFadeDistance: { value: 0.5 }, \t\t\tuFadeStart: { value: 0.6 }, \t\t}, \t\ttransparent: true, \t\tblending: THREE.AdditiveBlending, \t\tclippingPlanes: clippingPlanes, \t\tdepthWrite: false, \t}); \tconst line = new THREE.Line(geometry, material); \ttornadoGroup.add(line); \tlinesData.push({ \t\tline: line, \t\tpositions: positions, \t\tphaseOffset: phaseOffset, \t\tspeed: speed, \t\tlength: length, \t\tuOffset: Math.random() * Math.PI * 2, \t\trOffset: (Math.random() - 0.2) * 0.1, \t}); } const particleCount = 10000; const particlesGeometry = new THREE.BufferGeometry(); const particlePositions = new Float32Array(particleCount * 3); particlesGeometry.setAttribute( \t\"position\", \tnew THREE.BufferAttribute(particlePositions, 3) ); const particlesMaterial = new THREE.PointsMaterial({ \tcolor: 0x66ccff, \tsize: 0.002, \ttransparent: true, \topacity: 0.2, \tblending: THREE.AdditiveBlending, \tclippingPlanes: clippingPlanes, }); const particles = new THREE.Points(particlesGeometry, particlesMaterial); tornadoGroup.add(particles); const particlesData = []; for (let i = 0; i < particleCount; i++) { \tparticlesData.push({ \t\tuOffset: Math.random() * Math.PI * 2, \t\tphaseOffset: Math.random() * Math.PI * 2, \t\tspeed: 0.0001 - Math.random() * 0.001, \t\tradiusOffset: (Math.random() - 0.1) * 0.2, // More volume \t}); } tornadoGroup.rotation.x = Math.PI / 2; tornadoGroup.rotation.y = THREE.MathUtils.degToRad(18); scene.background = new THREE.Color(0x000000); const ambientLight = new THREE.AmbientLight(0x404040); scene.add(ambientLight); const dirLight = new THREE.DirectionalLight(0xffffff, 2); dirLight.position.set(0, 5, 5); scene.add(dirLight); let angelModel = null; const loader = new OBJLoader(); loader.load( \"https://cdn.jsdelivr.net/gh/danielyl123/person/person.obj\", \tfunction (object) { \t\tconst box = new THREE.Box3().setFromObject(object); \t\tconst center = box.getCenter(new THREE.Vector3()); \t\tobject.position.sub(center); \t\tconst size = box.getSize(new THREE.Vector3()); \t\tconst maxDim = Math.max(size.x, size.y, size.z); \t\tconst scale = 0.13 / maxDim; \t\tobject.scale.set(scale, scale, scale); \t\tobject.position.set(0.9, -0.6, 0); \t\tobject.rotation.y = Math.PI / -2; \t\tobject.traverse(function (child) { \t\t\tif (child.isMesh) { \t\t\t\tchild.material = new THREE.MeshStandardMaterial({ \t\t\t\t\tcolor: 0xaaaaaa, // Silver/White \t\t\t\t\troughness: 0.3, \t\t\t\t\tmetalness: 0.8, \t\t\t\t\tside: THREE.DoubleSide, \t\t\t\t}); \t\t\t} \t\t}); \t\tscene.add(object); \t\tangelModel = object; \t\tconsole.log(\"Angel loaded at center\"); \t}, \tfunction (xhr) { \t\tconsole.log((xhr.loaded / xhr.total) * 100 + \"% loaded\"); \t}, \tfunction (error) { \t\tconsole.error(\"Error loading angel:\", error); \t} ); function animate() { \trequestAnimationFrame(animate); \tconst time = Date.now() * 0.001; \tlinesData.forEach((data) => { \t\tdata.uOffset += data.speed; \t\tconst positions = data.positions; \t\tconst tempVec = new THREE.Vector3(); \t\tfor (let j = 0; j < segmentsPerLine; j++) { \t\t\tconst t = j / (segmentsPerLine - 1); \t\t\tconst currentU = data.uOffset - t * data.length; \t\t\tconst currentV = \t\t\t\t\t\tcurrentU * spiralRevolutions + data.phaseOffset + time * 0.4; \t\t\tgetTorusPoint(currentU, currentV, tempVec, data.rOffset); \t\t\tpositions[j * 3] = tempVec.x; \t\t\tpositions[j * 3 + 1] = tempVec.y; \t\t\tpositions[j * 3 + 2] = tempVec.z; \t\t} \t\tdata.line.geometry.attributes.position.needsUpdate = true; \t}); \tconst pPositions = particlesGeometry.attributes.position.array; \tparticlesData.forEach((data, i) => { \t\tdata.uOffset += data.speed; \t\tconst currentU = data.uOffset; \t\tconst currentV = \t\t\t\t\tcurrentU * spiralRevolutions + data.phaseOffset + time * 0.2; \t\tconst effectiveR = r + data.radiusOffset; \t\tconst x = (R + effectiveR * Math.cos(currentV)) * Math.cos(currentU); \t\tconst y = (R + effectiveR * Math.cos(currentV)) * Math.sin(currentU); \t\tconst z = effectiveR * Math.sin(currentV); \t\tpPositions[i * 3] = x; \t\tpPositions[i * 3 + 1] = y; \t\tpPositions[i * 3 + 2] = z; \t}); \tparticlesGeometry.attributes.position.needsUpdate = true; \tif (angelModel) { \t\tangelModel.position.y = -0.55 + Math.sin(time * 2) * 0.01; \t} \tcontrols.update(); \trenderer.render(scene, camera); \tcomposer.render(); } animate(); window.addEventListener(\"resize\", () => { \tcamera.aspect = window.innerWidth / window.innerHeight; \tcamera.updateProjectionMatrix(); \trenderer.setSize(window.innerWidth, window.innerHeight); });",
    "id": "celestial-ascension"
  },
  {
    "title": "cg-lusion-fluid-particles",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Lusion Fluid Simulation | mukta</title>\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js\"></script>\n  </head>\n  <body>\n    <div class=\"header\">\n      <p>Is your big idea ready to go wild?</p>\n      <h1>\n        Let's work <br />\n        together!\n      </h1>\n      <button>Let's talk</button>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "let particles = [];\nconst particleCount = 250;\nconst particleSize = 12;\nconst spacing = particleSize * 12;\nlet gravity;\nlet deltaTime = 1 / 60;\nlet mousePrevX = 0;\nlet mousePrevY = 0;\n\nclass Particle {\n  constructor(x, y) {\n    this.pos = createVector(x, y);\n    this.vel = createVector(random(-20, 20), random(-20, 20));\n    this.acc = createVector(0, 0);\n    this.color = color(255, 255, 255);\n    this.lastPos = createVector(x, y);\n    this.densityFactor = 0;\n    this.rotation = random(TWO_PI);\n    this.rotationVel = random(-0.1, 0.1);\n    this.shapeType = random([\"triangle\", \"square\", \"circle\"]);\n  }\n\n  update() {\n    this.lastPos.x = this.pos.x;\n    this.lastPos.y = this.pos.y;\n\n    this.rotation += this.rotationVel * deltaTime;\n\n    let gravityScale = map(this.densityFactor, 0, 5, 1, 0.7);\n    this.acc.add(p5.Vector.mult(gravity, 4 * gravityScale));\n\n    if (mouseIsPressed) {\n      let d = dist(this.pos.x, this.pos.y, mouseX, mouseY);\n      let maxDist = 250;\n      if (d < maxDist) {\n        let mouseVel = createVector(mouseX - mousePrevX, mouseY - mousePrevY);\n        let densityScale = map(this.densityFactor, 0, 5, 1, 0.85);\n        let force = mouseVel.copy().mult(10 * densityScale);\n        let strength = pow(map(d, 0, maxDist, 1, 0), 1.75);\n        force.mult(strength);\n        this.acc.add(force);\n        this.rotationVel += mouseVel.mag() * 0.01 * random(-1, 1);\n      }\n    }\n\n    let dampingFactor = map(this.densityFactor, 0, 5, 1, 1);\n    this.vel.add(p5.Vector.mult(this.acc, deltaTime * 15.0 * dampingFactor));\n\n    if (this.pos.y > height - particleSize * 2) {\n      this.vel.mult(0.92);\n      this.vel.x *= 0.94;\n      this.rotationVel *= 0.95;\n    } else {\n      this.vel.mult(0.985);\n      this.rotationVel *= 0.99;\n    }\n\n    this.pos.add(p5.Vector.mult(this.vel, deltaTime * 11.5));\n\n    let bounce = 0.45;\n    let buffer = particleSize;\n\n    if (this.pos.x < buffer) {\n      this.pos.x = buffer;\n      this.vel.x = abs(this.vel.x) * bounce;\n    }\n    if (this.pos.x > width - buffer) {\n      this.pos.x = width - buffer;\n      this.vel.x = -abs(this.vel.x) * bounce;\n    }\n    if (this.pos.y < buffer) {\n      this.pos.y = buffer;\n      this.vel.y = abs(this.vel.y) * bounce;\n    }\n    if (this.pos.y > height - buffer) {\n      this.pos.y = height - buffer;\n      this.vel.y = -abs(this.vel.y) * bounce;\n    }\n\n    this.acc.mult(0);\n    this.densityFactor = 0;\n  }\n\n  draw() {\n    noStroke();\n    fill(this.color);\n\n    let renderX = lerp(this.lastPos.x, this.pos.x, 0.5);\n    let renderY = lerp(this.lastPos.y, this.pos.y, 0.5);\n\n    push();\n    translate(renderX, renderY);\n    rotate(this.rotation);\n\n    let size = particleSize * 1;\n\n    switch (this.shapeType) {\n      case \"triangle\":\n        triangle(-size / 2, size / 2, size / 2, size / 2, 0, -size / 2);\n        break;\n      case \"square\":\n        rectMode(CENTER);\n        rect(0, 0, size, size);\n        break;\n      case \"circle\":\n        circle(0, 0, size);\n        break;\n    }\n\n    pop();\n  }\n\n  interact(other) {\n    let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);\n\n    if (d < spacing) {\n      let densityIncrease = map(d, 0, spacing, 1.2, 0.1);\n      this.densityFactor += densityIncrease;\n      other.densityFactor += densityIncrease;\n\n      let force = p5.Vector.sub(this.pos, other.pos);\n      force.normalize();\n\n      let strength = map(d, 0, spacing, 0.8, 0);\n      strength = pow(strength, 1.1);\n      force.mult(strength);\n\n      let overlap = spacing - d;\n      if (overlap > 0) {\n        let correctionStrength = map(overlap, 0, spacing, 0.15, 0.25);\n        let correction = force.copy().mult(overlap * correctionStrength);\n\n        let boundaryFactor = 1.0;\n        if (\n          this.pos.y > height - particleSize * 4 ||\n          other.pos.y > height - particleSize * 4\n        ) {\n          boundaryFactor = 0.7;\n        }\n\n        correction.mult(boundaryFactor);\n\n        let densityScale = map(\n          this.densityFactor + other.densityFactor,\n          0,\n          10,\n          1,\n          0.9\n        );\n\n        let correctionWeight = 0.15 * densityScale;\n        this.pos.add(p5.Vector.mult(correction, correctionWeight));\n        other.pos.sub(p5.Vector.mult(correction, correctionWeight));\n\n        let avgVel = p5.Vector.add(this.vel, other.vel).mult(0.5);\n        let velocityBlend = map(d, 0, spacing, 0.15, 0.02);\n        velocityBlend *= map(\n          this.densityFactor + other.densityFactor,\n          0,\n          10,\n          1.2,\n          0.95\n        );\n\n        if (d < spacing * 0.5) {\n          velocityBlend *= 1.5;\n        }\n\n        this.vel.lerp(avgVel, velocityBlend);\n        other.vel.lerp(avgVel, velocityBlend);\n      }\n\n      let accForce = force.copy().mult(0.4);\n      this.acc.add(accForce);\n      other.acc.sub(accForce);\n    }\n  }\n}\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  frameRate(60);\n  gravity = createVector(0, 2.2);\n  background(\"#1a2ffb\");\n\n  let availableWidth = width * 0.95;\n  let cols = floor(availableWidth / spacing);\n  let requiredRows = ceil(particleCount / cols);\n  let startX = (width - cols * spacing) * 0.5;\n  let startY = height * 0.05;\n\n  let count = 0;\n  let row = 0;\n\n  while (count < particleCount) {\n    for (let col = 0; col < cols && count < particleCount; col++) {\n      let x = startX + col * spacing + random(-5, 5);\n      let y = startY + row * spacing + random(-5, 5);\n      particles.push(new Particle(x, y));\n      count++;\n    }\n    row++;\n  }\n}\n\nfunction draw() {\n  background(\"#1a2ffb\");\n  deltaTime = 1 / frameRate();\n\n  let gridSize = spacing;\n  let grid = {};\n\n  for (let i = 0; i < particles.length; i++) {\n    let p = particles[i];\n    p.update();\n\n    let gridX = floor(p.pos.x / gridSize);\n    let gridY = floor(p.pos.y / gridSize);\n    let key = gridX + \",\" + gridY;\n\n    if (!grid[key]) {\n      grid[key] = [];\n    }\n    grid[key].push(i);\n  }\n\n  for (let key in grid) {\n    let cell = grid[key];\n    let [gx, gy] = key.split(\",\").map(Number);\n\n    for (let dx = -1; dx <= 1; dx++) {\n      for (let dy = -1; dy <= 1; dy++) {\n        let neighborKey = gx + dx + \",\" + (gy + dy);\n        if (grid[neighborKey]) {\n          for (let i of cell) {\n            for (let j of grid[neighborKey]) {\n              if (i < j) {\n                particles[i].interact(particles[j]);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  for (let p of particles) {\n    p.draw();\n  }\n\n  mousePrevX = mouseX;\n  mousePrevY = mouseY;\n}\n\nfunction windowResized() {\n  resizeCanvas(windowWidth, windowHeight);\n}\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  width: 100%;\n  height: 100%;\n  font-family: \"Aeonik\";\n  background-color: #1a2ffb;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.header {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  user-select: none;\n  z-index: 2;\n}\n\n.header p {\n  color: #fff;\n  text-transform: uppercase;\n  font-weight: 400;\n  margin-bottom: 1.5em;\n}\n\n.header h1 {\n  color: #fff;\n  text-align: center;\n  font-size: 7.5vw;\n  font-weight: 400;\n  line-height: 100%;\n  margin-bottom: 0.75em;\n}\n\nbutton {\n  border: none;\n  outline: none;\n  padding: 1.5em 3em;\n  text-transform: uppercase;\n  font-weight: 500;\n  background-color: #fff;\n  border-radius: 2em;\n}\n"
    }
  },
  {
    "title": "Neuro Noise (GLSL Shader)",
    "description": "",
    "code": "index.html: <div class=\"content\"> <div class=\"section\"> <div> Neural Noise </div> </div> <div class=\"section\"> <div> GLSL shader based on <a href=\"https://x.com/zozuar/\" target=\"_blank\">@zozuar</a> <a href=\"https://x.com/zozuar/status/1625182758745128981/\" target=\"_blank\">artwork</a> </div> </div> <div class=\"section\"> <div> <a href=\"https://linkedin.com/in/ksenia-kondrashova/\" target=\"_blank\">linkedIn</a> \t\t\t <a href=\"https://codepen.io/ksenia-k\" target=\"_blank\">codepen</a> \t\t\t <a href=\"https://x.com/uuuuuulala\" target=\"_top\">X (twitter)</a> </div> </div> </div> <canvas id=\"neuro\"></canvas> <script type=\"x-shader/x-fragment\" id=\"vertShader\"> precision mediump float; varying vec2 vUv; attribute vec2 a_position; void main() { vUv = .5 * (a_position + 1.); gl_Position = vec4(a_position, 0.0, 1.0); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShader\"> precision mediump float; varying vec2 vUv; uniform float u_time; uniform float u_ratio; uniform vec2 u_pointer_position; uniform float u_scroll_progress; vec2 rotate(vec2 uv, float th) { return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv; } float neuro_shape(vec2 uv, float t, float p) { vec2 sine_acc = vec2(0.); vec2 res = vec2(0.); float scale = 8.; for (int j = 0; j < 15; j++) { uv = rotate(uv, 1.); sine_acc = rotate(sine_acc, 1.); vec2 layer = uv * scale + float(j) + sine_acc - t; sine_acc += sin(layer) + 2.4 * p; res += (.5 + .5 * cos(layer)) / scale; scale *= (1.2); } return res.x + res.y; } void main() { vec2 uv = .5 * vUv; uv.x *= u_ratio; vec2 pointer = vUv - u_pointer_position; pointer.x *= u_ratio; float p = clamp(length(pointer), 0., 1.); p = .5 * pow(1. - p, 2.); float t = .001 * u_time; vec3 color = vec3(0.); float noise = neuro_shape(uv, t, p); noise = 1.2 * pow(noise, 3.); noise += pow(noise, 10.); noise = max(.0, noise - .5); noise *= (1. - length(vUv - .5)); color = normalize(vec3(.2, .5 + .4 * cos(3. * u_scroll_progress), .5 + .5 * sin(3. * u_scroll_progress))); color = color * noise; gl_FragColor = vec4(color, noise); } </script>\nstyle.css: body, html { margin: 0; padding: 0; background-color: #151912; \t overflow-x: hidden; } .content { width: 100vw; font-family: 'Times New Roman', serif; } .section { width: 100%; height: 100vh; display: flex; justify-content: center; align-items: center; color: #FFF6F7; text-align: center; } .section > div { width: 90%; } .section:nth-child(1) { font-size: 20vh; } @media (max-width: 600px) { .section:nth-child(1) { font-size: 25vw; } } @media (max-width: 350px) { .section:nth-child(1) { font-size: 30px; } } .section:nth-child(2) { font-size: 10vh; } .section:nth-child(3) { font-size: 8vh; } .section:nth-child(2) > div { max-width: 800px } .section:nth-child(3) > div { max-width: 900px } @media (max-width: 750px) { .section:nth-child(2), .section:nth-child(3) { font-size: 9vw; } } .section:nth-child(3) a { padding: 0 .3em; } canvas#neuro { position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; opacity: .95; } a { display: inline-block; text-decoration: none; color: inherit; font-weight: inherit; font-style: inherit; } a:hover { font-weight: inherit; text-decoration: none; color: rgb(160, 160, 255); } a:active { color: rgb(160, 255, 255); } body, html { margin: 0; padding: 0; background-color: #151912; } .content { width: 100vw; font-family: 'Times New Roman', serif; } .section { width: 100%; height: 100vh; display: flex; justify-content: center; align-items: center; color: #FFF6F7; text-align: center; } .section > div { width: 90%; } .section:nth-child(1) { font-size: 20vh; } @media (max-width: 600px) { .section:nth-child(1) { font-size: 25vw; } } @media (max-width: 350px) { .section:nth-child(1) { font-size: 30px; } } .section:nth-child(2) { font-size: 10vh; } .section:nth-child(3) { font-size: 8vh; } .section:nth-child(2) > div { max-width: 800px } .section:nth-child(3) > div { max-width: 900px } @media (max-width: 750px) { .section:nth-child(2), .section:nth-child(3) { font-size: 9vw; } } .section:nth-child(3) a { padding: 0 .3em; } canvas#neuro { position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; opacity: .95; } a { display: inline-block; text-decoration: none; color: inherit; font-weight: inherit; font-style: inherit; } a:hover { font-weight: inherit; text-decoration: none; color: rgb(160, 160, 255); } a:active { color: rgb(160, 255, 255); }\nscript.js: const containerEl = document.querySelector(\".container\"); const canvasEl = document.querySelector(\"canvas#neuro\"); const devicePixelRatio = Math.min(window.devicePixelRatio, 2); const pointer = { x: 0, y: 0, tX: 0, tY: 0, }; let uniforms; const gl = initShader(); setupEvents(); resizeCanvas(); window.addEventListener(\"resize\", resizeCanvas); render(); function initShader() { const vsSource = document.getElementById(\"vertShader\").innerHTML; const fsSource = document.getElementById(\"fragShader\").innerHTML; const gl = canvasEl.getContext(\"webgl\") || canvasEl.getContext(\"experimental-webgl\"); if (!gl) { alert(\"WebGL is not supported by your browser.\"); } function createShader(gl, sourceCode, type) { const shader = gl.createShader(type); gl.shaderSource(shader, sourceCode); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; } return shader; } const vertexShader = createShader(gl, vsSource, gl.VERTEX_SHADER); const fragmentShader = createShader(gl, fsSource, gl.FRAGMENT_SHADER); function createShaderProgram(gl, vertexShader, fragmentShader) { const program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error(\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program)); return null; } return program; } const shaderProgram = createShaderProgram(gl, vertexShader, fragmentShader); uniforms = getUniforms(shaderProgram); function getUniforms(program) { let uniforms = []; let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); for (let i = 0; i < uniformCount; i++) { let uniformName = gl.getActiveUniform(program, i).name; uniforms[uniformName] = gl.getUniformLocation(program, uniformName); } return uniforms; } const vertices = new Float32Array([-1., -1., 1., -1., -1., 1., 1., 1.]); const vertexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); gl.useProgram(shaderProgram); const positionLocation = gl.getAttribLocation(shaderProgram, \"a_position\"); gl.enableVertexAttribArray(positionLocation); gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0); return gl; } function render() { const currentTime = performance.now(); pointer.x += (pointer.tX - pointer.x) * .2; pointer.y += (pointer.tY - pointer.y) * .2; gl.uniform1f(uniforms.u_time, currentTime); gl.uniform2f(uniforms.u_pointer_position, pointer.x / window.innerWidth, 1 - pointer.y / window.innerHeight); gl.uniform1f(uniforms.u_scroll_progress, window[\"pageYOffset\"] / (2 * window.innerHeight)); gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); requestAnimationFrame(render); } function resizeCanvas() { canvasEl.width = window.innerWidth * devicePixelRatio; canvasEl.height = window.innerHeight * devicePixelRatio; gl.uniform1f(uniforms.u_ratio, canvasEl.width / canvasEl.height); gl.viewport(0, 0, canvasEl.width, canvasEl.height); } function setupEvents() { window.addEventListener(\"pointermove\", e => { updateMousePosition(e.clientX, e.clientY); }); window.addEventListener(\"touchmove\", e => { updateMousePosition(e.targetTouches[0].clientX, e.targetTouches[0].clientY); }); window.addEventListener(\"click\", e => { updateMousePosition(e.clientX, e.clientY); }); function updateMousePosition(eX, eY) { pointer.tX = eX; pointer.tY = eY; } }",
    "id": "neuro-noise-glsl-shader"
  },
  {
    "title": "Supernova Remnant - Three.js + GLSL",
    "description": "",
    "code": "index.html: <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Supernova Remnant</title> <style> body { margin: 0; overflow: hidden; background-color: #000; } canvas { display: block; } #theme-button { position: absolute; top: 20px; right: 20px; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 10px; padding: 10px 20px; color: white; font-family: Arial, sans-serif; font-size: 16px; cursor: pointer; transition: all 0.3s ease; z-index: 1; animation: borderGlow 5s linear infinite; } #theme-button:hover { background: rgba(255, 255, 255, 0.2); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); } @keyframes borderGlow { 0% { border-color: rgba(100, 181, 246, 0.8); box-shadow: 0 0 10px rgba(100, 181, 246, 0.8), 0 0 20px rgba(100, 181, 246, 0.5); } 25% { border-color: rgba(255, 152, 0, 0.8); box-shadow: 0 0 10px rgba(255, 152, 0, 0.8), 0 0 20px rgba(255, 152, 0, 0.5); } 50% { border-color: rgba(186, 104, 200, 0.8); box-shadow: 0 0 10px rgba(186, 104, 200, 0.8), 0 0 20px rgba(186, 104, 200, 0.5); } 75% { border-color: rgba(0, 188, 212, 0.8); box-shadow: 0 0 10px rgba(0, 188, 212, 0.8), 0 0 20px rgba(0, 188, 212, 0.5); } 100% { border-color: rgba(100, 181, 246, 0.8); box-shadow: 0 0 10px rgba(100, 181, 246, 0.8), 0 0 20px rgba(100, 181, 246, 0.5); } } </style> <script type=\"importmap\"> { \"imports\": { \"three\": \"https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js\" } } </script> <canvas id=\"gl-canvas\"></canvas> <button id=\"theme-button\">Change Theme</button> <script type=\"module\"> import * as THREE from 'three'; const scene = new THREE.Scene(); const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1); const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gl-canvas') }); const clock = new THREE.Clock(); const vertexShader = ` void main() { gl_Position = vec4(position, 1.0); } `; const fragmentShader = ` precision highp float; uniform vec2 u_resolution; uniform float u_time; uniform vec3 color_fil1_base; uniform vec3 color_fil1_glow; uniform vec3 color_fil2_base; uniform vec3 color_fil2_glow; uniform vec3 color_core; uniform vec3 color_stars; float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123); } float noise(vec2 st) { vec2 i = floor(st); vec2 f = fract(st); vec2 u = f * f * (3.0 - 2.0 * f); return mix(mix(random(i + vec2(0.0, 0.0)), random(i + vec2(1.0, 0.0)), u.x), mix(random(i + vec2(0.0, 1.0)), random(i + vec2(1.0, 1.0)), u.x), u.y); } float fbm(vec2 st) { float value = 0.0; float amplitude = 0.5; for (int i = 0; i < 6; i++) { value += amplitude * noise(st); st *= 2.0; amplitude *= 0.5; } return value; } float random3(vec3 st) { return fract(sin(dot(st, vec3(12.9898, 78.233, 45.543))) * 43758.5453123); } float noise3(vec3 st) { vec3 i = floor(st); vec3 f = fract(st); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix(random3(i + vec3(0.0, 0.0, 0.0)), random3(i + vec3(1.0, 0.0, 0.0)), u.x), mix(random3(i + vec3(0.0, 1.0, 0.0)), random3(i + vec3(1.0, 1.0, 0.0)), u.x), u.y), mix(mix(random3(i + vec3(0.0, 0.0, 1.0)), random3(i + vec3(1.0, 0.0, 1.0)), u.x), mix(random3(i + vec3(0.0, 1.0, 1.0)), random3(i + vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z); } float fbm3(vec3 st) { float value = 0.0; float amplitude = 0.5; for (int i = 0; i < 6; i++) { value += amplitude * noise3(st); st *= 2.0; amplitude *= 0.5; } return value; } void main() { vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y; float time = u_time * 0.3; vec3 final_color = vec3(0.0); float radius = length(uv); float angle = atan(uv.y, uv.x); vec3 gas_color = vec3(0.0); float speed1 = 0.5; float outer1 = time * speed1 + 1.5; float inner1 = outer1 - 0.5; float angular_scale1 = 3.0; float radial_scale1 = 3.0; vec3 p1 = vec3(sin(angle) * angular_scale1, cos(angle) * angular_scale1, radius * radial_scale1 + time * speed1); float filaments1 = fbm3(p1); filaments1 = 1.0 - abs(filaments1 - 0.5) * 2.0; filaments1 = pow(filaments1, 10.0); filaments1 *= smoothstep(outer1, inner1, radius); gas_color += filaments1 * color_fil1_base; gas_color += pow(filaments1, 12.0) * color_fil1_glow * 5.0; float speed2 = 0.8; float outer2 = time * speed2 + 1.5; float inner2 = outer2 - 0.4; float angular_scale2 = 5.0; float radial_scale2 = 4.0; vec3 p2 = vec3(sin(angle) * angular_scale2, cos(angle) * angular_scale2, radius * radial_scale2 + time * speed2) + vec3(3.7, 5.2, 1.3); float filaments2 = fbm3(p2); filaments2 = 1.0 - abs(filaments2 - 0.5) * 2.0; filaments2 = pow(filaments2, 15.0); filaments2 *= smoothstep(outer2, inner2, radius); gas_color += filaments2 * color_fil2_base; gas_color += pow(filaments2, 18.0) * color_fil2_glow * 5.0; float core_fade = smoothstep(1.5, 0.0, time); float core_texture = fbm(uv * 3.0 - time); float core_intensity = (1.0 - smoothstep(0.0, 0.2, radius)) * pow(core_fade, 2.0); gas_color += core_intensity * (core_texture * 2.0) * color_core; final_color += gas_color; float star_seed = random(floor(uv*200.0)); float star_brightness = pow(star_seed, 50.0); float star_dist = fract(star_seed * 10.0 + time * 0.2); float star_mask = 1.0 - smoothstep(0.0, 0.01, abs(radius - star_dist)); final_color += star_brightness * star_mask * color_stars; final_color = final_color / (final_color + vec3(1.0)); final_color = pow(final_color, vec3(0.8)); gl_FragColor = vec4(final_color, 1.0); } `; const geometry = new THREE.PlaneGeometry(2, 2); const uniforms = { u_time: { value: 0.0 }, u_resolution: { value: new THREE.Vector2() }, color_fil1_base: { value: new THREE.Vector3(0.1, 0.2, 0.8) }, color_fil1_glow: { value: new THREE.Vector3(0.8, 0.8, 1.0) }, color_fil2_base: { value: new THREE.Vector3(0.9, 0.5, 0.1) }, color_fil2_glow: { value: new THREE.Vector3(1.0, 1.0, 0.8) }, color_core: { value: new THREE.Vector3(1.0, 0.9, 0.7) }, color_stars: { value: new THREE.Vector3(1.0, 1.0, 0.8) } }; const material = new THREE.ShaderMaterial({ vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms }); const plane = new THREE.Mesh(geometry, material); scene.add(plane); const themes = [ { fil1_base: [0.1, 0.2, 0.8], fil1_glow: [0.8, 0.8, 1.0], fil2_base: [0.9, 0.5, 0.1], fil2_glow: [1.0, 1.0, 0.8], core: [1.0, 0.9, 0.7], stars: [1.0, 1.0, 0.8] }, { fil1_base: [0.8, 0.1, 0.2], fil1_glow: [1.0, 0.8, 0.8], fil2_base: [0.5, 0.1, 0.9], fil2_glow: [0.8, 0.8, 1.0], core: [1.0, 0.7, 0.9], stars: [1.0, 0.8, 1.0] }, { fil1_base: [0.1, 0.8, 0.2], fil1_glow: [0.8, 1.0, 0.8], fil2_base: [0.1, 0.5, 0.9], fil2_glow: [0.8, 1.0, 1.0], core: [0.7, 1.0, 0.9], stars: [0.8, 1.0, 1.0] } ]; let currentTheme = 0; const themeButton = document.getElementById('theme-button'); themeButton.addEventListener('click', () => { currentTheme = (currentTheme + 1) % themes.length; const theme = themes[currentTheme]; uniforms.color_fil1_base.value.set(...theme.fil1_base); uniforms.color_fil1_glow.value.set(...theme.fil1_glow); uniforms.color_fil2_base.value.set(...theme.fil2_base); uniforms.color_fil2_glow.value.set(...theme.fil2_glow); uniforms.color_core.value.set(...theme.core); uniforms.color_stars.value.set(...theme.stars); }); function onWindowResize() { const width = window.innerWidth; const height = window.innerHeight; renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(width, height); uniforms.u_resolution.value.x = renderer.domElement.width; uniforms.u_resolution.value.y = renderer.domElement.height; } function animate() { requestAnimationFrame(animate); uniforms.u_time.value = clock.getElapsedTime(); renderer.render(scene, camera); } onWindowResize(); window.addEventListener('resize', onWindowResize, false); animate(); </script>\nstyle.css: \nscript.js: ",
    "id": "supernova-remnant---threejs--glsl"
  },
  {
    "title": "Three.js Silk Shader Background Canvas",
    "description": "Animated silk-like shader background built with Three.js. Renders a responsive WebGL canvas overlay with customizable color, speed and scale, ideal for hero sections, headers or immersive UI backdrops.",
    "code": "\n<div id=\"shader-canvas\" class=\"absolute inset-0 -z-10\">\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n  <script>\n    class SilkShader {\n        constructor(container) {\n            this.container = container;\n            this.scene = new THREE.Scene();\n            this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n            this.clock = new THREE.Clock();\n            \n            this.init();\n            this.createShaderMaterial();\n            this.createMesh();\n            this.animate();\n            this.handleResize();\n            \n            window.addEventListener('resize', () => this.handleResize());\n        }\n        \n        init() {\n            this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);\n            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n            this.container.appendChild(this.renderer.domElement);\n        }\n        \n        hexToNormalizedRGB(hex) {\n            hex = hex.replace(\"#\", \"\");\n            return new THREE.Vector3(\n                parseInt(hex.slice(0, 2), 16) / 255,\n                parseInt(hex.slice(2, 4), 16) / 255,\n                parseInt(hex.slice(4, 6), 16) / 255\n            );\n        }\n        \n        createShaderMaterial() {\n            const vertexShader = `\n                varying vec2 vUv;\n                varying vec3 vPosition;\n                \n                void main() {\n                    vPosition = position;\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            `;\n            \n            const fragmentShader = `\n                varying vec2 vUv;\n                varying vec3 vPosition;\n                \n                uniform float uTime;\n                uniform vec3 uColor;\n                uniform float uSpeed;\n                uniform float uScale;\n                uniform float uRotation;\n                uniform float uNoiseIntensity;\n                \n                const float e = 2.71828182845904523536;\n                \n                float noise(vec2 texCoord) {\n                    float G = e;\n                    vec2 r = (G * sin(G * texCoord));\n                    return fract(r.x * r.y * (1.0 + texCoord.x));\n                }\n                \n                vec2 rotateUvs(vec2 uv, float angle) {\n                    float c = cos(angle);\n                    float s = sin(angle);\n                    mat2 rot = mat2(c, -s, s, c);\n                    return rot * uv;\n                }\n                \n                void main() {\n                    float rnd = noise(gl_FragCoord.xy);\n                    vec2 uv = rotateUvs(vUv * uScale, uRotation);\n                    vec2 tex = uv * uScale;\n                    float tOffset = uSpeed * uTime;\n                    \n                    tex.y += 0.03 * sin(8.0 * tex.x - tOffset);\n                    \n                    float pattern = 0.6 +\n                                  0.4 * sin(5.0 * (tex.x + tex.y +\n                                                  cos(3.0 * tex.x + 5.0 * tex.y) +\n                                                  0.02 * tOffset) +\n                                          sin(20.0 * (tex.x + tex.y - 0.1 * tOffset)));\n                    \n                    vec4 col = vec4(uColor, 1.0) * vec4(pattern) - rnd / 15.0 * uNoiseIntensity;\n                    col.a = 0.8;\n                    gl_FragColor = col;\n                }\n            `;\n            \n            this.uniforms = {\n                uTime: { value: 0 },\n                uSpeed: { value: 2 },\n                uScale: { value: 1.5 },\n                uNoiseIntensity: { value: 1.2 },\n                uColor: { value: this.hexToNormalizedRGB(\"#6366F1\") },\n                uRotation: { value: 0.5 }\n            };\n            \n            this.material = new THREE.ShaderMaterial({\n                uniforms: this.uniforms,\n                vertexShader,\n                fragmentShader,\n                transparent: true\n            });\n        }\n        \n        createMesh() {\n            const geometry = new THREE.PlaneGeometry(2, 2);\n            this.mesh = new THREE.Mesh(geometry, this.material);\n            this.scene.add(this.mesh);\n        }\n        \n        handleResize() {\n            this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);\n        }\n        \n        animate() {\n            requestAnimationFrame(() => this.animate());\n            \n            const delta = this.clock.getDelta();\n            this.uniforms.uTime.value += 0.1 * delta;\n            \n            this.renderer.render(this.scene, this.camera);\n        }\n    }\n    \n    // Initialize the shader when the page loads\n    document.addEventListener('DOMContentLoaded', () => {\n        const container = document.getElementById('shader-canvas');\n        new SilkShader(container);\n    });\n</script>\n</div>",
    "id": "threejs-silk-shader-background-canvas"
  },
  {
    "title": "ThreeJS Poke Grid",
    "description": "",
    "code": "index.html: <script src=\"https://aframe.io/releases/1.7.1/aframe.min.js\"></script> <script> \tAFRAME.registerComponent( 'fit-frustum', { \t\tinit: function() { \t\t\twindow.addEventListener( 'resize', () => this.fitToCamera() ); \t\t\tthis.fitToCamera(); \t\t}, \t\tfitToCamera: function() { \t\t\t \t\t\tconst el = this.el; \t\t\tconst sceneEl = el.sceneEl; \t\t\tconst camera = sceneEl.camera; \t\t\t \t\t\tif( !camera ) { \t\t\t\tsceneEl.addEventListener( 'camera-set-active', () => this.fitToCamera() ); \t\t\t\treturn; \t\t\t} \t\t\t \t\t\tconst distance = camera.el.object3D.position.y - el.object3D.position.y; \t\t\t \t\t\tconst vFov = ( camera.fov * Math.PI ) / 180; \t\t\tconst visibleHeight = 2 * Math.tan( vFov / 2 ) * distance; \t\t\t \t\t\tconst aspect = window.innerWidth / window.innerHeight; \t\t\tconst visibleWidth = visibleHeight * aspect; \t\t\t \t\t\tel.setAttribute( 'width', visibleWidth ); \t\t\tel.setAttribute( 'height', visibleHeight ); \t\t\t \t\t\tconsole.log( `plane resized to: ${visibleWidth.toFixed(2)} x ${visibleHeight.toFixed(2)}` ); \t\t} \t} ); \tAFRAME.registerComponent( 'mouse-tracker', { \t\tinit: function() { \t\t\t \t\t\tthis.mouseWorldPos = new THREE.Vector3( 0, 0, 0 ); \t\t}, \t\ttick: function() { \t\t\t \t\t\tconst raycaster = this.el.components.raycaster; \t\t\tif( raycaster && raycaster.intersections.length > 0 ) { \t\t\t\tthis.mouseWorldPos.copy( raycaster.intersections[ 0 ].point ); \t\t\t} \t\t} \t} ); \tAFRAME.registerComponent( 'dynamic-pillar-grid', { \t\tschema: { \t\t\twidth: { default: 1.5 }, \t\t\tdepth: { default: 1.5 }, \t\t\theight: { default: 10 }, \t\t\tspacing: { default: 0.2 } \t\t}, \t\tinit: function() { \t\t\t \t\t\tthis.pillars = []; \t\t\twindow.addEventListener( 'resize', () => this.updateGrid() ); \t\t\tsetTimeout( () => this.updateGrid(), 100 ); \t\t}, \t\tupdateGrid: function() { \t\t\tconst frustumPlane = document.querySelector( '[fit-frustum]' ); \t\t\tif( !frustumPlane ) return; \t\t\tconst vWidth = parseFloat( frustumPlane.getAttribute( 'width' ) ); \t\t\tconst vHeight = parseFloat( frustumPlane.getAttribute( 'height' ) ); \t\t\tconst colWidth = this.data.width + this.data.spacing; \t\t\tconst rowDepth = this.data.depth + this.data.spacing; \t\t\tlet cols = Math.floor( vWidth / colWidth ) + 2; \t\t\tif( cols % 2 === 0 ) cols ++; \t\t\tlet rows = Math.floor( vHeight / rowDepth ) + 2; \t\t\tif( rows % 2 === 0 ) rows ++; \t\t\tconst totalNeeded = cols * rows; \t\t\twhile( this.pillars.length > totalNeeded ) { \t\t\t\tconst p = this.pillars.pop(); \t\t\t\tp.parentNode.removeChild( p ); \t\t\t} \t\t\twhile( this.pillars.length < totalNeeded ) { \t\t\t\tconst p = document.createElement( 'a-box' ); \t\t\t\tp.setAttribute( 'width', this.data.width ); \t\t\t\tp.setAttribute( 'depth', this.data.depth ); \t\t\t\tp.setAttribute( 'height', this.data.height ); \t\t\t\tp.setAttribute( 'color', '#808080' ); \t\t\t\tp.setAttribute( 'metalness', 0.5 ); \t\t\t\tp.setAttribute( 'roughness', 0.5 ); \t\t\t\tp.setAttribute( 'distance-checker', '' ); \t\t\t\tthis.el.appendChild( p ); \t\t\t\tthis.pillars.push( p ); \t\t\t} \t\t\tconst offsetX = ( cols - 1 ) * colWidth / 2; \t\t\tconst offsetZ = ( rows - 1 ) * rowDepth / 2; \t\t\t \t\t\tfor( let i = 0; i < this.pillars.length; i ++ ) { \t\t\t\tconst r = Math.floor( i / cols ); \t\t\t\tconst c = i % cols; \t\t\t\tconst x = ( c * colWidth ) - offsetX; \t\t\t\tconst z = ( r * rowDepth ) - offsetZ; \t\t\t\tthis.pillars[ i ].setAttribute( 'position', `${x} 0 ${z}` ); \t\t\t} \t\t} \t} ); \tAFRAME.registerComponent( 'distance-checker', { \t\tschema: { \t\t\tradius: { default: 5 }, \t\t\tminElevation: { default: 0 }, \t\t\tmaxElevation: { default: 5 } \t\t}, \t\tinit: function() { \t\t\tconst cameraEl = document.querySelector( '[camera]' ); \t\t\tif( cameraEl ) this.tracker = cameraEl.components[ 'mouse-tracker' ]; \t\t\tthis.myPos = this.el.object3D.position; \t\t\tthis.baseY = this.data.minElevation; \t\t}, \t\ttick: function() { \t\t\t \t\t\tif( !this.tracker || !this.tracker.mouseWorldPos ) return; \t\t\t \t\t\tconst mousePos = this.tracker.mouseWorldPos; \t\t\t \t\t\tconst dx = mousePos.x - this.myPos.x; \t\t\tconst dz = mousePos.z - this.myPos.z; \t\t\tconst dist = Math.sqrt( dx * dx + dz * dz ); \t\t\tlet influence = Math.max( 0, 1 - ( dist / this.data.radius ) ); \t\t\tinfluence = influence * influence; \t\t\t \t\t\tconst targetY = this.baseY - ( influence * this.data.maxElevation ); \t\t\t \t\t\tthis.myPos.y = THREE.MathUtils.lerp( this.myPos.y, targetY, 0.1 ); \t\t\t \t\t\tif( influence > 0.01 ) { /**/ } \t\t} \t} ); </script> <a-scene \txr-mode-ui=\"enabled: false\" > \t<a-camera \t\tlook-controls-enabled=\"false\" \t\twasd-controls-enabled=\"false\" \t\tposition=\"0 10 0\" \t\trotation=\"-90 0 0\" \t\tcursor=\"rayOrigin: mouse\" \t\traycaster=\"objects: .receive-ray\" \t\tmouse-tracker \t></a-camera> \t<a-plane \t\tclass=\"receive-ray\" \t\tposition=\"0 5 0\" \t\trotation=\"-90 0 0\" \t\twidth=\"38.4\" \t\theight=\"21.6\" \t\topacity=\"0.0\" \t\tcolor=\"#000000\" \t\tfit-frustum \t></a-plane> \t<a-entity \t\tdynamic-pillar-grid=\"width: 1.5; depth: 1.5; height: 10; spacing: 0.2\" \t></a-entity> \t<a-light \t\tposition=\"0 11 0\" \t\ttype=\"point\" \t\tintensity=\"5\" \t></a-light> \t<a-sky \t\tcolor=\"#000000\" \t></a-sky> </a-scene>\nstyle.css: \nscript.js: ",
    "id": "threejs-poke-grid"
  },
  {
    "title": "Donut Glass",
    "description": "",
    "code": "index.html: <a href=\"#\" class=\"corner-text top-left\">NEURAL//NET</a> <a href=\"#\" class=\"corner-text top-right\">QUANTUM//OPS</a> <a href=\"#\" class=\"corner-text bottom-left\">CYBER//SYNC</a> <a href=\"#\" class=\"corner-text bottom-right\">MATRIX//3D</a> <canvas id=\"canvas-scene\"></canvas> <script type=\"importmap\"> \t{ \t\t\"imports\": { \t\t\t\"three\": \"https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js\", \t\t\t\t\"jsm/\": \"https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/\" \t\t} \t} </script>\nstyle.css: body { \tmargin: 0; \tbackground-color: #000; \tfont-family: \"Courier New\", monospace; \toverflow: hidden; } #canvas-scene { \tposition: absolute; \tinset: 0; \tdisplay: block; \twidth: 100vw; \theight: 100vh; \tz-index: 1; } .corner-text { \tposition: fixed; \tcolor: white; \tfont-size: 10px; \tfont-weight: bold; \tletter-spacing: 3px; \ttext-transform: uppercase; \tz-index: 10; \ttext-shadow: 0 0 5px rgba(128, 0, 128, 0.3); \tanimation: pulse 3s ease-in-out infinite; \tcursor: pointer; \ttext-decoration: none; } .top-left { \ttop: 20px; \tleft: 20px; } .top-right { \ttop: 20px; \tright: 20px; \ttext-align: right; } .bottom-left { \tbottom: 20px; \tleft: 20px; } .bottom-right { \tbottom: 20px; \tright: 20px; \ttext-align: right; } @keyframes pulse { \t0%, \t100% { \t\topacity: 0.5; \t} \t50% { \t\topacity: 1; \t} }\nscript.js: import * as THREE from \"three\"; import { OrbitControls } from \"jsm/controls/OrbitControls.js\"; const w = window.innerWidth; const h = window.innerHeight; const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera(80, w / h, 0.1, 1000); camera.position.z = 5; camera.position.y = 1; camera.position.x = 1; const canvasScene = document.querySelector(\"#canvas-scene\"); const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvasScene, }); renderer.setSize(w, h); const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.minPolarAngle = Math.PI / 2 - 0.1; controls.maxPolarAngle = Math.PI / 2 + 0.1; controls.minAzimuthAngle = Math.PI / 2 + 0.1; controls.maxAzimuthAngle = Math.PI / 2 + 0.1; const torus = new THREE.TorusGeometry(2.5, 0.29, 26, 64); const materialGlass = new THREE.MeshPhysicalMaterial({ thickness: 3, roughness: 0.09, clearcoat: 0.1, clearcoatRoughness: 0, transmission: 0.99, ior: 1.25, envMapIntensity: 1.5, reflectivity: 0.2, metalness: 0.9, transparent: true, }); const mesh = new THREE.Mesh(torus, materialGlass); scene.add(mesh); const torus2 = new THREE.TorusGeometry(1.8, 0.35, 26, 64); const materialGlass2 = new THREE.MeshPhysicalMaterial({ thickness: 10, roughness: 0, clearcoat: 0, clearcoatRoughness: 1, transmission: 1, envMapIntensity: 3, reflectivity: 0.1, metalness: 0, alphaTest: 0.1, }); const mesh2 = new THREE.Mesh(torus2, materialGlass2); scene.add(mesh2); const canvas = document.createElement(\"canvas\"); const ctx = canvas.getContext(\"2d\"); canvas.width = 512; canvas.height = 256; ctx.fillStyle = \"black\"; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.font = \"bold 70px Arial\"; ctx.fillStyle = \"white\"; ctx.textAlign = \"center\"; ctx.textBaseline = \"middle\"; ctx.fillText(\"GLASS TORUS\", canvas.width / 2, canvas.height / 2); const texture = new THREE.CanvasTexture(canvas); texture.colorSpace = THREE.SRGBColorSpace; texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(4, 4); const torus3 = new THREE.TorusGeometry(1.8, 0.34, 36, 604); const matcap = new THREE.TextureLoader().load(\"aluminio.jpg\"); const material = new THREE.MeshMatcapMaterial({ map: texture, flatShading: true, side: THREE.DoubleSide, alphaTest: 0.1, }); const mesh3 = new THREE.Mesh(torus3, material); scene.add(mesh3); const ball = new THREE.SphereGeometry(1, 32, 32); const redMaterial = new THREE.MeshStandardMaterial({ color: 0x800080, roughness: 0.2, metalness: 0.7, side: THREE.DoubleSide, alphaTest: 0.1, }); const redMesh = new THREE.Mesh(ball, redMaterial); redMesh.position.set(0, 0, 0); scene.add(redMesh); const light = new THREE.PointLight(0xffffff, 50, 10); light.position.set(4, 0, 0); scene.add(light); const directionalLight = new THREE.DirectionalLight(0x800080, 10); directionalLight.position.set(4, 0, 0); scene.add(directionalLight); function animate() { requestAnimationFrame(animate); mesh.rotation.y += (Math.PI / 180) * 0.1; mesh.rotation.x += (Math.PI / 180) * 0.1; mesh2.rotation.y -= (Math.PI / 180) * 0.1; mesh2.rotation.x -= (Math.PI / 180) * 0.1; mesh3.rotation.y -= (Math.PI / 180) * 0.1; mesh3.rotation.x -= (Math.PI / 180) * 0.1; texture.offset.y += (Math.PI / 180) * 0.1; texture.offset.x += (Math.PI / 180) * 0.1; renderer.render(scene, camera); controls.update(); } animate(); window.addEventListener(\"resize\", () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });",
    "id": "donut-glass"
  },
  {
    "title": "Interactive Iridescent WebGL Background Shader",
    "description": "Absolute positioned container that injects an OGL-based WebGL canvas rendering an animated iridescent shader. Mouse-responsive color shift, configurable speed and amplitude make it perfect for immersive hero banners or full-screen decorative backdrops.",
    "code": "<div class=\"shader-container absolute inset-0 -z-10\">\n  <script type=\"module\">\n    import { Renderer, Program, Mesh, Color, Triangle } from 'https://cdn.skypack.dev/ogl';\n\n    const vertexShader = `\n    attribute vec2 uv;\n    attribute vec2 position;\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = vec4(position, 0, 1);\n    }`;\n\n    const fragmentShader = `\n    precision highp float;\n    uniform float uTime;\n    uniform vec3 uColor;\n    uniform vec3 uResolution;\n    uniform vec2 uMouse;\n    uniform float uAmplitude;\n    uniform float uSpeed;\n    varying vec2 vUv;\n    void main() {\n      float mr = min(uResolution.x, uResolution.y);\n      vec2 uv = (vUv.xy * 2.0 - 1.0) * uResolution.xy / mr;\n      uv += (uMouse - vec2(0.5)) * uAmplitude;\n      float d = -uTime * 0.5 * uSpeed;\n      float a = 0.0;\n      for (float i = 0.0; i < 8.0; ++i) {\n        a += cos(i - d - a * uv.x);\n        d += sin(uv.y * i + a);\n      }\n      d += uTime * 0.5 * uSpeed;\n      vec3 col = vec3(cos(uv * vec2(d, a)) * 0.6 + 0.4, cos(a + d) * 0.5 + 0.5);\n      col = cos(col * cos(vec3(d, a, 2.5)) * 0.5 + 0.5) * uColor;\n      gl_FragColor = vec4(col, 1.0);\n    }`;\n\n    class IridescenceShader {\n        constructor(container, options = {}) {\n            this.container = container;\n            this.color = options.color || [1, 0.8, 0.9];\n            this.speed = options.speed || 1.0;\n            this.amplitude = options.amplitude || 0.15;\n            this.mouseReact = options.mouseReact !== false;\n            this.mousePos = { x: 0.5, y: 0.5 };\n            this.init();\n        }\n\n        init() {\n            this.renderer = new Renderer();\n            this.gl = this.renderer.gl;\n            this.gl.clearColor(0, 0, 0, 1);\n            \n            this.setupGeometry();\n            this.setupEventListeners();\n            this.resize();\n            this.animate();\n            \n            this.container.appendChild(this.gl.canvas);\n        }\n\n        setupGeometry() {\n            const geometry = new Triangle(this.gl);\n            this.program = new Program(this.gl, {\n                vertex: vertexShader,\n                fragment: fragmentShader,\n                uniforms: {\n                    uTime: { value: 0 },\n                    uColor: { value: new Color(...this.color) },\n                    uResolution: { value: new Color(1, 1, 1) },\n                    uMouse: { value: new Float32Array([0.5, 0.5]) },\n                    uAmplitude: { value: this.amplitude },\n                    uSpeed: { value: this.speed },\n                },\n            });\n            this.mesh = new Mesh(this.gl, { geometry, program: this.program });\n        }\n\n        setupEventListeners() {\n            this.handleResize = this.resize.bind(this);\n            this.handleMouseMove = this.onMouseMove.bind(this);\n            \n            window.addEventListener('resize', this.handleResize);\n            if (this.mouseReact) {\n                this.container.addEventListener('mousemove', this.handleMouseMove);\n            }\n        }\n\n        resize() {\n            const rect = this.container.getBoundingClientRect();\n            this.renderer.setSize(rect.width, rect.height);\n            if (this.program) {\n                this.program.uniforms.uResolution.value = new Color(\n                    this.gl.canvas.width,\n                    this.gl.canvas.height,\n                    this.gl.canvas.width / this.gl.canvas.height\n                );\n            }\n        }\n\n        onMouseMove(e) {\n            const rect = this.container.getBoundingClientRect();\n            const x = (e.clientX - rect.left) / rect.width;\n            const y = 1.0 - (e.clientY - rect.top) / rect.height;\n            this.mousePos = { x, y };\n            this.program.uniforms.uMouse.value[0] = x;\n            this.program.uniforms.uMouse.value[1] = y;\n        }\n\n        animate(t = 0) {\n            this.animationId = requestAnimationFrame(this.animate.bind(this));\n            this.program.uniforms.uTime.value = t * 0.001;\n            this.renderer.render({ scene: this.mesh });\n        }\n    }\n\n    document.addEventListener('DOMContentLoaded', () => {\n        const container = document.querySelector('.shader-container');\n        new IridescenceShader(container, {\n            color: [0.8, 0.4, 1],\n            speed: 0.6,\n            amplitude: 0.12\n        });\n    });\n  </script>\n</div>",
    "id": "interactive-iridescent-webgl-background-shader"
  },
  {
    "title": "Stripper polar",
    "description": "",
    "code": "index.html: <script type=\"x-shader/vertex\" id=\"vertex\">#version 300 es in vec3 position; in vec2 uv; out vec2 v_uv; void main() { gl_Position = vec4(position, 1.0); v_uv = uv; } </script> <script type=\"x-shader/fragment\" id=\"fragment\">#version 300 es precision highp float; uniform vec2 u_resolution; uniform float u_time; uniform float u_frame; in vec2 v_uv; out vec4 colour; //\tSimplex 3D Noise //\tby Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise) // vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);} vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;} float snoise(vec3 v){ const vec2 C = vec2(1.0/6.0, 1.0/3.0) ; const vec4 D = vec4(0.0, 0.5, 1.0, 2.0); // First corner vec3 i = floor(v + dot(v, C.yyy) ); vec3 x0 = v - i + dot(i, C.xxx) ; // Other corners vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min( g.xyz, l.zxy ); vec3 i2 = max( g.xyz, l.zxy ); // x0 = x0 - 0. + 0.0 * C vec3 x1 = x0 - i1 + 1.0 * C.xxx; vec3 x2 = x0 - i2 + 2.0 * C.xxx; vec3 x3 = x0 - 1. + 3.0 * C.xxx; // Permutations i = mod(i, 289.0 ); vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 )); // Gradients // ( N*N points uniformly over a square, mapped onto an octahedron.) float n_ = 1.0/7.0; // N=7 vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z *ns.z); // mod(p,N*N) vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N) vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4( x.xy, y.xy ); vec4 b1 = vec4( x.zw, y.zw ); vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0)); vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ; vec3 p0 = vec3(a0.xy,h.x); vec3 p1 = vec3(a0.zw,h.y); vec3 p2 = vec3(a1.xy,h.z); vec3 p3 = vec3(a1.zw,h.w); //Normalise gradients vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3))); p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w; // Mix final noise value vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0); m = m * m; return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) ); } vec2 getScreenSpace() { vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.y, u_resolution.x); return uv; } void main() { vec2 uv = getScreenSpace(); vec2 euv = uv; uv = vec2(length(uv), atan(uv.y, uv.x)); uv.x += 900.0 - u_time * 0.5; // Setup the grid and noise scale float cells = 6.0; float stipes = 50.0; float x_scaled = uv.x * cells; float id = floor(x_scaled); float local_x = fract(x_scaled); float blend = smoothstep(0.80, 1.0, local_x); float smooth_id = (id + blend) * 0.16; float noise_z = u_time * 0.5 + smooth_id; // To loop the noise around the angle (uv.y), we map the angle to a circle (sin/cos). vec2 loop1 = vec2(cos(uv.y), sin(uv.y)) * .5; float z1 = (uv.x * 2.0) + noise_z; vec2 loop2 = vec2(cos(euv.y), sin(euv.y)) * 0.5; float z2 = (uv.x * 0.5 + 1.0) + noise_z; // Mixing polar and cartesian noise for something interesting float n = snoise(vec3(loop2, z2)) * 0.5 + snoise(vec3(loop1, z1)); float ng = n * stipes; float aa = fwidth(sin(ng)); colour.r = smoothstep(0., aa, sin(ng)); colour.g = smoothstep(0., aa, sin(ng + 0.1)); colour.b = smoothstep(0., aa, sin(ng + 0.2)); colour.a = 1.0; } </script>\nstyle.css: body { background: pink; margin: 0; overflow: hidden; } canvas { width: 100%; }\nscript.js: import { Renderer, Uniform, Triangle, Program, Mesh, Framebuffer, Vec2 } from \"https://esm.sh/wtc-gl\"; console.clear(); const dpr = 2; const dimensions = new Vec2(0,0) let playing = true; const uniforms = { u_time : new Uniform({ name: 'time', value: 0, kind: 'float' }), u_resolution : new Uniform({ name: 'resolution', value: dimensions.array, kind: 'float_vec2' }), u_frame: new Uniform({ name: 'frame', value: 0, kind: 'float' }) } const renderer = new Renderer({ dpr }), { gl, gl: { canvas } } = renderer; document.body.appendChild(canvas); gl.clearColor(1,1,1,1); const resize = (e) => { dimensions.reset(window.innerWidth, window.innerHeight) uniforms.u_resolution.value = dimensions.scaleNew(dpr).array renderer.dimensions = dimensions }; window.addEventListener('resize', resize); resize(); const geometry = new Triangle(gl) const program = new Program(gl, { vertex: vertex.innerText, fragment: fragment.innerText, uniforms }) const mesh = new Mesh(gl, { geometry, program }) let lastTime = performance.now(), rafID; function render(t) { const diff = t - lastTime lastTime = t if(playing) { rafID = requestAnimationFrame(render); } uniforms.u_time.value += diff * 0.00005; uniforms.u_frame.value += 1; renderer.render({ scene: mesh }) } rafID = requestAnimationFrame(render);",
    "id": "stripper-polar"
  },
  {
    "title": "cg-canvas-animated-gradients 2",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>cg-canvas-animated-gradients | @mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <div class=\"container\">\n      <div class=\"header\">\n        <h1>mukta is a better way to build websites</h1>\n        <button>Get PRO</button>\n      </div>\n    </div>\n    <div class=\"glassy-overlay\"></div>\n    <canvas></canvas>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "const canvas = document.querySelector(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\n\nlet mouseMoved = false;\n\nconst pointer = {\n  x: 0.5 * window.innerWidth,\n  y: 0.5 * window.innerHeight,\n};\nconst params = {\n  pointsNumber: 40,\n  widthFactor: 10,\n  mouseThreshold: 0.5,\n  spring: 0.25,\n  friction: 0.5,\n};\n\nconst trail = new Array(params.pointsNumber);\nfor (let i = 0; i < params.pointsNumber; i++) {\n  trail[i] = {\n    x: pointer.x,\n    y: pointer.y,\n    dx: 0,\n    dy: 0,\n  };\n}\n\nwindow.addEventListener(\"click\", (e) => {\n  updateMousePosition(e.pageX, e.pageY);\n});\nwindow.addEventListener(\"mousemove\", (e) => {\n  mouseMoved = true;\n  updateMousePosition(e.pageX, e.pageY);\n});\nwindow.addEventListener(\"touchmove\", (e) => {\n  mouseMoved = true;\n  updateMousePosition(e.targetTouches[0].pageX, e.targetTouches[0].pageY);\n});\n\nfunction updateMousePosition(eX, eY) {\n  pointer.x = eX;\n  pointer.y = eY;\n}\n\nsetupCanvas();\nupdate(0);\nwindow.addEventListener(\"resize\", setupCanvas);\n\nfunction update(t) {\n  if (!mouseMoved) {\n    pointer.x =\n      (0.5 + 0.3 * Math.cos(0.002 * t) * Math.sin(0.005 * t)) *\n      window.innerWidth;\n    pointer.y =\n      (0.5 + 0.2 * Math.cos(0.005 * t) + 0.1 * Math.cos(0.01 * t)) *\n      window.innerHeight;\n  }\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  trail.forEach((p, pIdx) => {\n    const prev = pIdx === 0 ? pointer : trail[pIdx - 1];\n    const spring = pIdx === 0 ? 0.4 * params.spring : params.spring;\n    p.dx += (prev.x - p.x) * spring;\n    p.dy += (prev.y - p.y) * spring;\n    p.dx *= params.friction;\n    p.dy *= params.friction;\n    p.x += p.dx;\n    p.y += p.dy;\n  });\n\n  var gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);\n  gradient.addColorStop(0, \"rgba(160, 93, 134,1)\");\n  gradient.addColorStop(1, \"rgba(57, 34, 115,1)\");\n\n  ctx.strokeStyle = gradient;\n  ctx.lineCap = \"round\";\n  ctx.beginPath();\n  ctx.moveTo(trail[0].x, trail[0].y);\n\n  for (let i = 1; i < trail.length - 1; i++) {\n    const xc = 0.5 * (trail[i].x + trail[i + 1].x);\n    const yc = 0.5 * (trail[i].y + trail[i + 1].y);\n    ctx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);\n    ctx.lineWidth = params.widthFactor * (params.pointsNumber - i);\n    ctx.stroke();\n  }\n  ctx.lineTo(trail[trail.length - 1].x, trail[trail.length - 1].y);\n  ctx.stroke();\n\n  window.requestAnimationFrame(update);\n}\n\nfunction setupCanvas() {\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n}\n",
      "styles.css": "@import url(\"https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap\");\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody,\nhtml {\n  background: #10092c;\n  padding: 0;\n  margin: 0;\n  overscroll-behavior: none;\n  font-family: \"Inter\";\n}\n\n.header {\n  padding: 4em;\n  opacity: 0.75;\n}\n\n.header h1 {\n  width: 60%;\n  background: #cfcfcf;\n  background: linear-gradient(to top, #cecece 0%, #ffffff 100%);\n  background-clip: text;\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  font-weight: 500;\n  font-size: 80px;\n  letter-spacing: -0.05em;\n  line-height: 1;\n}\n\nbutton {\n  margin: 3em 0;\n  padding: 1em 1.5em;\n  color: #fff;\n  font-size: 16px;\n  border: 1px solid rgba(149, 99, 255, 0.5);\n  outline: none;\n  border-radius: 0.75em;\n  backdrop-filter: blur(20px);\n  cursor: pointer;\n  background: linear-gradient(\n      180deg,\n      rgba(60, 8, 126, 0) 0%,\n      rgba(60, 8, 126, 0.32) 100%\n    ),\n    rgba(113, 47, 255, 0.12);\n  box-shadow: inset 0 0 12px #bf97ff3d;\n}\n\n.glassy-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(255, 255, 255, 0.05);\n  backdrop-filter: blur(50px);\n  pointer-events: none;\n}\n\n.container {\n  position: absolute;\n  top: 0;\n  z-index: 10000;\n}\n"
    }
  },
  {
    "title": "Animated Aurora WebGL Background with Three.js",
    "description": "Fullscreen canvas background using Three.js ShaderMaterial to generate a dynamic, colorful aurora effect. Auto-animated and responsive to window resize, perfect for landing pages, hero sections, or immersive app backdrops.",
    "code": "<canvas id=\"aurora-canvas\">\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n  <style>\n    canvas { position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: -10; }\n  </style>\n  <script>\n    // WebGL Aurora Background\n    const scene = new THREE.Scene();\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    const renderer = new THREE.WebGLRenderer();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(renderer.domElement);\n\n    const material = new THREE.ShaderMaterial({\n        uniforms: {\n            iTime: { value: 0 },\n            iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }\n        },\n        vertexShader: `\n            void main() {\n                gl_Position = vec4(position, 1.0);\n            }\n        `,\n        fragmentShader: `\n            uniform float iTime;\n            uniform vec2 iResolution;\n\n            #define NUM_OCTAVES 3\n\n            float rand(vec2 n) { \n                return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n            }\n\n            float noise(vec2 p){\n                vec2 ip = floor(p);\n                vec2 u = fract(p);\n                u = u*u*(3.0-2.0*u);\n                \n                float res = mix(\n                    mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n                    mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n                return res*res;\n            }\n\n            float fbm(vec2 x) {\n                float v = 0.0;\n                float a = 0.3;\n                vec2 shift = vec2(100);    \n                mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n                for (int i = 0; i < NUM_OCTAVES; ++i) {\n                    v += a * noise(x);\n                    x = rot * x * 2.0 + shift;\n                    a *= 0.4;\n                }\n                return v;\n            }\n\n            void main() {\n                vec2 shake = vec2(sin(iTime * 1.2) * 0.005, cos(iTime * 2.1) * 0.005);\n                \n                vec2 p = ((gl_FragCoord.xy + shake * iResolution.xy) - iResolution.xy * 0.5) / iResolution.y * mat2(6.0, -4.0, 4.0, 6.0);\n                vec2 v;\n                vec4 o = vec4(0.0);\n                \n                float f = 2.0 + fbm(p + vec2(iTime * 5.0, 0.0)) * 0.5; \n                \n                for(float i = 0.0; i++ < 35.0;)\n                {\n                    v = p + cos(i * i + (iTime + p.x * 0.08) * 0.025 + i * vec2(13.0, 11.0)) * 3.5 + vec2(sin(iTime * 3.0 + i) * 0.003, cos(iTime * 3.5 - i) * 0.003);\n                    \n                    float tailNoise = fbm(v + vec2(iTime * 0.5, i)) * 0.3 * (1.0 - (i / 35.0)); \n                    \n                    vec4 auroraColors = vec4(\n                        0.1 + 0.3 * sin(i * 0.2 + iTime * 0.4),\n                        0.3 + 0.5 * cos(i * 0.3 + iTime * 0.5),\n                        0.7 + 0.3 * sin(i * 0.4 + iTime * 0.3),\n                        1.0\n                    );\n                    \n                    vec4 currentContribution = auroraColors * exp(sin(i * i + iTime * 0.8)) / length(max(v, vec2(v.x * f * 0.015, v.y * 1.5)));\n                    \n                    float thinnessFactor = smoothstep(0.0, 1.0, i / 35.0) * 0.6; \n                    o += currentContribution * (1.0 + tailNoise * 0.8) * thinnessFactor;\n                }\n                \n                o = tanh(pow(o / 100.0, vec4(1.6)));\n                gl_FragColor = o * 1.5;\n            }\n        `\n    });\n\n    const geometry = new THREE.PlaneGeometry(2, 2);\n    const mesh = new THREE.Mesh(geometry, material);\n    scene.add(mesh);\n\n    function animate() {\n        requestAnimationFrame(animate);\n        material.uniforms.iTime.value += 0.016;\n        renderer.render(scene, camera);\n    }\n\n    window.addEventListener('resize', () => {\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);\n    });\n\n    animate();\n  </script>\n</canvas>",
    "id": "animated-aurora-webgl-background-with-threejs"
  },
  {
    "title": "Hexagonal Grid",
    "description": "",
    "code": "index.html: <div id=\"app\"> <canvas id=\"webgl-canvas\"></canvas> <div class=\"hero\"> <h1>Hexagonal</h1> <h2>Grid</h2> </div> <div class=\"buttons\"> <button type=\"button\" id=\"colors-btn\"> Random colors </button> </div> </div>\nstyle.css: body, html, #app { margin: 0; width: 100%; height: 100%; background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(0,0,0,0.5) 200%); } #app { height: 100%; font-family: \"Montserrat\", serif; } .hero { position: relative; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; } h1, h2 { margin: 0; padding: 0; color: white; text-transform: uppercase; text-shadow: 0 0 20px rgba(0, 0, 0, 1); line-height: 100%; user-select: none; } h1 { font-size: 80px; font-weight: 700; } h2 { font-size: 60px; font-weight: 500; } #webgl-canvas { position: fixed; top: 0; right: 0; bottom: 0; left: 0; overflow: hidden; } .buttons { position: fixed; width: 100%; bottom: 15px; display: flex; justify-content: center; align-items: center; gap: 15px; } button { font-family: \"Montserrat\", serif; background: rgba(255, 255, 255, 0.5); border-radius: 5px; border: 1px solid grey; padding: 4px 8px; }\nscript.js: // Licence CC BY-NC-SA 4.0 // Attribution ‚Äî You must give appropriate credit. // Non Commercial ‚Äî You may not use the material for commercial purposes. import Grid1Background from 'https://cdn.jsdelivr.net/npm/threejs-components@0.0.16/build/backgrounds/grid1.cdn.min.js' const bg = Grid1Background(document.getElementById('webgl-canvas')) const button1 = document.getElementById('colors-btn') button1.addEventListener('click', () => { bg.grid.setColors([0xffffff * Math.random(), 0xffffff * Math.random(), 0xffffff * Math.random()]) bg.grid.light1.color.set(0xffffff * Math.random()) bg.grid.light1.intensity = 500 + Math.random() * 1000 bg.grid.light2.color.set(0xffffff * Math.random()) bg.grid.light2.intensity = 250 + Math.random() * 250 })",
    "id": "hexagonal-grid"
  }
]