[
  {
    "title": "Slider with infinite loop with drag and scroll",
    "description": "",
    "code": "index.html: <!-- Follow me on Instagram: https://www.instagram.com/supahfunk/ Dribbble: https://dribbble.com/supahfunk Twitter: https://twitter.com/supahfunk Codepen: https://codepen.io/supah/ Horizontal Version: https://codepen.io/supah/pen/VwegJwV --> <div class=\"menu\"> <ul class=\"menu--wrapper\"> <li class=\"menu--item\"><button href=\"#\">Facebook</button></li> <li class=\"menu--item\"><button href=\"#\">Netflix</button></li> <li class=\"menu--item\"><button href=\"#\">Instagram</button></li> <li class=\"menu--item\"><button href=\"#\">Google</button></li> <li class=\"menu--item\"><button href=\"#\">Twitter</button></li> <li class=\"menu--item\"><button href=\"#\">Amazon</button></li> <li class=\"menu--item\"><button href=\"#\">Pinterest</button></li> <li class=\"menu--item\"><button href=\"#\">Spotify</button></li> <li class=\"menu--item\"><button href=\"#\">YouTube</button></li> </ul> </div> <a class=\"version\" href=\"https://codepen.io/supah/pen/VwegJwV\" target=\"_parent\">Horizontal version</a>\nstyle.css: * { box-sizing: border-box; } body { height: 100vh; overflow: hidden; background: #c9b3a6; color: #020000; } .menu { height: 100vh; overflow: hidden; background: #fff; cursor: grab; &.is-dragging { cursor: grabbing; } ul { counter-reset: count; } &--item { counter-increment: count; position: absolute; z-index: 1; top: 0; left: 0; width: 100%; font-size: 120px; line-height: 1.2; padding: 2rem 0; text-align: center; @media (max-width: 767px) { font-size: 10vw; padding: 1rem 0; } &:nth-child(n+10):before { content: counter(count); } button { color: #020000; text-decoration: none; position: relative; z-index: 1; display: inline-block; user-select: none; font-size: 120px; -webkit-appearance: none; background: none; padding: 0; border: none; outline: none; box-shadow: none; color: #020000; font-family: 'Orelo-sw-db', serif; cursor: pointer; @media (max-width: 767px) { font-size: 10vw; } &:before { position: absolute; z-index: -1; left: 0; display: inline-block; transform: translateX(-100%) scale(.4); content: \"0\" counter(count); color: #862929; font-family: cursive; } } } } .version { display: inline-block; position: fixed; z-index: 1; text-decoration: none; background: #333; font-family: sans-serif; color: #fff; text-transform: uppercase; font-size: 12px; border-radius: 10px; box-shadow: 0 8px 10px -5px rgba(0, 0, 0, .2); top: -30px; right: -60px; bottom: auto; transform: rotate(45deg); transform-origin: 0% 100%; border-radius: 0; padding: 8px 30px; font-size: 11px; &:before { content: ''; position: absolute; z-index: -1; width: 100%; height: 100px; bottom: 0; right: 0%; background: transparent; } @media (max-width: 767px) { transform: scale(.6) rotate(45deg) ; right: -110px; } } @font-face { font-family: 'Orelo-sw-db'; src: url(data:font/truetype;charset=utf-8;base64,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KAIrAjICOQJGAkwCUgJZAl8CZgJuAnICeAJ/AoYCkwKaAqECpwKsArcCwALGAtEC1wLdAucC7ALxAvYDAgMIAxADGgMkAy4DNgM9A0gDUwNeA2IDagN2A38DiAOPA5gDnwOmA60DtAO7A8IDyQPSA9kD4APnA+4D9QP8BAgEEwQfBCsEMQRBBEcEUgRdBGMEbwSqBMEEyUFicmV2ZUFtYWNyb25Bb2dvbmVrQ2FjdXRlQ2Nhcm9uQ2RvdGFjY2VudERjYXJvbkRjcm9hdEVjYXJvbkVkb3RhY2NlbnRFbWFjcm9uRW9nb25la0dkb3RhY2NlbnRHYnJldmV1bmkwMTIySGJhcklkb3RhY2NlbnRJbWFjcm9uSW9nb25la3VuaTAxMzZMYWN1dGV1bmkwMTNCTGNhcm9uTGRvdE5jYXJvbk5hY3V0ZXVuaTAxNDVFbmdPbWFjcm9uT2h1bmdhcnVtbGF1dFJhY3V0ZVJjYXJvbnVuaTAxNTZTYWN1dGVUYmFyU2NlZGlsbGF1bmkwMjE4VGNhcm9udW5pMDE2MnVuaTAyMUFVbWFjcm9uVWh1bmdhcnVtbGF1dFVvZ29uZWtVcmluZ1dhY3V0ZVdjaXJjdW1mbGV4V2dyYXZlV2RpZXJlc2lzWWNpcmN1bWZsZXhZZ3JhdmVaYWN1dGVaZG90YWNjZW50YWJyZXZlYW1hY3JvbmFvZ29uZWtjYWN1dGVjY2Fyb25jZG90YWNjZW50ZGNhcm9uZGNyb2F0ZWNhcm9uZWRvdGFjY2VudGVtYWNyb25lb2dvbmVrZ2JyZXZldW5pMDEyM2hiYXJnZG90YWNjZW50aW1hY3JvbmkubG9jbFRSS2lvZ29uZWt1bmkwMjM3bGFjdXRldW5pMDEzN3VuaTAxM0NsY2Fyb25sZG90bmFjdXRlbmNhcm9uZW5ndW5pMDE0Nm9tYWNyb25vaHVuZ2FydW1sYXV0cmFjdXRlcmNhcm9udW5pMDE1N3NhY3V0ZXVuaTAyMTlzY2VkaWxsYXRiYXJ0Y2Fyb251bmkwMjFCdW5pMDE2M3VodW5nYXJ1bWxhdXR1bWFjcm9udW9nb25la3dhY3V0ZXVyaW5nd2NpcmN1bWZsZXh3ZGllcmVzaXN3Z3JhdmV5Y2lyY3VtZmxleHlncmF2ZXphY3V0ZXpkb3RhY2NlbnR3LjAwMWwu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CTQJOguYC5gLmAk0CToLmAuYC5gJNAk6C5gLmAuYCTQJOguYC5gLmAlACUYLmAuYC5gLmAlSCUwLmAuYC5gJUglMC5gLmAuYCVIJTAuYC5gLmAlSCUwLmAuYC5gJUglMC5gLmAuYCV4LmAlYC5gLmAleC5gJWAuYC5gJXguYCVgLmAuYCV4LmAlYC5gJZAlqC5gLmAuYCWQJaguYC5gLmAlkCWoLmAuYC5gJZAlqC5gLmAuYCWQJaguYC5gLmAlkCWoLmAuYC5gJZAlqC5gLmAuYCWQJaguYC5gLmAlkCWoLmAuYC5gLmAl2CXALmAuYC5gJdglwC5gLmAuYCXYJcAuYC5gLmAl2CXALmAuYC5gJgguYCXwLmAuYCYILmAl8C5gJiAmOC5gLmAuYCYgJjguYC5gLmAmICY4LmAuYC5gJiAmOC5gLmAuYCYgJjguYC5gLmAmICY4LmAuYC5gJiAmOC5gLmAuYCYgJjguYC5gLmAuYCZQLmAuYC5gLmAmgCZoLmAuYC5gJoAmaC5gLmAuYCbIJpgmsC5gLmAmyCaYJrAuYC5gJsgmmCawLmAuYCbIJpgmsC5gLmAmyCaYJrAm4C5gJsgmmCawLmAuYCb4LmAuYC5gLmAnKCcQLmAuYC5gJygnEC5gLmAuYCcoJxAuYC5gLmAnKCcQLmAuYC5gJygnEC5gLmAuYCdYLmAnQC5gLmAnWC5gJ0AuYC5gJ1guYCdALmAuYCdYLmAnQC5gLmAnWC5gJ0AuYC5gJ1guYCdALmAuYCdYLmAnQC5gLmAnWC5gJ0AuYC5gJ1guYCdALmAncCeILmAuYC5gLmAnWC5gJ0AuYC5gJ7gnoC5gLmAuYCe4J6AuYC5gLmAnuCegLmAuYC5gJ7gnoC5gLmAuYCfoJ9AuYC5gLmAn6CfQLmAuYC5gJ+gn0C5gLmAuYCfoJ9AuYC5gLmAn6CfQLmAuYC5gKDAoACgYLmAuYCgwKAAoGC5gLmAoMCgAKBguYC5gKDAoACgYLmAuYCgwKAAoGC5gKEgnuC5gLmAuYChIJ7guYC5gLmAoSCe4LmAuYC5gKEgnuC5gLmAuYChIJ7guYC5gLmAoSCe4LmAuYC5gKEgnuC5gLmAuYChIJ7guYC5gLmAoSCe4LmAuYC5gLmAoYC5gLmAuYC5gKGAuYC5gLmAuYChgLmAuYC5gLmAoYC5gLmAuYC5gKGAuYC5gLmAuYCh4LmAuYC5gLmAoeC5gLmAuYC5gKHguYC5gLmAuYCh4LmAuYC5gLmAoeC5gLmAuYC5gKJAuYC5gLmAuYCiQLmAuYC5gLmAokC5gLmAuYC5gKJAuYC5gLmAuYCjAKKguYC5gLmAowCioLmAuYC5gKMAoqC5gLmAuYCjAKKguYC5gKNgo8C5gLmAuYCjYKPAuYC5gLmAo2CjwLmAuYC5gKNgo8C5gLmAuYCjYKPAuYC5gLmAo2CjwLmAuYC5gKNgo8C5gLmAuYCjYKPAuYC5gLmAo2CjwLmAuYC5gKNgo8C5gLmAuYCkIKSAuYC5gLmAuYClQKTguYC5gLmApUCk4LmAuYC5gKVApOC5gLmAuYClQKTguYC5gLmApUCk4LmAuYC5gKYAuYCloLmAuYCmALmApaC5gLmApgC5gKWguYCmYKbAuYC5gLmApmCmwLmAuYC5gKZgpsC5gLmAuYCmYKbAuYC5gLmApmCmwLmAuYC5gKZgpsC5gLmAuYCmYKbAuYC5gLmApmCmwLmAuYC5gKZgpsC5gLmAuYC5gKcguYC5gLmAuYCngLmAuYC5gLmAp4C5gLmAuYC5gKeAuYC5gLmAuYCpAKhAqKCn4LmAqQCoQKigp+CqIKqAqcC5gKlgq6CsAKtAuYCq4LmArGC5gLmAuYC5gKxguYC5gLmAuYCsYLmAuYC5gKugrACrQLmAquC5gKxguYC5gLmAq6CsAKtAuYCq4KogqoCpwLmAqWC5gK0guYC5gKzAuYCtILmAuYCswLmAreCtgLmAuYC5gK3grYC5gLmAuYCuQKhAqKCn4LmArkCoQKigp+C5gK5AqECooKfguYCuQKhAqKCn4LmArkCoQKigrqC5gK5AqECooKfgq6CvAKtAuYCq4KugsCCvwLmAr2CroLAgr8C5gK9gq6CwIK/AuYCvYKugsCCvwLmAr2CroLCAr8C5gK9gq6CwIK/AuYCvYLmAsUC5gLDguYC5gLFAuYCw4LmAuYCxQLmAsOC5gLmAsUC5gLDguYC5gLFAuYCw4LmAuYCxQLmAsOC5gLmAsUC5gLDguYC5gLFAuYCw4LmAuYCxQLmAsOC5gLGgsgC5gLmAuYC5gLJguYC5gLmAuYCyYKhAqKCn4KugsyCywLmAquCroLMgssC5gKrgq6CzILLAuYCq4KugsyCywLmAqu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AC0AzQDRABIA0gDaABMA2wDgABQA4QDhAB8A4gDmABQA5wDqACMA6wDrABIA7ADsABQA7QDtAC0A7gDvACcA8AD2AAsA+AD4ABgA+QD5AB4A+gD6AB0A+wD7ABcA/AD8ABYA/QD9ABwA/gD+ABsA/wD/ABUBAAEAAC8BAQECACkBAwEEACwBBQEFACkBBgEGACYBCAEIABoBDgEPACIBEAEQABkBEQERAA8BEwETAA8BFQEVAA8BFgEZAA0BGwEdAA0BHgEfACkBIAEjABABKAEpABABKgEqAA4BLAEsAAMBMQExAA0BMwEzAA0BPgE+AA4BPwE/AAoAAgAsAIEAgQADAIIAggAMAIMAhwACAIgAiAAIAIkAiQAMAIoAigAJAIsAiwAIAIwAlAADAJUAlQAEAJYAmQAFAJoAmwAKAJwAnAATAKUApQAUAKcAqAAHAKkAqgAIAKsAqwAJAKwArAAIAK4ArgAIAK8AtQAKALYAvgAMAL8AvwADAMAAwAAMAMEAwQABAMIAwgANAMMAxgAOAMcAywAPAMwAzAAGAM0A0QAQANIA2gALANsA4AARAOEA4QAWAOIA5gARAOcA6gASAOsA6wAQAOwA7AARAO0A7QAIAO4A7gAVAPAA8AALAPEA8QAIAPIA8gAEAPMA8wALAPUA9QAIASoBKgACAT4BPgAMAAIASgACAAsAIwANAA0ALQAOABIAAgAhACQAAgAvAC8AAQAwADAALgAyADIAKgA/AEgAAgBJAEkAKwBLAEsAAgBQAFQAAwBVAFkABABaAGIABQBjAGgABgBpAGkABwBqAG4ACABvAHIACQB3AIEACgCCAIIAIgCDAIkAEACKAIsADACMAJQAEACVAJUADQCWAJkADgCaAJsAIgCcAJwAKQCdAJ0AJwClAKYADwCnAKcAIgCpAKwAIgCuAK4AIgCvALUAJwC2AL8AEADAAMEAJwDCAMIAEADDAMYAJwDHAMsAEwDMAMwAIgDNANEAFQDSANoAFgDbAOAAFwDhAOEAIQDiAOYAFwDnAOoAJADrAOsAFQDsAOwAFwDtAO0AIgDuAO8ADwDwAPYADQD4APgAHAD5APkAJQD6APoAIAD7APsAGgD8APwAGQD9AP0AHwD+AP4AHgD/AP8AKAEAAQAAGwEBAQIAJgEFAQUAJgEGAQYAGAEIAQgAHQEOAQ8AFAEQARAALAERAREAEQETARMAEQEVARUAEQEeAR8AJgEgASMAEgEoASkAEgEqASoAEAEsASwAAwE+AT4AEAE/AT8ACwABAS4AAQABAAIAIQAOABIAAgAhACQAAgAvAC8AAQA/AEgAAgBLAEsAAgBVAFkAAwBaAGIABABjAGgABQBpAGkABgBqAG4ABwBvAHIACAB3AIEACQCDAIkADQCMAJQADQCVAJUACgCWAJkACwCcAJwAEwClAKYADAC2AL8ADQDCAMIADQDHAMsADgDNANEADwDSANoAEADbAOAAEQDhAOEAFADiAOYAEQDnAOoAEgDrAOsADwDsAOwAEQDuAO8ADADwAPYACgEqASoADQE+AT4ADQABAQEAMwADAAMAAAAAAAMACgAGAAgACQAAAAAAAAAAAAUABQACAAcAAgAAAAIAAAABAAEAAQABAAAAAQABAAEAAwADAAQABAAEAAQAAAAAAAAAAAAEAAQAAAAAAAAAAAAAAAAAAAABAAAAAQACAC8AAgALAAUADgASAAcAIQAkAAcALwAvAAYAPwBIAAcASwBLAAcAUABUABQAVQBZAAEAWgBiABcAYwBoAAIAaQBpAAMAagBuAAQAbwByABUAdwCBAAgAggCCAAoAgwCJAAsAjACUAAsAlQCVAAkAlgCZABIAmgCbAAoAnACcABgAnQCdABYApQCmABMApwCnAAoAqQCsAAoArgCuAAoArwC1ABYAtgC/AAsAwADBABYAwgDCAAsAwwDGABYAxwDLAAwAzADMAAoAzQDRAA0A0gDaAA4A2wDgAA8A4QDhABEA4gDmAA8A5wDqABAA6wDrAA0A7ADsAA8A7QDtAAoA7gDvABMA8AD2AAkBKgEqAAsBLAEsABQBPgE+AAsAAQAAAAoBKATmAAJERkxUAA5sYXRuACYABAAAAAD//wAHAAAACgAUAB4AKAA6AEQANAAIQVpFIABIQ0FUIABeQ1JUIAB0S0FaIACKTU9MIACgUk9NIAC2VEFUIADMVFJLIADiAAD//wAHAAEACwAVAB8AKQA7AEUAAP//AAgAAgAMABYAIAAqADIAPABGAAD//wAIAAMADQAXACEAKwAzAD0ARwAA//8ACAAEAA4AGAAiACwANAA+AEgAAP//AAgABQAPABkAIwAtADUAPwBJAAD//wAIAAYAEAAaACQALgA2AEAASgAA//8ACAAHABEAGwAlAC8ANwBBAEsAAP//AAgACAASABwAJgAwADgAQgBMAAD//wAIAAkAEwAdACcAMQA5AEMATQBOYWFsdAHWYWFsdAHcYWFsdAHiYWFsdAHoYWFsdAHuYWFsdAH0YWFsdAH6YWFsdAIAYWFsdAIGYWFsdAIMY2FsdAISY2FsdAIYY2FsdAIeY2FsdAIkY2FsdAIqY2FsdAIwY2FsdAI2Y2FsdAI8Y2FsdAJCY2FsdAJIY2FzZQJOY2FzZQJUY2FzZQJaY2FzZQJgY2FzZQJmY2FzZQJsY2FzZQJyY2FzZQJ4Y2FzZQJ+Y2FzZQKEY2NtcAKKY2NtcAKSY2NtcAKaY2NtcAKiY2NtcAKqY2NtcAKyY2NtcAK6Y2NtcALCY2NtcALKY2NtcALSbGlnYQLabGlnYQLgbGlnYQLmbGlnYQLsbGlnYQLybGlnYQL4bGlnYQL+bGlnYQMEbGlnYQMKbGlnYQMQbG9jbAMWbG9jbAMcbG9jbAMibG9jbAMobG9jbAMubG9jbAM0bG9jbAM6bG9jbANAc2FsdANGc2FsdANMc2FsdANSc2FsdANYc2FsdANec2FsdANkc2FsdANqc2FsdANwc2FsdAN2c2FsdAN8c3MwMQOCc3MwMQOIc3MwMQOOc3MwMQOUc3MwMQOac3MwMQOgc3MwMQOmc3MwMQOsc3MwMQOyc3MwMQO4AAAAAQAAAAAAAQAAAAAAAQAAAAAAAQAAAAAAAQAAAAAAAQAAAAAAAQAAAAAAAQAAAAAAAQAAAAAAAQAAAAAAAQAPAAAAAQAPAAAAAQAPAAAAAQAPAAAAAQAPAAAAAQAPAAAAAQAPAAAAAQAPAAAAAQAPAAAAAQAPAAAAAQALAAAAAQALAAAAAQALAAAAAQALAAAAAQALAAAAAQALAAAAAQALAAAAAQALAAAAAQALAAAAAQALAAAAAgABAAIAAAACAAEAAgAAAAIAAQACAAAAAgABAAIAAAACAAEAAgAAAAIAAQACAAAAAgABAAIAAAACAAEAAgAAAAIAAQACAAAAAgABAAIAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAoAAAABAAMAAAABAAkAAAABAAYAAAABAAUAAAABAAQAAAABAAcAAAABAAgAAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA4AAAABAA4AAAABAA4AAAABAA4AAAABAA4AAAABAA4AAAABAA4AAAABAA4AAAABAA4AAAABAA4AEwAoADAAPgBIAFIAWgBiAGoAcgB6AIIAigCSAJoAogCqAMAAyADQAAEAAAABAloABgAAAAQAqAC6AM4A4AAGAAAAAgDkAPYABgAAAAIA/gESAAEAAAABARwAAQAAAAEBGgABAAAAAQEYAAEAAAABARYAAQAAAAEBFAABAAAAAQESAAEAAAABARAAAQAAAAEBDgAEAAAAAQEWAAEAAAABAUwAAQAAAAEBSgAGAAAACAFIAVoBbAF+AZABogG0AcYAAQAAAAEB5gAEAAAAAQHsAAEAAAABAgIAAwAAAAECAAABAggAAQAAABAAAwAAAAEB7gACAgAB9gABAAAAEAADAAEB9gABAfYAAAABAAAAEAADAAEB7AABAeQAAAABAAAAEAADAAAAAQHSAAEB5AABAAAAEAADAAEB0gABAcAAAAABAAAAEAADAAAAAgHIAc4AAQHIAAEAAAARAAMAAAACAcABugABAcAAAQAAABEAAQGyAAEAAQGsAAEAAQGyAAUAAQGsAAUAAQGmAAUAAQGgAAUAAQGaAAUAAgGaAAUBGwEcAR0BaAFpAAEBmAABAAgABgAOABYAHgAkACoAMADzAAMAlQCcAPUAAwCVAKkA8gACAJUA8AACAJwA9gACAKUA8QACAKkAAQFgACcAAQFaACcAAwABAV4AAQFkAAAAAQAAABIAAwABAVIAAQFSAAAAAQAAABIAAwABAUYAAQFAAAAAAQAAABIAAwABAToAAQEuAAAAAQAAABIAAwABAS4AAQEcAAAAAQAAABIAAwABASIAAQEKAAAAAQAAABIAAwABARYAAQD4AAAAAQAAABIAAwABAQoAAQDmAAAAAQAAABIAAgD+AA8AcwB0AHUAdgBUAFkAoQDuAMsA0QEbARwBHQFoAWkAAgD8AAQAnQCmAWgBaQABAPoAAgAKABQAAQAEADYAAgEKAAEABACtAAIBCgABAIQASQABAAIAnAClAAIAAQFJAVQAAAACAAEBVgFZAAAAAQACAVgBWQACAAEAAgB2AAAAAQACAWgBaQABAAEAqQABAAEBCgABAAEAMgABAAQAUwBYAMoA0AABAAEAnAABAAUBFgEYARkBWAFZAAEAAQCVAAIAAQBMAE8AAAABAAEAlgABAAEApQABAAEA4gABAAEAwgABAAEASwABAAEBCQABAAEBBwABAAEBEAABAA8ATABNAE4ATwBTAFgAnAClAMoA0AEWARgBGQFYAVkAAQAEAJwApQFYAVkAAQACADIAqQ==) format('truetype'); font-weight: inherit; font-style: inherit; }\nscript.js: /*-------------------- Vars --------------------*/ const $menu = document.querySelector('.menu') const $items = document.querySelectorAll('.menu--item') let menuHeight = $menu.clientHeight let itemHeight = $items[0].clientHeight let wrapHeight = $items.length * itemHeight let scrollSpeed = 0 let oldScrollY = 0 let scrollY = 0 let y = 0 /*-------------------- Lerp --------------------*/ const lerp = (v0, v1, t) => { return v0 * ( 1 - t ) + v1 * t } /*-------------------- Dispose --------------------*/ const dispose = (scroll) => { gsap.set($items, { y: (i) => { return i * itemHeight + scroll }, modifiers: { y: (y) => { const s = gsap.utils.wrap(-itemHeight, wrapHeight - itemHeight, parseInt(y)) return `${s}px` } } }) } dispose(0) /*-------------------- Wheel --------------------*/ const handleMouseWheel = (e) => { scrollY -= e.deltaY } /*-------------------- Touch --------------------*/ let touchStart = 0 let touchY = 0 let isDragging = false const handleTouchStart = (e) => { touchStart = e.clientY || e.touches[0].clientY isDragging = true $menu.classList.add('is-dragging') } const handleTouchMove = (e) => { if (!isDragging) return touchY = e.clientY || e.touches[0].clientY scrollY += (touchY - touchStart) * 2.5 touchStart = touchY } const handleTouchEnd = () => { isDragging = false $menu.classList.remove('is-dragging') } /*-------------------- Listeners --------------------*/ $menu.addEventListener('mousewheel', handleMouseWheel) $menu.addEventListener('touchstart', handleTouchStart) $menu.addEventListener('touchmove', handleTouchMove) $menu.addEventListener('touchend', handleTouchEnd) $menu.addEventListener('mousedown', handleTouchStart) $menu.addEventListener('mousemove', handleTouchMove) $menu.addEventListener('mouseleave', handleTouchEnd) $menu.addEventListener('mouseup', handleTouchEnd) $menu.addEventListener('selectstart', () => { return false }) /*-------------------- Resize --------------------*/ window.addEventListener('resize', () => { menuHeight = $menu.clientHeight itemHeight = $items[0].clientHeight wrapHeight = $items.length * itemHeight }) /*-------------------- Render --------------------*/ const render = () => { requestAnimationFrame(render) y = lerp(y, scrollY, .1) dispose(y) scrollSpeed = y - oldScrollY oldScrollY = y gsap.to($items, { scale: 1 - Math.min(100, Math.abs(scrollSpeed)) * .005, rotate: scrollSpeed * 0.2 }) } render()",
    "id": "slider-with-infinite-loop-with-drag-and-scroll"
  },
  {
    "title": "[threejs/gsap]  Liquid Morphology Slideshow",
    "description": "",
    "code": "index.html: <main class=\"slider-wrapper\"> <canvas class=\"webgl-canvas\"></canvas> <span class=\"slide-number\" id=\"slideNumber\">01</span> <span class=\"slide-total\" id=\"slideTotal\">06</span> <span class=\"help-text\"> H: Toggle Settings  Space/: Next  : Previous  Click to Advance </span> <nav class=\"slides-navigation\" id=\"slidesNav\"> <!-- Navigation items will be generated by JavaScript --> </nav> </main>\nstyle.css: @import url(\"https://fonts.cdnfonts.com/css/pp-neue-montreal\"); @font-face { font-family: \"PPSupplyMono\"; src: url(\"https://assets.codepen.io/7558/PPSupplyMono-Regular.ttf\") format(\"truetype\"); font-weight: normal; font-style: normal; font-display: swap; } :root { --font-mono: \"PPSupplyMono\", monospace; --font-sans: \"PP Neue Montreal\", sans-serif; --color-bg: #000; --color-text: #fff; --color-text-muted: rgba(255, 255, 255, 0.8); --color-text-light: rgba(255, 255, 255, 0.6); --color-accent: #fff; --font-size-mono: clamp(10px, 1.2vw, 12px); --spacing-sm: 1rem; --spacing-md: 2rem; } * { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: var(--font-sans); background: var(--color-bg); overflow: hidden; color: var(--color-text); cursor: pointer; } .slider-wrapper { position: relative; width: 100vw; height: 100vh; overflow: hidden; } .webgl-canvas { display: block; width: 100%; height: 100%; } /* Current slide number at middle left - UPDATED: 12px uppercase */ .slide-number { position: absolute; top: 50%; left: var(--spacing-md); transform: translateY(-50%); font-family: var(--font-mono); font-size: 12px; font-weight: 600; color: var(--color-text); z-index: 3; letter-spacing: 1px; text-transform: uppercase; } /* Total slides at middle right - UPDATED: 12px uppercase */ .slide-total { position: absolute; top: 50%; right: var(--spacing-md); transform: translateY(-50%); font-family: var(--font-mono); font-size: 12px; font-weight: 600; color: var(--color-text); z-index: 3; letter-spacing: 1px; text-transform: uppercase; } .slides-navigation { position: absolute; bottom: var(--spacing-md); left: var(--spacing-md); right: var(--spacing-md); display: flex; gap: 0; z-index: 3; pointer-events: all; } .slide-nav-item { display: flex; flex-direction: column; cursor: pointer; padding: var(--spacing-sm); flex: 1; border: none; background: none; } .slide-progress-line { width: 100%; height: 2px; background: rgba(255, 255, 255, 0.2); margin-bottom: 8px; border-radius: 1px; overflow: hidden; } .slide-progress-fill { height: 100%; width: 0%; background: var(--color-accent); transition: width 0.1s ease, opacity 0.3s ease; border-radius: 1px; } .slide-nav-title { font-family: var(--font-mono); font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--color-text-muted); font-weight: 600; transition: color 0.3s ease; } .slide-nav-item.active .slide-nav-title { color: var(--color-text); } .help-text { position: absolute; top: var(--spacing-md); left: var(--spacing-md); font-family: var(--font-mono); font-size: 11px; text-transform: uppercase; color: var(--color-text-muted); z-index: 3; } /* Tweakpane Styling */ .tp-dfwv { position: fixed !important; top: 20px !important; right: 20px !important; z-index: 1000 !important; max-width: 320px !important; background: rgba(0, 0, 0, 0.9) !important; backdrop-filter: blur(20px) !important; border: 1px solid rgba(255, 255, 255, 0.1) !important; border-radius: 8px !important; } .tp-dfwv .tp-btnv_b { background: rgba(255, 255, 255, 0.1) !important; border: 1px solid rgba(255, 255, 255, 0.2) !important; color: #ffffff !important; font-family: var(--font-mono) !important; border-radius: 4px !important; } .tp-dfwv .tp-btnv_b:hover { background: rgba(255, 255, 255, 0.2) !important; } @media (max-width: 600px) { .slides-navigation { bottom: var(--spacing-sm); left: var(--spacing-sm); right: var(--spacing-sm); } .slide-nav-item { padding: 0.75rem; } .help-text { top: var(--spacing-sm); left: var(--spacing-sm); } .slide-number { left: var(--spacing-sm); } .slide-total { right: var(--spacing-sm); } .tp-dfwv { top: 10px !important; right: 10px !important; max-width: 280px !important; } } /* Preloader styles */ .slider-wrapper { opacity: 0; transition: opacity 1.5s ease-in; pointer-events: none; } .slider-wrapper.loaded { opacity: 1; pointer-events: auto; }\nscript.js: // ======================================== // PRELOADER // ======================================== class SliderLoadingManager { constructor() { this.overlay = null; this.canvas = null; this.ctx = null; this.animationId = null; this.startTime = null; this.duration = 3000; this.createLoadingScreen(); } createLoadingScreen() { this.overlay = document.createElement(\"div\"); this.overlay.style.cssText = ` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000000; display: flex; justify-content: center; align-items: center; z-index: 10000; `; this.canvas = document.createElement(\"canvas\"); this.canvas.width = 300; this.canvas.height = 300; this.ctx = this.canvas.getContext(\"2d\"); this.overlay.appendChild(this.canvas); document.body.appendChild(this.overlay); this.startAnimation(); } startAnimation() { const centerX = this.canvas.width / 2; const centerY = this.canvas.height / 2; let time = 0; let lastTime = 0; const dotRings = [ { radius: 20, count: 8 }, { radius: 35, count: 12 }, { radius: 50, count: 16 }, { radius: 65, count: 20 }, { radius: 80, count: 24 } ]; const colors = { primary: \"#ffffff\", accent: \"#dddddd\" }; const easeInOutSine = (t) => { return -(Math.cos(Math.PI * t) - 1) / 2; }; const easeInOutCubic = (t) => { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }; const smoothstep = (edge0, edge1, x) => { const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0))); return t * t * (3 - 2 * t); }; const hexToRgb = (hex) => { if (hex.startsWith(\"#\")) { return [ parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16) ]; } const match = hex.match(/\\d+/g); return match ? [parseInt(match[0]), parseInt(match[1]), parseInt(match[2])] : [255, 255, 255]; }; const interpolateColor = (color1, color2, t, opacity = 1) => { const rgb1 = hexToRgb(color1); const rgb2 = hexToRgb(color2); const r = Math.round(rgb1[0] + (rgb2[0] - rgb1[0]) * t); const g = Math.round(rgb1[1] + (rgb2[1] - rgb1[1]) * t); const b = Math.round(rgb1[2] + (rgb2[2] - rgb1[2]) * t); return `rgba(${r}, ${g}, ${b}, ${opacity})`; }; const animate = (timestamp) => { if (!this.startTime) this.startTime = timestamp; if (!lastTime) lastTime = timestamp; const deltaTime = timestamp - lastTime; lastTime = timestamp; time += deltaTime * 0.001; this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.beginPath(); this.ctx.arc(centerX, centerY, 3, 0, Math.PI * 2); const rgb = hexToRgb(colors.primary); this.ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.9)`; this.ctx.fill(); dotRings.forEach((ring, ringIndex) => { for (let i = 0; i < ring.count; i++) { const angle = (i / ring.count) * Math.PI * 2; const pulseTime = time * 2 - ringIndex * 0.4; const radiusPulse = easeInOutSine((Math.sin(pulseTime) + 1) / 2) * 6 - 3; const x = centerX + Math.cos(angle) * (ring.radius + radiusPulse); const y = centerY + Math.sin(angle) * (ring.radius + radiusPulse); const opacityPhase = (Math.sin(pulseTime + i * 0.2) + 1) / 2; const opacityBase = 0.3 + easeInOutSine(opacityPhase) * 0.7; const highlightPhase = (Math.sin(pulseTime) + 1) / 2; const highlightIntensity = easeInOutCubic(highlightPhase); this.ctx.beginPath(); this.ctx.arc(x, y, 2, 0, Math.PI * 2); const colorBlend = smoothstep(0.2, 0.8, highlightIntensity); this.ctx.fillStyle = interpolateColor( colors.primary, colors.accent, colorBlend, opacityBase ); this.ctx.fill(); } }); if (timestamp - this.startTime >= this.duration) { this.complete(); return; } this.animationId = requestAnimationFrame(animate); }; this.animationId = requestAnimationFrame(animate); } complete() { if (this.animationId) { cancelAnimationFrame(this.animationId); } if (this.overlay) { this.overlay.style.opacity = \"0\"; this.overlay.style.transition = \"opacity 0.8s ease\"; setTimeout(() => { this.overlay?.remove(); setTimeout(() => { const sliderWrapper = document.querySelector(\".slider-wrapper\"); if (sliderWrapper) { sliderWrapper.classList.add(\"loaded\"); } }, 500); }, 800); } } } // Initialize preloader document.addEventListener(\"DOMContentLoaded\", function () { const loadingManager = new SliderLoadingManager(); }); // ======================================== // VISUAL EFFECTS SLIDER CONFIGURATION // ======================================== const SLIDER_CONFIG = { // Core settings settings: { // Timing settings transitionDuration: 2.5, autoSlideSpeed: 5000, // Current state currentEffect: \"glass\", currentEffectPreset: \"Default\", // Global settings that affect all effects globalIntensity: 1.0, speedMultiplier: 1.0, distortionStrength: 1.0, colorEnhancement: 1.0, // Effect-specific settings (will be overridden by presets) glassRefractionStrength: 1.0, glassChromaticAberration: 1.0, glassBubbleClarity: 1.0, glassEdgeGlow: 1.0, glassLiquidFlow: 1.0, frostIntensity: 1.5, frostCrystalSize: 1.0, frostIceCoverage: 1.0, frostTemperature: 1.0, frostTexture: 1.0, rippleFrequency: 25.0, rippleAmplitude: 0.08, rippleWaveSpeed: 1.0, rippleRippleCount: 1.0, rippleDecay: 1.0, plasmaIntensity: 1.2, plasmaSpeed: 0.8, plasmaEnergyIntensity: 0.4, plasmaContrastBoost: 0.3, plasmaTurbulence: 1.0, timeshiftDistortion: 1.6, timeshiftBlur: 1.5, timeshiftFlow: 1.4, timeshiftChromatic: 1.5, timeshiftTurbulence: 1.4 }, // Effect-specific presets effectPresets: { glass: { Subtle: { glassRefractionStrength: 0.6, glassChromaticAberration: 0.5, glassBubbleClarity: 1.3, glassEdgeGlow: 0.7, glassLiquidFlow: 0.8 }, Default: { glassRefractionStrength: 1.0, glassChromaticAberration: 1.0, glassBubbleClarity: 1.0, glassEdgeGlow: 1.0, glassLiquidFlow: 1.0 }, Crystal: { glassRefractionStrength: 1.5, glassChromaticAberration: 1.8, glassBubbleClarity: 0.7, glassEdgeGlow: 1.4, glassLiquidFlow: 0.5 }, Liquid: { glassRefractionStrength: 0.8, glassChromaticAberration: 0.4, glassBubbleClarity: 1.2, glassEdgeGlow: 0.8, glassLiquidFlow: 1.8 } }, frost: { Light: { frostIntensity: 0.8, frostCrystalSize: 1.3, frostIceCoverage: 0.6, frostTemperature: 0.7, frostTexture: 0.8 }, Default: { frostIntensity: 1.5, frostCrystalSize: 1.0, frostIceCoverage: 1.0, frostTemperature: 1.0, frostTexture: 1.0 }, Heavy: { frostIntensity: 2.2, frostCrystalSize: 0.7, frostIceCoverage: 1.4, frostTemperature: 1.5, frostTexture: 1.3 }, Arctic: { frostIntensity: 2.8, frostCrystalSize: 0.5, frostIceCoverage: 1.8, frostTemperature: 2.0, frostTexture: 1.6 } }, ripple: { Gentle: { rippleFrequency: 15.0, rippleAmplitude: 0.05, rippleWaveSpeed: 0.7, rippleRippleCount: 0.8, rippleDecay: 1.2 }, Default: { rippleFrequency: 25.0, rippleAmplitude: 0.08, rippleWaveSpeed: 1.0, rippleRippleCount: 1.0, rippleDecay: 1.0 }, Strong: { rippleFrequency: 35.0, rippleAmplitude: 0.12, rippleWaveSpeed: 1.4, rippleRippleCount: 1.3, rippleDecay: 0.8 }, Tsunami: { rippleFrequency: 45.0, rippleAmplitude: 0.18, rippleWaveSpeed: 1.8, rippleRippleCount: 1.6, rippleDecay: 0.6 } }, plasma: { Calm: { plasmaIntensity: 0.8, plasmaSpeed: 0.5, plasmaEnergyIntensity: 0.2, plasmaContrastBoost: 0.1, plasmaTurbulence: 0.6 }, Default: { plasmaIntensity: 1.2, plasmaSpeed: 0.8, plasmaEnergyIntensity: 0.4, plasmaContrastBoost: 0.3, plasmaTurbulence: 1.0 }, Storm: { plasmaIntensity: 1.8, plasmaSpeed: 1.3, plasmaEnergyIntensity: 0.7, plasmaContrastBoost: 0.5, plasmaTurbulence: 1.5 }, Nuclear: { plasmaIntensity: 2.5, plasmaSpeed: 1.8, plasmaEnergyIntensity: 1.0, plasmaContrastBoost: 0.8, plasmaTurbulence: 2.0 } }, timeshift: { Subtle: { timeshiftDistortion: 0.5, timeshiftBlur: 0.6, timeshiftFlow: 0.5, timeshiftChromatic: 0.4, timeshiftTurbulence: 0.6 }, Default: { timeshiftDistortion: 1.6, timeshiftBlur: 1.5, timeshiftFlow: 1.4, timeshiftChromatic: 1.5, timeshiftTurbulence: 1.4 }, Intense: { timeshiftDistortion: 2.2, timeshiftBlur: 2.0, timeshiftFlow: 2.0, timeshiftChromatic: 2.2, timeshiftTurbulence: 2.0 }, Dreamlike: { timeshiftDistortion: 2.8, timeshiftBlur: 2.5, timeshiftFlow: 2.5, timeshiftChromatic: 2.6, timeshiftTurbulence: 2.5 } } } }; // ======================================== // MAIN SLIDER CODE STARTS HERE // ======================================== import * as THREE from \"https://esm.sh/three\"; import { Pane } from \"https://cdn.skypack.dev/tweakpane@4.0.4\"; let currentSlideIndex = 0; let isTransitioning = false; let shaderMaterial, renderer, scene, camera; let slideTextures = []; let texturesLoaded = false; let autoSlideTimer = null; let progressAnimation = null; let sliderEnabled = false; let pane = null; let isApplyingPreset = false; // UI elements let effectFolders = {}; let currentEffectFolder = null; const SLIDE_DURATION = () => SLIDER_CONFIG.settings.autoSlideSpeed; const PROGRESS_UPDATE_INTERVAL = 50; const TRANSITION_DURATION = () => SLIDER_CONFIG.settings.transitionDuration; const slides = [ { title: \"Ethereal Glow\", media: \"https://assets.codepen.io/7558/orange-portrait-001.jpg\" }, { title: \"Rose Mirage\", media: \"https://assets.codepen.io/7558/orange-portrait-002.jpg\" }, { title: \"Velvet Mystique\", media: \"https://assets.codepen.io/7558/orange-portrait-003.jpg\" }, { title: \"Golden Hour\", media: \"https://assets.codepen.io/7558/orange-portrait-004.jpg\" }, { title: \"Midnight Dreams\", media: \"https://assets.codepen.io/7558/orange-portrait-005.jpg\" }, { title: \"Silver Light\", media: \"https://assets.codepen.io/7558/orange-portrait-006.jpg\" } ]; // Touch support variables let touchStartX = 0; let touchEndX = 0; const vertexShader = ` varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `; const fragmentShader = ` uniform sampler2D uTexture1; uniform sampler2D uTexture2; uniform float uProgress; uniform vec2 uResolution; uniform vec2 uTexture1Size; uniform vec2 uTexture2Size; uniform int uEffectType; // Global settings uniforms uniform float uGlobalIntensity; uniform float uSpeedMultiplier; uniform float uDistortionStrength; uniform float uColorEnhancement; // Glass uniforms uniform float uGlassRefractionStrength; uniform float uGlassChromaticAberration; uniform float uGlassBubbleClarity; uniform float uGlassEdgeGlow; uniform float uGlassLiquidFlow; // Frost uniforms uniform float uFrostIntensity; uniform float uFrostCrystalSize; uniform float uFrostIceCoverage; uniform float uFrostTemperature; uniform float uFrostTexture; // Ripple uniforms uniform float uRippleFrequency; uniform float uRippleAmplitude; uniform float uRippleWaveSpeed; uniform float uRippleRippleCount; uniform float uRippleDecay; // Plasma uniforms uniform float uPlasmaIntensity; uniform float uPlasmaSpeed; uniform float uPlasmaEnergyIntensity; uniform float uPlasmaContrastBoost; uniform float uPlasmaTurbulence; // Timeshift uniforms uniform float uTimeshiftDistortion; uniform float uTimeshiftBlur; uniform float uTimeshiftFlow; uniform float uTimeshiftChromatic; uniform float uTimeshiftTurbulence; varying vec2 vUv; vec2 getCoverUV(vec2 uv, vec2 textureSize) { vec2 s = uResolution / textureSize; float scale = max(s.x, s.y); vec2 scaledSize = textureSize * scale; vec2 offset = (uResolution - scaledSize) * 0.5; return (uv * uResolution - offset) / scaledSize; } float noise(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); } float smoothNoise(vec2 p) { vec2 i = floor(p); vec2 f = fract(p); f = f * f * (3.0 - 2.0 * f); return mix( mix(noise(i), noise(i + vec2(1.0, 0.0)), f.x), mix(noise(i + vec2(0.0, 1.0)), noise(i + vec2(1.0, 1.0)), f.x), f.y ); } float rand(vec2 uv) { float a = dot(uv, vec2(92., 80.)); float b = dot(uv, vec2(41., 62.)); float x = sin(a) + cos(b) * 51.; return fract(x); } vec4 glassEffect(vec2 uv, float progress) { float glassStrength = 0.08 * uGlassRefractionStrength * uDistortionStrength * uGlobalIntensity; float chromaticAberration = 0.02 * uGlassChromaticAberration * uGlobalIntensity; float waveDistortion = 0.025 * uDistortionStrength; float clearCenterSize = 0.3 * uGlassBubbleClarity; float surfaceRipples = 0.004 * uDistortionStrength; float liquidFlow = 0.015 * uGlassLiquidFlow * uSpeedMultiplier; float rimLightWidth = 0.05; float glassEdgeWidth = 0.025; float brightnessPhase = smoothstep(0.8, 1.0, progress); float rimLightIntensity = 0.08 * (1.0 - brightnessPhase) * uGlassEdgeGlow * uGlobalIntensity; float glassEdgeOpacity = 0.06 * (1.0 - brightnessPhase) * uGlassEdgeGlow; vec2 center = vec2(0.5, 0.5); vec2 p = uv * uResolution; vec2 uv1 = getCoverUV(uv, uTexture1Size); vec2 uv2_base = getCoverUV(uv, uTexture2Size); float maxRadius = length(uResolution) * 0.85; // FIX: Start completely off-screen at progress 0 float bubbleRadius = progress * maxRadius; vec2 sphereCenter = center * uResolution; float dist = length(p - sphereCenter); float normalizedDist = dist / max(bubbleRadius, 0.001); vec2 direction = (dist > 0.0) ? (p - sphereCenter) / dist : vec2(0.0); float inside = smoothstep(bubbleRadius + 3.0, bubbleRadius - 3.0, dist); float distanceFactor = smoothstep(clearCenterSize, 1.0, normalizedDist); float time = progress * 5.0 * uSpeedMultiplier; vec2 liquidSurface = vec2( smoothNoise(uv * 100.0 + time * 0.3), smoothNoise(uv * 100.0 + time * 0.2 + 50.0) ) - 0.5; liquidSurface *= surfaceRipples * distanceFactor; vec2 distortedUV = uv2_base; if (inside > 0.0) { float refractionOffset = glassStrength * pow(distanceFactor, 1.5); vec2 flowDirection = normalize(direction + vec2(sin(time), cos(time * 0.7)) * 0.3); distortedUV -= flowDirection * refractionOffset; float wave1 = sin(normalizedDist * 22.0 - time * 3.5); float wave2 = sin(normalizedDist * 35.0 + time * 2.8) * 0.7; float wave3 = sin(normalizedDist * 50.0 - time * 4.2) * 0.5; float combinedWave = (wave1 + wave2 + wave3) / 3.0; float waveOffset = combinedWave * waveDistortion * distanceFactor; distortedUV -= direction * waveOffset + liquidSurface; vec2 flowOffset = vec2( sin(time + normalizedDist * 10.0), cos(time * 0.8 + normalizedDist * 8.0) ) * liquidFlow * distanceFactor * inside; distortedUV += flowOffset; } vec4 newImg; if (inside > 0.0) { float aberrationOffset = chromaticAberration * pow(distanceFactor, 1.2); vec2 uv_r = distortedUV + direction * aberrationOffset * 1.2; vec2 uv_g = distortedUV + direction * aberrationOffset * 0.2; vec2 uv_b = distortedUV - direction * aberrationOffset * 0.8; float r = texture2D(uTexture2, uv_r).r; float g = texture2D(uTexture2, uv_g).g; float b = texture2D(uTexture2, uv_b).b; newImg = vec4(r, g, b, 1.0); } else { newImg = texture2D(uTexture2, uv2_base); } if (inside > 0.0 && rimLightIntensity > 0.0) { float rim = smoothstep(1.0 - rimLightWidth, 1.0, normalizedDist) * (1.0 - smoothstep(1.0, 1.01, normalizedDist)); newImg.rgb += rim * rimLightIntensity; float edge = smoothstep(1.0 - glassEdgeWidth, 1.0, normalizedDist) * (1.0 - smoothstep(1.0, 1.01, normalizedDist)); newImg.rgb = mix(newImg.rgb, vec3(1.0), edge * glassEdgeOpacity); } // Apply color enhancement newImg.rgb = mix(newImg.rgb, newImg.rgb * 1.2, (uColorEnhancement - 1.0) * 0.5); vec4 currentImg = texture2D(uTexture1, uv1); if (progress > 0.95) { vec4 pureNewImg = texture2D(uTexture2, uv2_base); float endTransition = (progress - 0.95) / 0.05; newImg = mix(newImg, pureNewImg, endTransition); } return mix(currentImg, newImg, inside); } vec4 frostEffect(vec2 uv, float progress) { vec4 currentImg = texture2D(uTexture1, getCoverUV(uv, uTexture1Size)); vec4 newImg = texture2D(uTexture2, getCoverUV(uv, uTexture2Size)); float effectiveIntensity = uFrostIntensity * uGlobalIntensity; float crystalScale = 80.0 / uFrostCrystalSize; float iceScale = 40.0 / uFrostCrystalSize; float temperatureEffect = uFrostTemperature; float frost1 = smoothNoise(uv * crystalScale * uFrostTexture); float frost2 = smoothNoise(uv * iceScale + 50.0) * 0.7; float frost3 = smoothNoise(uv * (crystalScale * 2.0) + 100.0) * 0.3; float frost = (frost1 + frost2 + frost3) / 2.0; float icespread = smoothNoise(uv * 25.0 / uFrostCrystalSize + 200.0); vec2 rnd = vec2( rand(uv + frost * 0.1), rand(uv + frost * 0.1 + 0.5) ); // Clamp ice coverage to prevent numerical instability float clampedIceCoverage = clamp(uFrostIceCoverage, 0.1, 2.5); float size = mix(progress, sqrt(progress), 0.5) * 1.12 * clampedIceCoverage + 0.0000001; // Prevent lens.y from becoming too extreme by clamping the power float lensY = clamp(pow(size, clamp(4.0, 1.5, 6.0)) / 2.0, size * 0.1, size * 8.0); vec2 lens = vec2(size, lensY); float dist = distance(uv, vec2(0.5, 0.5)); float vignette = pow(1.0 - smoothstep(lens.x, lens.y, dist), 2.0); float frostyness = 0.8 * effectiveIntensity * uDistortionStrength; rnd *= frost * vignette * frostyness * (1.0 - floor(vignette)); vec4 regular = newImg; vec4 frozen = texture2D(uTexture2, getCoverUV(uv + rnd * 0.06, uTexture2Size)); // Temperature-based color shift (clamped to prevent extreme values) float tempShift = clamp(temperatureEffect * 0.15, 0.0, 0.3); frozen *= vec4( clamp(0.85 + tempShift, 0.7, 1.2), clamp(0.9, 0.8, 1.0), clamp(1.2 - tempShift, 0.8, 1.3), 1.0 ); // Reduced temperature mixing effect float tempMixStrength = clamp(0.1 * temperatureEffect, 0.0, 0.25); frozen = mix(frozen, vec4(0.9, 0.95, 1.1, 1.0), tempMixStrength); float frostMask = smoothstep(icespread * 0.8, 1.0, pow(vignette, 1.5)); vec4 frostResult = mix(frozen, regular, frostMask); // Adjust color transition timing based on frost intensity float transitionStart = mix(0.85, 0.7, clamp(effectiveIntensity - 1.0, 0.0, 1.0)); float colorTransition = smoothstep(transitionStart, 1.0, progress); vec4 finalFrost = mix(frostResult, regular, colorTransition); // Apply color enhancement finalFrost.rgb = mix(finalFrost.rgb, finalFrost.rgb * 1.2, (uColorEnhancement - 1.0) * 0.5); // Extend the blend all the way to 100% and smooth the final transition float overallBlend = smoothstep(0.0, 1.0, progress); // Add final cleanup transition for the last 5% if (progress > 0.95) { float endTransition = (progress - 0.95) / 0.05; finalFrost = mix(finalFrost, newImg, endTransition * 0.5); } return mix(currentImg, finalFrost, overallBlend); } vec4 rippleEffect(vec2 uv, float progress) { vec4 currentImg = texture2D(uTexture1, getCoverUV(uv, uTexture1Size)); vec4 newImg = texture2D(uTexture2, getCoverUV(uv, uTexture2Size)); vec2 center = vec2(0.5, 0.5); float dist = distance(uv, center); float maxDist = 0.8; float effectiveSpeed = uRippleWaveSpeed * uSpeedMultiplier; float effectiveAmplitude = uRippleAmplitude * uDistortionStrength * uGlobalIntensity; float effectiveDecay = uRippleDecay; float waveRadius = progress * maxDist * 1.5 * effectiveSpeed; float ripple1 = sin((dist - waveRadius) * uRippleFrequency) * exp(-abs(dist - waveRadius) * 8.0 * effectiveDecay); float ripple2 = sin((dist - waveRadius * 0.7) * uRippleFrequency * 1.3) * exp(-abs(dist - waveRadius * 0.7) * 6.0 * effectiveDecay) * 0.6 * uRippleRippleCount; float ripple3 = sin((dist - waveRadius * 0.4) * uRippleFrequency * 1.8) * exp(-abs(dist - waveRadius * 0.4) * 4.0 * effectiveDecay) * 0.3 * uRippleRippleCount; float combinedRipple = (ripple1 + ripple2 + ripple3) * effectiveAmplitude; vec2 normal = normalize(uv - center); vec2 distortedUV = getCoverUV(uv + normal * combinedRipple, uTexture2Size); vec4 distortedImg = texture2D(uTexture2, distortedUV); float fadeEdge = smoothstep(maxDist, maxDist * 0.9, dist); vec4 rippleResult = mix(newImg, distortedImg, fadeEdge); float mask = smoothstep(0.0, 0.3, progress) * (1.0 - smoothstep(0.7, 1.0, progress)); rippleResult = mix(newImg, rippleResult, mask); // Apply color enhancement rippleResult.rgb = mix(rippleResult.rgb, rippleResult.rgb * 1.2, (uColorEnhancement - 1.0) * 0.5); float transition = smoothstep(0.0, 1.0, progress); return mix(currentImg, rippleResult, transition); } vec4 plasmaEffect(vec2 uv, float progress) { vec4 currentImg = texture2D(uTexture1, getCoverUV(uv, uTexture1Size)); vec4 newImg = texture2D(uTexture2, getCoverUV(uv, uTexture2Size)); float effectiveSpeed = uPlasmaSpeed * uSpeedMultiplier; float effectiveIntensity = uPlasmaIntensity * uGlobalIntensity; float time = progress * 8.0 * effectiveSpeed; float plasma1 = sin(uv.x * 10.0 + time) * cos(uv.y * 8.0 + time * 0.7); float plasma2 = sin((uv.x + uv.y) * 12.0 + time * 1.3) * cos((uv.x - uv.y) * 15.0 + time * 0.9); float plasma3 = sin(length(uv - vec2(0.5)) * 20.0 + time * 1.8); float turbulence1 = smoothNoise(uv * 15.0 * uPlasmaTurbulence + vec2(time * 0.5, time * 0.3)); float turbulence2 = smoothNoise(uv * 25.0 * uPlasmaTurbulence + vec2(time * 0.8, -time * 0.4)) * 0.7; float turbulence3 = smoothNoise(uv * 40.0 * uPlasmaTurbulence + vec2(-time * 0.6, time * 0.9)) * 0.4; float combinedTurbulence = (turbulence1 + turbulence2 + turbulence3) / 2.1; float plasma = (plasma1 + plasma2 + plasma3) * 0.333 + combinedTurbulence * 0.5; plasma = sin(plasma * 3.14159); float plasmaPhase = smoothstep(0.0, 0.3, progress) * (1.0 - smoothstep(0.7, 1.0, progress)); vec2 electricField = vec2( sin(plasma * 6.28 + time) * 0.02, cos(plasma * 4.71 + time * 1.1) * 0.02 ) * effectiveIntensity * plasmaPhase * uDistortionStrength; vec2 flowField1 = vec2( smoothNoise(uv * 8.0 + time * 0.4), smoothNoise(uv * 8.0 + time * 0.4 + 100.0) ) - 0.5; vec2 flowField2 = vec2( smoothNoise(uv * 16.0 + time * 0.6 + 200.0), smoothNoise(uv * 16.0 + time * 0.6 + 300.0) ) - 0.5; flowField1 *= 0.015 * effectiveIntensity * plasmaPhase * uDistortionStrength; flowField2 *= 0.008 * effectiveIntensity * plasmaPhase * uDistortionStrength; vec2 totalDistortion = electricField + flowField1 + flowField2; vec2 distortedUV1 = getCoverUV(uv + totalDistortion, uTexture1Size); vec2 distortedUV2 = getCoverUV(uv + totalDistortion, uTexture2Size); vec4 distortedCurrentImg = texture2D(uTexture1, distortedUV1); vec4 distortedNewImg = texture2D(uTexture2, distortedUV2); float energyMask = abs(plasma) * plasmaPhase * effectiveIntensity; vec4 blendedDistorted = mix(distortedCurrentImg, distortedNewImg, progress); vec3 energyColor = vec3(0.9, 0.95, 1.0); float energyPulse = sin(time * 4.0) * 0.5 + 0.5; float finalEnergyIntensity = energyMask * uPlasmaEnergyIntensity * (0.7 + energyPulse * 0.3); float contrast = 1.0 + energyMask * uPlasmaContrastBoost; vec3 contrastedColor = (blendedDistorted.rgb - 0.5) * contrast + 0.5; float saturationBoost = 1.0 + energyMask * 0.4; float luminance = dot(contrastedColor, vec3(0.299, 0.587, 0.114)); vec3 saturatedColor = mix(vec3(luminance), contrastedColor, saturationBoost); vec3 glowColor = saturatedColor + energyColor * finalEnergyIntensity; float crackle = smoothNoise(uv * 50.0 + time * 2.0); crackle = smoothstep(0.85, 1.0, crackle) * energyMask; glowColor += vec3(1.0) * crackle * uPlasmaEnergyIntensity * 0.5; float brightnessPulse = sin(time * 6.0 + plasma * 10.0) * 0.5 + 0.5; glowColor += energyMask * brightnessPulse * uPlasmaEnergyIntensity * 0.2; // Apply color enhancement glowColor = mix(glowColor, glowColor * 1.2, (uColorEnhancement - 1.0) * 0.5); vec4 plasmaResult = vec4(glowColor, 1.0); if (progress > 0.85) { float endFade = (progress - 0.85) / 0.15; plasmaResult = mix(plasmaResult, newImg, endFade); } float overallTransition = smoothstep(0.0, 1.0, progress); return mix(currentImg, plasmaResult, overallTransition); } vec4 timeshiftEffect(vec2 uv, float progress) { // Get base images vec2 uv1 = getCoverUV(uv, uTexture1Size); vec2 uv2_base = getCoverUV(uv, uTexture2Size); vec4 currentImg = texture2D(uTexture1, uv1); vec4 newImg = texture2D(uTexture2, uv2_base); // Effect parameters - BOOSTED for more intensity float effectiveDistortion = uTimeshiftDistortion * uDistortionStrength * uGlobalIntensity; float effectiveBlur = uTimeshiftBlur * uGlobalIntensity; float effectiveFlow = uTimeshiftFlow * uSpeedMultiplier; float effectiveChromatic = uTimeshiftChromatic * uGlobalIntensity; float effectiveTurbulence = uTimeshiftTurbulence; // Create growing circle from center vec2 center = vec2(0.5, 0.5); vec2 p = uv * uResolution; vec2 sphereCenter = center * uResolution; float maxRadius = length(uResolution) * 0.85; // FIX: Start completely off-screen at progress 0 float circleRadius = progress * maxRadius; float dist = length(p - sphereCenter); float normalizedDist = dist / max(circleRadius, 0.001); // Create transition boundary zone - WIDER for more organic feel float boundaryWidth = 0.2 * effectiveBlur; float inside = smoothstep(circleRadius + circleRadius * boundaryWidth, circleRadius - circleRadius * boundaryWidth, dist); // Only apply heavy distortion at the boundary vec4 finalColor = newImg; if (inside > 0.01 && inside < 0.99) { // We're in the transition boundary - create INTENSE organic distortion vec2 fromCenter = uv - center; float radius = length(fromCenter); vec2 direction = radius > 0.0 ? fromCenter / radius : vec2(0.0); // Boundary strength (strongest at edge, fades toward center) float boundaryStrength = smoothstep(0.0, 0.3, inside) * smoothstep(1.0, 0.7, inside); // Time-based animation float time = progress * 6.28 * effectiveFlow; // INTENSIFIED multi-layered organic turbulence float turb1 = smoothNoise(uv * 12.0 * effectiveTurbulence + time * 0.4); float turb2 = smoothNoise(uv * 20.0 * effectiveTurbulence - time * 0.5); float turb3 = smoothNoise(uv * 35.0 * effectiveTurbulence + time * 0.7); float turb4 = smoothNoise(uv * 55.0 * effectiveTurbulence - time * 0.4); // Combine turbulence layers with MORE weight vec2 turbulence = vec2( (turb1 - 0.5) * 1.2 + (turb2 - 0.5) * 0.8 + (turb3 - 0.5) * 0.4, (turb2 - 0.5) * 1.2 + (turb3 - 0.5) * 0.8 + (turb4 - 0.5) * 0.4 ); // STRONGER displacement at boundary float displacementStrength = 0.18 * effectiveDistortion * boundaryStrength; vec2 displacement = turbulence * displacementStrength; // INTENSIFIED radial pull/push effect float radialPull = sin(normalizedDist * 12.0 - time * 2.5) * 0.05 * effectiveDistortion; displacement += direction * radialPull * boundaryStrength; // STRONGER flow/swirl around the boundary vec2 perpendicular = vec2(-direction.y, direction.x); float swirl = sin(time * 2.5 + normalizedDist * 10.0) * 0.06 * effectiveFlow; displacement += perpendicular * swirl * boundaryStrength; // Sample both images with heavy distortion vec2 distortedUV1 = getCoverUV(uv + displacement, uTexture1Size); vec2 distortedUV2 = getCoverUV(uv + displacement, uTexture2Size); vec4 distortedOld = texture2D(uTexture1, distortedUV1); vec4 distortedNew = texture2D(uTexture2, distortedUV2); // STRONGER chromatic aberration at boundary if (effectiveChromatic > 0.01) { float chromaticStr = boundaryStrength * 0.03 * effectiveChromatic; // Old image chromatic vec2 uv1_r = getCoverUV(uv + displacement + direction * chromaticStr * 2.0, uTexture1Size); vec2 uv1_b = getCoverUV(uv + displacement - direction * chromaticStr * 1.2, uTexture1Size); distortedOld = vec4( texture2D(uTexture1, uv1_r).r, distortedOld.g, texture2D(uTexture1, uv1_b).b, 1.0 ); // New image chromatic vec2 uv2_r = getCoverUV(uv + displacement + direction * chromaticStr * 2.0, uTexture2Size); vec2 uv2_b = getCoverUV(uv + displacement - direction * chromaticStr * 1.2, uTexture2Size); distortedNew = vec4( texture2D(uTexture2, uv2_r).r, distortedNew.g, texture2D(uTexture2, uv2_b).b, 1.0 ); } // Blend between distorted old and new based on position finalColor = mix(distortedOld, distortedNew, inside); // ENHANCED dreamy blur effect if (effectiveBlur > 0.5) { vec4 blurSample1 = texture2D(uTexture2, getCoverUV(uv + displacement + turbulence * 0.015, uTexture2Size)); vec4 blurSample2 = texture2D(uTexture2, getCoverUV(uv + displacement - turbulence * 0.015, uTexture2Size)); vec4 blurSample3 = texture2D(uTexture1, getCoverUV(uv + displacement + vec2(turbulence.y, -turbulence.x) * 0.015, uTexture1Size)); float blurAmount = boundaryStrength * effectiveBlur * 0.6; finalColor = mix(finalColor, (finalColor + blurSample1 + blurSample2 + blurSample3) * 0.25, blurAmount); } } else if (inside >= 0.99) { // Fully inside - show new image finalColor = newImg; } else { // Outside - show current image finalColor = currentImg; } // Apply color enhancement finalColor.rgb = mix(finalColor.rgb, finalColor.rgb * 1.2, (uColorEnhancement - 1.0) * 0.5); // Clean end transition if (progress > 0.95) { float endTransition = (progress - 0.95) / 0.05; finalColor = mix(finalColor, newImg, endTransition); } // Final blend return mix(currentImg, finalColor, smoothstep(0.0, 1.0, progress)); } void main() { if (uEffectType == 0) { gl_FragColor = glassEffect(vUv, uProgress); } else if (uEffectType == 1) { gl_FragColor = frostEffect(vUv, uProgress); } else if (uEffectType == 2) { gl_FragColor = rippleEffect(vUv, uProgress); } else if (uEffectType == 3) { gl_FragColor = plasmaEffect(vUv, uProgress); } else { gl_FragColor = timeshiftEffect(vUv, uProgress); } } `; // Map effect names to shader indices const getEffectIndex = (effectName) => { const effectMap = { glass: 0, frost: 1, ripple: 2, plasma: 3, timeshift: 4 }; return effectMap[effectName] || 0; }; // Randomize effect settings const randomizeEffect = () => { const effects = [\"glass\", \"frost\", \"ripple\", \"plasma\", \"timeshift\"]; const randomEffect = effects[Math.floor(Math.random() * effects.length)]; SLIDER_CONFIG.settings.currentEffect = randomEffect; // Randomize global settings SLIDER_CONFIG.settings.globalIntensity = 0.5 + Math.random() * 1.5; SLIDER_CONFIG.settings.speedMultiplier = 0.5 + Math.random() * 2.0; SLIDER_CONFIG.settings.distortionStrength = 0.5 + Math.random() * 2.0; SLIDER_CONFIG.settings.colorEnhancement = 0.7 + Math.random() * 1.3; // Randomize effect-specific settings if (randomEffect === \"glass\") { SLIDER_CONFIG.settings.glassRefractionStrength = 0.5 + Math.random() * 2.0; SLIDER_CONFIG.settings.glassChromaticAberration = 0.3 + Math.random() * 2.0; SLIDER_CONFIG.settings.glassBubbleClarity = 0.5 + Math.random() * 1.5; SLIDER_CONFIG.settings.glassEdgeGlow = Math.random() * 2.0; SLIDER_CONFIG.settings.glassLiquidFlow = 0.3 + Math.random() * 2.5; } else if (randomEffect === \"frost\") { SLIDER_CONFIG.settings.frostIntensity = 0.5 + Math.random() * 2.5; SLIDER_CONFIG.settings.frostCrystalSize = 0.3 + Math.random() * 1.7; SLIDER_CONFIG.settings.frostIceCoverage = 0.3 + Math.random() * 1.5; SLIDER_CONFIG.settings.frostTemperature = 0.3 + Math.random() * 2.5; SLIDER_CONFIG.settings.frostTexture = 0.5 + Math.random() * 1.5; } else if (randomEffect === \"ripple\") { SLIDER_CONFIG.settings.rippleFrequency = 10.0 + Math.random() * 40.0; SLIDER_CONFIG.settings.rippleAmplitude = 0.03 + Math.random() * 0.15; SLIDER_CONFIG.settings.rippleWaveSpeed = 0.3 + Math.random() * 2.5; SLIDER_CONFIG.settings.rippleRippleCount = 0.2 + Math.random() * 1.8; SLIDER_CONFIG.settings.rippleDecay = 0.3 + Math.random() * 1.7; } else if (randomEffect === \"plasma\") { SLIDER_CONFIG.settings.plasmaIntensity = 0.6 + Math.random() * 2.2; SLIDER_CONFIG.settings.plasmaSpeed = 0.3 + Math.random() * 1.7; SLIDER_CONFIG.settings.plasmaEnergyIntensity = Math.random(); SLIDER_CONFIG.settings.plasmaContrastBoost = Math.random() * 0.8; SLIDER_CONFIG.settings.plasmaTurbulence = 0.3 + Math.random() * 2.5; } else if (randomEffect === \"timeshift\") { SLIDER_CONFIG.settings.timeshiftDistortion = 0.4 + Math.random() * 1.8; SLIDER_CONFIG.settings.timeshiftBlur = 0.4 + Math.random() * 1.6; SLIDER_CONFIG.settings.timeshiftFlow = 0.4 + Math.random() * 1.6; SLIDER_CONFIG.settings.timeshiftChromatic = 0.3 + Math.random() * 1.7; SLIDER_CONFIG.settings.timeshiftTurbulence = 0.4 + Math.random() * 1.6; } SLIDER_CONFIG.settings.currentEffectPreset = \"Custom\"; handleEffectChange(randomEffect); updateShaderUniforms(); pane.refresh(); }; // Initialize Tweakpane with new structure const setupPane = () => { pane = new Pane({ title: \"Visual Effects Controls\" }); // 1. GENERAL SETTINGS (always visible) const generalFolder = pane.addFolder({ title: \"General Settings\" }); generalFolder.addBinding(SLIDER_CONFIG.settings, \"globalIntensity\", { label: \"Global Intensity\", min: 0.1, max: 2.0, step: 0.1 }); generalFolder.addBinding(SLIDER_CONFIG.settings, \"speedMultiplier\", { label: \"Speed Multiplier\", min: 0.1, max: 3.0, step: 0.1 }); generalFolder.addBinding(SLIDER_CONFIG.settings, \"distortionStrength\", { label: \"Distortion\", min: 0.1, max: 3.0, step: 0.1 }); generalFolder.addBinding(SLIDER_CONFIG.settings, \"colorEnhancement\", { label: \"Color Enhancement\", min: 0.5, max: 2.0, step: 0.1 }); // Timing controls const timingFolder = pane.addFolder({ title: \"Timing\" }); timingFolder.addBinding(SLIDER_CONFIG.settings, \"transitionDuration\", { label: \"Transition Duration\", min: 0.5, max: 5.0, step: 0.1 }); timingFolder.addBinding(SLIDER_CONFIG.settings, \"autoSlideSpeed\", { label: \"Auto Slide Speed\", min: 2000, max: 10000, step: 500 }); // 2. EFFECT SELECTION (always visible) const effectFolder = pane.addFolder({ title: \"Effect Selection\" }); effectFolder.addBinding(SLIDER_CONFIG.settings, \"currentEffect\", { label: \"Effect Type\", options: { Glass: \"glass\", Frost: \"frost\", Ripple: \"ripple\", Plasma: \"plasma\", Timeshift: \"timeshift\" } }); // Add randomize button effectFolder .addButton({ title: \"Randomize Effect\" }) .on(\"click\", randomizeEffect); // 3. EFFECT PRESETS (always visible, dynamic content) const presetsFolder = pane.addFolder({ title: \"Effect Presets\" }); presetsFolder.addBinding(SLIDER_CONFIG.settings, \"currentEffectPreset\", { label: \"Preset\", options: getPresetOptions(SLIDER_CONFIG.settings.currentEffect) }); // 4. EFFECT SETTINGS (dynamic folders) setupEffectFolders(); // Set initial effect folder visibility updateEffectFolderVisibility(SLIDER_CONFIG.settings.currentEffect); // Event handling pane.on(\"change\", (event) => { if (isApplyingPreset) return; if (event.target.key === \"currentEffect\") { handleEffectChange(SLIDER_CONFIG.settings.currentEffect); } else if (event.target.key === \"currentEffectPreset\") { applyEffectPreset( SLIDER_CONFIG.settings.currentEffect, SLIDER_CONFIG.settings.currentEffectPreset ); } else { // Mark as custom if any specific setting is changed if ( !isApplyingPreset && !event.target.key.includes(\"currentEffect\") && !event.target.key.includes(\"global\") && !event.target.key.includes(\"Duration\") && !event.target.key.includes(\"Speed\") ) { SLIDER_CONFIG.settings.currentEffectPreset = \"Custom\"; pane.refresh(); } updateShaderUniforms(); } }); // Hide initially const paneElement = document.querySelector(\".tp-dfwv\"); if (paneElement) { paneElement.style.display = \"none\"; } }; const getPresetOptions = (effectName) => { if (SLIDER_CONFIG.effectPresets[effectName]) { const presets = SLIDER_CONFIG.effectPresets[effectName]; const options = {}; Object.keys(presets).forEach((key) => { options[key] = key; }); options[\"Custom\"] = \"Custom\"; return options; } return { Default: \"Default\", Custom: \"Custom\" }; }; const setupEffectFolders = () => { // Glass folder effectFolders.glass = pane.addFolder({ title: \"Glass Settings\" }); effectFolders.glass.addBinding( SLIDER_CONFIG.settings, \"glassRefractionStrength\", { label: \"Refraction Strength\", min: 0.1, max: 3.0, step: 0.1 } ); effectFolders.glass.addBinding( SLIDER_CONFIG.settings, \"glassChromaticAberration\", { label: \"Chromatic Aberration\", min: 0.1, max: 3.0, step: 0.1 } ); effectFolders.glass.addBinding(SLIDER_CONFIG.settings, \"glassBubbleClarity\", { label: \"Bubble Clarity\", min: 0.1, max: 2.0, step: 0.1 }); effectFolders.glass.addBinding(SLIDER_CONFIG.settings, \"glassEdgeGlow\", { label: \"Edge Glow\", min: 0.0, max: 2.0, step: 0.1 }); effectFolders.glass.addBinding(SLIDER_CONFIG.settings, \"glassLiquidFlow\", { label: \"Liquid Flow\", min: 0.1, max: 3.0, step: 0.1 }); // Frost folder effectFolders.frost = pane.addFolder({ title: \"Frost Settings\" }); effectFolders.frost.addBinding(SLIDER_CONFIG.settings, \"frostIntensity\", { label: \"Frost Intensity\", min: 0.5, max: 3.0, step: 0.1 }); effectFolders.frost.addBinding(SLIDER_CONFIG.settings, \"frostCrystalSize\", { label: \"Crystal Size\", min: 0.3, max: 2.0, step: 0.1 }); effectFolders.frost.addBinding(SLIDER_CONFIG.settings, \"frostIceCoverage\", { label: \"Ice Coverage\", min: 0.1, max: 2.0, step: 0.1 }); effectFolders.frost.addBinding(SLIDER_CONFIG.settings, \"frostTemperature\", { label: \"Temperature\", min: 0.1, max: 3.0, step: 0.1 }); effectFolders.frost.addBinding(SLIDER_CONFIG.settings, \"frostTexture\", { label: \"Texture Detail\", min: 0.3, max: 2.0, step: 0.1 }); // Ripple folder effectFolders.ripple = pane.addFolder({ title: \"Ripple Settings\" }); effectFolders.ripple.addBinding(SLIDER_CONFIG.settings, \"rippleFrequency\", { label: \"Frequency\", min: 10.0, max: 50.0, step: 1.0 }); effectFolders.ripple.addBinding(SLIDER_CONFIG.settings, \"rippleAmplitude\", { label: \"Amplitude\", min: 0.02, max: 0.2, step: 0.01 }); effectFolders.ripple.addBinding(SLIDER_CONFIG.settings, \"rippleWaveSpeed\", { label: \"Wave Speed\", min: 0.2, max: 3.0, step: 0.1 }); effectFolders.ripple.addBinding(SLIDER_CONFIG.settings, \"rippleRippleCount\", { label: \"Ripple Count\", min: 0.1, max: 2.0, step: 0.1 }); effectFolders.ripple.addBinding(SLIDER_CONFIG.settings, \"rippleDecay\", { label: \"Decay Rate\", min: 0.2, max: 2.0, step: 0.1 }); // Plasma folder effectFolders.plasma = pane.addFolder({ title: \"Plasma Settings\" }); effectFolders.plasma.addBinding(SLIDER_CONFIG.settings, \"plasmaIntensity\", { label: \"Plasma Intensity\", min: 0.5, max: 3.0, step: 0.1 }); effectFolders.plasma.addBinding(SLIDER_CONFIG.settings, \"plasmaSpeed\", { label: \"Plasma Speed\", min: 0.2, max: 2.0, step: 0.1 }); effectFolders.plasma.addBinding( SLIDER_CONFIG.settings, \"plasmaEnergyIntensity\", { label: \"Energy Intensity\", min: 0.0, max: 1.0, step: 0.05 } ); effectFolders.plasma.addBinding( SLIDER_CONFIG.settings, \"plasmaContrastBoost\", { label: \"Contrast Boost\", min: 0.0, max: 1.0, step: 0.05 } ); effectFolders.plasma.addBinding(SLIDER_CONFIG.settings, \"plasmaTurbulence\", { label: \"Turbulence\", min: 0.1, max: 3.0, step: 0.1 }); // Timeshift folder effectFolders.timeshift = pane.addFolder({ title: \"Timeshift Settings\" }); effectFolders.timeshift.addBinding( SLIDER_CONFIG.settings, \"timeshiftDistortion\", { label: \"Distortion\", min: 0.3, max: 3.0, step: 0.1 } ); effectFolders.timeshift.addBinding(SLIDER_CONFIG.settings, \"timeshiftBlur\", { label: \"Blur Amount\", min: 0.3, max: 3.0, step: 0.1 }); effectFolders.timeshift.addBinding(SLIDER_CONFIG.settings, \"timeshiftFlow\", { label: \"Flow Speed\", min: 0.3, max: 3.0, step: 0.1 }); effectFolders.timeshift.addBinding( SLIDER_CONFIG.settings, \"timeshiftChromatic\", { label: \"Chromatic Glitch\", min: 0.0, max: 3.0, step: 0.1 } ); effectFolders.timeshift.addBinding( SLIDER_CONFIG.settings, \"timeshiftTurbulence\", { label: \"Turbulence\", min: 0.3, max: 3.0, step: 0.1 } ); }; const updateEffectFolderVisibility = (currentEffect) => { // Hide all effect folders Object.keys(effectFolders).forEach((effectName) => { if (effectFolders[effectName]) { effectFolders[effectName].hidden = effectName !== currentEffect; } }); currentEffectFolder = effectFolders[currentEffect]; }; const handleEffectChange = (newEffect) => { // Update shader effect type if (shaderMaterial) { shaderMaterial.uniforms.uEffectType.value = getEffectIndex(newEffect); } // Update folder visibility updateEffectFolderVisibility(newEffect); // Update preset options const presetsFolder = pane.children.find( (child) => child.title === \"Effect Presets\" ); if (presetsFolder) { // Remove old preset binding const oldBinding = presetsFolder.children.find( (child) => child.key === \"currentEffectPreset\" ); if (oldBinding) { presetsFolder.remove(oldBinding); } // Add new preset binding with updated options presetsFolder.addBinding(SLIDER_CONFIG.settings, \"currentEffectPreset\", { label: \"Preset\", options: getPresetOptions(newEffect) }); } // Apply default preset for new effect SLIDER_CONFIG.settings.currentEffectPreset = \"Default\"; applyEffectPreset(newEffect, \"Default\"); pane.refresh(); }; const applyEffectPreset = (effectName, presetName) => { if ( SLIDER_CONFIG.effectPresets[effectName] && SLIDER_CONFIG.effectPresets[effectName][presetName] ) { isApplyingPreset = true; // Apply the preset settings Object.assign( SLIDER_CONFIG.settings, SLIDER_CONFIG.effectPresets[effectName][presetName] ); updateShaderUniforms(); pane.refresh(); setTimeout(() => { isApplyingPreset = false; }, 100); } }; const updateShaderUniforms = () => { if (!shaderMaterial) return; // Update all uniforms with current settings const uniforms = shaderMaterial.uniforms; const settings = SLIDER_CONFIG.settings; // Global uniforms if (uniforms.uGlobalIntensity) uniforms.uGlobalIntensity.value = settings.globalIntensity; if (uniforms.uSpeedMultiplier) uniforms.uSpeedMultiplier.value = settings.speedMultiplier; if (uniforms.uDistortionStrength) uniforms.uDistortionStrength.value = settings.distortionStrength; if (uniforms.uColorEnhancement) uniforms.uColorEnhancement.value = settings.colorEnhancement; // Glass uniforms if (uniforms.uGlassRefractionStrength) uniforms.uGlassRefractionStrength.value = settings.glassRefractionStrength; if (uniforms.uGlassChromaticAberration) uniforms.uGlassChromaticAberration.value = settings.glassChromaticAberration; if (uniforms.uGlassBubbleClarity) uniforms.uGlassBubbleClarity.value = settings.glassBubbleClarity; if (uniforms.uGlassEdgeGlow) uniforms.uGlassEdgeGlow.value = settings.glassEdgeGlow; if (uniforms.uGlassLiquidFlow) uniforms.uGlassLiquidFlow.value = settings.glassLiquidFlow; // Frost uniforms if (uniforms.uFrostIntensity) uniforms.uFrostIntensity.value = settings.frostIntensity; if (uniforms.uFrostCrystalSize) uniforms.uFrostCrystalSize.value = settings.frostCrystalSize; if (uniforms.uFrostIceCoverage) uniforms.uFrostIceCoverage.value = settings.frostIceCoverage; if (uniforms.uFrostTemperature) uniforms.uFrostTemperature.value = settings.frostTemperature; if (uniforms.uFrostTexture) uniforms.uFrostTexture.value = settings.frostTexture; // Ripple uniforms if (uniforms.uRippleFrequency) uniforms.uRippleFrequency.value = settings.rippleFrequency; if (uniforms.uRippleAmplitude) uniforms.uRippleAmplitude.value = settings.rippleAmplitude; if (uniforms.uRippleWaveSpeed) uniforms.uRippleWaveSpeed.value = settings.rippleWaveSpeed; if (uniforms.uRippleRippleCount) uniforms.uRippleRippleCount.value = settings.rippleRippleCount; if (uniforms.uRippleDecay) uniforms.uRippleDecay.value = settings.rippleDecay; // Plasma uniforms if (uniforms.uPlasmaIntensity) uniforms.uPlasmaIntensity.value = settings.plasmaIntensity; if (uniforms.uPlasmaSpeed) uniforms.uPlasmaSpeed.value = settings.plasmaSpeed; if (uniforms.uPlasmaEnergyIntensity) uniforms.uPlasmaEnergyIntensity.value = settings.plasmaEnergyIntensity; if (uniforms.uPlasmaContrastBoost) uniforms.uPlasmaContrastBoost.value = settings.plasmaContrastBoost; if (uniforms.uPlasmaTurbulence) uniforms.uPlasmaTurbulence.value = settings.plasmaTurbulence; // Timeshift uniforms if (uniforms.uTimeshiftDistortion) uniforms.uTimeshiftDistortion.value = settings.timeshiftDistortion; if (uniforms.uTimeshiftBlur) uniforms.uTimeshiftBlur.value = settings.timeshiftBlur; if (uniforms.uTimeshiftFlow) uniforms.uTimeshiftFlow.value = settings.timeshiftFlow; if (uniforms.uTimeshiftChromatic) uniforms.uTimeshiftChromatic.value = settings.timeshiftChromatic; if (uniforms.uTimeshiftTurbulence) uniforms.uTimeshiftTurbulence.value = settings.timeshiftTurbulence; }; // Navigation UI const createSlidesNavigation = () => { const navContainer = document.getElementById(\"slidesNav\"); navContainer.innerHTML = \"\"; slides.forEach((slide, index) => { const navItem = document.createElement(\"div\"); navItem.className = `slide-nav-item ${index === 0 ? \"active\" : \"\"}`; navItem.dataset.slideIndex = index; navItem.innerHTML = ` <div class=\"slide-progress-line\"> <div class=\"slide-progress-fill\" style=\"width: 0%\"></div> </div> <div class=\"slide-nav-title\">${slide.title}</div> `; navItem.addEventListener(\"click\", (e) => { e.stopPropagation(); const targetIndex = parseInt(navItem.dataset.slideIndex); if (targetIndex !== currentSlideIndex && !isTransitioning) { navigateToSlide(targetIndex); } }); navContainer.appendChild(navItem); }); }; const updateNavigationState = (activeIndex) => { const navItems = document.querySelectorAll(\".slide-nav-item\"); navItems.forEach((item, index) => { item.classList.toggle(\"active\", index === activeIndex); }); }; const updateSlideProgress = (slideIndex, progress) => { const navItems = document.querySelectorAll(\".slide-nav-item\"); if (navItems[slideIndex]) { const progressFill = navItems[slideIndex].querySelector( \".slide-progress-fill\" ); progressFill.style.width = `${progress}%`; progressFill.style.opacity = \"1\"; } }; const fadeSlideProgress = (slideIndex) => { const navItems = document.querySelectorAll(\".slide-nav-item\"); if (navItems[slideIndex]) { const progressFill = navItems[slideIndex].querySelector( \".slide-progress-fill\" ); progressFill.style.opacity = \"0\"; setTimeout(() => (progressFill.style.width = \"0%\"), 300); } }; const quickResetProgress = (slideIndex) => { const navItems = document.querySelectorAll(\".slide-nav-item\"); if (navItems[slideIndex]) { const progressFill = navItems[slideIndex].querySelector( \".slide-progress-fill\" ); // Quickly animate back to 0% instead of just fading progressFill.style.transition = \"width 0.2s ease-out\"; progressFill.style.width = \"0%\"; // Reset transition back to normal after animation setTimeout(() => { progressFill.style.transition = \"width 0.1s ease, opacity 0.3s ease\"; }, 200); } }; const updateCounter = (index) => { const slideNumber = document.getElementById(\"slideNumber\"); slideNumber.textContent = String(index + 1).padStart(2, \"0\"); const slideTotal = document.getElementById(\"slideTotal\"); slideTotal.textContent = String(slides.length).padStart(2, \"0\"); }; // Timer functions const startAutoSlideTimer = () => { if (!texturesLoaded || !sliderEnabled || slideTextures.length < 2) return; stopAutoSlideTimer(); let progress = 0; const increment = (100 / SLIDE_DURATION()) * PROGRESS_UPDATE_INTERVAL; progressAnimation = setInterval(() => { if (!sliderEnabled) { stopAutoSlideTimer(); return; } progress += increment; updateSlideProgress(currentSlideIndex, progress); if (progress >= 100) { clearInterval(progressAnimation); progressAnimation = null; fadeSlideProgress(currentSlideIndex); if (!isTransitioning) { handleSlideChange(); } } }, PROGRESS_UPDATE_INTERVAL); }; const stopAutoSlideTimer = () => { if (progressAnimation) { clearInterval(progressAnimation); progressAnimation = null; } if (autoSlideTimer) { clearTimeout(autoSlideTimer); autoSlideTimer = null; } }; const safeStartTimer = (delay = 0) => { stopAutoSlideTimer(); if (sliderEnabled && texturesLoaded) { if (delay > 0) { autoSlideTimer = setTimeout(() => { if (sliderEnabled) startAutoSlideTimer(); }, delay); } else { startAutoSlideTimer(); } } }; // Navigation const navigateToSlide = (targetIndex) => { if (isTransitioning || targetIndex === currentSlideIndex) return; stopAutoSlideTimer(); // Quickly reset current slide progress when manually navigating quickResetProgress(currentSlideIndex); const currentTexture = slideTextures[currentSlideIndex]; const targetTexture = slideTextures[targetIndex]; if (!currentTexture || !targetTexture) return; isTransitioning = true; shaderMaterial.uniforms.uTexture1.value = currentTexture; shaderMaterial.uniforms.uTexture2.value = targetTexture; shaderMaterial.uniforms.uTexture1Size.value = currentTexture.userData.size; shaderMaterial.uniforms.uTexture2Size.value = targetTexture.userData.size; currentSlideIndex = targetIndex; updateCounter(currentSlideIndex); updateNavigationState(currentSlideIndex); gsap.fromTo( shaderMaterial.uniforms.uProgress, { value: 0 }, { value: 1, duration: TRANSITION_DURATION(), ease: \"power2.inOut\", onComplete: () => { shaderMaterial.uniforms.uProgress.value = 0; shaderMaterial.uniforms.uTexture1.value = targetTexture; shaderMaterial.uniforms.uTexture1Size.value = targetTexture.userData.size; isTransitioning = false; safeStartTimer(100); } } ); }; const handleSlideChange = () => { if (isTransitioning || !texturesLoaded || !sliderEnabled) return; const nextIndex = (currentSlideIndex + 1) % slides.length; navigateToSlide(nextIndex); }; const handleSwipe = () => { if (Math.abs(touchEndX - touchStartX) < 50) return; // Minimum swipe distance if (touchEndX < touchStartX && !isTransitioning && sliderEnabled) { // Swipe left - next slide stopAutoSlideTimer(); quickResetProgress(currentSlideIndex); handleSlideChange(); } else if (touchEndX > touchStartX && !isTransitioning && sliderEnabled) { // Swipe right - previous slide stopAutoSlideTimer(); quickResetProgress(currentSlideIndex); const prevIndex = (currentSlideIndex - 1 + slides.length) % slides.length; navigateToSlide(prevIndex); } }; // Texture loading const loadImageTexture = (src) => { return new Promise((resolve, reject) => { const loader = new THREE.TextureLoader(); const timeout = setTimeout(() => reject(new Error(\"Timeout\")), 10000); loader.load( src, (texture) => { clearTimeout(timeout); texture.minFilter = texture.magFilter = THREE.LinearFilter; texture.userData = { size: new THREE.Vector2(texture.image.width, texture.image.height) }; resolve(texture); }, undefined, (error) => { clearTimeout(timeout); reject(error); } ); }); }; // Initialize const initializeRenderer = async () => { const canvas = document.querySelector(\".webgl-canvas\"); if (!canvas) return; scene = new THREE.Scene(); camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1); renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: false, alpha: false }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); shaderMaterial = new THREE.ShaderMaterial({ uniforms: { uTexture1: { value: null }, uTexture2: { value: null }, uProgress: { value: 0.0 }, uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }, uTexture1Size: { value: new THREE.Vector2(1, 1) }, uTexture2Size: { value: new THREE.Vector2(1, 1) }, uEffectType: { value: getEffectIndex(SLIDER_CONFIG.settings.currentEffect) }, // Global settings uniforms uGlobalIntensity: { value: SLIDER_CONFIG.settings.globalIntensity }, uSpeedMultiplier: { value: SLIDER_CONFIG.settings.speedMultiplier }, uDistortionStrength: { value: SLIDER_CONFIG.settings.distortionStrength }, uColorEnhancement: { value: SLIDER_CONFIG.settings.colorEnhancement }, // Glass uniforms uGlassRefractionStrength: { value: SLIDER_CONFIG.settings.glassRefractionStrength }, uGlassChromaticAberration: { value: SLIDER_CONFIG.settings.glassChromaticAberration }, uGlassBubbleClarity: { value: SLIDER_CONFIG.settings.glassBubbleClarity }, uGlassEdgeGlow: { value: SLIDER_CONFIG.settings.glassEdgeGlow }, uGlassLiquidFlow: { value: SLIDER_CONFIG.settings.glassLiquidFlow }, // Frost uniforms uFrostIntensity: { value: SLIDER_CONFIG.settings.frostIntensity }, uFrostCrystalSize: { value: SLIDER_CONFIG.settings.frostCrystalSize }, uFrostIceCoverage: { value: SLIDER_CONFIG.settings.frostIceCoverage }, uFrostTemperature: { value: SLIDER_CONFIG.settings.frostTemperature }, uFrostTexture: { value: SLIDER_CONFIG.settings.frostTexture }, // Ripple uniforms uRippleFrequency: { value: SLIDER_CONFIG.settings.rippleFrequency }, uRippleAmplitude: { value: SLIDER_CONFIG.settings.rippleAmplitude }, uRippleWaveSpeed: { value: SLIDER_CONFIG.settings.rippleWaveSpeed }, uRippleRippleCount: { value: SLIDER_CONFIG.settings.rippleRippleCount }, uRippleDecay: { value: SLIDER_CONFIG.settings.rippleDecay }, // Plasma uniforms uPlasmaIntensity: { value: SLIDER_CONFIG.settings.plasmaIntensity }, uPlasmaSpeed: { value: SLIDER_CONFIG.settings.plasmaSpeed }, uPlasmaEnergyIntensity: { value: SLIDER_CONFIG.settings.plasmaEnergyIntensity }, uPlasmaContrastBoost: { value: SLIDER_CONFIG.settings.plasmaContrastBoost }, uPlasmaTurbulence: { value: SLIDER_CONFIG.settings.plasmaTurbulence }, // Timeshift uniforms uTimeshiftDistortion: { value: SLIDER_CONFIG.settings.timeshiftDistortion }, uTimeshiftBlur: { value: SLIDER_CONFIG.settings.timeshiftBlur }, uTimeshiftFlow: { value: SLIDER_CONFIG.settings.timeshiftFlow }, uTimeshiftChromatic: { value: SLIDER_CONFIG.settings.timeshiftChromatic }, uTimeshiftTurbulence: { value: SLIDER_CONFIG.settings.timeshiftTurbulence } }, vertexShader, fragmentShader }); const geometry = new THREE.PlaneGeometry(2, 2); const mesh = new THREE.Mesh(geometry, shaderMaterial); scene.add(mesh); // Load textures for (let i = 0; i < slides.length; i++) { try { const texture = await loadImageTexture(slides[i].media); slideTextures.push(texture); } catch (error) { console.warn(`Failed to load image ${i}`); } } if (slideTextures.length >= 2) { shaderMaterial.uniforms.uTexture1.value = slideTextures[0]; shaderMaterial.uniforms.uTexture2.value = slideTextures[1]; shaderMaterial.uniforms.uTexture1Size.value = slideTextures[0].userData.size; shaderMaterial.uniforms.uTexture2Size.value = slideTextures[1].userData.size; texturesLoaded = true; sliderEnabled = true; safeStartTimer(500); } // Render loop const render = () => { requestAnimationFrame(render); renderer.render(scene, camera); }; render(); }; // Event listeners window.addEventListener(\"load\", async () => { createSlidesNavigation(); updateCounter(0); setupPane(); await initializeRenderer(); }); document.addEventListener(\"click\", (e) => { if (e.target.closest(\".slides-navigation\")) return; if (!isTransitioning && sliderEnabled) { stopAutoSlideTimer(); quickResetProgress(currentSlideIndex); handleSlideChange(); } }); // Touch event listeners for mobile swipe support document.addEventListener(\"touchstart\", (e) => { touchStartX = e.changedTouches[0].screenX; }); document.addEventListener(\"touchend\", (e) => { touchEndX = e.changedTouches[0].screenX; handleSwipe(); }); window.addEventListener(\"resize\", () => { if (renderer && shaderMaterial) { renderer.setSize(window.innerWidth, window.innerHeight); shaderMaterial.uniforms.uResolution.value.set( window.innerWidth, window.innerHeight ); } }); document.addEventListener(\"keydown\", (e) => { if (e.code === \"Space\" || e.code === \"ArrowRight\") { e.preventDefault(); if (!isTransitioning && sliderEnabled) { stopAutoSlideTimer(); quickResetProgress(currentSlideIndex); handleSlideChange(); } } else if (e.code === \"ArrowLeft\") { e.preventDefault(); if (!isTransitioning && sliderEnabled) { stopAutoSlideTimer(); quickResetProgress(currentSlideIndex); const prevIndex = (currentSlideIndex - 1 + slides.length) % slides.length; navigateToSlide(prevIndex); } } else if (e.code === \"KeyH\") { e.preventDefault(); const paneElement = document.querySelector(\".tp-dfwv\"); if (paneElement) { paneElement.style.display = paneElement.style.display === \"none\" ? \"block\" : \"none\"; } } }); document.addEventListener(\"visibilitychange\", () => { if (document.hidden) { stopAutoSlideTimer(); } else if (sliderEnabled && !isTransitioning) { safeStartTimer(); } });",
    "id": "threejsgsap--liquid-morphology-slideshow"
  },
  {
    "title": "GSAP Scroll-Synced Image Slideshow with Timed Cues and Keyhole Effect",
    "description": "",
    "code": "index.html: <div class=\"viewport-wrapper\"> <div class=\"content-scroll\"> <main class=\"main-content\"> <section class=\"intro\"> <h2>Scroll-Synced Image Slideshow with Cues, Keyhole Reveal, and Track Markers</h2> <p> A scroll-driven image sequence powered by <code>GSAP</code> and <code>ScrollTrigger</code>. Images fade in based on defined cue ranges, with only one image visible at any time. </p> <p> Cue-based overlay text is synchronized with the current image using <code>data-start</code> and <code>data-end</code> attributes. Only one cue is shown at a time, transitioning based on scroll direction and timing. </p> <h3>Keyhole Reveal</h3> <p> A polygonal <code>clip-path</code> expands during scroll to reveal the slideshow through a central keyhole shape. Four corner elements animate outward in sync. The effect is scroll-driven, reversible, and tied to the slideshow container. </p> <h3>Image Preloading Strategy</h3> <ul> <li>The initial image is resolved based on scroll position and preloaded first.</li> <li>Surrounding images are preloaded in interleaved order (<code>+1, -1, +2</code>).</li> <li>Remaining images are preloaded in sequence after the first batch completes.</li> <li>Images fade in only when confirmed loaded. No <code>decode()</code> is used.</li> </ul> <h3>Preloader Lifecycle</h3> <ul> <li>An overlay is shown until the first image is displayed.</li> <li>It is removed after fade-in via a guarded <code>nextTick</code> mechanism.</li> <li>Fade animations are skipped while the preloader is active.</li> </ul> <h3>Scroll Track and Cue Markers</h3> <ul> <li>Vertical time markers (e.g. <code>0s, 1s, 2s</code>) are displayed next to the track.</li> <li>Each cue is visualized with labeled markers for start and end points.</li> <li>Markers update dynamically based on timeline duration.</li> </ul> </section> <section class=\"indicator\"> <h3>Scroll Down<br></h3> </section> <section> <div id=\"scrub_01\" class=\"seq-wrapper\" data-duration=\"16\"> <div class=\"seq-pin-container\"> <div class=\"seq-img-layer\"> <img class=\"seq-img\" data-start=\"-0.5\" data-end=\"2.0\" data-src=\"https://www.lessrain.com/dev/images/demo-img-01.webp\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1' height='1'%3E%3C/svg%3E\" alt=\"\" fetchpriority=\"low\" /> <img class=\"seq-img\" data-start=\"2.0\" data-end=\"4.0\" data-src=\"https://www.lessrain.com/dev/images/demo-img-02.webp\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1' height='1'%3E%3C/svg%3E\" alt=\"\" fetchpriority=\"low\" /> <img class=\"seq-img\" data-start=\"4.0\" data-end=\"6.0\" data-src=\"https://www.lessrain.com/dev/images/demo-img-03.webp\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1' height='1'%3E%3C/svg%3E\" alt=\"\" fetchpriority=\"low\" /> <img class=\"seq-img\" data-start=\"6.0\" data-end=\"8.0\" data-src=\"https://www.lessrain.com/dev/images/demo-img-04.webp\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1' height='1'%3E%3C/svg%3E\" alt=\"\" fetchpriority=\"low\" /> <img class=\"seq-img\" data-start=\"8.0\" data-end=\"10.0\" data-src=\"https://www.lessrain.com/dev/images/demo-img-05.webp\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1' height='1'%3E%3C/svg%3E\" alt=\"\" fetchpriority=\"low\" /> <img class=\"seq-img\" data-start=\"10.0\" data-end=\"12.0\" data-src=\"https://www.lessrain.com/dev/images/demo-img-06.webp\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1' height='1'%3E%3C/svg%3E\" alt=\"\" fetchpriority=\"low\" /> <img class=\"seq-img\" data-start=\"12.0\" data-end=\"14.0\" data-src=\"https://www.lessrain.com/dev/images/demo-img-07.webp\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1' height='1'%3E%3C/svg%3E\" alt=\"\" fetchpriority=\"low\" /> <img class=\"seq-img\" data-start=\"14.0\" data-src=\"https://www.lessrain.com/dev/images/demo-img-08.webp\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1' height='1'%3E%3C/svg%3E\" alt=\"\" fetchpriority=\"low\" /> </div> <div class=\"seq-overlay-layer\"> <div class=\"seq-overlay\" data-start=\"0.3\" data-end=\"1.8\"> <div class=\"seq-overlay-inner\"> <h2>Rising Surge</h2> <p>Wave and scaffolding clash in sculpted tension.</p> </div> </div> <div class=\"seq-overlay\" data-start=\"2.3\" data-end=\"3.8\"> <div class=\"seq-overlay-inner\"> <h2>Forcefield Bloom</h2> <p>Abstract energy bursts into form.</p> </div> </div> <div class=\"seq-overlay\" data-start=\"4.3\" data-end=\"5.8\"> <div class=\"seq-overlay-inner\"> <h2>Grid Bloom</h2> <p>Curved cables burst through lattice frames.</p> </div> </div> <div class=\"seq-overlay\" data-start=\"6.3\" data-end=\"7.8\"> <div class=\"seq-overlay-inner\"> <h2>Breach</h2> <p>The whale emerges into tensioned sky.</p> </div> </div> <div class=\"seq-overlay\" data-start=\"8.3\" data-end=\"9.8\"> <div class=\"seq-overlay-inner\"> <h2>Impact</h2> <p>Explosion of lines, sea, and scale.</p> </div> </div> <div class=\"seq-overlay\" data-start=\"10.3\" data-end=\"11.8\"> <div class=\"seq-overlay-inner\"> <h2>Vegas Surge</h2> <p>The desert and the ocean collide in neon ruin.</p> </div> </div> <div class=\"seq-overlay\" data-start=\"12.3\" data-end=\"13.8\"> <div class=\"seq-overlay-inner\"> <h2>Module Storm</h2> <p>Structures twist in midair collapse.</p> </div> </div> <div class=\"seq-overlay\" data-start=\"14.3\" data-end=\"15.8\"> <div class=\"seq-overlay-inner\"> <h2>Spiral Drown</h2> <p>Spinning currents pull architecture downward.</p> </div> </div> </div> <div class=\"seq-preloader-layer\"></div> <div class=\"seq-keyhole-layer\"> <div class=\"seq-keyhole\"></div> <div class=\"seq-keyhole-corner top-left\"></div> <div class=\"seq-keyhole-corner top-right\"></div> <div class=\"seq-keyhole-corner bottom-left\"></div> <div class=\"seq-keyhole-corner bottom-right\"></div> </div> </div> <div class=\"seq-track\"> <div class=\"seq-track-markers\"></div> </div> </div> </section> <section class=\"indicator\"> <h3><br>Scroll Up</h3> </section> <section> <div class=\"spacer\"></div> </section> </main> </div> </div> <div class=\"resources-layer\"> <div class=\"resources\"> <a href=\"https://www.lessrain.com\">Less Rain GmbH</a> <a href=\"https://codepen.io/collection/bNyZkZ\">JavaScript Codepen Collection</a> </div> </div>\nstyle.css: :root { --dark-color-h: 334.29; --dark-color-s: 32.03%; --dark-color-l: 30%; --light-color-h: 19.2; --light-color-s: 30.86%; --light-color-l: 84.12%; --dark-color: hsl(var(--dark-color-h), var(--dark-color-s), var(--dark-color-l)); --dark-color-lighter: hsl(var(--dark-color-h), var(--dark-color-s), calc(var(--dark-color-l) + 10%)); --dark-color-darker: hsl(var(--dark-color-h), var(--dark-color-s), calc(var(--dark-color-l) - 10%)); --dark-color-translucent: hsla(var(--dark-color-h), var(--dark-color-s), var(--dark-color-l), 0.75); --dark-color-darker-translucent: hsla(var(--dark-color-h), var(--dark-color-s), calc(var(--dark-color-l) - 10%), 0.75); --light-color: hsl(var(--light-color-h), var(--light-color-s), var(--light-color-l)); --light-color-lighter: hsl(var(--light-color-h), var(--light-color-s), calc(var(--light-color-l) + 10%)); --light-color-darker: hsl(var(--light-color-h), var(--light-color-s), calc(var(--light-color-l) - 10%)); --light-color-translucent: hsla(var(--light-color-h), var(--light-color-s), var(--light-color-l), 0.75); --color-bg: var(--dark-color); --color-text: var(--light-color); --color-muted: color-mix(in oklab, var(--color-text) 50%, var(--color-bg) 50%); --color-accent: color-mix(in oklab, var(--color-text) 80%, var(--color-bg) 20%); --color-border: color-mix(in oklab, var(--color-text) 30%, var(--color-bg) 70%); --resources-bg-color: var(--dark-color-darker-translucent); --resources-active-color: color-mix(in srgb, var(--light-color) 75%, transparent); --resources-color: var(--color-text); --ts-h6: clamp(12px, 1.0753vw + 8.9892px, 20px); --ts-h5: clamp(14.4px, 1.2903vw + 10.7871px, 24px); --ts-h4: clamp(17.28px, 1.5484vw + 12.9445px, 28.8px); --ts-h3: clamp(20.736px, 1.8581vw + 15.5334px, 34.56px); --ts-h2: clamp(24.8832px, 2.2297vw + 18.6401px, 41.472px); --ts-h1: clamp(29.8598px, 2.6756vw + 22.3681px, 49.7664px); } *, ::after, ::before { border-style: solid; border-width: 0; box-sizing: border-box; } * { -webkit-tap-highlight-color: rgba(0, 0, 0, 0); } html { overflow-y: scroll; -webkit-text-size-adjust: 100%; -moz-text-size-adjust: 100%; text-size-adjust: 100%; } body { background: var(--color-bg); color: var(--color-text); font-family: Inter, Roboto, \"Helvetica Neue\", \"Arial Nova\", \"Nimbus Sans\", Arial, sans-serif; line-height: 1.5; margin: 0; min-height: 100vh; width: 100%; } .viewport-wrapper { height: auto; overflow: visible; position: relative; } .content-scroll { display: block; width: 100%; } body:not(.normalize-scroll) .viewport-wrapper { bottom: 0; height: 100%; left: 0; overflow: hidden; position: fixed; right: 0; top: 0; width: 100%; } body:not(.normalize-scroll) .content-scroll { overflow: visible; } body:not(.normalize-scroll) .content-scroll .seq-wrapper { perspective: 2000px; } body:not(.normalize-scroll) .content-scroll .pin-spacer { transform-style: preserve-3d; } h2 { font-size: var(--ts-h2); } h2, h3 { color: var(--color-accent); font-weight: 400; letter-spacing: .025em; line-height: 1.3; margin-bottom: .65rem; margin-top: 0; } h3 { font-size: var(--ts-h3); } ul { padding-left: 1.2rem; } li { margin-bottom: .5em; } code { background: var(--dark-color-darker-translucent); border-radius: .1875rem; padding: .125rem .25rem; white-space: normal; word-break: break-word; } pre code { overflow-x: auto; padding: 1rem; white-space: pre; word-break: normal; } main, pre code { display: block; } main { margin: 0; position: relative; } section { display: block; psoition: relative; } section:is(.intro, .indicator) { margin: 4rem auto; max-width: 56.25rem; width: calc(100% - 2rem); } section.intro a, section.intro a:visited { color: var(--color-text); } section.intro a:active { color: var(--color-accent); } section.intro a:focus-visible { color: var(--color-accent); outline: none; } section.indicator { text-align: center; } section.indicator h3 { font-size: var(--ts-h5); font-weight: 400; margin: 0; } section:has(.seq-wrapper) { background: var(--dark-color-darker); padding: 4rem 0; } .seq-wrapper { --border-radius: clamp(0.5rem, 1.5vh, 1.5rem); display: block; margin-inline: auto; max-width: 64rem; position: relative; width: calc(100% - 2rem); } .seq-wrapper-full-view { min-height: 100lvh; width: 100%; } .seq-pin-container { aspect-ratio: 16/9; display: grid; max-height: 100lvh; overflow: hidden; position: relative; width: 100%; } .seq-img-layer { aspect-ratio: inherit; overflow: hidden; z-index: 1; } .seq-img-layer:after { background: linear-gradient(-90deg, transparent, color-mix(in srgb, #111 85%, transparent)); background-size: 100% 100%; content: \"\"; display: block; grid-area: 1/-1; height: 100%; pointer-events: none; position: relative; width: 100%; z-index: 5; } .seq-overlay-layer { z-index: 2; } .seq-preloader-layer { background: #000; display: block; grid-area: 1/-1; pointer-events: none; position: relative; transition: opacity .35s cubic-bezier(.4, 0, .2, 1); -webkit-user-select: none; -moz-user-select: none; user-select: none; z-index: 3; } .seq-keyhole-layer { z-index: 4; } :is(.seq-img-layer, .seq-overlay-layer, .seq-overlay, .seq-keyhole-layer) { display: grid; grid-area: 1/-1; height: 100%; position: relative; width: 100%; } .seq-img { aspect-ratio: inherit; backface-visibility: hidden; background-repeat: no-repeat; background-size: cover; border: 0; color: transparent; display: block; font: 0/0 a; grid-area: 1/-1; max-width: 100%; -o-object-fit: cover; object-fit: cover; outline: none; padding: 0; text-color-shadow: none; vertical-align: middle; } .seq-img, .seq-overlay-inner { height: 100%; pointer-events: none; position: relative; -webkit-user-select: none; -moz-user-select: none; user-select: none; width: 100%; } .seq-overlay-inner { align-items: center; display: flex; flex-direction: column; justify-content: center; opacity: 0; padding: 1rem; text-align: center; } .seq-overlay-inner h2 { color: var(--light-color-lighter); margin-bottom: .25em; text-shadow: .125rem .125rem .25rem rgba(0, 0, 0, .5); } .seq-overlay-inner p { margin-top: -.5em; } .seq-keyhole { background: var(--dark-color-darker); -webkit-clip-path: polygon(0 0, 0 100%, 0 100%, 0 0, 100% 0, 100% 100%, 0 100%, 0 100%, 100% 100%, 100% 0); clip-path: polygon(0 0, 0 100%, 0 100%, 0 0, 100% 0, 100% 100%, 0 100%, 0 100%, 100% 100%, 100% 0); height: 100%; position: relative; width: 100%; } .seq-keyhole, .seq-keyhole-corner { display: block; grid-area: 1/-1; pointer-events: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; } .seq-keyhole-corner { --keyhole-corner-color-bg: var(--dark-color-darker); height: var(--border-radius); position: absolute; width: var(--border-radius); } .seq-keyhole-corner:is(.top-left, .top-right) { margin-top: -.03125rem; } .seq-keyhole-corner:is(.bottom-left, .bottom-right) { margin-top: calc(-1 * var(--border-radius) + .03125rem); } .seq-keyhole-corner:is(.top-left, .bottom-left) { margin-left: -.03125rem; } .seq-keyhole-corner:is(.top-right, .bottom-right) { margin-left: calc(-1 * var(--border-radius) + .03125rem); } .seq-keyhole-corner.top-left { background: radial-gradient(circle at bottom right, transparent calc(var(--border-radius) - .0625rem), var(--keyhole-corner-color-bg) var(--border-radius)); } .seq-keyhole-corner.top-right { background: radial-gradient(circle at bottom left, transparent calc(var(--border-radius) - .0625rem), var(--keyhole-corner-color-bg) var(--border-radius)); } .seq-keyhole-corner.bottom-left { background: radial-gradient(circle at top right, transparent calc(var(--border-radius) - .0625rem), var(--keyhole-corner-color-bg) var(--border-radius)); } .seq-keyhole-corner.bottom-right { background: radial-gradient(circle at top left, transparent calc(var(--border-radius) - .0625rem), var(--keyhole-corner-color-bg) var(--border-radius)); } .seq-track { display: block; height: var(--track-height, 100lvh); margin-top: var(--track-offset-y, -100lvh); pointer-events: none; position: relative; -webkit-user-select: none; -moz-user-select: none; user-select: none; width: 100%; } .seq-track-markers { inset: 0; pointer-events: none; position: absolute; } .seq-track-time-marker { border-top: thin dashed var(--light-color); color: var(--light-color); font-size: .625rem; left: 0; padding-right: .25rem; position: absolute; text-align: right; width: 100%; } .seq-track-overlay-marker { align-items: center; display: flex; height: .0625rem; left: 0; position: absolute; width: 100%; } .seq-track-overlay-marker.start { background-color: #2ecc71; } .seq-track-overlay-marker.end { background-color: #e74c3c; } .seq-track-overlay-label { background: var(--light-color); border-radius: .1875rem; color: var(--dark-color-darker); font-size: .625rem; margin-left: .25rem; padding: .125rem .25rem; } .spacer { display: block; height: 100lvh; position: relative; } .resources-layer { bottom: 0; display: block; position: fixed; right: 0; z-index: 1000; } .resources { background: var(--resources-bg-color); display: grid; font-size: .6875rem; font-weight: 300; grid-auto-flow: column; line-height: 1.3; padding: .5rem; pointer-events: auto; } .resources a { align-content: center; display: grid; justify-content: center; padding: 0 .5rem; place-content: center; transition: color .2s ease-in-out; } .resources a, .resources a:visited { color: var(--resources-color); } .resources a:active, .resources a:focus-visible { color: var(--resources-active-color); } .resources a:focus-visible { outline: none; } .resources a:not(:first-child) { border-inline-start: thin solid currentColor; } @media (max-width:51.29875em) { .seq-wrapper { --border-radius: clamp(0.5rem, 2vh, 1rem); } .seq-pin-container { aspect-ratio: 4/3; } } @media (max-width:36.04875em) { .seq-pin-container { aspect-ratio: 1/1; } } @media (hover:hover) and (pointer:fine) { section.intro a:active:not(:hover), section.intro a:hover { color: var(--color-accent); } .resources a:active:not(:hover), .resources a:hover { color: var(--resources-active-color); } }\nscript.js: // Utils https://assets.codepen.io/573855/utils-v3.js gsap.registerPlugin(ScrollTrigger, ScrollSmoother); ScrollTrigger.config({ limitCallbacks: true, ignoreMobileResize: true, autoRefreshEvents: 'DOMContentLoaded,load', }); const scroller = (() => { if (typeof gsap === 'undefined' || typeof ScrollSmoother === 'undefined' || utils.device.isTouch()) { document.body.classList.add('normalize-scroll'); return null; } return { initialize: (contentSelector = '.content-scroll', wrapperSelector = '.viewport-wrapper') => ScrollSmoother.create({ content: contentSelector, wrapper: wrapperSelector, smooth: 2, effects: false, normalizeScroll: true, preventDefault: true, }), }; })(); const createScrub = () => { let DOM = { container: null, pinContainer: null, triggerElement: null, imageLayer: null, overlayLayer: null, preloaderLayer: null, keyholeMask: null, corners: { topLeft: null, topRight: null, bottomLeft: null, bottomRight: null, }, trackElement: null, trackMarkersContainer: null, }; let observer = null; let scrollTrigger = null; let imageItems = []; let overlayCueItems = []; let isScrollLocked = true; let isImageUpdateQueued = false; let scrollDirection = 'down'; let activeImageIndex = -1; let lastResolvedImageIndex = -1; let lastScrollProgress = 0; let queuedImageProgress = 0; let preloaderRemoved = false; let preloaderRemovalTick = null; let timelineDuration = 1; let lastRenderedTrackHeight = null; let lastAnimatedClipPath = ''; const options = { selector: null, trigger: null, startOffset: null, duration: null, scrollFactor: 1, }; const resolveTimelineDuration = (value, containerEl) => { const fromOptions = parseFloat(value); const fromAttr = parseFloat(containerEl.getAttribute('data-duration')); if (Number.isFinite(fromOptions) && fromOptions > 0) return fromOptions; if (Number.isFinite(fromAttr) && fromAttr > 0) return fromAttr; console.warn('[createScrub] No valid duration found; using default of 1s.'); return 1; }; const initialize = (opts = {}) => { reset(); Object.assign(options, opts); const container = utils.dom.resolveElement(options.selector); if (!container) { console.warn('[createScrub] Invalid or missing selector.'); return; } DOM.container = container; DOM.pinContainer = container.querySelector('.seq-pin-container'); if (!DOM.pinContainer) { console.warn('[createScrub] Missing .seq-pin-container'); return; } DOM.triggerElement = container.querySelector(options.trigger) || DOM.pinContainer; DOM.imageLayer = container.querySelector('.seq-img-layer'); DOM.overlayLayer = container.querySelector('.seq-overlay-layer'); DOM.preloaderLayer = container.querySelector('.seq-preloader-layer'); DOM.keyholeMask = container.querySelector('.seq-keyhole'); DOM.corners = { topLeft: DOM.pinContainer.querySelector('.top-left'), topRight: DOM.pinContainer.querySelector('.top-right'), bottomLeft: DOM.pinContainer.querySelector('.bottom-left'), bottomRight: DOM.pinContainer.querySelector('.bottom-right'), }; DOM.trackElement = container.querySelector('.seq-track'); DOM.trackMarkersContainer = DOM.trackElement?.querySelector('.seq-track-markers'); timelineDuration = resolveTimelineDuration(options.duration, container); prepareImageLayer(); prepareOverlayCues(); setupScrollTrigger(); revealKeyholeMask(75); hideKeyholeMask(75, -1); observe(container); }; const reset = () => { observer?.disconnect(); scrollTrigger?.kill(); DOM = { container: null, pinContainer: null, triggerElement: null, imageLayer: null, overlayLayer: null, preloaderLayer: null, keyholeMask: null, corners: { topLeft: null, topRight: null, bottomLeft: null, bottomRight: null, }, trackElement: null, trackMarkersContainer: null, }; observer = null; scrollTrigger = null; lastRenderedTrackHeight = null; imageItems = []; overlayCueItems = []; isScrollLocked = true; preloaderRemoved = false; isImageUpdateQueued = false; scrollDirection = 'down'; activeImageIndex = -1; lastResolvedImageIndex = -1; lastScrollProgress = 0; queuedImageProgress = 0; }; const setupScrollTrigger = () => { if (scrollTrigger || !DOM.trackElement || !DOM.pinContainer) return; const getLVH = utils.css.getLVH; scrollTrigger = ScrollTrigger.create({ trigger: DOM.triggerElement, pin: DOM.pinContainer, start: () => `center ${options.startOffset ?? 0.5 * getLVH()}px`, end: () => { updateTrack(); return `+=${DOM.trackElement.offsetHeight - DOM.pinContainer.offsetHeight}`; }, scrub: true, pinSpacing: false, invalidateOnRefresh: true, onUpdate: (self) => { if (isScrollLocked) return; const progress = self.progress; scrollDirection = progress > lastScrollProgress ? 'down' : 'up'; lastScrollProgress = progress; throttledUpdateImageLayer(progress); updateOverlayCues(progress); } }); }; // ----- 1 Scroll Coordination ----- // Controls the entry point and main update cycle. // Uses IntersectionObserver to start logic when container enters viewport. const observe = (target) => { let hasTriggered = false; observer = new IntersectionObserver(([entry]) => { if (!entry?.isIntersecting || hasTriggered) return; hasTriggered = true; isScrollLocked = false; const matchedIndex = findInitialImageCueIndex(); const matched = imageItems[matchedIndex]; // First: preload and activate matched preloadImage(matched, (isFirstLoad) => { updateImage(matchedIndex, isFirstLoad === false); // Step 1: preload surrounding in interleaved order [+1, -1, +2, -2, ...] const preloadWindow = 3; const preloadOrder = []; let i = 1; for (; i <= preloadWindow; i++) { if (matchedIndex + i < imageItems.length) preloadOrder.push(matchedIndex + i); if (matchedIndex - i >= 0) preloadOrder.push(matchedIndex - i); } let j = 0; const totalNearby = preloadOrder.length; for (; j < totalNearby; j++) { preloadImage(imageItems[preloadOrder[j]], null, false); } // Step 2: preload *all remaining* images (excluding matched and already preloaded) let k = 0; const total = imageItems.length; for (; k < total; k++) { if (k === matchedIndex || preloadOrder.includes(k)) continue; if (!imageItems[k].loaded) { preloadImage(imageItems[k], null, false); } } }, true); }, { threshold: 0.01, rootMargin: '0px 0px -0.01% 0px', }); observer.observe(target); }; const throttledUpdateImageLayer = (progress) => { queuedImageProgress = progress; if (isImageUpdateQueued) return; isImageUpdateQueued = true; requestAnimationFrame(() => { updateImageLayer(queuedImageProgress); isImageUpdateQueued = false; }); }; // ----- 2 Image Layer Preparation ----- // Parsing DOM and cue data for image items. const prepareImageLayer = () => { if (!DOM.imageLayer) return; const imageEls = DOM.imageLayer.querySelectorAll('.seq-img'); imageItems.length = 0; let imageEl, cueStart, cueEnd; let i = 0; const total = imageEls.length; for (; i < total; i++) { imageEl = imageEls[i]; cueStart = parseFloat(imageEl.getAttribute('data-start')); cueEnd = parseFloat(imageEl.getAttribute('data-end')); if (!Number.isFinite(cueStart)) continue; if (!Number.isFinite(cueEnd)) cueEnd = null; gsap.set(imageEl, { opacity: 0 }); const imageItem = { el: imageEl, start: cueStart, end: cueEnd, active: false, loaded: false, loading: false }; imageItems.push(imageItem); } }; // ----- 3 Scroll-to-Cue Resolution ----- // Maps scroll progress to matched image index. const findInitialImageCueIndex = () => { const scrollY = window.scrollY; const scrollRange = document.documentElement.scrollHeight - window.innerHeight; const scrollProgress = scrollRange > 0 ? scrollY / scrollRange : 0; const currentTime = +(scrollProgress * timelineDuration).toFixed(4); let matchedIndex = -1; let i = 0; const total = imageItems.length; for (; i < total; i++) { if (imageItems[i].start <= currentTime) { matchedIndex = i; } else { break; } } return matchedIndex; }; const findMatchingImageIndex = (time) => { let i = 0; const total = imageItems.length; for (; i < total; i++) { if (imageItems[i].start > time) return i - 1; } return total - 1; }; // ----- 4 Image Cue Switching Logic ----- // Main logic for what to show and how. const updateImageLayer = (progress) => { const currentTime = +(progress * timelineDuration).toFixed(4); const matchedIndex = findMatchingImageIndex(currentTime); lastResolvedImageIndex = matchedIndex; if (matchedIndex !== -1) { activateMatchedImage(matchedIndex); } else { fadeOutActiveImage(); } }; const activateMatchedImage = (index) => { const matched = imageItems[index]; const preloadWindow = 2; const totalImages = imageItems.length; if (!matched.loaded && !matched.loading) { preloadImage(matched, () => { updateImage(index); }); } else { updateImage(index); } }; const updateImage = (targetIndex) => { if (targetIndex === activeImageIndex) return; const prevImageItem = imageItems[activeImageIndex]; const nextImageItem = imageItems[targetIndex]; // --- Fade out previous --- if (prevImageItem) { gsap.killTweensOf(prevImageItem.el); if (!preloaderRemoved) { // Hard reset without transition prevImageItem.el.style.opacity = '0'; prevImageItem.active = false; prevImageItem.el.style.zIndex = '0'; } else { gsap.to(prevImageItem.el, { opacity: 0, duration: 0.5, ease: 'power2.inOut', onComplete: () => { prevImageItem.active = false; prevImageItem.el.style.zIndex = '0'; } }); } } // --- Fade in new --- gsap.killTweensOf(nextImageItem.el); nextImageItem.active = true; nextImageItem.el.style.zIndex = '1'; if (!preloaderRemoved) { nextImageItem.el.style.opacity = '1'; if (!preloaderRemovalTick) { preloaderRemovalTick = utils.system.nextTick(() => { removePreloaderOnce(); }, null, 250); } } else { gsap.to(nextImageItem.el, { opacity: 1, duration: 0.8, ease: 'power2.out' }); } activeImageIndex = targetIndex; }; const fadeOutActiveImage = () => { const activeImageItem = imageItems[activeImageIndex]; if (!activeImageItem) return; gsap.killTweensOf(activeImageItem.el); gsap.to(activeImageItem.el, { opacity: 0, duration: 0.5, ease: 'power2.inOut', onComplete: () => { activeImageItem.active = false; activeImageItem.el.style.zIndex = '0'; } }); activeImageIndex = -1; }; // ----- 5 Image Loading ----- // Handles loading and preload logic. const preloadImage = (imageItem, callback = null, shouldUpdateOnLoad = true) => { if (imageItem.loaded || imageItem.loading || imageItem.preloadRequested) { if (imageItem.loaded && callback && shouldUpdateOnLoad) { callback(false); // not first load } return; } imageItem.preloadRequested = true; imageItem.loading = true; const imageEl = imageItem.el.querySelector('img') || imageItem.el; if (imageEl.dataset.src) imageEl.src = imageEl.dataset.src; if (imageEl.dataset.srcset) imageEl.srcset = imageEl.dataset.srcset; const finalize = () => { imageItem.loaded = true; imageItem.loading = false; }; const done = (isFirstLoad) => { finalize(); if (callback && shouldUpdateOnLoad) { callback(isFirstLoad); } }; imageEl.onerror = () => done(false); if (imageEl.complete && imageEl.naturalWidth !== 0) { done(false); // already loaded } else { imageEl.onload = () => done(true); imageEl.onerror = () => done(false); } //imageEl.decode().then(() => done(true)).catch(() => done(false)); }; // ----- 6 Preloader Lifecycle ----- // Final cleanup after first image has loaded. const removePreloaderOnce = () => { if (!preloaderRemoved && DOM.preloaderLayer) { preloaderRemoved = true; DOM.preloaderLayer.style.opacity = '0'; utils.system.nextTick(() => { DOM.preloaderLayer?.parentNode?.removeChild(DOM.preloaderLayer); DOM.preloaderLayer = null; }, null, 350); } }; // ----- 7 Overlay Cue Layer ----- // Parse overlay cue elements and control visibility transitions during scroll. const prepareOverlayCues = () => { if (!DOM.overlayLayer) return; const cueElements = DOM.overlayLayer.querySelectorAll('.seq-overlay'); overlayCueItems.length = 0; let cueEl, innerEl, start, end; let i = 0; const total = cueElements.length; for (; i < total; i++) { cueEl = cueElements[i]; start = parseFloat(cueEl.getAttribute('data-start')); end = parseFloat(cueEl.getAttribute('data-end')); innerEl = cueEl.querySelector('.seq-overlay-inner'); if (!innerEl) continue; if (Number.isFinite(start) && Number.isFinite(end)) { overlayCueItems.push({ container: cueEl, inner: innerEl, start, end, active: false }); } } }; const updateOverlayCues = (progress) => { const currentTime = progress * timelineDuration; const isScrollingDown = scrollDirection === 'down'; const yIn = isScrollingDown ? 50 : -50; const yOut = isScrollingDown ? -50 : 50; let activeCue = null; let i = 0; const total = overlayCueItems.length; let cueItem, innerEl, otherCue; // Find current active cue for (; i < total; i++) { cueItem = overlayCueItems[i]; if (currentTime >= cueItem.start && currentTime < cueItem.end) { activeCue = cueItem; break; } } // Animate cues for (i = 0; i < total; i++) { cueItem = overlayCueItems[i]; innerEl = cueItem.inner; if (cueItem === activeCue) { if (!cueItem.active) { cueItem.active = true; // Deactivate all others for (let j = 0; j < total; j++) { otherCue = overlayCueItems[j]; if (otherCue !== cueItem && otherCue.active) { otherCue.active = false; gsap.killTweensOf(otherCue.inner); gsap.set(otherCue.inner, { opacity: 0, y: 0 }); } } gsap.set(innerEl, { opacity: 0, y: yIn }); gsap.to(innerEl, { opacity: 1, y: 0, duration: 0.3, ease: 'power2.out', overwrite: true, }); } } else if (cueItem.active) { cueItem.active = false; gsap.killTweensOf(innerEl); gsap.to(innerEl, { opacity: 0, y: yOut, duration: 0.3, ease: 'power1.inOut', overwrite: true, onComplete: () => { gsap.set(innerEl, { y: 0 }); }, }); } } }; // ----- 8 Keyhole Mask Effects ----- // Scroll-driven clip-path animation that reveals or hides a central \"keyhole\" mask. // Optional decorative corners animate in sync with the mask shape. /** * Returns the fully expanded polygon shape for the visible keyhole. */ const getKeyholePolygonRevealed = () => [ '0% 0%', '0% 100%', '0% 100%', '0% 0%', '100% 0%', '100% 100%', '0% 100%', '0% 100%', '100% 100%', '100% 0%' ].join(','); /** * Returns the collapsed polygon shape for hiding the keyhole. * @param {number} innerPercent - The size of the inner remaining keyhole in percent. */ const getKeyholePolygonCollapsed = (innerPercent = 65) => { const outer = 100 - innerPercent; return [ '0% 0%', '0% 100%', `${outer}% 100%`, `${outer}% ${outer}%`, `${innerPercent}% ${outer}%`, `${innerPercent}% ${innerPercent}%`, `${outer}% ${innerPercent}%`, `${outer}% 100%`, '100% 100%', '100% 0%' ].join(','); }; /** * Animates a keyhole mask from one polygon to another, optionally syncing decorative corners. * Skips redundant re-animation if clip path has not changed. */ const animateKeyholeClipPath = ({ maskElement, fromPolygon, toPolygon, scrollTrigger, containerElement = null, cornerConfigs = null, suppressImmediateRender = false }) => { if (!maskElement || !fromPolygon || !toPolygon || !scrollTrigger) return; const clipKey = `${fromPolygon}__${toPolygon}`; if (clipKey === lastAnimatedClipPath) return; lastAnimatedClipPath = clipKey; gsap.fromTo(maskElement, { clipPath: `polygon(${fromPolygon})` }, { clipPath: `polygon(${toPolygon})`, ease: 'none', scrollTrigger, immediateRender: !suppressImmediateRender }); if (containerElement && cornerConfigs) { const corners = DOM.corners; Object.entries(cornerConfigs).forEach(([key, config]) => { const cornerEl = corners[key]; if (cornerEl && config?.from && config?.to) { gsap.fromTo(cornerEl, config.from, { ...config.to, ease: 'none', scrollTrigger, immediateRender: !suppressImmediateRender }); } }); } }; /** * Scroll-driven keyhole reveal animation (clip-path + corner elements). */ const revealKeyholeMask = (innerPercent = 65, startOffset = 0, endOffset = 0) => { if (!DOM.keyholeMask) return; const getLVH = utils.css.getLVH; const outer = 100 - innerPercent; const fromPolygon = getKeyholePolygonCollapsed(innerPercent); const toPolygon = getKeyholePolygonRevealed(); animateKeyholeClipPath({ maskElement: DOM.keyholeMask, fromPolygon, toPolygon, scrollTrigger: { trigger: DOM.pinContainer, scrub: true, start: () => `top ${getLVH() + startOffset}px`, end: () => `center ${0.5 * getLVH() + endOffset}px`, }, containerElement: DOM.pinContainer, cornerConfigs: { topLeft: { from: { top: `${outer}%`, left: `${outer}%` }, to: { top: '0%', left: '0%' } }, topRight: { from: { top: `${outer}%`, left: `${innerPercent}%` }, to: { top: '0%', left: '100%' } }, bottomLeft: { from: { top: `${innerPercent}%`, left: `${outer}%` }, to: { top: '100%', left: '0%' } }, bottomRight: { from: { top: `${innerPercent}%`, left: `${innerPercent}%` }, to: { top: '100%', left: '100%' } }, } }); }; /** * Scroll-driven keyhole hide animation (reversed from reveal). */ const hideKeyholeMask = (innerPercent = 65, startOffset = 0, endOffset = 0) => { if (!DOM.keyholeMask) return; const getLVH = utils.css.getLVH; const outer = 100 - innerPercent; const fromPolygon = getKeyholePolygonRevealed(); const toPolygon = getKeyholePolygonCollapsed(innerPercent); animateKeyholeClipPath({ maskElement: DOM.keyholeMask, fromPolygon, toPolygon, scrollTrigger: { trigger: DOM.pinContainer, scrub: true, start: () => `center ${0.5 * getLVH() + startOffset}px`, end: () => `bottom ${endOffset}px`, }, containerElement: DOM.pinContainer, cornerConfigs: { topLeft: { from: { top: '0%', left: '0%' }, to: { top: `${outer}%`, left: `${outer}%` } }, topRight: { from: { top: '0%', left: '100%' }, to: { top: `${outer}%`, left: `${innerPercent}%` } }, bottomLeft: { from: { top: '100%', left: '0%' }, to: { top: `${innerPercent}%`, left: `${outer}%` } }, bottomRight: { from: { top: '100%', left: '100%' }, to: { top: `${innerPercent}%`, left: `${innerPercent}%` } }, }, suppressImmediateRender: true }); }; // ----- 9 Track Rendering ----- /** * Renders vertical markers for time and overlay cue points along the scroll track. * Reuses existing elements when possible to avoid unnecessary DOM updates. */ const renderTrackMarkers = () => { const container = DOM.trackMarkersContainer; if (!DOM.trackElement || !container || overlayCueItems.length === 0) return; const trackHeight = DOM.trackElement.offsetHeight; const pinHeight = DOM.pinContainer.offsetHeight; const scrollableHeight = trackHeight - pinHeight; const pinOffset = pinHeight / 2; const frag = document.createDocumentFragment(); const edges = [ { prop: 'start', className: 'start' }, { prop: 'end', className: 'end' } ]; // Cache for comparison to avoid DOM churn const existing = container.children; const expectedCount = Math.floor(timelineDuration) + 1 + overlayCueItems.length * 2; if (existing.length !== expectedCount) container.innerHTML = ''; // Mismatch, clear all const seconds = Math.floor(timelineDuration); let i = 0; let progress, offset, marker, existingMarker; for (; i <= seconds; i++) { progress = i / timelineDuration; offset = (progress * scrollableHeight) + pinOffset; existingMarker = container.children[i]; if (existingMarker && existingMarker.classList.contains('seq-track-time-marker')) { existingMarker.style.top = `${offset}px`; existingMarker.textContent = `${i}s`; frag.appendChild(existingMarker); } else { marker = document.createElement('div'); marker.className = 'seq-track-time-marker'; marker.style.top = `${offset}px`; marker.textContent = `${i}s`; frag.appendChild(marker); } } // Overlay cue markers let overlayItem, edge, time, labelEl; const offsetIndex = i; // continue from time marker count i = 0; const total = overlayCueItems.length; for (; i < total; i++) { overlayItem = overlayCueItems[i]; for (let j = 0; j < 2; j++) { edge = edges[j]; time = overlayItem[edge.prop]; progress = time / timelineDuration; offset = (progress * scrollableHeight) + pinOffset; marker = document.createElement('div'); marker.className = `seq-track-overlay-marker ${edge.className}`; marker.style.top = `${offset}px`; labelEl = document.createElement('span'); labelEl.className = 'seq-track-overlay-label'; labelEl.textContent = `${time.toFixed(1)}s`; marker.appendChild(labelEl); frag.appendChild(marker); } } container.innerHTML = ''; container.appendChild(frag); }; /** * Updates track height and offset based on current scrollable content and pin size. * Also triggers marker rendering. */ const updateTrack = () => { const trackEl = DOM.trackElement; const pinEl = DOM.pinContainer; if (!trackEl || !pinEl) return; const pinHeight = pinEl.offsetHeight; const scrollFactor = options.scrollFactor || 1; const totalHeight = (pinHeight * timelineDuration) * scrollFactor; const newHeight = `${totalHeight - pinHeight}px`; if (newHeight === lastRenderedTrackHeight) return; trackEl.style.setProperty('--track-offset-y', `-${pinHeight}px`); trackEl.style.setProperty('--track-height', newHeight); lastRenderedTrackHeight = newHeight; renderTrackMarkers(); }; const update = () => { updateTrack(); }; return { initialize, update, }; }; document.addEventListener('DOMContentLoaded', () => { if (scroller) scroller.initialize(); const scrubInstance = createScrub(); scrubInstance.initialize({ selector: '#scrub_01', scrollFactor: 1.5, }); const globalRefresh = () => { scrubInstance.update(); ScrollTrigger.refresh(); }; if (utils.device.isTouch()) { window.addEventListener('orientationchange', () => { utils.system.nextTick(globalRefresh, null, 500); }); } else { window.addEventListener('resize', () => { utils.system.nextTick(globalRefresh); }); } utils.system.nextTick(() => { globalRefresh(); }, null, 300); const isCodePen = document.referrer.includes(\"codepen.io\"); const hostDomains = isCodePen ? [\"codepen.io\"] : []; hostDomains.push(window.location.hostname); const links = document.getElementsByTagName(\"a\"); utils.url.validateLinks(links, hostDomains); });",
    "id": "gsap-scroll-synced-image-slideshow-with-timed-cues-and-keyhole-effect"
  },
  {
    "title": "[threejs]  Momentum Distortion Gallery Slider",
    "description": "",
    "code": "index.html: <div class=\"preloader\"> <div class=\"circle-container\"> <!-- Dots will be inserted by JavaScript --> </div> <div class=\"initializing-text-container\"> <div class=\"initializing-progress\"></div> <div class=\"initializing-text\">INITIALIZING</div> </div> </div> <footer> <p>DRAG TO EXPLORE</p> </footer> <div class=\"particles\" id=\"particles\"></div> <div id=\"titles-container\"></div> <canvas id=\"canvas\"></canvas>\nstyle.css: @import url(\"https://fonts.cdnfonts.com/css/thegoodmonolith\"); @import url(\"https://fonts.cdnfonts.com/css/pp-neue-montreal\"); * { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: \"TheGoodMonolith\", monospace; background-color: #111; color: #f0f0f0; overflow: hidden; position: relative; } /* Dust/Scratches background effect for the entire site */ body::after { content: \"\"; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-image: url(\"https://img.freepik.com/premium-photo/white-dust-scratches-black-background_279525-2.jpg?w=640\"); background-repeat: repeat; opacity: 0.1; mix-blend-mode: screen; pointer-events: none; z-index: 1; } /* Animated noise effect */ body::before { content: \"\"; position: fixed; top: -50%; left: -50%; width: 200%; height: 200%; background: transparent url(\"http://assets.iceable.com/img/noise-transparent.png\") repeat 0 0; background-size: 300px 300px; animation: noise-animation 0.3s steps(5) infinite; opacity: 0.9; will-change: transform; z-index: 100; pointer-events: none; } @keyframes noise-animation { 0% { transform: translate(0, 0); } 10% { transform: translate(-2%, -3%); } 20% { transform: translate(-4%, 2%); } 30% { transform: translate(2%, -4%); } 40% { transform: translate(-2%, 5%); } 50% { transform: translate(-4%, 2%); } 60% { transform: translate(3%, 0); } 70% { transform: translate(0, 3%); } 80% { transform: translate(-3%, 0); } 90% { transform: translate(2%, 2%); } 100% { transform: translate(1%, 0); } } p { text-transform: uppercase; font-size: 13px; letter-spacing: 0.05em; -webkit-font-smoothing: antialiased; } footer { position: fixed; width: 100vw; padding: 2em; display: flex; justify-content: flex-end; align-items: center; z-index: 2; mix-blend-mode: difference; bottom: 0; right: 0; opacity: 0; transition: opacity 0.5s ease; } #canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden; cursor: grab; opacity: 0; transition: opacity 0.5s ease; } #canvas:active { cursor: grabbing; } .particles { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; opacity: 0; transition: opacity 0.5s ease; } .particle { position: absolute; background: rgba(255, 255, 255, 0.1); border-radius: 50%; } .tp-dfwv { position: fixed; top: 10px; right: 10px; z-index: 10; } /* Slide titles container */ #titles-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; opacity: 0; transition: opacity 0.5s ease; } .slide-title { position: absolute; color: white; pointer-events: none; transition: opacity 0.3s ease, filter 0.3s ease; } .title-text { font-family: \"PP Neue Montreal\", sans-serif; text-transform: uppercase; font-size: 6vw; line-height: 0.9; font-weight: 400; letter-spacing: -0.03em; margin: 0; white-space: nowrap; } .title-number { font-family: \"TheGoodMonolith\", monospace; font-size: 0.8vw; margin: 0; position: relative; padding-top: 10px; display: flex; align-items: center; } .title-number::before { content: \"\"; display: block; width: 40px; height: 3px; background-color: #ffe600; margin-right: 10px; } .preloader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; } .circle-container { position: relative; width: 200px; height: 200px; margin-bottom: 30px; } .initializing-text-container { position: relative; margin-top: 30px; overflow: hidden; } .initializing-text { font-family: \"TheGoodMonolith\", monospace; color: #fff; font-size: 12px; letter-spacing: 3px; position: relative; z-index: 2; mix-blend-mode: difference; } .initializing-progress { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background-color: #ffe600; z-index: 1; } .dot { position: absolute; width: 6px; height: 6px; border-radius: 50%; background-color: #ffe600; opacity: 0; } @keyframes fadeIn { 0% { opacity: 0; transform: scale(0); } 100% { opacity: 1; transform: scale(1); } } @keyframes fadeOut { 0% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(0); } } @keyframes pulse { 0% { transform: scale(0.8); } 50% { transform: scale(1.2); } 100% { transform: scale(0.8); } }\nscript.js: import * as THREE from \"https://esm.sh/three\"; import { Pane } from \"https://cdn.skypack.dev/tweakpane@4.0.4\"; const createPreloader = () => { const container = document.querySelector(\".circle-container\"); const progressBar = document.querySelector(\".initializing-progress\"); const rings = 5; const allDots = []; // Create center dot first const centerDot = document.createElement(\"div\"); centerDot.className = \"dot\"; centerDot.style.width = \"8px\"; centerDot.style.height = \"8px\"; centerDot.style.left = \"calc(50% - 4px)\"; centerDot.style.top = \"calc(50% - 4px)\"; centerDot.style.backgroundColor = \"#ffe600\"; centerDot.style.animation = \"pulse 1.5s infinite ease-in-out\"; centerDot.style.opacity = \"1\"; container.appendChild(centerDot); // Create all dots for each ring for (let r = 0; r < rings; r++) { const radius = 15 + r * 20; const numDots = 6 + r * 6; // Calculate color based on ring (yellow inner to white outer) const yellowAmount = Math.max(0, 1 - r / (rings - 1)); const colorR = 255; const colorG = Math.floor(230 + 25 * (1 - yellowAmount)); const colorB = Math.floor(0 + 255 * (1 - yellowAmount)); const color = `rgb(${colorR}, ${colorG}, ${colorB})`; // Create dots in this ring for (let i = 0; i < numDots; i++) { const dot = document.createElement(\"div\"); dot.className = \"dot\"; // Calculate position in a circle const angle = (i / numDots) * Math.PI * 2; const x = Math.cos(angle) * radius; const y = Math.sin(angle) * radius; // Set dot position and size (larger dots in outer rings) const size = 3 + r * 0.8; dot.style.width = `${size}px`; dot.style.height = `${size}px`; dot.style.left = `calc(50% + ${x}px - ${size / 2}px)`; dot.style.top = `calc(50% + ${y}px - ${size / 2}px)`; dot.style.backgroundColor = color; // All dots start invisible dot.style.opacity = \"0\"; container.appendChild(dot); allDots.push({ element: dot, ring: r, index: i, totalInRing: numDots }); } } // Animation sequence const totalAnimationTime = 5000; // 5 seconds total animation const progressUpdateInterval = 50; // Update progress every 50ms let startTime = Date.now(); // Start progress bar animation const updateProgress = () => { const elapsed = Date.now() - startTime; const progress = Math.min(100, (elapsed / totalAnimationTime) * 100); progressBar.style.width = `${progress}%`; if (progress < 100) { setTimeout(updateProgress, progressUpdateInterval); } }; // Start updating progress updateProgress(); setTimeout(() => { // First phase: animate dots appearing from center outward let delay = 0; const delayIncrement = 20; // ms between dots // Sort dots by ring and then by index within ring allDots.sort((a, b) => { if (a.ring !== b.ring) return a.ring - b.ring; return a.index - b.index; }); // Animate each dot with increasing delay allDots.forEach((dot, i) => { setTimeout(() => { dot.element.style.animation = \"fadeIn 0.4s forwards ease-out\"; }, delay); delay += delayIncrement; }); // Second phase: wait, then reverse the animation setTimeout(() => { // Hide center dot first centerDot.style.animation = \"fadeOut 0.4s forwards ease-in\"; // Sort dots in reverse order (outside in) allDots.sort((a, b) => { if (a.ring !== b.ring) return b.ring - a.ring; return a.index - b.index; }); // Animate dots disappearing let reverseDelay = 200; // Start after a small pause allDots.forEach((dot, i) => { setTimeout(() => { dot.element.style.animation = \"fadeOut 0.4s forwards ease-in\"; }, reverseDelay); reverseDelay += delayIncrement; }); // Final phase: complete preloader and show main content setTimeout(() => { const preloader = document.querySelector(\".preloader\"); const mainElements = document.querySelectorAll( \"#canvas, .particles, #titles-container, footer\" ); // Fade in main content mainElements.forEach((el) => { el.style.opacity = \"1\"; }); // Fade out preloader preloader.style.opacity = \"0\"; preloader.style.transition = \"opacity 0.8s cubic-bezier(0.65, 0, 0.35, 1)\"; setTimeout(() => { preloader.style.display = \"none\"; }, 800); }, reverseDelay + 250); // Wait for reverse animation to complete }, delay + 750); // Wait for all dots to appear }, 750); // Initial delay before starting the sequence return allDots; }; // Run preloader creation immediately createPreloader(); // Create ambient particles. const particlesContainer = document.getElementById(\"particles\"); const particleCount = 80; for (let i = 0; i < particleCount; i++) { const particle = document.createElement(\"div\"); particle.className = \"particle\"; const size = Math.random() * 5 + 2; particle.style.width = `${size}px`; particle.style.height = `${size}px`; const x = Math.random() * 100; const y = Math.random() * 100; particle.style.left = `${x}%`; particle.style.top = `${y}%`; particle.style.opacity = Math.random() * 0.5 + 0.1; particlesContainer.appendChild(particle); } const canvas = document.getElementById(\"canvas\"); const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true, alpha: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); const scene = new THREE.Scene(); scene.background = new THREE.Color(0x000); scene.fog = new THREE.FogExp2(0x000, 0.08); const camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 ); camera.position.z = 5; // Lights. const ambientLight = new THREE.AmbientLight(0x404040, 1); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); directionalLight.position.set(0, 1, 1); scene.add(directionalLight); // --- Slides and Global Settings --- const slideWidth = 3.2; const slideHeight = 1.8; const gap = 0.25; const slideCount = 10; const imagesCount = 5; const totalWidth = slideCount * (slideWidth + gap); const slideUnit = slideWidth + gap; /* Global settings: - textFadeStart/textFadeEnd: define the range in which the text is visible. - textMaxBlur: maximum blur (in pixels). - rotationFactor: scales extra rotation (\"wobble\") from distortions. - distortionIntensity: scales overall distortion. - horizontalDistortionDamping: reduces the X-axis jitter on small movements. For demonstration, camera movement amplitude is set to 0 so the scene doesn't \"drift\". If you want a subtle drift, set amplitude > 0 again in updateCamera(). */ const settings = { wheelSensitivity: 0.01, touchSensitivity: 0.01, momentumMultiplier: 2.5, smoothing: 0.1, slideLerp: 0.075, distortionDecay: 0.93, maxDistortion: 4.0, distortionSensitivity: 0.25, distortionSmoothing: 0.075, rotationFactor: 0.2, animationSpeed: 0.5, textFadeStart: slideWidth / 2, // e.g., 1.6 for slideWidth=3.2 textFadeEnd: slideWidth / 2 + 0.5, textMaxBlur: 5, distortionIntensity: 0.3, horizontalDistortionDamping: 0.3, // Parameters for enhanced momentum distortion momentumDistortionBoost: 0.3, directionInfluence: 0.4, waveAmplitudeBoost: 0.2, directionChangeThreshold: 0.02, // Minimum movement needed to change direction directionSmoothing: 0.03 // Slower transitions between directions }; // Setup Tweakpane controls. const pane = new Pane(); const distortionFolder = pane.addFolder({ title: \"Distortion\" }); distortionFolder.addBinding(settings, \"maxDistortion\", { min: 1.0, max: 10.0 }); distortionFolder.addBinding(settings, \"distortionSensitivity\", { min: 0.1, max: 1.0 }); distortionFolder.addBinding(settings, \"distortionDecay\", { min: 0.8, max: 0.99 }); distortionFolder.addBinding(settings, \"distortionSmoothing\", { min: 0.01, max: 0.2 }); distortionFolder.addBinding(settings, \"distortionIntensity\", { min: 0.0, max: 1.0 }); distortionFolder.addBinding(settings, \"horizontalDistortionDamping\", { min: 0.0, max: 1.0 }); distortionFolder.addBinding(settings, \"momentumDistortionBoost\", { min: 0.0, max: 1.0 }); distortionFolder.addBinding(settings, \"directionInfluence\", { min: 0.0, max: 1.0 }); distortionFolder.addBinding(settings, \"waveAmplitudeBoost\", { min: 0.0, max: 1.0 }); distortionFolder.addBinding(settings, \"directionChangeThreshold\", { min: 0.0, max: 0.1 }); distortionFolder.addBinding(settings, \"directionSmoothing\", { min: 0.01, max: 0.2 }); const controlsFolder = pane.addFolder({ title: \"Controls\" }); controlsFolder.addBinding(settings, \"wheelSensitivity\", { min: 0.001, max: 0.05 }); controlsFolder.addBinding(settings, \"touchSensitivity\", { min: 0.001, max: 0.05 }); controlsFolder.addBinding(settings, \"momentumMultiplier\", { min: 0.5, max: 5.0 }); const effectsFolder = pane.addFolder({ title: \"Effects\" }); effectsFolder.addBinding(settings, \"rotationFactor\", { min: 0.0, max: 0.5 }); effectsFolder.addBinding(settings, \"animationSpeed\", { min: 0.1, max: 2.0 }); effectsFolder.addBinding(settings, \"textFadeStart\", { min: 0.0, max: 5.0 }); effectsFolder.addBinding(settings, \"textFadeEnd\", { min: 0.0, max: 5.0 }); effectsFolder.addBinding(settings, \"textMaxBlur\", { min: 0, max: 20 }); distortionFolder.expanded = false; controlsFolder.expanded = false; effectsFolder.expanded = false; // --- Slides and Titles Initialization --- const slides = []; let currentPosition = 0; let targetPosition = 0; let isScrolling = false; let autoScrollSpeed = 0; let lastTime = 0; let touchStartX = 0; let touchLastX = 0; let globalTime = 0; let currentDistortionFactor = 0; let targetDistortionFactor = 0; let peakVelocity = 0; let velocityHistory = [0, 0, 0, 0, 0]; let lastDeltaX = 0; let movementDirection = new THREE.Vector2(0, 0); let lastMovementInput = 0; let accumulatedMovement = 0; // White light instead of colored const pointLight = new THREE.PointLight(0xffffff, 2, 10); pointLight.position.set(0, 0, 2); scene.add(pointLight); window.addEventListener(\"mousemove\", (e) => { const mouseX = (e.clientX / window.innerWidth) * 2 - 1; const mouseY = -(e.clientY / window.innerHeight) * 2 + 1; pointLight.position.x = mouseX * 3; pointLight.position.y = mouseY * 2; }); const imageUrls = [ \"https://cdn.cosmos.so/2f49a117-05e7-4ae9-9e95-b9917f970adb?format=jpeg\", \"https://cdn.cosmos.so/7b5340f5-b4dc-4c08-8495-c507fa81480b?format=jpeg\", \"https://cdn.cosmos.so/f733585a-081e-48e7-a30e-e636446f2168?format=jpeg\", \"https://cdn.cosmos.so/47caf8a0-f456-41c5-98ea-6d0476315731?format=jpeg\", \"https://cdn.cosmos.so/f99f8445-6a19-4a9a-9de3-ac382acc1a3f?format=jpeg\" ]; const imageTitles = [ { title: \"COSMIC VOYAGE\", offset: { x: 0, y: -25 } }, { title: \"ASTRAL NEBULA\", offset: { x: 0, y: 30 } }, { title: \"STELLAR DRIFT\", offset: { x: 0, y: 20 } }, { title: \"ORBITAL PATH\", offset: { x: 0, y: -20 } }, { title: \"CELESTIAL FLOW\", offset: { x: 0, y: -15 } } ]; const titlesContainer = document.getElementById(\"titles-container\"); const titleElements = []; for (let i = 0; i < slideCount; i++) { const imageIndex = i % imagesCount; const titleInfo = imageTitles[imageIndex]; const titleEl = document.createElement(\"div\"); titleEl.className = \"slide-title\"; const titleText = document.createElement(\"h2\"); titleText.className = \"title-text\"; titleText.textContent = titleInfo.title; const titleNumber = document.createElement(\"p\"); titleNumber.className = \"title-number\"; titleNumber.textContent = `0${i + 1}`; titleEl.appendChild(titleText); titleEl.appendChild(titleNumber); titleEl.style.opacity = \"0\"; titleEl.style.filter = \"blur(0px)\"; titlesContainer.appendChild(titleEl); titleElements.push({ element: titleEl, offset: titleInfo.offset, index: i }); } const correctImageColor = (texture) => { texture.colorSpace = THREE.SRGBColorSpace; return texture; }; const createSlide = (index) => { const geometry = new THREE.PlaneGeometry(slideWidth, slideHeight, 64, 32); const material = new THREE.MeshPhysicalMaterial({ color: 0xffffff, side: THREE.DoubleSide, metalness: 0.2, roughness: 0.8, clearcoat: 0.4, clearcoatRoughness: 0.3 }); const mesh = new THREE.Mesh(geometry, material); mesh.position.x = index * (slideWidth + gap); mesh.userData = { originalVertices: [...geometry.attributes.position.array], index, time: Math.random() * 1000, waveSpeed: 0.5 + Math.random() * 0.5, waveAmplitude: 1.0, wavePhase: Math.random() * Math.PI * 2 }; const imageIndex = index % imagesCount; const imagePath = imageUrls[imageIndex]; new THREE.TextureLoader().load( imagePath, (texture) => { correctImageColor(texture); material.map = texture; material.needsUpdate = true; const imgAspect = texture.image.width / texture.image.height; const slideAspect = slideWidth / slideHeight; if (imgAspect > slideAspect) { mesh.scale.y = slideAspect / imgAspect; } else { mesh.scale.x = imgAspect / slideAspect; } }, undefined, (err) => console.warn(`Couldn't load image ${imagePath}`, err) ); scene.add(mesh); slides.push(mesh); }; for (let i = 0; i < slideCount; i++) { createSlide(i); } slides.forEach((slide) => { slide.position.x -= totalWidth / 2; slide.userData.targetX = slide.position.x; slide.userData.currentX = slide.position.x; // Slight random rotation just for style. slide.rotation.x = (Math.random() - 0.5) * 0.1; slide.rotation.y = (Math.random() - 0.5) * 0.1; }); // Updated title positions to keep text horizontally centered over each image. const updateTitlePositions = () => { titleElements.forEach((titleObj) => { const slide = slides[titleObj.index]; const { element, offset } = titleObj; // Project the slide's position into screen coords. const vector = new THREE.Vector3( slide.position.x, slide.position.y, slide.position.z ); vector.project(camera); const screenX = (vector.x * 0.5 + 0.5) * window.innerWidth; const screenY = (-vector.y * 0.5 + 0.5) * window.innerHeight; // Place text exactly horizontally centered, and apply only vertical offset. // After setting, measure text width and recenter horizontally. element.style.left = `${screenX}px`; element.style.top = `${screenY + offset.y}px`; const textRect = element.getBoundingClientRect(); element.style.left = `${screenX - textRect.width / 2}px`; // Fade + blur based on world distance from center. const distanceFromCenter = Math.abs(slide.position.x); let opacity; if (distanceFromCenter < settings.textFadeStart) { opacity = 1; } else if (distanceFromCenter > settings.textFadeEnd) { opacity = 0; } else { opacity = 1 - (distanceFromCenter - settings.textFadeStart) / (settings.textFadeEnd - settings.textFadeStart); } element.style.opacity = opacity.toFixed(2); // Compute blur: maximum at opacity=0 const blurValue = (1 - opacity) * settings.textMaxBlur; element.style.filter = `blur(${blurValue}px)`; }); }; // Enhanced distortion with smoother momentum and directional influence const updateDistortion = (mesh, distortionFactor, deltaTime) => { mesh.userData.time += deltaTime * settings.animationSpeed * mesh.userData.waveSpeed; const time = mesh.userData.time; const positionAttribute = mesh.geometry.attributes.position; const originalVertices = mesh.userData.originalVertices; // Enhanced wave amplitude based on momentum (with more gradual changes) const momentumBoost = Math.min( 1.0, peakVelocity * settings.momentumDistortionBoost ); // More gradual wave amplitude changes const targetWaveAmplitude = 1.0 + momentumBoost * settings.waveAmplitudeBoost * 3.0; mesh.userData.waveAmplitude = mesh.userData.waveAmplitude || 1.0; mesh.userData.waveAmplitude += (targetWaveAmplitude - mesh.userData.waveAmplitude) * 0.05; const effectiveDistortion = distortionFactor * settings.distortionIntensity; const gravityCenterX = Math.sin(time * 0.1) * 0.5; const gravityCenterY = Math.cos(time * 0.15) * 0.3; const gravityStrength = Math.min(2.0, Math.max(0, effectiveDistortion)) * 2.0; const dx = mesh.userData.targetX - mesh.userData.currentX; const dxAbs = Math.abs(dx); // Only update direction if movement exceeds threshold if (dxAbs > settings.directionChangeThreshold) { // Get movement sign const newDirection = dx > 0 ? -1 : 1; // Apply much smoother directional changes const directionBlend = Math.min( 1.0, settings.directionSmoothing * (1 + dxAbs * 5) ); movementDirection.x += (newDirection - movementDirection.x) * directionBlend; } // Scale direction influence by velocity to reduce effect of small movements const velocityScale = Math.min(1.0, peakVelocity * 2); const effectiveDirectionInfluence = settings.directionInfluence * velocityScale; for (let i = 0; i < positionAttribute.count; i++) { const x = originalVertices[i * 3]; const y = originalVertices[i * 3 + 1]; const z = originalVertices[i * 3 + 2]; const distX = x - gravityCenterX; const distY = y - gravityCenterY; const dist = Math.sqrt(distX * distX + distY * distY + 0.0001); const gravityFactor = Math.min(1, 1 / (1 + dist * 8)); // Smoother directional wave with velocity scaling const dirWaveX = movementDirection.x * Math.sin(dist * 5 + time) * effectiveDirectionInfluence; // Keep Y wave minimal to prevent vertical jumpiness const dirWaveY = movementDirection.y * Math.cos(dist * 5 + time) * (effectiveDirectionInfluence * 0.3); // Distortion components const pullX = distX * gravityFactor * gravityStrength * 0.5; const pullY = distY * gravityFactor * gravityStrength * 0.5; // Reduce stretch effect for small movements const stretchFactor = effectiveDistortion * 0.3 * velocityScale; const stretchX = movementDirection.x * stretchFactor * (1 - Math.min(1, Math.abs(y))); const stretchY = movementDirection.y * stretchFactor * (1 - Math.min(1, Math.abs(x))); // Enhanced wave effect that scales with momentum const waveScale = mesh.userData.waveAmplitude; const phase = mesh.userData.wavePhase; const pulse = Math.sin(time + dist * 3 + phase) * 0.05 * effectiveDistortion * waveScale; const twistAmount = effectiveDistortion * 0.1 * gravityFactor * velocityScale; const twistX = -y * twistAmount; const twistY = x * twistAmount; // Apply extra horizontal damping for small movements const horizontalDamping = settings.horizontalDistortionDamping * (1 - velocityScale * 0.3); // Apply displacement with more aggressive damping at low velocities const newX = x + Math.min( 1, Math.max(-1, (pullX + stretchX + twistX + dirWaveX) * horizontalDamping) ); const newY = y + Math.min(1, Math.max(-1, pullY + stretchY + twistY + dirWaveY)); const newZ = Math.min( 2, Math.max( -2, (gravityFactor * gravityStrength + pulse) * (1 + Math.min(5, dist)) ) ); positionAttribute.setXYZ(i, newX, newY, newZ); } positionAttribute.needsUpdate = true; mesh.geometry.computeVertexNormals(); // More gradual rotation changes const targetRotFactor = Math.min(0.2, effectiveDistortion) * settings.rotationFactor * (1 + momentumBoost * 0.5); mesh.userData.currentRotFactor = mesh.userData.currentRotFactor || 0; mesh.userData.currentRotFactor += (targetRotFactor - mesh.userData.currentRotFactor) * 0.1; const rotFactor = mesh.userData.currentRotFactor; mesh.rotation.x = Math.sin(time * 0.2) * 0.1 * rotFactor; mesh.rotation.y = Math.sin(time * 0.3 + 0.5) * 0.1 * rotFactor; mesh.rotation.z = rotFactor * 0.05 * Math.sin(time * 0.1); }; // Drag and scroll functionality. let isDragging = false; let dragStartX = 0; let dragLastX = 0; canvas.addEventListener(\"mousedown\", (e) => { isDragging = true; dragStartX = e.clientX; dragLastX = dragStartX; canvas.style.cursor = \"grabbing\"; // Removed brightness/contrast filter }); window.addEventListener(\"mousemove\", (e) => { if (!isDragging) return; const mouseX = e.clientX; const deltaX = mouseX - dragLastX; lastDeltaX = deltaX; // Store for movement direction // Accumulate small movements to avoid jerkiness accumulatedMovement += deltaX; // Only apply movement if it exceeds threshold or time has passed const now = performance.now(); const timeDelta = now - lastMovementInput; if (Math.abs(accumulatedMovement) > 1 || timeDelta > 50) { dragLastX = mouseX; const dragStrength = Math.abs(accumulatedMovement) * 0.02; targetDistortionFactor = Math.min( 1.0, targetDistortionFactor + dragStrength ); targetPosition -= accumulatedMovement * settings.touchSensitivity; accumulatedMovement = 0; lastMovementInput = now; } }); window.addEventListener(\"mouseup\", () => { if (!isDragging) return; isDragging = false; canvas.style.cursor = \"grab\"; // Removed filter reset const velocity = (dragLastX - dragStartX) * 0.005; if (Math.abs(velocity) > 0.5) { autoScrollSpeed = -velocity * settings.momentumMultiplier * 0.05; targetDistortionFactor = Math.min( 1.0, Math.abs(velocity) * 3 * settings.distortionSensitivity ); isScrolling = true; setTimeout(() => { isScrolling = false; }, 800); } }); window.addEventListener(\"mouseleave\", () => { if (isDragging) { isDragging = false; canvas.style.cursor = \"grab\"; // Removed filter reset } }); window.addEventListener(\"keydown\", (e) => { if (e.key === \"ArrowLeft\") { targetPosition += slideUnit; targetDistortionFactor = Math.min(1.0, targetDistortionFactor + 0.4); movementDirection.x = 1; // Set direction for left } else if (e.key === \"ArrowRight\") { targetPosition -= slideUnit; targetDistortionFactor = Math.min(1.0, targetDistortionFactor + 0.4); movementDirection.x = -1; // Set direction for right } }); window.addEventListener( \"wheel\", (e) => { e.preventDefault(); const wheelStrength = Math.abs(e.deltaY) * 0.001; targetDistortionFactor = Math.min( 1.0, targetDistortionFactor + wheelStrength ); targetPosition -= e.deltaY * settings.wheelSensitivity; isScrolling = true; autoScrollSpeed = Math.min(Math.abs(e.deltaY) * 0.0005, 0.05) * Math.sign(e.deltaY); movementDirection.x = Math.sign(e.deltaY) * -1; // Set direction for wheel clearTimeout(window.scrollTimeout); window.scrollTimeout = setTimeout(() => { isScrolling = false; }, 150); }, { passive: false } ); window.addEventListener( \"touchstart\", (e) => { touchStartX = e.touches[0].clientX; touchLastX = touchStartX; isScrolling = false; }, { passive: false } ); window.addEventListener( \"touchmove\", (e) => { e.preventDefault(); const touchX = e.touches[0].clientX; const deltaX = touchX - touchLastX; lastDeltaX = deltaX; // Store for movement direction // Accumulate small movements to avoid jerkiness accumulatedMovement += deltaX; // Only apply movement if it exceeds threshold or time has passed const now = performance.now(); const timeDelta = now - lastMovementInput; if (Math.abs(accumulatedMovement) > 1 || timeDelta > 50) { touchLastX = touchX; const touchStrength = Math.abs(accumulatedMovement) * 0.02; targetDistortionFactor = Math.min( 1.0, targetDistortionFactor + touchStrength ); targetPosition -= accumulatedMovement * settings.touchSensitivity; accumulatedMovement = 0; lastMovementInput = now; isScrolling = true; } }, { passive: false } ); window.addEventListener(\"touchend\", () => { const velocity = (touchLastX - touchStartX) * 0.005; if (Math.abs(velocity) > 0.5) { autoScrollSpeed = -velocity * settings.momentumMultiplier * 0.05; targetDistortionFactor = Math.min( 1.0, Math.abs(velocity) * 3 * settings.distortionSensitivity ); movementDirection.x = Math.sign(velocity) * -1; // Set direction from velocity isScrolling = true; setTimeout(() => { isScrolling = false; }, 800); } }); window.addEventListener(\"resize\", () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); updateTitlePositions(); }); // Subtle camera movement is now disabled. Set amplitude > 0 if you want drift. const updateCamera = (time) => { const amplitude = 0; // <--- camera drift disabled const frequency = 0.2; camera.position.y = Math.sin(time * frequency) * amplitude; camera.position.x = Math.cos(time * frequency * 0.7) * amplitude * 0.5; camera.lookAt(0, 0, 0); }; const animate = (time) => { requestAnimationFrame(animate); const deltaTime = lastTime ? (time - lastTime) / 1000 : 0.016; lastTime = time; globalTime += deltaTime; // Removed color change and set to constant white light pointLight.color.set(0xffffff); const prevPos = currentPosition; if (isScrolling) { targetPosition += autoScrollSpeed; const speedBasedDecay = 0.97 - Math.abs(autoScrollSpeed) * 0.5; autoScrollSpeed *= Math.max(0.92, speedBasedDecay); if (Math.abs(autoScrollSpeed) < 0.001) { autoScrollSpeed = 0; } } // Smoother position updates with adaptive smoothing // Use less smoothing for larger movements to maintain responsiveness // Use more smoothing for small movements to prevent jitter const positionDelta = Math.abs(targetPosition - currentPosition); const adaptiveSmoothing = settings.smoothing * (positionDelta < 0.1 ? 0.5 : 1.0); currentPosition += (targetPosition - currentPosition) * adaptiveSmoothing; // Compute current velocity in slides with improved tracking const currentVelocity = Math.abs(currentPosition - prevPos) / deltaTime; // More stable velocity calculation with threshold filtering // Filter out tiny movements that could cause jitter const significantVelocity = currentVelocity > 0.01 ? currentVelocity : 0; velocityHistory.push(significantVelocity); velocityHistory.shift(); // Use weighted average with more weight on recent values const weights = [0.1, 0.15, 0.2, 0.25, 0.3]; // More weight on recent values let weightSum = 0; let weightedVelocity = 0; for (let i = 0; i < velocityHistory.length; i++) { weightedVelocity += velocityHistory[i] * weights[i]; weightSum += weights[i]; } const avgVelocity = weightSum > 0 ? weightedVelocity / weightSum : 0; // Smoother peak velocity updates if (avgVelocity > peakVelocity) { // Gradual increase to peak peakVelocity += (avgVelocity - peakVelocity) * 0.3; // Boost distortion on acceleration more smoothly const accelerationBoost = Math.min(0.1, avgVelocity * 0.03); targetDistortionFactor = Math.min( settings.maxDistortion, targetDistortionFactor + accelerationBoost ); } const velocityRatio = avgVelocity / (peakVelocity + 0.001); const isDecelerating = velocityRatio < 0.7 && peakVelocity > 0.3; // More gradual peak velocity decay for smoother transitions peakVelocity *= 0.98; // Scale movement distortion by square of velocity to reduce impact of small moves const movementDistortion = Math.min( 1.0, currentVelocity * currentVelocity * 2 ); if (currentVelocity > 0.03) { // More gradual increase const blendFactor = Math.min(0.2, currentVelocity); targetDistortionFactor += (movementDistortion - targetDistortionFactor) * blendFactor; } // Different decay rates for acceleration vs deceleration if (isDecelerating) { // Slower decay when decelerating for more lasting effect targetDistortionFactor *= settings.distortionDecay * 1.01; } else if (avgVelocity < 0.1) { // Faster decay when nearly stopped targetDistortionFactor *= settings.distortionDecay * 0.9; } // Adaptive smoothing based on distortion magnitude // More smoothing for small changes to reduce jitter const distortionDelta = Math.abs( targetDistortionFactor - currentDistortionFactor ); const adaptiveDistortionSmoothing = settings.distortionSmoothing * (distortionDelta < 0.05 ? 0.5 : 1.0); currentDistortionFactor += (targetDistortionFactor - currentDistortionFactor) * adaptiveDistortionSmoothing; updateCamera(globalTime); slides.forEach((slide, i) => { let baseX = i * slideUnit - currentPosition; baseX = ((baseX % totalWidth) + totalWidth) % totalWidth; if (baseX > totalWidth / 2) { baseX -= totalWidth; } if (Math.abs(baseX - slide.userData.targetX) > slideWidth * 2) { slide.userData.currentX = baseX; } slide.userData.targetX = baseX; slide.userData.currentX += (slide.userData.targetX - slide.userData.currentX) * settings.slideLerp; if (Math.abs(slide.userData.currentX) < totalWidth / 2 + slideWidth * 1.5) { slide.position.x = slide.userData.currentX; const distanceFromCenter = Math.abs(slide.position.x); // We do a subtle Z offset so slides off-center recede slightly slide.position.z = distanceFromCenter * -0.05; updateDistortion(slide, currentDistortionFactor, deltaTime); } }); updateTitlePositions(); renderer.render(scene, camera); }; animate();",
    "id": "threejs--momentum-distortion-gallery-slider"
  },
  {
    "title": "centered-looping-slider",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.14.1/dist/gsap.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.14.1/dist/ScrollTrigger.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.14.1/dist/Draggable.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.14.1/dist/CustomEase.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.14.1/dist/InertiaPlugin.min.js\">script>\n\nStep 1: Add HTML\n\n<div data-slider-autoplay-duration=\"4\" aria-label=\"Testimonial Slider\" data-centered-slider=\"wrapper\" data-slider-autoplay=\"true\" class=\"centered-slider-group\">\n  <div class=\"container\">\n    <div class=\"centered-slider-content\">\n      <ul role=\"tablist\" class=\"centered-slider-bullet__list\">\n        <li class=\"centered-slider-bullet__item\"><button data-centered-slider=\"bullet\" role=\"tab\" aria-selected=\"false\" class=\"centered-slider-bullet\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a1ad3054186d3c6711_avatar-5.avif\"  alt=\"\">button>li>\n        <li class=\"centered-slider-bullet__item\"><button data-centered-slider=\"bullet\" role=\"tab\" aria-selected=\"false\" class=\"centered-slider-bullet\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a1af65ba866dc30020_avatar-2.avif\"  alt=\"\">button>li>\n        <li class=\"centered-slider-bullet__item\"><button data-centered-slider=\"bullet\" role=\"tab\" aria-selected=\"false\" class=\"centered-slider-bullet\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a1a74f278cb103f171_avatar-3.avif\"  alt=\"\">button>li>\n        <li class=\"centered-slider-bullet__item\"><button data-centered-slider=\"bullet\" role=\"tab\" aria-selected=\"false\" class=\"centered-slider-bullet\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a1014f1ec2c349acc8_avatar-6.avif\"  alt=\"\">button>li>\n        <li class=\"centered-slider-bullet__item\"><button data-centered-slider=\"bullet\" role=\"tab\" aria-selected=\"false\" class=\"centered-slider-bullet\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a154378639f0c3b8cb_avatar-4.avif\"  alt=\"\">button>li>\n        <li class=\"centered-slider-bullet__item\"><button data-centered-slider=\"bullet\" role=\"tab\" aria-selected=\"false\" class=\"centered-slider-bullet\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a1a49715653617490f_avatar-8.avif\"  alt=\"\">button>li>\n        <li class=\"centered-slider-bullet__item\"><button data-centered-slider=\"bullet\" role=\"tab\" aria-selected=\"false\" class=\"centered-slider-bullet\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a18cb9163202902407_avatar-1.avif\" alt=\"\">button>li>\n        <li class=\"centered-slider-bullet__item\"><button data-centered-slider=\"bullet\" role=\"tab\" aria-selected=\"false\" class=\"centered-slider-bullet\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a088b02147174966b6_avatar-7.avif\"  alt=\"\">button>li>\n      ul>\n    div>\n  div>\n  <div class=\"centered-slider-row\">\n    <div aria-label=\"slides\" data-centered-slider=\"list\" role=\"group\" class=\"centered-slider-list\">\n      <div data-centered-slider=\"slide\" class=\"centered-slider-slide\">\n        <div class=\"centered-slider-slide__inner\">  \n          <p class=\"slide-demo__description\">mukta is my new go-to resource for the best Webflow cloneables and code snippets. It saves me a lot of time and elevates my workflow. The scaling system, in particular, is a game-changerits exactly what I was missing and is now my fluid scaling solution for every project.p>\n          <div class=\"slide-demo__details\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a1ad3054186d3c6711_avatar-5.avif\" alt=\"\" class=\"slide-demo__avatar\"><span class=\"slide-demo__eyebrow\">Liam Bennettspan>div>\n        div>\n      div>\n      <div data-centered-slider=\"slide\" class=\"centered-slider-slide\">\n        <div class=\"centered-slider-slide__inner\">  \n          <p class=\"slide-demo__description\">The mukta Vault is a must-have for freelancers and agencies. It saves you a tremendous amount of time, delivers exceptional quality, and enhances creativity in your projects.p>\n          <div class=\"slide-demo__details\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a1af65ba866dc30020_avatar-2.avif\" alt=\"\" class=\"slide-demo__avatar\"><span class=\"slide-demo__eyebrow\">Sophia Carterspan>div>\n        div>\n      div>\n      <div data-centered-slider=\"slide\" class=\"centered-slider-slide\">\n        <div class=\"centered-slider-slide__inner\">  \n          <p class=\"slide-demo__description\">The creative developer's cheat code. mukta is a one-stop shop, offering everything from snippets to help you set up your site to advanced animations and interactions that elevate it to the next level. The resources are so easy to implement, and with some imagination, you can adapt them to create something unique.p>\n          <div class=\"slide-demo__details\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a1a74f278cb103f171_avatar-3.avif\" alt=\"\" class=\"slide-demo__avatar\"><span class=\"slide-demo__eyebrow\">Ethan Harperspan>div>\n        div>\n      div>\n      <div data-centered-slider=\"slide\" class=\"centered-slider-slide\">\n        <div class=\"centered-slider-slide__inner\">  \n          <p class=\"slide-demo__description\">mukta combines high-quality resources with intuitive guides, making the process of designing standout websites faster and easier, helping creatives to achieve great results in less time.p>\n          <div class=\"slide-demo__details\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a1014f1ec2c349acc8_avatar-6.avif\" alt=\"\" class=\"slide-demo__avatar\"><span class=\"slide-demo__eyebrow\">Mia Reynoldsspan>div>\n        div>\n      div>\n      <div data-centered-slider=\"slide\" class=\"centered-slider-slide\">\n        <div class=\"centered-slider-slide__inner\">  \n          <p class=\"slide-demo__description\">One of a kind platform for any developers out there. It's incredible to be able to see and learn how the pros implement their animations. If you love web animations and creative development, this platform this a no brainerjust sign up already.p>\n          <div class=\"slide-demo__details\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a154378639f0c3b8cb_avatar-4.avif\" alt=\"\" class=\"slide-demo__avatar\"><span class=\"slide-demo__eyebrow\">Noah Brooksspan>div>\n        div> \n      div>\n      <div data-centered-slider=\"slide\" class=\"centered-slider-slide\">\n        <div class=\"centered-slider-slide__inner\">  \n          <p class=\"slide-demo__description\">Flawless UIdetailed, easy to implement, and straight-up reliable. The code is clean, well-explained, and ready to drop into Webflow without a hitch. You can tell its built by pros. Love it and definitely using this on most of my projects. mukta is the real deal.p>\n          <div class=\"slide-demo__details\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a1a49715653617490f_avatar-8.avif\" alt=\"\" class=\"slide-demo__avatar\"><span class=\"slide-demo__eyebrow\">Olivia Porterspan>div>\n        div>\n      div>\n      <div data-centered-slider=\"slide\" class=\"centered-slider-slide\">\n        <div class=\"centered-slider-slide__inner\">   \n          <p class=\"slide-demo__description\">mukta is full of awesome (and easy to use) interactions that save so much time. Theyre visually powerful but also robust, and the best thing is, its only going to get better as more even resources get added! Oh and it doesnt hurt that the dashboard looks sick too.p>\n          <div class=\"slide-demo__details\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a18cb9163202902407_avatar-1.avif\" alt=\"\" class=\"slide-demo__avatar\"><span class=\"slide-demo__eyebrow\">Lucas Mitchellspan>div>\n        div> \n      div>\n      <div data-centered-slider=\"slide\" class=\"centered-slider-slide\">\n        <div class=\"centered-slider-slide__inner\">  \n          <p class=\"slide-demo__description\">It's nice to get access to some creative dev best kept secrets - they're a great a source of inspiration for animations and interactions. Already found out some tricks for some issues that were giving me headaches before! Love how it explains the implementation rather than blindly copy-pasting it, making it much easier to customize.p>\n          <div class=\"slide-demo__details\"><img src=\"https://cdn.prod.website-files.com/67eeaec872efc86f0f0af614/67eec8a088b02147174966b6_avatar-7.avif\" alt=\"\" class=\"slide-demo__avatar\"><span class=\"slide-demo__eyebrow\">Ava Thompsonspan>div>\n        div>\n      div>\n    div>\n  div>\n  <div class=\"container\">\n    <div class=\"centered-slider-content\">\n      <div class=\"centered-slider-buttons\">\n        <button aria-label=\"previous slide\" data-centered-slider=\"prev-button\" class=\"centered-slider-button is--prev\">\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" viewbox=\"0 0 24 24\" fill=\"none\" class=\"slider-button-arrow\">\n            <path d=\"M14 19L21 12L14 5\" stroke=\"currentColor\" stroke-miterlimit=\"10\">path>\n            <path d=\"M21 12H2\" stroke=\"currentColor\" stroke-miterlimit=\"10\">path>\n          svg>\n        button>\n        <button aria-label=\"next slide\" data-centered-slider=\"next-button\" class=\"centered-slider-button\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" viewbox=\"0 0 24 24\" fill=\"none\" class=\"slider-button-arrow\">\n            <path d=\"M14 19L21 12L14 5\" stroke=\"currentColor\" stroke-miterlimit=\"10\">path>\n            <path d=\"M21 12H2\" stroke=\"currentColor\" stroke-miterlimit=\"10\">path>\n          svg>\n        button>\n      div>\n    div>\n  div>\ndiv>\n\nStep 2: Add CSS\n\n.centered-slider-row {\n  width: 100%;\n  margin-top: 2em;\n  margin-bottom: 4em;\n  padding-top: 1em;\n  padding-bottom: 1em;\n  display: flex;\n  position: relative;\n  overflow: clip;\n}\n\n.centered-slider-list {\n  flex-flow: row;\n  justify-content: flex-start;\n  align-items: center;\n  width: 100%;\n  display: flex;\n}\n\n.centered-slider-slide {\n  flex: none;\n  padding: 0.75em;\n  transition: opacity .25s cubic-bezier(.77, 0, .175, 1);\n  position: relative;\n}\n\n.centered-slider-slide__inner {\n  position: relative;\n  display: flex;\n  width: 21em;\n  padding-top: 1.25em;\n  padding-right: 1.25em;\n  padding-bottom: 1.25em;\n  padding-left: 1.25em;\n  flex-direction: column;\n  justify-content: flex-start;\n  flex-wrap: nowrap;\n  align-items: flex-start;\n  grid-column-gap: 3em;\n  grid-row-gap: 3em;\n  border: 1px solid #efeeec1a;\n  background-color: rgba(239, 238, 236, 0.1);\n}\n\n.centered-slider-row:has( .centered-slider-slide.active) .centered-slider-slide:not(.active){\n  opacity: 0.45;\n}\n\n/* Little (orange) corners on each slide */\n/* https://css-tip.com/corner-only-border-image/ */\n.centered-slider-slide::after {\n  --size: 1em; /* corner size */\n  --width: 1px;  /* border width */\n  --gap: 0.125em; /* gap */\n  --color: #FF4C24;\n  content: '';\n  position: absolute;\n  inset: calc(var(--gap) * -1);\n  z-index: 1;\n  opacity: 0;\n  padding: calc(var(--gap) + var(--width));\n  outline: var(--width) solid var(--color);\n  outline-offset: calc(var(--gap)/-1);\n  mask:\n    conic-gradient(at var(--size) var(--size),#0000 75%,#000 0)\n    0 0/calc(100% - var(--size)) calc(100% - var(--size)),\n    linear-gradient(#000 0 0) content-box;\n  transition: all 0.4s cubic-bezier(0.65, 0.05, 0, 1);\n}\n.centered-slider-slide.active::after {\n  outline-offset: calc(-1*var(--width));\n  opacity: 1;\n}\n\n.slide-demo__details {\n  grid-column-gap: .75em;\n  grid-row-gap: .75em;\n  justify-content: flex-start;\n  align-items: center;\n  display: flex;\n}\n\n.slide-demo__avatar {\n  border-radius: 100em;\n  width: 2.5em;\n  height: 2.5em;\n  overflow: hidden;\n}\n\n.slide-demo__eyebrow {\n  text-transform: uppercase;\n  font-family: RM Mono, Arial, sans-serif;\n  font-size: .75em;\n  line-height: 1.2;\n}\n\n.centered-slider-content {\n  justify-content: center;\n  align-items: center;\n  margin-left: auto;\n  margin-right: auto;\n  display: flex;\n}\n\n.centered-slider-bullet__list {\n  grid-column-gap: .75em;\n  grid-row-gap: .75em;\n  flex-flow: wrap;\n  justify-content: center;\n  align-items: center;\n  margin-bottom: 0;\n  padding: 0;\n  list-style: none;\n  display: flex;\n}\n\n.centered-slider-bullet {\n  background-color: #0000;\n  border-radius: 100em;\n  width: 2em;\n  height: 2em;\n  padding: 0;\n  position: relative;\n}\n\n.centered-slider-bullet:focus {\n  border: none;\n  outline: none;\n}\n\n.centered-slider-bullet::after{\n  content: '';\n  position: absolute;\n  inset: 2px;\n  border-radius: 100em;\n  z-index: -1;\n  border: 1px solid #FF4C24;\n  transition: all 0.5s cubic-bezier(0.65, 0.05, 0, 1);\n}\n\n.centered-slider-bullet:hover::after,\n.centered-slider-bullet.active::after,\n.centered-slider-bullet:focus::after{\n  inset: -5px;\n}\n\n.centered-slider-buttons {\n  grid-column-gap: 1em;\n  grid-row-gap: 1em;\n  justify-content: center;\n  align-items: center;\n  display: flex;\n}\n\n.centered-slider-button {\n  background-color: #efeeec1a;\n  border: 1px solid #efeeec1a;\n  border-radius: .25em;\n  justify-content: center;\n  align-items: center;\n  width: 3em;\n  height: 3em;\n  padding: 0;\n  transition: border-color .2s, background-color .2s;\n  display: flex;\n}\n\n.centered-slider-button:hover {\n  background-color: #efeeec33;\n  border-color: #efeeec40;\n}\n\n.centered-slider-button.is--prev {\n  transform: rotate(-180deg);\n}\n\n.slider-button-arrow {\n  justify-content: center;\n  align-items: center;\n  width: 1.25em;\n}\n\n@media screen and (max-width: 479px) {\n  .centered-slider-slide {\n    width: 85vw;\n  }\n  \n  .centered-slider-slide__inner {\n    width: 100%;\n  }\n}\n\nStep 2: Add custom Javascript\n\ngsap.registerPlugin(CustomEase, ScrollTrigger, Draggable, InertiaPlugin)\n\nCustomEase.create(\"mukta-ease\", \"0.625, 0.05, 0, 1\")\n\nfunction initSliders() {\n  const sliderWrappers = gsap.utils.toArray(document.querySelectorAll('[data-centered-slider=\"wrapper\"]'));\n\n  sliderWrappers.forEach((sliderWrapper) => {\n    const slides = gsap.utils.toArray(sliderWrapper.querySelectorAll('[data-centered-slider=\"slide\"]'));\n    const bullets = gsap.utils.toArray(sliderWrapper.querySelectorAll('[data-centered-slider=\"bullet\"]'));\n    const prevButton = sliderWrapper.querySelector('[data-centered-slider=\"prev-button\"]');\n    const nextButton = sliderWrapper.querySelector('[data-centered-slider=\"next-button\"]');\n\n    let activeElement;\n    let activeBullet;\n    let currentIndex = 0;\n    let autoplay;\n\n    // Autoplay is now enabled/disabled via a boolean attribute.\n    const autoplayEnabled = sliderWrapper.getAttribute('data-slider-autoplay') === 'true';\n    \n    // If enabled, get the autoplay duration (in seconds) from the separate attribute.\n    const autoplayDuration = autoplayEnabled ? parseFloat(sliderWrapper.getAttribute('data-slider-autoplay-duration')) || 0 : 0;\n\n    // Dynamically assign unique IDs to slides\n    slides.forEach((slide, i) => {\n      slide.setAttribute(\"id\", `slide-${i}`);\n    });\n    \n    // Set ARIA attributes on bullets if they exist\n    if (bullets && bullets.length > 0) {\n      bullets.forEach((bullet, i) => {\n        bullet.setAttribute(\"aria-controls\", `slide-${i}`);\n        bullet.setAttribute(\"aria-selected\", i === currentIndex ? \"true\" : \"false\");\n      });\n    }\n\n    const loop = horizontalLoop(slides, {\n      paused: true,\n      draggable: true,\n      center: true,\n      onChange: (element, index) => {\n        currentIndex = index;\n        \n        if (activeElement) activeElement.classList.remove(\"active\");\n        element.classList.add(\"active\");\n        activeElement = element;\n\n        if (bullets && bullets.length > 0) {\n          if (activeBullet) activeBullet.classList.remove(\"active\");\n          if (bullets[index]) {\n            bullets[index].classList.add(\"active\");\n            activeBullet = bullets[index];\n          }\n          bullets.forEach((bullet, i) => {\n            bullet.setAttribute(\"aria-selected\", i === index ? \"true\" : \"false\");\n          });\n        }\n        \n      }\n    });\n    \n    // On initialization, center the slider\n    loop.toIndex(2, { duration: 0.01 });\n\n    function startAutoplay() {\n      if (autoplayDuration > 0 && !autoplay) {\n        const repeat = () => {\n          loop.next({ ease: \"mukta-ease\", duration: 0.725 });\n          autoplay = gsap.delayedCall(autoplayDuration, repeat);\n        };\n        autoplay = gsap.delayedCall(autoplayDuration, repeat);\n      }\n    }\n\n    function stopAutoplay() {\n      if (autoplay) {\n        autoplay.kill();\n        autoplay = null;\n      }\n    }\n\n    // Start/stop autoplay based on viewport visibility via ScrollTrigger\n    ScrollTrigger.create({\n      trigger: sliderWrapper,\n      start: \"top bottom\",\n      end: \"bottom top\",\n      onEnter: startAutoplay,\n      onLeave: stopAutoplay,\n      onEnterBack: startAutoplay,\n      onLeaveBack: stopAutoplay\n    });\n\n    // Pause autoplay on mouse hover over the slider\n    sliderWrapper.addEventListener(\"mouseenter\", stopAutoplay);\n    sliderWrapper.addEventListener(\"mouseleave\", () => {\n      if (ScrollTrigger.isInViewport(sliderWrapper)) startAutoplay();\n    });\n\n    // Slide click event for direct navigation\n    slides.forEach((slide, i) => {\n      slide.addEventListener(\"click\", () => {\n        loop.toIndex(i, { ease: \"mukta-ease\", duration: 0.725 });\n      });\n    });\n\n    // Bullets click event for direct navigation (if available)\n    if (bullets && bullets.length > 0) {\n      bullets.forEach((bullet, i) => {\n        bullet.addEventListener(\"click\", () => {\n          loop.toIndex(i, { ease: \"mukta-ease\", duration: 0.725 });\n          if (activeBullet) activeBullet.classList.remove(\"active\");\n          bullet.classList.add(\"active\");\n          activeBullet = bullet;\n          bullets.forEach((b, j) => {\n            b.setAttribute(\"aria-selected\", j === i ? \"true\" : \"false\");\n          });\n        });\n      });\n    }\n\n    // Prev/Next button listeners (if the buttons exist)\n    if (prevButton) {\n      prevButton.addEventListener(\"click\", () => {\n        let newIndex = currentIndex - 1;\n        if (newIndex < 0) newIndex = slides.length - 1;\n        loop.toIndex(newIndex, { ease: \"mukta-ease\", duration: 0.725 });\n      });\n    }\n\n    if (nextButton) {\n      nextButton.addEventListener(\"click\", () => {\n        let newIndex = currentIndex + 1;\n        if (newIndex >= slides.length) newIndex = 0;\n        loop.toIndex(newIndex, { ease: \"mukta-ease\", duration: 0.725 });\n      });\n    }\n    \n  });\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", () =>{\n  initSliders()\n})\n\n// GSAP Helper function to create a looping slider\n// Read more: https://gsap.com/docs/v3/HelperFunctions/helpers/seamlessLoop\nfunction horizontalLoop(items, config) {\n  let timeline;\n  items = gsap.utils.toArray(items);\n  config = config || {};\n  gsap.context(() => { \n    let onChange = config.onChange,\n      lastIndex = 0,\n      tl = gsap.timeline({repeat: config.repeat, onUpdate: onChange && function() {\n          let i = tl.closestIndex();\n          if (lastIndex !== i) {\n            lastIndex = i;\n            onChange(items[i], i);\n          }\n        }, paused: config.paused, defaults: {ease: \"none\"}, onReverseComplete: () => tl.totalTime(tl.rawTime() + tl.duration() * 100)}),\n      length = items.length,\n      startX = items[0].offsetLeft,\n      times = [],\n      widths = [],\n      spaceBefore = [],\n      xPercents = [],\n      curIndex = 0,\n      indexIsDirty = false,\n      center = config.center,\n      pixelsPerSecond = (config.speed || 1) * 100,\n      snap = config.snap === false ? v => v : gsap.utils.snap(config.snap || 1),\n      timeOffset = 0,\n      container = center === true ? items[0].parentNode : gsap.utils.toArray(center)[0] || items[0].parentNode,\n      totalWidth,\n      getTotalWidth = () => items[length-1].offsetLeft + xPercents[length-1] / 100 * widths[length-1] - startX + spaceBefore[0] + items[length-1].offsetWidth * gsap.getProperty(items[length-1], \"scaleX\") + (parseFloat(config.paddingRight) || 0),\n      populateWidths = () => {\n        let b1 = container.getBoundingClientRect(), b2;\n        items.forEach((el, i) => {\n          widths[i] = parseFloat(gsap.getProperty(el, \"width\", \"px\"));\n          xPercents[i] = snap(parseFloat(gsap.getProperty(el, \"x\", \"px\")) / widths[i] * 100 + gsap.getProperty(el, \"xPercent\"));\n          b2 = el.getBoundingClientRect();\n          spaceBefore[i] = b2.left - (i ? b1.right : b1.left);\n          b1 = b2;\n        });\n        gsap.set(items, {\n          xPercent: i => xPercents[i]\n        });\n        totalWidth = getTotalWidth();\n      },\n      timeWrap,\n      populateOffsets = () => {\n        timeOffset = center ? tl.duration() * (container.offsetWidth / 2) / totalWidth : 0;\n        center && times.forEach((t, i) => {\n          times[i] = timeWrap(tl.labels[\"label\" + i] + tl.duration() * widths[i] / 2 / totalWidth - timeOffset);\n        });\n      },\n      getClosest = (values, value, wrap) => {\n        let i = values.length,\n          closest = 1e10,\n          index = 0, d;\n        while (i--) {\n          d = Math.abs(values[i] - value);\n          if (d > wrap / 2) {\n            d = wrap - d;\n          }\n          if (d < closest) {\n            closest = d;\n            index = i;\n          }\n        }\n        return index;\n      },\n      populateTimeline = () => {\n        let i, item, curX, distanceToStart, distanceToLoop;\n        tl.clear();\n        for (i = 0; i < length; i++) {\n          item = items[i];\n          curX = xPercents[i] / 100 * widths[i];\n          distanceToStart = item.offsetLeft + curX - startX + spaceBefore[0];\n          distanceToLoop = distanceToStart + widths[i] * gsap.getProperty(item, \"scaleX\");\n          tl.to(item, {xPercent: snap((curX - distanceToLoop) / widths[i] * 100), duration: distanceToLoop / pixelsPerSecond}, 0)\n            .fromTo(item, {xPercent: snap((curX - distanceToLoop + totalWidth) / widths[i] * 100)}, {xPercent: xPercents[i], duration: (curX - distanceToLoop + totalWidth - curX) / pixelsPerSecond, immediateRender: false}, distanceToLoop / pixelsPerSecond)\n            .add(\"label\" + i, distanceToStart / pixelsPerSecond);\n          times[i] = distanceToStart / pixelsPerSecond;\n        }\n        timeWrap = gsap.utils.wrap(0, tl.duration());\n      },\n      refresh = (deep) => {\n        let progress = tl.progress();\n        tl.progress(0, true);\n        populateWidths();\n        deep && populateTimeline();\n        populateOffsets();\n        deep && tl.draggable ? tl.time(times[curIndex], true) : tl.progress(progress, true);\n      },\n      onResize = () => refresh(true),\n      proxy;\n    gsap.set(items, {x: 0});\n    populateWidths();\n    populateTimeline();\n    populateOffsets();\n    window.addEventListener(\"resize\", onResize);\n    function toIndex(index, vars) {\n      vars = vars || {};\n      (Math.abs(index - curIndex) > length / 2) && (index += index > curIndex ? -length : length); // always go in the shortest direction\n      let newIndex = gsap.utils.wrap(0, length, index),\n        time = times[newIndex];\n      if (time > tl.time() !== index > curIndex && index !== curIndex) { // if we're wrapping the timeline's playhead, make the proper adjustments\n        time += tl.duration() * (index > curIndex ? 1 : -1);\n      }\n      if (time < 0 || time > tl.duration()) {\n        vars.modifiers = {time: timeWrap};\n      }\n      curIndex = newIndex;\n      vars.overwrite = true;\n      gsap.killTweensOf(proxy);    \n      return vars.duration === 0 ? tl.time(timeWrap(time)) : tl.tweenTo(time, vars);\n    }\n    tl.toIndex = (index, vars) => toIndex(index, vars);\n    tl.closestIndex = setCurrent => {\n      let index = getClosest(times, tl.time(), tl.duration());\n      if (setCurrent) {\n        curIndex = index;\n        indexIsDirty = false;\n      }\n      return index;\n    };\n    tl.current = () => indexIsDirty ? tl.closestIndex(true) : curIndex;\n    tl.next = vars => toIndex(tl.current()+1, vars);\n    tl.previous = vars => toIndex(tl.current()-1, vars);\n    tl.times = times;\n    tl.progress(1, true).progress(0, true); // pre-render for performance\n    if (config.reversed) {\n      tl.vars.onReverseComplete();\n      tl.reverse();\n    }\n    if (config.draggable && typeof(Draggable) === \"function\") {\n      proxy = document.createElement(\"div\")\n      let wrap = gsap.utils.wrap(0, 1),\n        ratio, startProgress, draggable, dragSnap, lastSnap, initChangeX, wasPlaying,\n        align = () => tl.progress(wrap(startProgress + (draggable.startX - draggable.x) * ratio)),\n        syncIndex = () => tl.closestIndex(true);\n      typeof(InertiaPlugin) === \"undefined\" && console.warn(\"InertiaPlugin required for momentum-based scrolling and snapping. https://greensock.com/club\");\n      draggable = Draggable.create(proxy, {\n        trigger: items[0].parentNode,\n        type: \"x\",\n        onPressInit() {\n          let x = this.x;\n          gsap.killTweensOf(tl);\n          wasPlaying = !tl.paused();\n          tl.pause();\n          startProgress = tl.progress();\n          refresh();\n          ratio = 1 / totalWidth;\n          initChangeX = (startProgress / -ratio) - x;\n          gsap.set(proxy, {x: startProgress / -ratio});\n        },\n        onDrag: align,\n        onThrowUpdate: align,\n        overshootTolerance: 0,\n        inertia: true,\n        snap(value) {\n          if (Math.abs(startProgress / -ratio - this.x) < 10) {\n            return lastSnap + initChangeX\n          }\n          let time = -(value * ratio) * tl.duration(),\n            wrappedTime = timeWrap(time),\n            snapTime = times[getClosest(times, wrappedTime, tl.duration())],\n            dif = snapTime - wrappedTime;\n          Math.abs(dif) > tl.duration() / 2 && (dif += dif < 0 ? tl.duration() : -tl.duration());\n          lastSnap = (time + dif) / tl.duration() / -ratio;\n          return lastSnap;\n        },\n        onRelease() {\n          syncIndex();\n          draggable.isThrowing && (indexIsDirty = true);\n        },\n        onThrowComplete: () => {\n          syncIndex();\n          wasPlaying && tl.play();\n        }\n      })[0];\n      tl.draggable = draggable;\n    }\n    tl.closestIndex(true);\n    lastIndex = curIndex;\n    onChange && onChange(items[curIndex], curIndex);\n    timeline = tl;\n    return () => window.removeEventListener(\"resize\", onResize); \n  });\n  return timeline;\n  \n}\n\nImplementation\n\nThis Slider leverages GSAP Draggable, Intertia and ScrollTrigger to create a responsive slider with support for click, drag, and autoplay interactions. Heres how you can implement it:\n\n\nHTML Structure\n\nWrapper:\nUse a container with the attribute data-centered-slider=\"wrapper\". Autoplay is optional, and is added as follows:\n<div data-centered-slider=\"wrapper\" data-slider-autoplay=\"true\" data-slider-autoplay-duration=\"4\">\nSlides:\nEach slide must have data-centered-slider=\"slide\". Unique IDs are dynamically assigned (e.g., slide-0, slide-1, ).\n\nBullets:\nNavigation bullets are buttons marked with data-centered-slider=\"bullet\". They include ARIA attributes like aria-controls and aria-selected. In our example we've set larger thumbnails, but these could of course also be more traditional bullet point navigation items.\n\nPrev/Next Controls:\nAdd buttons with data-centered-slider=\"prev-button\" and data-centered-slider=\"next-button\", and provide aria-label values.\n\nJavaScript Functionality\n\nInitialization:\nOn DOMContentLoaded, the slider initializes by assigning unique IDs to slides and setting ARIA attributes on bullets.\n\nAnimation & Interaction:\n- Uses GSAPs horizontalLoop with a custom ease to animate transitions.\n- Users can navigate by clicking slides or bullets, using prev/next buttons, or dragging slides (with GSAP Draggable and InertiaPlugin).\n- When data-slider-autoplay is \"true\", the slider automatically advances using a duration defined in data-slider-autoplay-duration (in seconds).\nScrollTrigger pauses autoplay when the slider is off-screen or hovered, resuming when visible.",
    "id": "centered-looping-slider"
  },
  {
    "title": "[gsap/component]  Full Screen Scroll Slideshow with Sound FX",
    "description": "",
    "code": "index.html: <div class=\"loading-overlay\" id=\"loading-overlay\">Loading <span class=\"loading-counter\" id=\"loading-counter\">[00]</span></div> <div class=\"debug-info\" id=\"debug-info\">Current Section: 0</div> <div class=\"scroll-container\" id=\"scroll-container\"> <div class=\"fixed-section\" id=\"fixed-section\"> <div class=\"fixed-container\" id=\"fixed-container\"> <div class=\"background-container\" id=\"background-container\"> <img src=\"https://assets.codepen.io/7558/flame-glow-blur-001.jpg\" alt=\"Background 1\" class=\"background-image active\" id=\"background-1\"> <img src=\"https://assets.codepen.io/7558/flame-glow-blur-002.jpg\" alt=\"Background 2\" class=\"background-image\" id=\"background-2\"> <img src=\"https://assets.codepen.io/7558/flame-glow-blur-003.jpg\" alt=\"Background 3\" class=\"background-image\" id=\"background-3\"> <img src=\"https://assets.codepen.io/7558/flame-glow-blur-004.jpg\" alt=\"Background 4\" class=\"background-image\" id=\"background-4\"> <img src=\"https://assets.codepen.io/7558/flame-glow-blur-005.jpg\" alt=\"Background 5\" class=\"background-image\" id=\"background-5\"> <img src=\"https://assets.codepen.io/7558/flame-glow-blur-006.jpg\" alt=\"Background 6\" class=\"background-image\" id=\"background-6\"> <img src=\"https://assets.codepen.io/7558/flame-glow-blur-007.jpg\" alt=\"Background 7\" class=\"background-image\" id=\"background-7\"> <img src=\"https://assets.codepen.io/7558/flame-glow-blur-008.jpg\" alt=\"Background 8\" class=\"background-image\" id=\"background-8\"> <img src=\"https://assets.codepen.io/7558/flame-glow-blur-009.jpg\" alt=\"Background 9\" class=\"background-image\" id=\"background-9\"> <img src=\"https://assets.codepen.io/7558/flame-glow-blur-010.jpg\" alt=\"Background 10\" class=\"background-image\" id=\"background-10\"> </div> <div class=\"grid-container\"> <div class=\"header\"> <div class=\"header-row\">The Creative</div> <div class=\"header-row\">Process</div> </div> <div class=\"content\"> <div class=\"left-column\" id=\"left-column\"> <div class=\"artist active\" id=\"artist-0\" data-index=\"0\">Silence</div> <div class=\"artist\" id=\"artist-1\" data-index=\"1\">Meditation</div> <div class=\"artist\" id=\"artist-2\" data-index=\"2\">Intuition</div> <div class=\"artist\" id=\"artist-3\" data-index=\"3\">Authenticity</div> <div class=\"artist\" id=\"artist-4\" data-index=\"4\">Presence</div> <div class=\"artist\" id=\"artist-5\" data-index=\"5\">Listening</div> <div class=\"artist\" id=\"artist-6\" data-index=\"6\">Curiosity</div> <div class=\"artist\" id=\"artist-7\" data-index=\"7\">Patience</div> <div class=\"artist\" id=\"artist-8\" data-index=\"8\">Surrender</div> <div class=\"artist\" id=\"artist-9\" data-index=\"9\">Simplicity</div> </div> <div class=\"featured\" id=\"featured\"> <div class=\"featured-content active\" id=\"featured-0\" data-index=\"0\"> <h3>Creative Elements</h3> </div> <div class=\"featured-content\" id=\"featured-1\" data-index=\"1\"> <h3>Inner Stillness</h3> </div> <div class=\"featured-content\" id=\"featured-2\" data-index=\"2\"> <h3>Deep Knowing</h3> </div> <div class=\"featured-content\" id=\"featured-3\" data-index=\"3\"> <h3>True Expression</h3> </div> <div class=\"featured-content\" id=\"featured-4\" data-index=\"4\"> <h3>Now Moment</h3> </div> <div class=\"featured-content\" id=\"featured-5\" data-index=\"5\"> <h3>Deep Attention</h3> </div> <div class=\"featured-content\" id=\"featured-6\" data-index=\"6\"> <h3>Open Exploration</h3> </div> <div class=\"featured-content\" id=\"featured-7\" data-index=\"7\"> <h3>Calm Waiting</h3> </div> <div class=\"featured-content\" id=\"featured-8\" data-index=\"8\"> <h3>Let Go Control</h3> </div> <div class=\"featured-content\" id=\"featured-9\" data-index=\"9\"> <h3>Pure Essence</h3> </div> </div> <div class=\"right-column\" id=\"right-column\"> <div class=\"category active\" id=\"category-0\" data-index=\"0\">Reduction</div> <div class=\"category\" id=\"category-1\" data-index=\"1\">Essence</div> <div class=\"category\" id=\"category-2\" data-index=\"2\">Space</div> <div class=\"category\" id=\"category-3\" data-index=\"3\">Resonance</div> <div class=\"category\" id=\"category-4\" data-index=\"4\">Truth</div> <div class=\"category\" id=\"category-5\" data-index=\"5\">Feeling</div> <div class=\"category\" id=\"category-6\" data-index=\"6\">Clarity</div> <div class=\"category\" id=\"category-7\" data-index=\"7\">Emptiness</div> <div class=\"category\" id=\"category-8\" data-index=\"8\">Awareness</div> <div class=\"category\" id=\"category-9\" data-index=\"9\">Minimalism</div> </div> </div> <div class=\"footer\" id=\"footer\"> <div class=\"header-row\">Beyond</div> <div class=\"header-row\">Thinking</div> <div class=\"progress-indicator\"> <div class=\"progress-numbers\"> <span id=\"current-section\">01</span> <span id=\"total-sections\">10</span> </div> <div class=\"progress-fill\" id=\"progress-fill\"></div> </div> </div> </div> </div> </div> <div class=\"end-section\"> <p class=\"fin\">fin</p> </div> </div>\nstyle.css: @import url(\"https://fonts.cdnfonts.com/css/pp-neue-montreal\"); :root { --font-primary: \"PP Neue Montreal\", sans-serif; --text-color: rgba(245, 245, 245, 0.9); } * { margin: 0; padding: 0; box-sizing: border-box; } html { overflow-x: hidden; width: 100%; background-color: #fff; } body { font-family: var(--font-primary); background-color: #fff; color: #000; font-weight: 500; letter-spacing: -0.02em; text-transform: uppercase; overflow-x: hidden; width: 100%; } .scroll-container { position: relative; background-color: #fff; } .end-section { font-size: 2rem; height: 100vh; position: relative; background-color: #fff; display: flex; align-items: center; justify-content: center; } .fin { transform: rotate(90deg); position: sticky; top: 50vh; color: #000; } .fixed-section { height: 1100vh; position: relative; background-color: #fff; } .fixed-container { position: sticky; top: 0; left: 0; width: 100%; height: 100vh; overflow: hidden; will-change: transform, height; transform-origin: top center; background-color: #fff; } .grid-container { display: grid; grid-template-columns: repeat(12, 1fr); gap: 1rem; padding: 0 2rem; height: 100%; position: relative; z-index: 2; } .background-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; overflow: hidden; background-color: #000; } .background-image { position: absolute; top: -10%; left: 0; width: 100%; height: 120%; object-fit: cover; opacity: 0; filter: brightness(0.8); will-change: transform; transform-origin: center center; } .background-image.active { opacity: 1; z-index: 2; } .background-image.previous { opacity: 1; z-index: 1; } .header { grid-column: 1 / 13; align-self: start; padding-top: 5vh; font-size: 10vw; line-height: 0.8; text-align: center; color: var(--text-color); will-change: transform, filter, opacity; } .header-row { display: block; } .footer { grid-column: 1 / 13; align-self: end; padding-bottom: 5vh; font-size: 10vw; line-height: 0.8; text-align: center; color: var(--text-color); will-change: transform, filter, opacity; transition: filter 0.5s ease, opacity 0.5s ease; } .progress-indicator { width: 160px; height: 1px; margin: 2vh auto 0; position: relative; background-color: rgba(245, 245, 245, 0.3); } .progress-fill { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background-color: var(--text-color); transition: width 0.3s cubic-bezier(0.65, 0, 0.35, 1); } .progress-numbers { position: absolute; top: 0; left: 0; right: 0; display: flex; justify-content: space-between; font-size: 0.7rem; color: var(--text-color); font-family: var(--font-primary); letter-spacing: -0.02em; transform: translateY(-50%); margin: 0 -25px; } .footer.blur, .left-column.blur, .right-column.blur { filter: blur(8px); opacity: 0.3; transition: filter 0.8s ease, opacity 0.8s ease; } .content { grid-column: 1 / 13; display: flex; justify-content: space-between; align-items: center; width: 100%; position: absolute; top: 50%; left: 0; transform: translateY(-50%); padding: 0 2rem; will-change: transform; } .left-column { width: 40%; display: flex; flex-direction: column; gap: 0.25rem; text-align: left; will-change: filter, opacity; transition: filter 0.5s ease, opacity 0.5s ease; } .right-column { width: 40%; display: flex; flex-direction: column; gap: 0.25rem; text-align: right; will-change: filter, opacity; transition: filter 0.5s ease, opacity 0.5s ease; } .featured { width: 20%; display: flex; justify-content: center; align-items: center; text-align: center; font-size: 1.5vw; position: relative; height: 10vh; overflow: hidden; will-change: filter, opacity; transition: filter 0.5s ease, opacity 0.5s ease; } .featured.blur { filter: blur(8px); opacity: 0.3; transition: filter 0.8s ease, opacity 0.8s ease; } .featured-content { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; opacity: 0; visibility: hidden; } .featured-content.active { opacity: 1; visibility: visible; } .featured-content h3 { white-space: nowrap; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; margin: 0; font-weight: 500; color: var(--text-color); } .word-mask { display: inline-block; overflow: hidden; vertical-align: middle; } .split-word { display: inline-block; vertical-align: middle; } .artist { opacity: 0; transform: translateY(20px); transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1); color: var(--text-color); cursor: pointer; position: relative; padding-left: 0; } .category { opacity: 0; transform: translateY(20px); transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1); color: var(--text-color); cursor: pointer; position: relative; padding-right: 0; } .artist:hover, .category:hover { opacity: 1 !important; } .artist.loaded { opacity: 0.3; transform: translateY(0); } .category.loaded { opacity: 0.3; transform: translateY(0); } .artist.active { opacity: 1; transform: translateX(10px); padding-left: 15px; transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1); } .artist.active::before { content: \"\"; position: absolute; left: 0; top: 50%; transform: translateY(-50%); width: 4px; height: 4px; background-color: var(--text-color); border-radius: 50%; } .category.active { opacity: 1; transform: translateX(-10px); padding-right: 15px; transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1); } .category.active::after { content: \"\"; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 4px; height: 4px; background-color: var(--text-color); border-radius: 50%; } .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #fff; display: flex; justify-content: center; align-items: center; z-index: 9999; color: #000; font-size: 1.5rem; font-family: var(--font-primary); text-transform: uppercase; letter-spacing: -0.02em; } .loading-counter { margin-left: 0.5rem; } .debug-info { position: fixed; bottom: 10px; right: 10px; background: rgba(255, 255, 255, 0.7); color: #000; padding: 10px; font-size: 12px; z-index: 9000; font-family: monospace; display: none; } /* Sound toggle button */ .sound-toggle { position: fixed; top: 20px; right: 20px; width: 40px; height: 40px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 1000; transition: all 0.3s ease; backdrop-filter: blur(10px); } .sound-toggle:hover { background: rgba(255, 255, 255, 0.15); border-color: rgba(255, 255, 255, 0.3); transform: scale(1.05); } .sound-toggle.disabled { background: rgba(255, 255, 255, 0.05); border-color: rgba(255, 255, 255, 0.1); } .sound-toggle.disabled:hover { background: rgba(255, 255, 255, 0.08); } /* Sound dots container */ .sound-dots { position: relative; width: 4px; height: 4px; } /* Base dot */ .sound-dot { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 4px; height: 4px; background: white; border-radius: 50%; opacity: 1; } /* Animated expanding dots */ .sound-dot.animated { animation: expandDot 2s ease-out infinite; } .sound-dot.animated:nth-child(2) { animation-delay: 0.5s; } .sound-dot.animated:nth-child(3) { animation-delay: 1s; } .sound-dot.animated:nth-child(4) { animation-delay: 1.5s; } @keyframes expandDot { 0% { width: 4px; height: 4px; opacity: 1; } 100% { width: 20px; height: 20px; opacity: 0; } } /* Disabled state - no animation */ .sound-toggle.disabled .sound-dot.animated { animation: none; width: 4px; height: 4px; opacity: 0.3; } @media (max-width: 768px) { .content { flex-direction: column; gap: 5vh; } .left-column, .right-column, .featured { width: 100%; text-align: center; } .featured { font-size: 3vw; order: -1; margin-bottom: 2vh; } .header, .footer { font-size: 15vw; } .progress-indicator { width: 120px; } }\nscript.js: gsap.registerPlugin(ScrollTrigger, CustomEase, SplitText); CustomEase.create(\"customEase\", \"M0,0 C0.86,0 0.07,1 1,1\"); let lenis; // Sound management class SoundManager { constructor() { this.sounds = {}; this.isEnabled = false; this.init(); } init() { // Preload sounds this.loadSound( \"hover\", \"https://assets.codepen.io/7558/click-reverb-001.mp3\" ); this.loadSound( \"click\", \"https://assets.codepen.io/7558/shutter-fx-001.mp3\" ); this.loadSound( \"textChange\", \"https://assets.codepen.io/7558/whoosh-fx-001.mp3\" ); } loadSound(name, url) { const audio = new Audio(url); audio.preload = \"auto\"; // Set different volumes for different sounds if (name === \"hover\") { audio.volume = 0.15; // Lower volume for hover } else { audio.volume = 0.3; // Default volume for click and text change } this.sounds[name] = audio; } enableAudio() { if (!this.isEnabled) { this.isEnabled = true; console.log(\"Audio enabled\"); } } play(soundName, delay = 0) { if (this.isEnabled && this.sounds[soundName]) { if (delay > 0) { setTimeout(() => { this.sounds[soundName].currentTime = 0; this.sounds[soundName].play().catch((e) => { console.log(\"Audio play failed:\", e); }); }, delay); } else { // Reset the audio to beginning and play immediately this.sounds[soundName].currentTime = 0; this.sounds[soundName].play().catch((e) => { console.log(\"Audio play failed:\", e); }); } } } // Method to add more sounds later addSound(name, url, volume = 0.3) { this.loadSound(name, url); if (this.sounds[name]) { this.sounds[name].volume = volume; } } } // Initialize sound manager const soundManager = new SoundManager(); document.addEventListener(\"DOMContentLoaded\", function () { setTimeout(() => { document.fonts.ready.then(() => { initLenis(); initPage(); }); }, 500); }); function initLenis() { lenis = new Lenis({ duration: 1.2, easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)), direction: \"vertical\", gestureDirection: \"vertical\", smooth: true, smoothTouch: false, touchMultiplier: 2 }); lenis.on(\"scroll\", ScrollTrigger.update); gsap.ticker.add((time) => { lenis.raf(time * 1000); }); gsap.ticker.lagSmoothing(0); } function initPage() { // Loading counter animation const loadingOverlay = document.getElementById(\"loading-overlay\"); const loadingCounter = document.getElementById(\"loading-counter\"); let counter = 0; // Animate counter from 00 to 100 const counterInterval = setInterval(() => { counter += Math.random() * 3 + 1; // Random increment for realistic feel if (counter >= 100) { counter = 100; clearInterval(counterInterval); // When counter reaches 100, start fade out setTimeout(() => { // First animate the loading text out gsap.to(loadingOverlay.querySelector(\".loading-counter\"), { opacity: 0, y: -20, duration: 0.6, ease: \"power2.inOut\" }); gsap.to(loadingOverlay.childNodes[0], { opacity: 0, y: -20, duration: 0.6, ease: \"power2.inOut\", onComplete: () => { // Then slide overlay up and out to reveal content gsap.to(loadingOverlay, { y: \"-100%\", duration: 1.2, ease: \"power3.inOut\", delay: 0.3, onComplete: () => { loadingOverlay.style.display = \"none\"; // Start staggered animation for left and right columns animateColumns(); } }); } }); }, 200); // Small delay after reaching 100 } loadingCounter.textContent = `[${counter.toFixed(0).padStart(2, \"0\")}]`; }, 30); const duration = 0.64; const debugInfo = document.getElementById(\"debug-info\"); const fixedContainer = document.getElementById(\"fixed-container\"); const fixedSectionElement = document.querySelector(\".fixed-section\"); const header = document.querySelector(\".header\"); const content = document.querySelector(\".content\"); const footer = document.getElementById(\"footer\"); const leftColumn = document.getElementById(\"left-column\"); const rightColumn = document.getElementById(\"right-column\"); const featured = document.getElementById(\"featured\"); const backgrounds = document.querySelectorAll(\".background-image\"); const artists = document.querySelectorAll(\".artist\"); const categories = document.querySelectorAll(\".category\"); const featuredContents = document.querySelectorAll(\".featured-content\"); const progressFill = document.getElementById(\"progress-fill\"); const currentSectionDisplay = document.getElementById(\"current-section\"); const splitTexts = {}; // Function to animate columns with stagger function animateColumns() { const artistItems = document.querySelectorAll(\".artist\"); const categoryItems = document.querySelectorAll(\".category\"); // Animate left column (artists) first artistItems.forEach((item, index) => { setTimeout(() => { item.classList.add(\"loaded\"); }, index * 60); }); // Animate right column (categories) with slight delay categoryItems.forEach((item, index) => { setTimeout(() => { item.classList.add(\"loaded\"); }, index * 60 + 200); // 200ms delay after artists start }); } // Function to update progress numbers function updateProgressNumbers() { currentSectionDisplay.textContent = (currentSection + 1) .toString() .padStart(2, \"0\"); } // Calculate exact scroll positions for each section const fixedSectionTop = fixedSectionElement.offsetTop; const fixedSectionHeight = fixedSectionElement.offsetHeight; let currentSection = 0; let isAnimating = false; let isSnapping = false; let lastProgress = 0; let scrollDirection = 0; let sectionPositions = []; // Each section takes 10% of the total scroll distance for (let i = 0; i < 10; i++) { sectionPositions.push(fixedSectionTop + (fixedSectionHeight * i) / 10); } // Function to navigate to a specific section function navigateToSection(index) { if (index === currentSection || isAnimating || isSnapping) return; // Enable audio on first user interaction and play sound soundManager.enableAudio(); soundManager.play(\"click\"); isSnapping = true; const targetPosition = sectionPositions[index]; // Start the visual transition changeSection(index); // Scroll to the target position lenis.scrollTo(targetPosition, { duration: 0.8, easing: (t) => 1 - Math.pow(1 - t, 3), lock: true, onComplete: () => { isSnapping = false; } }); } // Add click and hover handlers for navigation artists.forEach((artist, index) => { artist.addEventListener(\"click\", (e) => { e.preventDefault(); navigateToSection(index); }); artist.addEventListener(\"mouseenter\", () => { soundManager.enableAudio(); soundManager.play(\"hover\"); }); }); categories.forEach((category, index) => { category.addEventListener(\"click\", (e) => { e.preventDefault(); navigateToSection(index); }); category.addEventListener(\"mouseenter\", () => { soundManager.enableAudio(); soundManager.play(\"hover\"); }); }); // Enable audio on any user interaction document.addEventListener( \"click\", () => { soundManager.enableAudio(); }, { once: true } ); try { featuredContents.forEach((content, index) => { const h3 = content.querySelector(\"h3\"); if (h3) { splitTexts[`featured-${index}`] = new SplitText(h3, { type: \"words\", wordsClass: \"split-word\" }); splitTexts[`featured-${index}`].words.forEach((word) => { const wrapper = document.createElement(\"div\"); wrapper.className = \"word-mask\"; wrapper.style.display = \"inline-block\"; wrapper.style.overflow = \"hidden\"; word.parentNode.insertBefore(wrapper, word); wrapper.appendChild(word); if (index !== 0) { gsap.set(word, { yPercent: 100, opacity: 0 }); } else { gsap.set(word, { yPercent: 0, opacity: 1 }); } }); } }); } catch (error) { console.error(\"SplitText error:\", error); } gsap.set(fixedContainer, { height: \"100vh\" }); const mainScrollTrigger = ScrollTrigger.create({ trigger: \".fixed-section\", start: \"top top\", end: \"bottom bottom\", pin: \".fixed-container\", pinSpacing: true, onUpdate: (self) => { if (isSnapping) return; // Don't process updates while snapping const progress = self.progress; const progressDelta = progress - lastProgress; // Detect scroll direction if (Math.abs(progressDelta) > 0.001) { scrollDirection = progressDelta > 0 ? 1 : -1; } // Calculate which section we should be in const targetSection = Math.min(9, Math.floor(progress * 10)); // Check if we've crossed a section boundary if (targetSection !== currentSection && !isAnimating) { // Determine the next section (only allow moving one section at a time) const nextSection = currentSection + (targetSection > currentSection ? 1 : -1); // Snap to this section snapToSection(nextSection); } lastProgress = progress; // Update progress fill based on current section const sectionProgress = currentSection / 9; progressFill.style.width = `${sectionProgress * 100}%`; debugInfo.textContent = `Section: ${currentSection}, Target: ${targetSection}, Progress: ${progress.toFixed( 3 )}, Direction: ${scrollDirection}`; } }); function snapToSection(targetSection) { if ( targetSection < 0 || targetSection > 9 || targetSection === currentSection || isAnimating ) return; isSnapping = true; // Start the visual transition changeSection(targetSection); // Snap the scroll position to this exact section const targetPosition = sectionPositions[targetSection]; lenis.scrollTo(targetPosition, { duration: 0.6, easing: (t) => 1 - Math.pow(1 - t, 3), lock: true, // Prevent other scroll events during snap onComplete: () => { isSnapping = false; } }); } const parallaxAmount = 5; function changeSection(newSection) { if (newSection === currentSection || isAnimating) return; isAnimating = true; const isScrollingDown = newSection > currentSection; const previousSection = currentSection; currentSection = newSection; // Update progress numbers updateProgressNumbers(); // Update progress fill based on current section - THIS IS THE FIX const sectionProgress = currentSection / 9; progressFill.style.width = `${sectionProgress * 100}%`; debugInfo.textContent = `Changing to Section: ${newSection} (${ isScrollingDown ? \"Down\" : \"Up\" })`; featuredContents.forEach((content, i) => { if (i !== newSection && i !== previousSection) { content.classList.remove(\"active\"); gsap.set(content, { visibility: \"hidden\", opacity: 0 }); } }); if (previousSection !== null) { const prevWords = splitTexts[`featured-${previousSection}`]?.words; if (prevWords) { gsap.to(prevWords, { yPercent: isScrollingDown ? -100 : 100, opacity: 0, duration: duration * 0.6, stagger: isScrollingDown ? 0.03 : -0.03, ease: \"customEase\", onComplete: () => { featuredContents[previousSection].classList.remove(\"active\"); gsap.set(featuredContents[previousSection], { visibility: \"hidden\" }); } }); } } const newWords = splitTexts[`featured-${newSection}`]?.words; if (newWords) { // Play text change sound with a 250ms delay to avoid overlapping with click sound soundManager.play(\"textChange\", 250); featuredContents[newSection].classList.add(\"active\"); gsap.set(featuredContents[newSection], { visibility: \"visible\", opacity: 1 }); gsap.set(newWords, { yPercent: isScrollingDown ? 100 : -100, opacity: 0 }); gsap.to(newWords, { yPercent: 0, opacity: 1, duration: duration, stagger: isScrollingDown ? 0.05 : -0.05, ease: \"customEase\" }); } backgrounds.forEach((bg, i) => { bg.classList.remove(\"previous\", \"active\"); if (i === newSection) { if (isScrollingDown) { gsap.set(bg, { opacity: 1, y: 0, clipPath: \"inset(100% 0 0 0)\" }); gsap.to(bg, { clipPath: \"inset(0% 0 0 0)\", duration: duration, ease: \"customEase\" }); } else { gsap.set(bg, { opacity: 1, y: 0, clipPath: \"inset(0 0 100% 0)\" }); gsap.to(bg, { clipPath: \"inset(0 0 0% 0)\", duration: duration, ease: \"customEase\" }); } bg.classList.add(\"active\"); } else if (i === previousSection) { bg.classList.add(\"previous\"); gsap.to(bg, { y: isScrollingDown ? `${parallaxAmount}%` : `-${parallaxAmount}%`, duration: duration, ease: \"customEase\" }); gsap.to(bg, { opacity: 0, delay: duration * 0.5, duration: duration * 0.5, ease: \"customEase\", onComplete: () => { bg.classList.remove(\"previous\"); gsap.set(bg, { y: 0 }); isAnimating = false; } }); } else { gsap.to(bg, { opacity: 0, duration: duration * 0.3, ease: \"customEase\" }); } }); artists.forEach((artist, i) => { if (i === newSection) { artist.classList.add(\"active\"); gsap.to(artist, { opacity: 1, duration: 0.3, ease: \"power2.out\" }); } else { artist.classList.remove(\"active\"); gsap.to(artist, { opacity: 0.3, duration: 0.3, ease: \"power2.out\" }); } }); categories.forEach((category, i) => { if (i === newSection) { category.classList.add(\"active\"); gsap.to(category, { opacity: 1, duration: 0.3, ease: \"power2.out\" }); } else { category.classList.remove(\"active\"); gsap.to(category, { opacity: 0.3, duration: 0.3, ease: \"power2.out\" }); } }); } let globalProgress = 0; const progressBarTrigger = ScrollTrigger.create({ trigger: \".scroll-container\", start: \"top top\", end: \"bottom bottom\", onUpdate: (self) => { globalProgress = self.progress; } }); // End section scroll handling - fixed to prevent overlap ScrollTrigger.create({ trigger: \".end-section\", start: \"top center\", end: \"bottom bottom\", onUpdate: (self) => { // Handle blur effects first (always execute) if (self.progress > 0.1) { footer.classList.add(\"blur\"); leftColumn.classList.add(\"blur\"); rightColumn.classList.add(\"blur\"); featured.classList.add(\"blur\"); } else { footer.classList.remove(\"blur\"); leftColumn.classList.remove(\"blur\"); rightColumn.classList.remove(\"blur\"); featured.classList.remove(\"blur\"); } // Only start unpinning when we're actually in the end section if (self.progress > 0.1) { const newHeight = Math.max( 0, 100 - ((self.progress - 0.1) / 0.9) * 100 ); gsap.to(fixedContainer, { height: `${newHeight}vh`, duration: 0.1, ease: \"power1.out\" }); const moveY = (-(self.progress - 0.1) / 0.9) * 200; gsap.to(header, { y: moveY * 1.5, duration: 0.1, ease: \"power1.out\" }); gsap.to(content, { y: `calc(${moveY}px + (-50%))`, duration: 0.1, ease: \"power1.out\" }); gsap.to(footer, { y: moveY * 0.5, duration: 0.1, ease: \"power1.out\" }); } else { // Reset positions when scrolling back up gsap.to(fixedContainer, { height: \"100vh\", duration: 0.1, ease: \"power1.out\" }); gsap.to(header, { y: 0, duration: 0.1, ease: \"power1.out\" }); gsap.to(content, { y: \"-50%\", duration: 0.1, ease: \"power1.out\" }); gsap.to(footer, { y: 0, duration: 0.1, ease: \"power1.out\" }); } debugInfo.textContent = `End Section - Height: ${ fixedContainer.style.height }, Progress: ${self.progress.toFixed(2)}`; } }); document.addEventListener(\"keydown\", (e) => { if (e.key.toLowerCase() === \"h\") { debugInfo.style.display = debugInfo.style.display === \"none\" ? \"block\" : \"none\"; } }); // Initialize progress numbers updateProgressNumbers(); debugInfo.textContent = `Current Section: 0 (Initial)`; } // Global access to sound manager for adding more sounds later window.addSound = function (name, url, volume = 0.3) { soundManager.addSound(name, url, volume); }; // Example usage for adding more sounds later: // window.addSound('background', 'path/to/background-music.mp3', 0.1);",
    "id": "gsapcomponent--full-screen-scroll-slideshow-with-sound-fx"
  },
  {
    "title": "cg-aristidebenoist-slider",
    "code": {
      "data.js": "export const titles = [\n  [\n    [\"p\", \"\", \"r\", \"\", \"i\", \"s\", \"m\"],\n    [\"\", \"t\", \"\", \"o\", \"n\", \"e\", \"\"],\n  ],\n  [\n    [\"\", \"l\", \"u\", \"m\", \"e\", \"\", \"n\"],\n    [\"d\", \"\", \"r\", \"e\", \"a\", \"m\", \"\"],\n  ],\n  [\n    [\"r\", \"\", \"u\", \"s\", \"\", \"h\", \"\"],\n    [\"\", \"s\", \"l\", \"i\", \"\", \"c\", \"e\"],\n  ],\n  [\n    [\"e\", \"\", \"c\", \"h\", \"o\", \"\", \"e\"],\n    [\"\", \"c\", \"o\", \"\", \"d\", \"e\", \"6\"],\n  ],\n  [\n    [\"t\", \"e\", \"\", \"c\", \"h\", \"y\", \"\"],\n    [\"\", \"m\", \"\", \"\", \"a\", \"p\", \"l\"],\n  ],\n  [\n    [\"\", \"w\", \"a\", \"v\", \"\", \"e\", \"s\"],\n    [\"b\", \"o\", \"\", \"x\", \"\", \"\", \"\"],\n  ],\n  [\n    [\"c\", \"\", \"u\", \"b\", \"\", \"\", \"e\"],\n    [\"\", \"s\", \"i\", \"t\", \"\", \"9\", \"0\"],\n  ],\n  [\n    [\"r\", \"u\", \"\", \"s\", \"h\", \"\", \"x\"],\n    [\"t\", \"\", \"o\", \"r\", \"\", \"k\", \"\"],\n  ],\n  [\n    [\"c\", \"\", \"o\", \"d\", \"\", \"e\", \"\"],\n    [\"l\", \"a\", \"b\", \"\", \"\", \"0\", \"8\"],\n  ],\n  [\n    [\"m\", \"i\", \"x\", \"\", \"e\", \"\", \"d\"],\n    [\"\", \"\", \"a\", \"r\", \"\", \"k\", \"\"],\n  ],\n  [\n    [\"\", \"t\", \"e\", \"\", \"s\", \"t\", \"\"],\n    [\"b\", \"\", \"e\", \"d\", \"\", \"5\", \"4\"],\n  ],\n  [\n    [\"f\", \"o\", \"c\", \"u\", \"\", \"\", \"s\"],\n    [\"\", \"d\", \"o\", \"c\", \"k\", \"\", \"\"],\n  ],\n  [\n    [\"p\", \"\", \"a\", \"\", \"c\", \"e\", \"\"],\n    [\"s\", \"e\", \"t\", \"\", \"1\", \"\", \"7\"],\n  ],\n  [\n    [\"\", \"b\", \"\", \"l\", \"a\", \"s\", \"t\"],\n    [\"m\", \"o\", \"\", \"d\", \"\", \"\", \"e\"],\n  ],\n  [\n    [\"z\", \"o\", \"\", \"n\", \"e\", \"\", \"\"],\n    [\"g\", \"e\", \"3\", \"\", \"\", \"n\", \"\"],\n  ],\n  [\n    [\"d\", \"\", \"r\", \"e\", \"a\", \"\", \"m\"],\n    [\"s\", \"c\", \"a\", \"p\", \"0\", \"\", \"\"],\n  ],\n  [\n    [\"e\", \"l\", \"e\", \"v\", \"a\", \"n\", \"\"],\n    [\"\", \"p\", \"a\", \"\", \"t\", \"\", \"h\"],\n  ],\n  [\n    [\"\", \"s\", \"\", \"h\", \"i\", \"f\", \"t\"],\n    [\"\", \"n\", \"e\", \"\", \"\", \"u\", \"e\"],\n  ],\n  [\n    [\"i\", \"\", \"c\", \"o\", \"\", \"\", \"n\"],\n    [\"\", \"m\", \"e\", \"m\", \"o\", \"\", \"\"],\n  ],\n  [\n    [\"\", \"a\", \"\", \"\", \"u\", \"r\", \"a\"],\n    [\"w\", \"\", \"a\", \"v\", \"e\", \"\", \"6\"],\n  ],\n  [\n    [\"s\", \"t\", \"e\", \"l\", \"\", \"l\", \"a\"],\n    [\"\", \"o\", \"\", \"r\", \"b\", \"i\", \"t\"],\n  ],\n  [\n    [\"v\", \"\", \"e\", \"r\", \"t\", \"e\", \"\"],\n    [\"c\", \"o\", \"\", \"r\", \"\", \"e\", \"\"],\n  ],\n  [\n    [\"i\", \"n\", \"f\", \"i\", \"\", \"9\", \"\"],\n    [\"\", \"\", \"\", \"e\", \"t\", \"h\", \"o\"],\n  ],\n  [\n    [\"\", \"\", \"q\", \"u\", \"a\", \"n\", \"t\"],\n    [\"d\", \"e\", \"\", \"c\", \"\", \"\", \"k\"],\n  ],\n  [\n    [\"\", \"n\", \"\", \"\", \"o\", \"v\", \"a\"],\n    [\"r\", \"\", \"a\", \"y\", \"\", \"\", \"\"],\n  ],\n  [\n    [\"\", \"r\", \"a\", \"d\", \"i\", \"a\", \"n\"],\n    [\"g\", \"l\", \"o\", \"\", \"\", \"w\", \"0\"],\n  ],\n  [\n    [\"c\", \"o\", \"s\", \"m\", \"i\", \"c\", \"\"],\n    [\"p\", \"\", \"a\", \"t\", \"h\", \"\", \"\"],\n  ],\n  [\n    [\"\", \"s\", \"o\", \"l\", \"a\", \"r\", \"\"],\n    [\"d\", \"r\", \"i\", \"f\", \"\", \"\", \"t\"],\n  ],\n  [\n    [\"z\", \"e\", \"n\", \"\", \"l\", \"a\", \"y\"],\n    [\"\", \"e\", \"r\", \"v\", \"\", \"y\", \"\"],\n  ],\n  [\n    [\"a\", \"p\", \"e\", \"\", \"x\", \"\", \"\"],\n    [\"f\", \"o\", \"r\", \"g\", \"e\", \"0\", \"0\"],\n  ],\n  [\n    [\"\", \"c\", \"r\", \"y\", \"s\", \"t\", \"a\"],\n    [\"l\", \"b\", \"y\", \"t\", \"e\", \"\", \"\"],\n  ],\n];\n",
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Aristide Benoist Carousel Rebuild Using GSAP | @mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <div class=\"container\">\n      <nav>\n        <a href=\"#\" id=\"logo\">mukta</a>\n        <a href=\"#\">Subscribe</a>\n      </nav>\n      <footer>\n        <a href=\"#\">Unlock Source Code with PRO</a>\n        <a href=\"#\">Link in description</a>\n      </footer>\n      <div class=\"bg-overlay\"></div>\n      <div class=\"slider-nav\"></div>\n      <div class=\"slides\"></div>\n      <div class=\"slide-title\">\n        <div class=\"slide-title-row\">\n          <div class=\"letter\"></div>\n          <div class=\"letter\"></div>\n          <div class=\"letter\"></div>\n          <div class=\"letter\"></div>\n          <div class=\"letter\"></div>\n          <div class=\"letter\"></div>\n          <div class=\"letter\"></div>\n        </div>\n        <div class=\"slide-title-row\">\n          <div class=\"letter\"></div>\n          <div class=\"letter\"></div>\n          <div class=\"letter\"></div>\n          <div class=\"letter\"></div>\n          <div class=\"letter\"></div>\n          <div class=\"letter\"></div>\n          <div class=\"letter\"></div>\n        </div>\n      </div>\n    </div>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/CustomEase.min.js\"></script>\n    <script type=\"module\" src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "import { titles } from \"./data.js\";\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  gsap.registerPlugin(CustomEase);\n  CustomEase.create(\n    \"hop\",\n    \"M0,0 C0.071,0.505 0.192,0.726 0.318,0.852 0.45,0.984 0.504,1 1,1\"\n  );\n\n  const sliderNav = document.querySelector(\".slider-nav\");\n  const slidesContainer = document.querySelector(\".slides\");\n  const bgOverlay = document.querySelector(\".bg-overlay\");\n  const slideTitle = document.querySelector(\".slide-title\");\n  const numberOfItems = 30;\n  let currentIndex = 0;\n\n  function getRandomColor() {\n    const letters = \"0123456789ABCDEF\";\n    let color = \"#\";\n    for (let i = 0; i < 6; i++) {\n      color += letters[Math.floor(Math.random() * 16)];\n    }\n    return color;\n  }\n\n  function updateTitle(newIndex, color) {\n    const title = titles[newIndex];\n    const titleRows = slideTitle.querySelectorAll(\".slide-title-row\");\n\n    titleRows.forEach((row, rowIndex) => {\n      row.querySelectorAll(\".letter\").forEach((letter, letterIndex) => {\n        const existingSpan = letter.querySelector(\"span\");\n        if (existingSpan) {\n          letter.removeChild(existingSpan);\n        }\n\n        const newSpan = document.createElement(\"span\");\n        const direction = newIndex > currentIndex ? 150 : -150;\n        gsap.set(newSpan, {\n          x: direction,\n          color: color,\n          filter: \"brightness(0.75)\",\n        });\n        newSpan.textContent = title[rowIndex][letterIndex] || \"\";\n        letter.appendChild(newSpan);\n        gsap.to(newSpan, {\n          x: 0,\n          duration: 1,\n          ease: \"power2.out\",\n          delay: 0.125,\n        });\n      });\n    });\n  }\n\n  for (let i = 0; i < numberOfItems; i++) {\n    const navItemWrapper = document.createElement(\"div\");\n    navItemWrapper.classList.add(\"nav-item-wrapper\");\n    if (i === 0) {\n      navItemWrapper.classList.add(\"active\");\n    }\n\n    const navItem = document.createElement(\"div\");\n    navItem.classList.add(\"nav-item\");\n\n    navItemWrapper.appendChild(navItem);\n    sliderNav.appendChild(navItemWrapper);\n\n    navItemWrapper.addEventListener(\"click\", () => {\n      if (i === currentIndex) {\n        return;\n      }\n\n      document\n        .querySelectorAll(\".nav-item-wrapper\")\n        .forEach((nav) => nav.classList.remove(\"active\"));\n      navItemWrapper.classList.add(\"active\");\n\n      const translateXValue = -i * 100;\n      gsap.to(slidesContainer, {\n        x: `${translateXValue}vw`,\n        duration: 1.5,\n        ease: \"hop\",\n      });\n\n      const newColor = getRandomColor();\n      gsap.to(bgOverlay, {\n        backgroundColor: newColor,\n        duration: 1.5,\n        ease: \"hop\",\n      });\n\n      updateTitle(i, newColor);\n      currentIndex = i;\n    });\n\n    const slide = document.createElement(\"div\");\n    slide.classList.add(\"slide\");\n    if (i === 0) {\n      slide.classList.add(\"active\");\n    }\n\n    const imgWrapper = document.createElement(\"div\");\n    imgWrapper.classList.add(\"img\");\n\n    const img = document.createElement(\"img\");\n    img.src = `./assets/img${i + 1}.jpg`;\n    img.alt = \"\";\n\n    imgWrapper.appendChild(img);\n    slide.appendChild(imgWrapper);\n    slidesContainer.appendChild(slide);\n  }\n\n  updateTitle(0, getComputedStyle(bgOverlay).backgroundColor);\n});\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  width: 100%;\n  height: 100%;\n  font-family: \"PP Neue Montreal\";\n}\n\n.container {\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n}\n\nnav,\nfooter {\n  position: fixed;\n  left: 0;\n  width: 100vw;\n  padding: 2.75em;\n  display: flex;\n  justify-content: space-between;\n  z-index: 2;\n}\n\nnav {\n  top: 0;\n}\n\nfooter {\n  bottom: 0;\n}\n\na {\n  text-decoration: none;\n  text-transform: uppercase;\n  font-size: 12px;\n  font-weight: 500;\n  color: #000;\n}\n\nnav a#logo {\n  position: relative;\n  top: -12px;\n  font-family: \"Timmons NY 2.005\";\n  font-size: 42px;\n}\n\n.bg-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  background-color: rgb(213, 183, 71);\n  filter: brightness(0.75);\n  opacity: 0.5;\n}\n\n.slider-nav {\n  position: fixed;\n  top: 5%;\n  left: 50%;\n  transform: translateX(-50%);\n  width: 25%;\n  height: 15px;\n  display: flex;\n  justify-content: space-between;\n  z-index: 10;\n}\n\n.nav-item-wrapper {\n  flex: 1;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  transition: all 750ms cubic-bezier(0, 0.75, 0.5, 1);\n}\n\n.nav-item {\n  width: 1px;\n  height: 100%;\n  border: 1px solid rgba(0, 0, 0, 0.15);\n  transition: all 750ms cubic-bezier(0, 0.75, 0.5, 1);\n}\n\n.nav-item-wrapper.active {\n  flex: 5;\n}\n\n.nav-item-wrapper.active .nav-item {\n  width: 50%;\n  border: 1px solid rgba(0, 0, 0, 1);\n}\n\n.slides {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 3000vw;\n  height: 100vh;\n  display: flex;\n}\n\n.slide {\n  flex: 1;\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.slide .img {\n  width: 50%;\n  height: 50%;\n  opacity: 0.75;\n}\n\nimg {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\n.slide-title {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 75%;\n  height: 65%;\n  display: flex;\n  flex-direction: column;\n  pointer-events: none;\n}\n\n.slide-title-row {\n  flex: 1;\n  width: 100%;\n  display: flex;\n  gap: 0em;\n}\n\n.slide-title-row:nth-child(2) {\n  position: relative;\n  left: 4em;\n}\n\n.letter {\n  flex: 1;\n  height: 100%;\n  padding-left: 2em;\n  clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%);\n}\n\n.letter span {\n  position: relative;\n  display: inline-block;\n  font-family: \"Timmons NY 2.005\";\n  font-size: 280px;\n  filter: brightness(0.25) saturate(0.75) !important;\n}\n\n@media (max-width: 900px) {\n  .slider-nav {\n    width: 40%;\n  }\n\n  .slide .img {\n    width: 80%;\n    height: 75%;\n  }\n\n  .slide-title {\n    left: 47.5%;\n    height: 25%;\n  }\n\n  .slide-title-row:nth-child(2) {\n    left: 0;\n  }\n\n  .letter span {\n    font-size: 100px;\n  }\n}\n"
    }
  }
]