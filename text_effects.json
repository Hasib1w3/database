[
  {
    "title": "falling-text-with-gravity",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/Physics2DPlugin.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/ScrollTrigger.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/SplitText.min.js\">script>\n\nStep 1: Add HTML\n\n<div class=\"drop-wrapper\">\n  <div class=\"drop-section\">\n    <h1 data-drop-text=\"\" class=\"drop-heading\">This is just a<span data-drop-img=\"\" class=\"drop-heading-img is--first\"><img src=\"https://cdn.prod.website-files.com/681a615bf5a0f1ba3cb1ca38/681a62d0bb34b74d3514ecab_shape-squigle-1.png\">span>random quote<span data-drop-img=\"\" class=\"drop-heading-img is--second\"><img src=\"https://cdn.prod.website-files.com/681a615bf5a0f1ba3cb1ca38/681a62d0bb34b74d3514ecad_shape-squigle-2.png\">span>we usedh1>\n  div>\n  <div class=\"drop-section\">\n    <h1 data-drop-text=\"\" class=\"drop-heading\">See how our window acts like<span data-drop-img=\"\" class=\"drop-heading-img is--third\"><img src=\"https://cdn.prod.website-files.com/681a615bf5a0f1ba3cb1ca38/681a62d0bb34b74d3514ecaf_shape-squigle-3.png\">span> a roof?h1>\n  div>\n  <div class=\"drop-section\">\n    <h1 data-drop-text=\"\" class=\"drop-heading\">So much fun!h1>\n  div>\ndiv>\n\nStep 2: Add CSS\n\n.drop-wrapper {\n  width: 100%;\n  min-height: 350vh;\n}\n\n.drop-section {\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  min-height: 100vh;\n  display: flex;\n  position: relative;\n}\n\n.drop-heading {\n  text-align: center;\n  max-width: 40rem;\n  margin-top: 0;\n  margin-bottom: 0;\n  font-size: 4rem;\n  font-weight: 500;\n  line-height: 1;\n}\n\n.drop-heading-img {\n  z-index: 2;\n  width: 1.2em;\n  display: inline-block;\n  position: relative;\n}\n\n.drop-heading-img img {\n  width: 100%;\n  max-width: 100%;\n}\n\n.drop-heading-img.is--first {\n  transform: rotate(-20deg)translate(.15em, -.2em);\n}\n\n.drop-heading-img.is--second {\n  transform: translate(-.1em, 0.2em)rotate(10deg);\n}\n\n.drop-heading-img.is--third {\n  margin-left: -.1em;\n  margin-right: -.1em;\n  margin-top: -.2em;\n  transform: translate(-.05em, .1em)rotate(50deg);\n}\n\n[data-drop-text] .line { \n  display: block;\n}\n\nStep 2: Add custom Javascript\n\ngsap.registerPlugin(ScrollTrigger, SplitText, Physics2DPlugin);\n\nfunction initFallingTextGravity() {\n  new SplitText(\"[data-drop-text]\", {\n    type: \"lines, chars\",\n    autoSplit: true, // resplit split if the element resizes and it's split by lines\n    linesClass: \"line\",\n    onSplit(self) {\n      // use a context to collect up all the animations\n      let ctx = gsap.context(() => {\n        self.lines.forEach((line) => { // loop around the lines\n          // only one timeline per line rather than one per element\n          gsap\n            .timeline({\n              scrollTrigger: {\n                once: true, // only fire once\n                trigger: line, // use the line as a trigger\n                start: \"top top-=10\" // adjust offset as you see fit\n              }\n            })\n            .to(line.children, { // target the children\n              duration: \"random(1.5, 3)\", // Use GSAP utils for randomized values\n              physics2D: {\n                velocity: \"random(500, 1000)\",\n                angle: 90,\n                gravity: 3000\n              },\n              rotation: \"random(-90, 90)\",\n              ease: \"none\"\n            })\n            .to(line.children,{ // towards the end of the 'fall', fade out the elements\n              autoAlpha: 0,\n              duration: 0.2\n            }, \"-=.2\");\n        });\n      });\n\n      return ctx; // return our animations so GSAP can clean them up when onSplit fires\n    }\n  });\n}\n\n// Initialize Falling Text with Gravity\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  initFallingTextGravity();\n});\n\nImplementation\nWe\u2019re combining the SplitText + Physics2D plugins from GSAP in this one. On scroll your headings shatter into characters and \u201cfall\u201d off the top of the viewport, as if they hit a \u2018roof\u2019. \n\n1. Add the target attribute\nAdd the data-drop-text attribute to any heading you want to target.\n\n2. Find and split all the targets\nIn our JS, we create a new SplitText instance for all of our targets. We split the text in lines, and then in separate letters. The lines are used as triggers in our ScrollTrigger (see next step) and the characters of course for our animation. Setting autoSplit to true means our SplitText will revert, and then re-init on resize, if our text wraps. That's why we use the onSplit() callback to create our animation in the next step. A great way to make any SplitText animation responsive easily!\n\n3. ScrollTrigger Setup\nIn our onSplit callback, we loop over each line in the heading, inside of a context. This context, which we return at the end, makes sure GSAP can clean up this animation whenever the text re-splits. \nIn our loop, we create a ScrollTrigger for each line, and we set once: true, so our animation only fires once. In step 4 we\u2019ll add our animation!\nIt\u2019s worth playing around with the start values to really nail the moment where your text visually \u2018touches\u2019 the top of the window. For our font, size, and line-height combo, an offset of 10px worked great.\n\n4. Drop the letters with Physics2D\nNow, let\u2019s add 2 tweens to our timeline. The first one, using the Physics2D plugin, sends each child element of the line, flying straight down with randomized velocity, angle, and gravity. A second tween makes sure the elements are faded out towards the end. \nDefinitely have a look around the Physics2D docs to check the values and options you can tweak to really make this exactly like you want it! I'll explain the ones we used:\n- Velocity \u2192 The initial velocity of the object measured in pixels per time unit. We used a random value between 500 and 100 to make all letters fall a bit more natural. \n- Angle \u2192 The initial angle (in degrees) at which the object should travel. This only matters when a velocity is defined. You could make this a random value between 80 and 100 for example, to make the letters spread out a bit. Just an idea!\n- Gravity \u2192 The amount of downward acceleration applied to the object, measured in pixels per second. A higher value will mean the letters fall faster.",
    "id": "falling-text-with-gravity"
  },
  {
    "title": "highlight-text-on-scroll",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/ScrollTrigger.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/SplitText.min.js\">script>\n\nStep 1: Add HTML\n\n<h1 data-highlight-text>Add your heading hereh1>\n\nStep 2: Add custom Javascript\n\ngsap.registerPlugin(ScrollTrigger, SplitText)\n  \nfunction initHighlightText(){\n\n  let splitHeadingTargets = document.querySelectorAll(\"[data-highlight-text]\")\n  splitHeadingTargets.forEach((heading) => {\n    \n    const scrollStart = heading.getAttribute(\"data-highlight-scroll-start\") || \"top 90%\"\n    const scrollEnd = heading.getAttribute(\"data-highlight-scroll-end\") || \"center 40%\"\n    const fadedValue = heading.getAttribute(\"data-highlight-fade\") || 0.2 // Opacity of letter\n    const staggerValue =  heading.getAttribute(\"data-highlight-stagger\") || 0.1 // Smoother reveal\n    \n    new SplitText(heading, {\n      type: \"words, chars\",\n      autoSplit: true,\n      onSplit(self) {\n        let ctx = gsap.context(() => {\n          let tl = gsap.timeline({\n            scrollTrigger: {\n              scrub: true,\n              trigger: heading, \n              start: scrollStart,\n              end: scrollEnd,\n            }\n          })\n          tl.from(self.chars,{\n            autoAlpha: fadedValue,\n            stagger: staggerValue,\n            ease: \"linear\"\n          })\n        });\n        return ctx; // return our animations so GSAP can clean them up when onSplit fires\n      }\n    });    \n  });\n}\n\n// Initialize Highlight Text on Scroll\ndocument.addEventListener(\"DOMContentLoaded\", () =>{\n  initHighlightText();\n});\n\nImplementation\nWe've seen many different ways of implementing this type of scroll effect, our implementation might be the simplest one yet. No pseudo elements, duplicated text or masks that you have to animate. We simply split the text into characters, and then tween each letter from a lower opacity to fully visible. With the new GSAP SplitText version, making this responsive and accessible is easier than ever:\nSimply add the [data-highlight-text] attribute to a text element you want to target. Include the JavaScript in your project, and done!\n\nCustomization options\nWe included a couple of attributes you can add to the same heading element as in step 1. These allow you to customize the behaviour of the animation. You can change it either in the JS directly, or, add the following attributes to your heading:\n\nScroll start position\n[data-highlight-scroll-start] Controls when the text starts highlighting. The default is top 90%. Learn more about the options in the ScrollTrigger docs.\n\nScroll end position\n[data-highlight-scroll-end] Controls when the text animation finishes. Default is center 40%.\n\nPre-highlight opacity\n[data-highlight-fade] Controls the opacity of the text when it is not 'highlighted' yet. Our default is 0.2.\n\nStagger duration\n[data-highlight-stagger] Controls the stagger duration between each letter. A stagger duration of 1 would mean the letters are highlighted one after one, with no fade. A lower number makes it smoother. Play around with this to get your desired result! Our default is 0.1.",
    "id": "highlight-text-on-scroll"
  },
  {
    "title": "looping-words-with-selector",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js\">script>\n\nStep 1: Add HTML\n\n<div class=\"looping-words\">\n  <div class=\"looping-words__containers\">\n    <ul data-looping-words-list=\"\" class=\"looping-words__list\">\n      <li class=\"looping-words__list\">\n        <p class=\"looping-words__p\">GSAPp>\n      li>\n      <li class=\"looping-words__list\">\n        <p class=\"looping-words__p\">Loopingp>\n      li>\n      <li class=\"looping-words__list\">\n        <p class=\"looping-words__p\">Wordsp>\n      li>\n      <li class=\"looping-words__list\">\n        <p class=\"looping-words__p\">Selectorp>\n      li>\n      <li class=\"looping-words__list\">\n        <p class=\"looping-words__p\">Made withp>\n      li>\n    ul>\n  div>\n  <div class=\"looping-words__fade\">div>\n  <div data-looping-words-selector=\"\" class=\"looping-words__selector\">\n    <div class=\"looping-words__edge\">div>\n    <div class=\"looping-words__edge is--2\">div>\n    <div class=\"looping-words__edge is--3\">div>\n    <div class=\"looping-words__edge is--4\">div>\n  div>\ndiv>\n\nStep 2: Add CSS\n\n.looping-words {\n  height: 2.7em;\n  padding-left: .1em;\n  padding-right: .1em;\n  font-family: PP Neue Corp Tight, Arial, sans-serif;\n  font-size: 10em;\n  font-weight: 700;\n  line-height: .9;\n  position: relative;\n}\n\n.looping-words__list {\n  text-align: center;\n  text-transform: uppercase;\n  white-space: nowrap;\n  flex-flow: column;\n  align-items: center;\n  margin-top: 0;\n  margin-bottom: 0;\n  padding-left: 0;\n  list-style: none;\n  display: flex;\n  position: relative;\n}\n\n.looping-words__fade {\n  pointer-events: none;\n  background-image: linear-gradient(rgb(230, 226, 247) 5%, rgba(230, 226, 247, 0) 40%, rgba(230, 226, 247, 0) 60%, rgb(230, 226, 247) 95%);\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n.looping-words__edge {\n  border-top: .035em solid #2600ff;\n  border-left: .035em solid #2600ff;\n  width: .125em;\n  height: .125em;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n.looping-words__edge.is--2 {\n  left: auto;\n  right: 0;\n  transform: rotate(90deg);\n}\n\n.looping-words__edge.is--3 {\n  inset: auto 0 0 auto;\n  transform: rotate(180deg);\n}\n\n.looping-words__edge.is--4 {\n  top: auto;\n  bottom: 0;\n  transform: rotate(270deg);\n}\n\n.looping-words__selector {\n  pointer-events: none;\n  width: 100%;\n  height: .9em;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.looping-words__containers {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  overflow: hidden;\n}\n\n.looping-words__p {\n  margin: 0;\n}\n\nStep 2: Add custom Javascript\n\nfunction initLoopingWordsWithSelector() {  \n  const wordList = document.querySelector('[data-looping-words-list]');\n  const words = Array.from(wordList.children);\n  const totalWords = words.length;\n  const wordHeight = 100 / totalWords; // Offset as a percentage\n  const edgeElement = document.querySelector('[data-looping-words-selector]');\n  let currentIndex = 0;\n\n  function updateEdgeWidth() {\n    const centerIndex = (currentIndex + 1) % totalWords;\n    const centerWord = words[centerIndex];\n    const centerWordWidth = centerWord.getBoundingClientRect().width;\n    const listWidth = wordList.getBoundingClientRect().width;\n    const percentageWidth = (centerWordWidth / listWidth) * 100;\n\n    gsap.to(edgeElement, {\n      width: `${percentageWidth}%`,\n      duration: 0.5,\n      ease: 'Expo.easeOut',\n    });\n  }\n\n  function moveWords() {\n    currentIndex++;\n\n    gsap.to(wordList, {\n      yPercent: -wordHeight * currentIndex,\n      duration: 1.2,\n      ease: 'elastic.out(1, 0.85)',\n      onStart: updateEdgeWidth,\n      onComplete: function() {\n        if (currentIndex >= totalWords - 3) {\n          wordList.appendChild(wordList.children[0]);\n          currentIndex--;\n          gsap.set(wordList, { yPercent: -wordHeight * currentIndex });\n          words.push(words.shift());\n        }\n      }\n    });\n  }\n\n  updateEdgeWidth();\n\n  gsap.timeline({ repeat: -1, delay: 1 })\n    .call(moveWords)\n    .to({}, { duration: 2 })\n    .repeat(-1);\n}\n\n// Initialize Looping Words with Selector\ndocument.addEventListener('DOMContentLoaded', () => {\n  initLoopingWordsWithSelector();\n});\n\nImplementation\n\nCustomization Options\n\nEasing\nFor this example we use the Elastic effect of GSAP, but it's also possible to customize this with the Bounce or Expo easing.\n\nDuration\nIn the Javascript adjust GSAP of wordList duration: = 1.2; to make the animation faster.\nIt's also possible to change the duration of the selector edgeElement duration = 0.5",
    "id": "looping-words-with-selector"
  },
  {
    "title": "masked-text-reveal",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/ScrollTrigger.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/SplitText.min.js\">script>\n\nStep 2: Add custom Javascript\n\ngsap.registerPlugin(SplitText, ScrollTrigger);2. HTML Markup / What to add in Webflow\n\nFor each heading you want to reveal on scroll, add an attribute of data-split=\"heading\". \n3. A very basic SplitText animation\nThis will split every element with the selected attribute into lines, then wrap each line in another div with overflow hidden (to create a mask effect), and then animate those lines coming from the bottom. We return the GSAP tween so that the instance is reverted on window resize. Otherwise we end up creating new animations on top of old ones on every split. \ndocument.addEventListener(\"DOMContentLoaded\", () => {\n\n  let headings = document.querySelectorAll('[data-split=\"heading\"]')\n  headings.forEach(heading => {\n    SplitText.create(heading, {\n        type: \"lines\",\n        autoSplit: true,\n        mask: \"lines\",\n        onSplit(instance) {\n          return gsap.from(instance.lines, {\n            duration: 0.8, \n            yPercent: 110,\n            stagger: 0.1,\n            ease:\"expo.out\",\n          });\n        }\n    });    \n  });\n  \n});4. Connect that to a ScrollTrigger\nBecause we've already included and registered the ScrollTrigger plugin in our project, we can go ahead and implement it directly in the existing GSAP tween like below. And basically, that's it already! You now have a clean reveal effect for every heading on your page! Below this code block, we will continue with a more advanced example, and all the way at the end of this article you can find some 'notes'. \ndocument.addEventListener(\"DOMContentLoaded\", () => {\n\n  let headings = document.querySelectorAll('[data-split=\"heading\"]')\n  headings.forEach(heading => {\n    SplitText.create(heading, {\n      type: \"lines\",\n      autoSplit: true,\n      mask: \"lines\",\n      onSplit(instance) {\n        return gsap.from(instance.lines, {\n          duration: 0.8, \n          yPercent: 110,\n          stagger: 0.1,\n          ease:\"expo.out\",\n          scrollTrigger: {\n            trigger: heading,\n            start: 'top 80%',\n            once: true,\n          }\n        });\n      }\n    });    \n  });\n});Advanced implementation\n1. HTML Markup / What to add in Webflow\n\nContrary to the basic example, we'll include 2 attributes on each heading. One to target, and one to decide on the split-type. For each heading you want to reveal on scroll, add 2 attributes: data-split=\"heading\" and data-split-reveal=\"lines\". \ndata-split=\"heading\" marks elements to process.\ndata-split-reveal accepts \"lines\", \"words\", or \"chars\" (alias for characters).\nIf you don't add a value inside data-split-reveal, it will default to \"lines\".\n2. Configuration options\nWe define a global config object to store the default duration and stagger duration for all our different split-types. You can change these however you like! Technically, you could expand the object with different eases or even animations, but we'll keep it as is for now:\nconst splitConfig = {\n  lines: { duration: 0.8,  stagger: 0.08 },\n  words: { duration: 0.6,  stagger: 0.06 },\n  chars: { duration: 0.4,  stagger: 0.01 }\n}3. The actual scroll-reveal function\nEverything happens in one init function. We only want to do the minimum amount of splitting to reduce unnecessary DOM nodes. After all, if you only want to animate lines, there's no need to split your text all the way into separate letters!\nlines \u2192 split by lines only\nwords \u2192 split by lines and words\nchars \u2192 split by lines, words and characters\nSo, here's what we'll do in total:\nGrab each [data-split=\"heading\"]\nRead the data-split-reveal value.\nCall SplitText.create for the correct type.\nIn onSplit, create the ScrollTrigger, and return the tween for cleanup.\nClamp the start value of our ScrollTrigger to force the animation to always start from 0. Learn more here.\ngsap.registerPlugin(SplitText, ScrollTrigger);\n\nconst splitConfig = {\n  lines: { duration: 0.8, stagger: 0.08 },\n  words: { duration: 0.6, stagger: 0.06 },\n  chars: { duration: 0.4, stagger: 0.01 }\n}\n\nfunction initMaskTextScrollReveal() {\n  document.querySelectorAll('[data-split=\"heading\"]').forEach(heading => {\n    // Find the split type, the default is 'lines'\n    const type = heading.dataset.splitReveal || 'lines'\n    const typesToSplit =\n      type === 'lines' ? ['lines'] :\n      type === 'words' ? ['lines','words'] :\n      ['lines','words','chars']\n    \n    // Split the text\n    SplitText.create(heading, {\n      type: typesToSplit.join(', '), // split into required elements\n      mask: 'lines', // wrap each line in an overflow:hidden div\n      autoSplit: true,\n      linesClass: 'line',\n      wordsClass: 'word',\n      charsClass: 'letter',\n      onSplit: function(instance) {\n        const targets = instance[type] // Register animation targets\n        const config = splitConfig[type] // Find matching duration and stagger from our splitConfig\n        \n        return gsap.from(targets, {\n          yPercent: 110,\n          duration: config.duration,\n          stagger: config.stagger,\n          ease: 'expo.out',\n          scrollTrigger: {\n            trigger: heading,\n            start: 'clamp(top 80%)',\n            once: true\n          }\n        });\n      }\n    })\n  })\n\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  initMaskTextScrollReveal()\n});Some notes\nAccessibility\nSince the new version of SplitText (version 13.0) there's now an a super nice, built-in option to make your split animations accessible for screen readers. You don't even need to add anything yourself, as the default for aria is already set automatically. Learn more here.\nFlash of unstyled content (FOUC)\nPerhaps you have a heading with a reveal animation that is immediately visible in the first viewport. Sometimes you might see it visible, before it is animated, which looks kind of odd. This happens because your browser renders things as quickly as possible, often before your JavaScript executes the first time. The solution that we like the most, is to simply hide your elements in CSS, and then use a gsap.set tween to show the element right before you want to animate it. \nCSS:\n/* Hide your heading in CSS */\n[data-split=\"heading\"]{\n  visibility: hidden;\n}\n\n/* For Webflow users only: */\n/* Make sure the heading does not disappear in the designer or editor */\n.wf-design-mode [data-split=\"heading\"],\n.w-editor [data-split=\"heading\"]{\n  visibility: visible !important;\n}And then in our JS:\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  let headings = document.querySelectorAll('[data-split=\"heading\"]')\n  headings.forEach(heading => {\n    // Reset CSS visibility here:\n    gsap.set(heading,{ autoAlpha:1 })\n    \n    // .... rest of your code below\n  });\n});Bonus tips\n1. To make sure you split the text after the font is loaded you can put your code inside this function:\ndocument.fonts.ready.then(function () {\n  // Your code here\n});2. Some CSS that can result in better and faster rendering of the fonts:\n.text {\n  -webkit-text-rendering: optimizeSpeed; \n  text-rendering: optimizeSpeed;\n  -webkit-transform: translateZ(0); \n  font-kerning: none;\n}3. Using Adobe fonts? Use this tutorial on YouTube to download the font files. Upload them or run them locally this way for faster load times.\n\nImplementation\n\nBasic implementation\n\nIn this guide, we\u2019ll cover how to build a reusable scroll-triggered reveal function using GSAP\u2019s SplitText and ScrollTrigger plugins. You\u2019ll learn how to:\n- Start with the most basic version, a simple GSAP tween to animate lines\n- Then we'll connect those lines to a ScrollTrigger\n- We'll finalize with a production-ready function that is more advanced and scalable across your project\n\n1. Getting started\nRegister the plugins we're going to use.\ngsap.registerPlugin(SplitText, ScrollTrigger);\n2. HTML Markup / What to add in Webflow\n\nFor each heading you want to reveal on scroll, add an attribute of data-split=\"heading\". \n\n3. A very basic SplitText animation\nThis will split every element with the selected attribute into lines, then wrap each line in another div with overflow hidden (to create a mask effect), and then animate those lines coming from the bottom. We return the GSAP tween so that the instance is reverted on window resize. Otherwise we end up creating new animations on top of old ones on every split. \ndocument.addEventListener(\"DOMContentLoaded\", () => {\n\n  let headings = document.querySelectorAll('[data-split=\"heading\"]')\n  headings.forEach(heading => {\n    SplitText.create(heading, {\n        type: \"lines\",\n        autoSplit: true,\n        mask: \"lines\",\n        onSplit(instance) {\n          return gsap.from(instance.lines, {\n            duration: 0.8, \n            yPercent: 110,\n            stagger: 0.1,\n            ease:\"expo.out\",\n          });\n        }\n    });    \n  });\n  \n});\n4. Connect that to a ScrollTrigger\nBecause we've already included and registered the ScrollTrigger plugin in our project, we can go ahead and implement it directly in the existing GSAP tween like below. And basically, that's it already! You now have a clean reveal effect for every heading on your page! Below this code block, we will continue with a more advanced example, and all the way at the end of this article you can find some 'notes'. \ndocument.addEventListener(\"DOMContentLoaded\", () => {\n\n  let headings = document.querySelectorAll('[data-split=\"heading\"]')\n  headings.forEach(heading => {\n    SplitText.create(heading, {\n      type: \"lines\",\n      autoSplit: true,\n      mask: \"lines\",\n      onSplit(instance) {\n        return gsap.from(instance.lines, {\n          duration: 0.8, \n          yPercent: 110,\n          stagger: 0.1,\n          ease:\"expo.out\",\n          scrollTrigger: {\n            trigger: heading,\n            start: 'top 80%',\n            once: true,\n          }\n        });\n      }\n    });    \n  });\n});\nAdvanced implementation\n\n1. HTML Markup / What to add in Webflow\n\nContrary to the basic example, we'll include 2 attributes on each heading. One to target, and one to decide on the split-type. For each heading you want to reveal on scroll, add 2 attributes: data-split=\"heading\" and data-split-reveal=\"lines\". \n- data-split=\"heading\" marks elements to process.\n- data-split-reveal accepts \"lines\", \"words\", or \"chars\" (alias for characters).\n- If you don't add a value inside data-split-reveal, it will default to \"lines\".\n\n2. Configuration options\nWe define a global config object to store the default duration and stagger duration for all our different split-types. You can change these however you like! Technically, you could expand the object with different eases or even animations, but we'll keep it as is for now:\nconst splitConfig = {\n  lines: { duration: 0.8,  stagger: 0.08 },\n  words: { duration: 0.6,  stagger: 0.06 },\n  chars: { duration: 0.4,  stagger: 0.01 }\n}\n3. The actual scroll-reveal function\nEverything happens in one init function. We only want to do the minimum amount of splitting to reduce unnecessary DOM nodes. After all, if you only want to animate lines, there's no need to split your text all the way into separate letters!\n- lines \u2192 split by lines only\n- words \u2192 split by lines and words\n- chars \u2192 split by lines, words and characters\nSo, here's what we'll do in total:\n- Grab each [data-split=\"heading\"]\n- Read the data-split-reveal value.\n- Call SplitText.create for the correct type.\n- In onSplit, create the ScrollTrigger, and return the tween for cleanup.\n- Clamp the start value of our ScrollTrigger to force the animation to always start from 0. Learn more here.\ngsap.registerPlugin(SplitText, ScrollTrigger);\n\nconst splitConfig = {\n  lines: { duration: 0.8, stagger: 0.08 },\n  words: { duration: 0.6, stagger: 0.06 },\n  chars: { duration: 0.4, stagger: 0.01 }\n}\n\nfunction initMaskTextScrollReveal() {\n  document.querySelectorAll('[data-split=\"heading\"]').forEach(heading => {\n    // Find the split type, the default is 'lines'\n    const type = heading.dataset.splitReveal || 'lines'\n    const typesToSplit =\n      type === 'lines' ? ['lines'] :\n      type === 'words' ? ['lines','words'] :\n      ['lines','words','chars']\n    \n    // Split the text\n    SplitText.create(heading, {\n      type: typesToSplit.join(', '), // split into required elements\n      mask: 'lines', // wrap each line in an overflow:hidden div\n      autoSplit: true,\n      linesClass: 'line',\n      wordsClass: 'word',\n      charsClass: 'letter',\n      onSplit: function(instance) {\n        const targets = instance[type] // Register animation targets\n        const config = splitConfig[type] // Find matching duration and stagger from our splitConfig\n        \n        return gsap.from(targets, {\n          yPercent: 110,\n          duration: config.duration,\n          stagger: config.stagger,\n          ease: 'expo.out',\n          scrollTrigger: {\n            trigger: heading,\n            start: 'clamp(top 80%)',\n            once: true\n          }\n        });\n      }\n    })\n  })\n\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  initMaskTextScrollReveal()\n});\nSome notes\n\nAccessibility\nSince the new version of SplitText (version 13.0) there's now an a super nice, built-in option to make your split animations accessible for screen readers. You don't even need to add anything yourself, as the default for aria is already set automatically. Learn more here.\n\nFlash of unstyled content (FOUC)\nPerhaps you have a heading with a reveal animation that is immediately visible in the first viewport. Sometimes you might see it visible, before it is animated, which looks kind of odd. This happens because your browser renders things as quickly as possible, often before your JavaScript executes the first time. The solution that we like the most, is to simply hide your elements in CSS, and then use a gsap.set tween to show the element right before you want to animate it. \n\nCSS:\n/* Hide your heading in CSS */\n[data-split=\"heading\"]{\n  visibility: hidden;\n}\n\n/* For Webflow users only: */\n/* Make sure the heading does not disappear in the designer or editor */\n.wf-design-mode [data-split=\"heading\"],\n.w-editor [data-split=\"heading\"]{\n  visibility: visible !important;\n}\nAnd then in our JS:\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  let headings = document.querySelectorAll('[data-split=\"heading\"]')\n  headings.forEach(heading => {\n    // Reset CSS visibility here:\n    gsap.set(heading,{ autoAlpha:1 })\n    \n    // .... rest of your code below\n  });\n});\nBonus tips\n1. To make sure you split the text after the font is loaded you can put your code inside this function:\ndocument.fonts.ready.then(function () {\n  // Your code here\n});2. Some CSS that can result in better and faster rendering of the fonts:\n.text {\n  -webkit-text-rendering: optimizeSpeed; \n  text-rendering: optimizeSpeed;\n  -webkit-transform: translateZ(0); \n  font-kerning: none;\n}3. Using Adobe fonts? Use this tutorial on YouTube to download the font files. Upload them or run them locally this way for faster load times.",
    "id": "masked-text-reveal"
  },
  {
    "title": "rotating-text",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.14.1/dist/gsap.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.14.1/dist/SplitText.min.js\">script>\n\nStep 1: Add HTML\n\n<h1 data-rotating-title class=\"rotating-text__heading\">Simple \n  <span data-rotating-words=\"routines, tools, systems, help\" class=\"rotating-text__highlight\">routinesspan> \n  that give growing and ambitious teams more clarity.\nh1>\n\nStep 2: Add CSS\n\n.rotating-text__heading {\n  text-align: center;\n  letter-spacing: -.02em;\n  margin: 0;\n  font-family: Haffer, Arial, sans-serif;\n  font-size: clamp(2.5em, 7.5vw, 4.5em);\n  font-weight: 500;\n  line-height: 1;\n}\n\n.rotating-text__highlight {\n  color: #33de96;\n}\n\n[data-rotating-words] {\n  display: inline-block;\n  position: relative;\n}\n\n.rotating-text__inner {\n  display: inline-block;\n}\n\n.rotating-text__word {\n  display: block;\n  white-space: nowrap;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n.rotating-line{\n  padding-bottom: 0.1em;\n  margin-bottom: -0.1em;\n  white-space: nowrap;\n}\n\n.rotating-line-mask{\n  overflow-x: visible !important;\n  overflow-y: clip !important;\n}\n\nStep 2: Add custom Javascript\n\nfunction initRotatingText() {\n  document.querySelectorAll('[data-rotating-title]').forEach((heading) => {\n\n    const stepDuration = parseFloat(heading.getAttribute('data-step-duration') || '1.75');\n\n    SplitText.create(heading, {\n      type: 'lines',\n      mask: 'lines',\n      autoSplit: true,\n      linesClass: 'rotating-line',\n      onSplit(instance) {\n        const rotatingSpan = heading.querySelector('[data-rotating-words]');\n        if (!rotatingSpan) return;\n\n        const rawWords = rotatingSpan.getAttribute('data-rotating-words') || '';\n        const words = rawWords\n          .split(',')\n          .map((w) => w.trim())\n          .filter(Boolean);\n\n        if (!words.length) return;\n\n        // Build inner wrapper with stacked words\n        const wrapper = document.createElement('span');\n        wrapper.className = 'rotating-text__inner';\n\n        const wordEls = words.map((word) => {\n          const el = document.createElement('span');\n          el.className = 'rotating-text__word';\n          el.textContent = word;\n          wrapper.appendChild(el);\n          return el;\n        });\n\n        // Replace the original content of the highlight span\n        rotatingSpan.textContent = '';\n        rotatingSpan.appendChild(wrapper);\n\n        requestAnimationFrame(() => {\n          \n          // Define duration of your in + out movement\n          const inDuration = 0.75;\n          const outDuration = 0.6;\n\n          // Initial state: everyone hidden below\n          gsap.set(wordEls, { yPercent: 150, autoAlpha: 0 });\n\n          // Show first word immediately\n          let activeIndex = 0;\n          const firstWord = wordEls[activeIndex];\n          gsap.set(firstWord, { yPercent: 0, autoAlpha: 1 });\n\n          // Set initial width to first word\n          const firstWidth = firstWord.getBoundingClientRect().width;\n          wrapper.style.width = firstWidth + 'px';\n\n          function showNext() {\n            const nextIndex = (activeIndex + 1) % wordEls.length;\n            const prev = wordEls[activeIndex];\n            const current = wordEls[nextIndex];\n\n            const targetWidth = current.getBoundingClientRect().width;\n\n            // Animate wrapper width to match new word\n            gsap.to(wrapper, {\n              width: targetWidth,\n              duration: inDuration,\n              ease: 'power4.inOut'\n            });\n\n            // Move old word out\n            if (prev && prev !== current) {\n              gsap.to(prev, {\n                yPercent: -150,\n                autoAlpha: 0,\n                duration: outDuration,\n                ease: 'power4.inOut'\n              });\n            }\n\n            // Reveal new word\n            gsap.fromTo(\n              current,\n              { yPercent: 150, autoAlpha: 0 },\n              {\n                yPercent: 0,\n                autoAlpha: 1,\n                duration: inDuration,\n                ease: 'power4.inOut'\n              }\n            );\n\n            activeIndex = nextIndex;\n\n            gsap.delayedCall(stepDuration, showNext);\n          }\n\n          // First word is already visible, start rotating after a full step\n          if (wordEls.length > 1) {\n            gsap.delayedCall(stepDuration, showNext);\n          }\n        });\n      }\n    });\n  });\n}\n\n// Initialize Rotating Text\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  initRotatingText();\n});\n\nImplementation\n\nHeading Target\n\u200dUse [data-rotating-title] on the heading that should animate so the script can register the element, split it into lines, and drive the rotating text effect.\n\nRotating Words\nUse [data-rotating-words] on a span inside your heading to define the words that the script should cycle through. The value of this attribute is a comma-separated list of all words you want to animate, in the exact order they should appear:\n<h1 data-rotating-title>\n  Hello\n  <span data-rotating-words=\"word 1, word 2, word 3\">word 1span>\n  World\nh1>The script reads this list and generates the full word stack dynamically, so you do not need to place all words in your HTML, only inside the attribute value!\n\nLongest Word Requirement\nEnsure the word you place visibly in the DOM on load (the one inside the span) is the longest word from your list, allowing GSAP's SplitText to calculate the correct line width before the dynamic rotating words are injected.\n\nStep Duration\n\u200dUse [data-step-duration] (default 1.75) on the same element as [data-rotating-title] to control the delay in seconds between each word change in the rotation loop.\n<h1 data-rotating-title data-step-duration=\"2.5\">\n  Hello\n  <span data-rotating-words=\"word 1, word 2, word 3\">word 1span>\n  World\nh1>",
    "id": "rotating-text"
  },
  {
    "title": "sticky-title-scroll-effect",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/ScrollTrigger.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/SplitText.min.js\">script>\n\nStep 1: Add HTML\n\n<section data-sticky-title=\"wrap\" class=\"sticky-title-wrapper\">\n  <div class=\"sticky-title-container\">\n    <div class=\"sticky-title-inner\">\n      <h2 data-sticky-title=\"heading\" class=\"sticky-title-el\">Use this effect to really emphasize your messageh2>\n      <h2 data-sticky-title=\"heading\" class=\"sticky-title-el is--stacked\">You can layer multiple headings on each otherh2>\n      <h2 data-sticky-title=\"heading\" class=\"sticky-title-el is--stacked\">Add as many as you want, but I like the balance of 3h2>\n    div>\n  div>\nsection>\n\nStep 2: Add CSS\n\n.sticky-title-wrapper {\n  background-image: linear-gradient(#000, #777);\n  width: 100%;\n  height: 350vh;\n  position: relative;\n}\n\n.sticky-title-container {\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  height: 100vh;\n  padding-left: 1.5em;\n  padding-right: 1.5em;\n  display: flex;\n  position: sticky;\n  top: 0;\n}\n\n.sticky-title-inner {\n  text-align: center;\n  flex-flow: column;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  max-width: 60em;\n  margin-left: auto;\n  margin-right: auto;\n  display: flex;\n  position: relative;\n}\n\n.sticky-title-el {\n  margin-top: 0;\n  margin-bottom: 0;\n  font-size: 5em;\n  font-weight: 500;\n  line-height: 1;\n}\n\n.sticky-title-el.is--stacked {\n  visibility: hidden;\n  position: absolute;\n}\n\n@media screen and (max-width: 767px) {\n  .sticky-title-el {\n    font-size: 3.5em;\n  }\n}\n\nStep 2: Add custom Javascript\n\ngsap.registerPlugin(ScrollTrigger, SplitText)\n\nfunction initStickyTitleScroll() {\n  const wraps = document.querySelectorAll('[data-sticky-title=\"wrap\"]');\n  \n  wraps.forEach(wrap => {\n    const headings = Array.from(wrap.querySelectorAll('[data-sticky-title=\"heading\"]'));\n    \n    const masterTl = gsap.timeline({\n      scrollTrigger: {\n        trigger: wrap,\n        start: \"top 40%\",\n        end: \"bottom bottom\",\n        scrub: true,\n      }\n    });\n    \n    const revealDuration = 0.7,\n          fadeOutDuration = 0.7,\n          overlapOffset = 0.15;\n    \n    headings.forEach((heading, index) => {\n      // Save original heading content for screen readers\n      heading.setAttribute(\"aria-label\", heading.textContent);\n      \n      const split = new SplitText(heading, { type: \"words,chars\" });\n      \n      // Hide all the separate words from screenreader\n      split.words.forEach(word => word.setAttribute(\"aria-hidden\", \"true\"));\n      \n      // Reset visibility on the 'stacked' headings\n      gsap.set(heading, { visibility: \"visible\" });\n      \n      const headingTl = gsap.timeline();\n      headingTl.from(split.chars, {\n        autoAlpha: 0,\n        stagger: { amount: revealDuration, from: \"start\" },\n        duration: revealDuration\n      });\n      \n      // Animate fade-out for every heading except the last one.\n      if (index < headings.length - 1) {\n        headingTl.to(split.chars, {\n          autoAlpha: 0,\n          stagger: { amount: fadeOutDuration, from: \"end\" },\n          duration: fadeOutDuration\n        });\n      }\n      \n      // Overlap the start of fade-in of the new heading a little bit\n      if (index === 0) {\n        masterTl.add(headingTl);\n      } else {\n        masterTl.add(headingTl, `-=${overlapOffset}`);\n      }\n    });\n  });\n}\n\n// Initialize Sticky Title Scroll Effect\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  initStickyTitleScroll();\n});\n\nImplementation\n\nDocumentation\nThis creates a smooth, scroll-based text animation where multiple stacked headings are revealed sequentially. The headings animate in and out using GSAP\u2019s ScrollTrigger and SplitText, emphasizing your content as users scroll.\n\n\nHTML Structure & Requirements\n- Wrapper Element:- Use an element with the attribute data-sticky-title=\"wrap\".\n- Set its height to define the scrolling area (for example, height: 300vh; or any value you decide based on the number of headings).\n\n- Sticky Container:- Inside the wrapper, include a sticky container (e.g., ).",
    "id": "sticky-title-scroll-effect"
  },
  {
    "title": "text-scramble-load-scroll-hover",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/ScrambleTextPlugin.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/SplitText.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/ScrollTrigger.min.js\">script>\n\nStep 1: Add HTML\n\n<div class=\"demo-group\">\n  <div class=\"scramble-section\">\n    <h1 data-scramble=\"load\" class=\"scramble-heading\">This heading will reveal with a basic scrambling effect<br>on page loadh1>\n  div>\n  <div class=\"scramble-section u--bg-light\">\n    <h2 data-scramble=\"scroll\" class=\"scramble-heading\">this is an example of a heading that is triggered by a scrolltriggerh2>\n  div>\n  <div class=\"scramble-section\">\n    <h2 data-scramble-alt=\"\" data-scramble=\"scroll\" class=\"scramble-heading\">You can even control the characters that are used during scrambleh2>\n  div>\n  <div class=\"scramble-section u--bg-light\">\n    <h2 class=\"scramble-heading\">and here's how to work with scramble text on hover:h2>\n    <a data-scramble-hover=\"link\" href=\"#\" class=\"scramble-button w-inline-block\">\n      <p data-scramble-text=\"this text can be custom too\" data-scramble-hover=\"target\" class=\"scramble-button-text\">How to scramble on hoverp>\n    a>\n  div>\ndiv>\n\nStep 2: Add CSS\n\n.scramble-section {\n  grid-column-gap: 2em;\n  grid-row-gap: 2em;\n  flex-flow: column;\n  justify-content: center;\n  align-items: center;\n  width: 100%;\n  min-height: 100vh;\n  display: flex;\n}\n\n.scramble-section.u--bg-light {\n  background-color: #efeeec;\n}\n\n.scramble-heading {\n  text-align: center;\n  letter-spacing: -.03em;\n  text-transform: uppercase;\n  max-width: 12em;\n  margin: 0 auto;\n  font-family: RM Mono, Arial, sans-serif;\n  font-size: 3em;\n  font-weight: 400;\n  line-height: .9;\n}\n\n.scramble-button {\n  color: #131313;\n  text-transform: uppercase;\n  border: 1px dotted #000;\n  border-radius: .3125em;\n  padding: .5em 1em;\n  font-family: RM Mono, Arial, sans-serif;\n  font-size: 1em;\n  font-weight: 400;\n  text-decoration: none;\n}\n\n.scramble-button-text {\n  margin: 0;\n}\n\nStep 2: Add custom Javascript\n\ngsap.registerPlugin(ScrollTrigger, ScrambleTextPlugin, SplitText)\n\n// Function to reveal stuff on load\nfunction initScrambleOnLoad(){\n  let targets = document.querySelectorAll('[data-scramble=\"load\"]')\n  \n  targets.forEach((target) => {\n  \t// split into seperate words + letters \n    let split = new SplitText(target, {\n      type: \"words, chars\",\n      wordsClass: \"word\",\n      charsClass: \"char\"\n    });\n    \n    gsap.to(split.words, {\n      duration: 1.2,\n      stagger: 0.01,\n      scrambleText: {\n        text: \"{original}\",\n        chars: 'upperCase', // experiment with different scramble characters here\n        speed: 0.85,\n      },\n      // Once animation is done, revert the split to reduce DOM size\n      onComplete: () => split.revert()\n    });\n  });\n}\n\n// Function to reveal stuff on scroll\nfunction initScrambleOnScroll(){\n  let targets = document.querySelectorAll('[data-scramble=\"scroll\"]')\n  \n  targets.forEach((target) => {\n  \t// Used this attribute to showcase a different character scramble, can be replaced with many scenarios\n    let isAlternative = target.hasAttribute(\"data-scramble-alt\")\n    \n    let split = new SplitText(target, {\n      type: \"words, chars\",\n      wordsClass: \"word\",\n      charsClass: \"char\"\n    });\n    \n    gsap.to(split.words, {\n      duration: 1.4,\n      stagger: 0.015,\n      scrambleText: {\n        text: \"{original}\", \n        chars: isAlternative ? '\u25af|' : 'upperCase',  // experiment with different scramble characters here\n        speed: 0.95,\n      },\n      scrollTrigger: {\n        trigger: target,\n        start: \"top bottom\",\n        once: true\n      },\n      // Once animation is done, revert the split to reduce DOM size\n      onComplete: () => split.revert()\n    });\n  });\n}\n\nfunction initScrambleOnHover(){\n  let targets = document.querySelectorAll('[data-scramble-hover=\"link\"]')\n  \n  targets.forEach((target) => {\n    let textEl = target.querySelector('[data-scramble-hover=\"target\"]')\n    let originalText = textEl.textContent // save original text\n    let customHoverText = textEl.getAttribute(\"data-scramble-text\") // if this attribute is present, take a custom hover text\n    \n    let split = new SplitText(textEl, {\n      type: \"words, chars\",\n      wordsClass: \"word\",\n      charsClass: \"char\"\n    });\n    \n    target.addEventListener(\"mouseenter\", () => {\n      gsap.to(textEl, {\n        duration: 1,\n        scrambleText: {\n          text: customHoverText ? customHoverText : originalText,\n          chars: \"\u25ca\u25af\u2206|\"\n        }\n      });\n    });\n    \n    target.addEventListener(\"mouseleave\", () => {\n      gsap.to(textEl, {\n        duration: 0.6,\n        scrambleText: {\n          text: originalText,\n          speed: 2,\n          chars: \"\u25ca\u25af\u2206\"\n        }\n      });\n    });\n  });\n}\n\n// Initialize Scramble Functions\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  initScrambleOnLoad();\n  initScrambleOnScroll();\n  initScrambleOnHover();\n});\n\nImplementation\n\nIntroduction\nFrom my experience, first splitting the text into separate letters results in a nicer scramble effect than directly applying the scrambleText effect onto an element. This is a matter of preference though, and I definitely recommend playing around with it to find what you like best. To reduce the DOM size with all these separate characters, the script 'reverts' the splitting after the animation is done.\n\nApplication\nThe code above searches for any data-scramble=\"load\" and data-scramble=\"scroll\" elements on the page to reveal them, well, on load or scroll. As you'll see, adding the plugin is rather simple, and just goes in a regular GSAP tween. Definitely check out the GSAP Docs of the ScrambleTextPlugin to see all of the available options.",
    "id": "text-scramble-load-scroll-hover"
  },
  {
    "title": "cg-explode-text-on-scroll-matterjs",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Explode Text On Scroll | mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <section class=\"intro\">\n      <nav>\n        <p>Menu</p>\n        <p>Let's talk</p>\n      </nav>\n      <h1>mukta</h1>\n    </section>\n    <section class=\"sticky\">\n      <p>\n        mukta is a YouTube channel where you learn to code modern web designs\n        using HTML, CSS, JavaScript, React and NextJS. Focused on creating\n        aesthetic interfaces, web animations, and immersive experiences,\n        mukta draws inspiration from the captivating websites showcased on\n        platforms like Awwwards and Godly. With a keen eye for design, mukta\n        crafts elements and interfaces that exhibit a similar taste, often\n        employing the power of GSAP and ScrollTrigger. In a nutshell, mukta\n        is all about coding elite web designs. In 2017, inspired by the standout\n        designs of Awwwards, mukta emerged. Beyond merely admiring these\n        designs, there was a vision: to recreate them. The channel identified a\n        gap \u2014 although these designs were exceptional, there wasn't a clear\n        method for many to replicate them. It was this void that mukta sought\n        to fill. From its very inception, the platform has dedicated itself to\n        converting design marvels into structured, comprehensible guides for\n        coders of all proficiency levels. Recently, muktaPRO was introduced,\n        a subscription-based service tailored to the needs of passionate web\n        designers. As a PRO member, you gain exclusive access to source code for\n        each tutorial and monthly website templates. These resources are\n        carefully curated to support and inspire your creativity, helping you\n        take your web design skills to the next level. muktaPRO opens up a\n        realm of opportunities for professional growth and empowers you to bring\n        your ideas to life with ease.\n      </p>\n    </section>\n    <section class=\"outro\">\n      <h1>One subscription, endless web design.</h1>\n    </section>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js\"></script>\n    <script src=\"https://unpkg.com/split-type\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.0/gsap.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js\"></script>\n    <script src=\"https://unpkg.com/lenis@1.1.20/dist/lenis.min.js\"></script>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "document.addEventListener(\"DOMContentLoaded\", () => {\n  const lenis = new Lenis();\n  lenis.on(\"scroll\", ScrollTrigger.update);\n  gsap.ticker.add((time) => {\n    lenis.raf(time * 1000);\n  });\n  gsap.ticker.lagSmoothing(0);\n\n  const highlightWords = [\n    \"YouTube\",\n    \"aesthetic\",\n    \"immersive\",\n    \"exceptional\",\n    \"inspiration\",\n    \"recreate\",\n    \"void\",\n    \"passionate\",\n    \"PRO\",\n    \"creativity\",\n    \"life\",\n  ];\n\n  const text = new SplitType(\".sticky p\", { types: \"words\" });\n  const words = [...text.words];\n\n  const { Engine, Runner, World, Bodies, Body, Events } = Matter;\n  const engine = Engine.create({\n    gravity: { x: 0, y: 0 },\n  });\n  const runner = Runner.create();\n  Runner.run(runner, engine);\n\n  const floor = Bodies.rectangle(\n    window.innerWidth / 2,\n    window.innerHeight + 5,\n    window.innerWidth,\n    20,\n    { isStatic: true }\n  );\n  World.add(engine.world, floor);\n\n  const shuffledWords = [...words];\n  for (let i = shuffledWords.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [shuffledWords[i], shuffledWords[j]] = [shuffledWords[j], shuffledWords[i]];\n  }\n\n  const wordsToHighlight = words.filter((word) =>\n    highlightWords.some((highlight) => word.textContent.includes(highlight))\n  );\n\n  let physicsEnabled = false;\n  let lastProgress = 0;\n  const charElements = [];\n  const charBodies = [];\n\n  wordsToHighlight.forEach((word) => {\n    const chars = word.textContent.split(\"\");\n    const wordRect = word.getBoundingClientRect();\n    const stickyRect = document\n      .querySelector(\".sticky\")\n      .getBoundingClientRect();\n\n    word.style.opacity = 1;\n\n    chars.forEach((char, charIndex) => {\n      const charSpan = document.createElement(\"span\");\n      charSpan.className = \"char\";\n      charSpan.textContent = char;\n      charSpan.style.position = \"absolute\";\n      document.querySelector(\".sticky\").appendChild(charSpan);\n\n      const charWidth = word.offsetWidth / chars.length;\n      const x = wordRect.left - stickyRect.left + charIndex * charWidth;\n      const y = wordRect.top - stickyRect.top;\n\n      charSpan.style.left = `${x}px`;\n      charSpan.style.top = `${y}px`;\n      charSpan.style.color = getComputedStyle(word).color;\n      charElements.push(charSpan);\n\n      const body = Bodies.rectangle(\n        x + charWidth / 2,\n        y + charSpan.offsetHeight / 2,\n        charWidth,\n        charSpan.offsetHeight,\n        {\n          restitution: 0.75,\n          friction: 0.5,\n          frictionAir: 0.0175,\n          isStatic: true,\n        }\n      );\n\n      World.add(engine.world, body);\n      charBodies.push({\n        body,\n        element: charSpan,\n        initialX: x,\n        initialY: y,\n      });\n    });\n  });\n\n  function resetAnimation() {\n    engine.world.gravity.y = 0;\n\n    charBodies.forEach(({ body, element, initialX, initialY }) => {\n      Body.setStatic(body, true);\n      Body.setPosition(body, {\n        x: initialX + element.offsetWidth / 2,\n        y: initialY + element.offsetHeight / 2,\n      });\n      Body.setAngle(body, 0);\n      Body.setVelocity(body, { x: 0, y: 0 });\n      Body.setAngularVelocity(body, 0);\n\n      element.style.transform = \"none\";\n      element.style.opacity = 0;\n    });\n\n    words.forEach((word) => {\n      gsap.to(word, {\n        opacity: 1,\n        duration: 0.5,\n        ease: \"power2.in\",\n      });\n    });\n  }\n\n  const tl = gsap.timeline({\n    scrollTrigger: {\n      trigger: \".sticky\",\n      start: \"top top\",\n      end: `+=${window.innerHeight * 4}px`,\n      pin: true,\n      scrub: true,\n      onUpdate: (self) => {\n        const isScrollingDown = self.progress > lastProgress;\n        lastProgress = self.progress;\n\n        if (self.progress >= 0.6 && !physicsEnabled && isScrollingDown) {\n          physicsEnabled = true;\n          engine.world.gravity.y = 1;\n\n          wordsToHighlight.forEach((word) => {\n            word.style.opacity = 0;\n          });\n\n          charBodies.forEach(({ body, element }) => {\n            element.style.opacity = 1;\n            element.style.color = \"#FFFFFF\";\n            Body.setStatic(body, false);\n            Body.setAngularVelocity(body, (Math.random() - 0.5) * 0.25);\n            Body.setVelocity(body, {\n              x: (Math.random() - 0.5) * 5,\n              y: -Math.random() * 5,\n            });\n          });\n\n          gsap.to(\n            words.filter(\n              (word) =>\n                !highlightWords.some((hw) => word.textContent.includes(hw))\n            ),\n            {\n              opacity: 0,\n              duration: 0.5,\n              ease: \"power2.out\",\n            }\n          );\n        } else if (self.progress < 0.6 && physicsEnabled && !isScrollingDown) {\n          physicsEnabled = false;\n          resetAnimation();\n        }\n      },\n    },\n  });\n\n  const phase1 = gsap.timeline();\n  shuffledWords.forEach((word) => {\n    phase1.to(\n      word,\n      {\n        color: \"#EB4330\",\n        duration: 0.1,\n        ease: \"power2.inOut\",\n      },\n      Math.random() * 0.9\n    );\n  });\n\n  const phase2 = gsap.timeline();\n  const shuffledHighlights = [...wordsToHighlight];\n  for (let i = shuffledHighlights.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [shuffledHighlights[i], shuffledHighlights[j]] = [\n      shuffledHighlights[j],\n      shuffledHighlights[i],\n    ];\n  }\n\n  shuffledHighlights.forEach((word) => {\n    phase2.to(\n      word,\n      {\n        color: \"#FFFFFF\",\n        duration: 0.1,\n        ease: \"power2.inOut\",\n      },\n      Math.random() * 0.9\n    );\n  });\n\n  tl.add(phase1, 0).add(phase2, 1).to({}, { duration: 2 });\n\n  Events.on(engine, \"afterUpdate\", () => {\n    charBodies.forEach(({ body, element, initialX, initialY }) => {\n      if (physicsEnabled) {\n        const deltaX = body.position.x - (initialX + element.offsetWidth / 2);\n        const deltaY = body.position.y - (initialY + element.offsetHeight / 2);\n        element.style.transform = `translate(${deltaX}px, ${deltaY}px) rotate(${body.angle}rad)`;\n      }\n    });\n  });\n});\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: \"Space Mono\";\n  overflow-x: hidden;\n}\n\nsection {\n  position: relative;\n  width: 100vw;\n  height: 100vh;\n  padding: 2em;\n  overflow: hidden;\n}\n\n.intro,\n.outro {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.intro {\n  background-color: #ebeae4;\n  color: #0f0f0f;\n}\n\n.outro {\n  background-color: #eb4330;\n  color: #0f0f0f;\n}\n\nnav {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  padding: 2em;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\nnav p {\n  text-transform: uppercase;\n  font-size: 12px;\n  padding: 2px 8px;\n  border-radius: 20px;\n  background-color: #0f0f0f;\n  color: #ebeae4;\n}\n\n.sticky {\n  background-color: #0f0f0f;\n}\n\n.sticky p {\n  color: #0f0f0f;\n}\n\n.char {\n  display: inline-block;\n  position: absolute;\n  pointer-events: none;\n  opacity: 0;\n}\n"
    }
  },
  {
    "title": "cg-pixelated-text-hover-shaders",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Text Hover Effect Using Shaders | @mukta</title>\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n  </head>\n  <body>\n    <div id=\"textContainer\"></div>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/0.155.0/three.min.js\"></script>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "const textContainer = document.getElementById(\"textContainer\");\nlet easeFactor = 0.02;\nlet scene, camera, renderer, planeMesh;\nlet mousePosition = { x: 0.5, y: 0.5 };\nlet targetMousePosition = { x: 0.5, y: 0.5 };\nlet prevPosition = { x: 0.5, y: 0.5 };\n\nconst vertexShader = `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n\nconst fragmentShader = `\n  varying vec2 vUv;\n  uniform sampler2D u_texture;\n  uniform vec2 u_mouse;\n  uniform vec2 u_prevMouse;\n\n  void main() {\n    vec2 gridUV = floor(vUv * vec2(40.0, 40.0)) / vec2(40.0, 40.0);\n    vec2 centerOfPixel = gridUV + vec2(1.0/40.0, 1.0/40.0);\n\n    vec2 mouseDirection = u_mouse - u_prevMouse;\n\n    vec2 pixelToMouseDirection = centerOfPixel - u_mouse;\n    float pixelDistanceToMouse = length(pixelToMouseDirection);\n    float strength = smoothstep(0.3, 0.0, pixelDistanceToMouse);\n\n    vec2 uvOffset = strength * -mouseDirection * 0.4;\n    vec2 uv = vUv - uvOffset;\n\n    vec4 color = texture2D(u_texture, uv);\n    gl_FragColor = color;\n  }\n`;\n\nfunction createTextTexture(text, font, size, color, fontWeight = \"100\") {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n\n  const canvasWidth = window.innerWidth * 2;\n  const canvasHeight = window.innerHeight * 2;\n\n  canvas.width = canvasWidth;\n  canvas.height = canvasHeight;\n\n  ctx.fillStyle = color || \"#ffffff\";\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  const fontSize = size || Math.floor(canvasWidth * 2);\n\n  ctx.fillStyle = \"#1a1a1a\";\n  ctx.font = `${fontWeight} ${fontSize}px \"${font || \"Blanquotey\"}\"`;\n  ctx.textAlign = \"center\";\n  ctx.textBaseline = \"middle\";\n\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = \"high\";\n\n  const textMetrics = ctx.measureText(text);\n  const textWidth = textMetrics.width;\n\n  const scaleFactor = Math.min(1, (canvasWidth * 1) / textWidth);\n  const aspectCorrection = canvasWidth / canvasHeight;\n\n  ctx.setTransform(\n    scaleFactor,\n    0,\n    0,\n    scaleFactor / aspectCorrection,\n    canvasWidth / 2,\n    canvasHeight / 2\n  );\n\n  ctx.strokeStyle = \"#1a1a1a\";\n  ctx.lineWidth = fontSize * 0.005;\n  for (let i = 0; i < 3; i++) {\n    ctx.strokeText(text, 0, 0);\n  }\n  ctx.fillText(text, 0, 0);\n\n  return new THREE.CanvasTexture(canvas);\n}\n\nfunction initializeScene(texture) {\n  scene = new THREE.Scene();\n\n  const aspectRatio = window.innerWidth / window.innerHeight;\n  camera = new THREE.OrthographicCamera(\n    -1,\n    1,\n    1 / aspectRatio,\n    -1 / aspectRatio,\n    0.1,\n    1000\n  );\n  camera.position.z = 1;\n\n  let shaderUniforms = {\n    u_mouse: { type: \"v2\", value: new THREE.Vector2() },\n    u_prevMouse: { type: \"v2\", value: new THREE.Vector2() },\n    u_texture: { type: \"t\", value: texture },\n  };\n\n  planeMesh = new THREE.Mesh(\n    new THREE.PlaneGeometry(2, 2),\n    new THREE.ShaderMaterial({\n      uniforms: shaderUniforms,\n      vertexShader,\n      fragmentShader,\n    })\n  );\n\n  scene.add(planeMesh);\n\n  renderer = new THREE.WebGLRenderer({ antialias: true });\n  renderer.setClearColor(0xffffff, 1);\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  renderer.setPixelRatio(window.devicePixelRatio);\n\n  textContainer.appendChild(renderer.domElement);\n}\n\nfunction reloadTexture() {\n  const newTexture = createTextTexture(\n    \"zayno\",\n    \"Blanquotey\",\n    null,\n    \"#ffffff\",\n    \"100\"\n  );\n  planeMesh.material.uniforms.u_texture.value = newTexture;\n}\n\ninitializeScene(\n  createTextTexture(\"zayno\", \"Blanquotey\", null, \"#ffffff\", \"100\")\n);\n\nfunction animateScene() {\n  requestAnimationFrame(animateScene);\n\n  mousePosition.x += (targetMousePosition.x - mousePosition.x) * easeFactor;\n  mousePosition.y += (targetMousePosition.y - mousePosition.y) * easeFactor;\n\n  planeMesh.material.uniforms.u_mouse.value.set(\n    mousePosition.x,\n    1.0 - mousePosition.y\n  );\n\n  planeMesh.material.uniforms.u_prevMouse.value.set(\n    prevPosition.x,\n    1.0 - prevPosition.y\n  );\n\n  renderer.render(scene, camera);\n}\n\nanimateScene();\n\ntextContainer.addEventListener(\"mousemove\", handleMouseMove);\ntextContainer.addEventListener(\"mouseenter\", handleMouseEnter);\ntextContainer.addEventListener(\"mouseleave\", handleMouseLeave);\n\nfunction handleMouseMove(event) {\n  easeFactor = 0.035;\n  let rect = textContainer.getBoundingClientRect();\n  prevPosition = { ...targetMousePosition };\n\n  targetMousePosition.x = (event.clientX - rect.left) / rect.width;\n  targetMousePosition.y = (event.clientY - rect.top) / rect.height;\n}\n\nfunction handleMouseEnter(event) {\n  easeFactor = 0.01;\n  let rect = textContainer.getBoundingClientRect();\n\n  mousePosition.x = targetMousePosition.x =\n    (event.clientX - rect.left) / rect.width;\n  mousePosition.y = targetMousePosition.y =\n    (event.clientY - rect.top) / rect.height;\n}\n\nfunction handleMouseLeave() {\n  easeFactor = 0.01;\n  targetMousePosition = { ...prevPosition };\n}\n\nwindow.addEventListener(\"resize\", onWindowResize, false);\n\nfunction onWindowResize() {\n  const aspectRatio = window.innerWidth / window.innerHeight;\n  camera.left = -1;\n  camera.right = 1;\n  camera.top = 1 / aspectRatio;\n  camera.bottom = -1 / aspectRatio;\n  camera.updateProjectionMatrix();\n\n  renderer.setSize(window.innerWidth, window.innerHeight);\n\n  reloadTexture();\n}\n",
      "styles.css": "@import url(\"https://fonts.cdnfonts.com/css/blanquotey\");\n\nbody,\nhtml {\n  margin: 0;\n  padding: 0;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  background-color: #ffffff;\n  font-family: \"Blanquotey\", sans-serif;\n}\n\n#textContainer {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\ncanvas {\n  position: absolute;\n  top: 45%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  display: block;\n  width: 100%;\n  height: 100%;\n}\n"
    }
  },
  {
    "title": "cg-radial-rotating-texts",
    "code": {
      "data.js": "export const interiors = [\n  { id: 1, name: \"Lunar Horizon Lounge\" },\n  { id: 2, name: \"Martian Red Quarters\" },\n  { id: 3, name: \"Orbit Oasis Chamber\" },\n  { id: 4, name: \"Neon Nexus Home\" },\n  { id: 5, name: \"Quantum Quiet Quarters\" },\n  { id: 6, name: \"Galactic Gateway Studio\" },\n  { id: 7, name: \"Starlight Sky Suite\" },\n  { id: 8, name: \"Void Vector Villa\" },\n  { id: 9, name: \"Cosmic Cove Nook\" },\n  { id: 10, name: \"Satellite Space Site\" },\n  { id: 11, name: \"Plasma Peak Penthouse\" },\n  { id: 12, name: \"Asteroid Alley Loft\" },\n  { id: 13, name: \"Celestial City Condo\" },\n  { id: 14, name: \"Pulsar Point Pavilion\" },\n  { id: 15, name: \"Gravity Garden Suite\" },\n  { id: 16, name: \"Interstellar Ivy Inn\" },\n  { id: 17, name: \"Nebula Nest Nook\" },\n  { id: 18, name: \"Exoplanet Escape Estate\" },\n  { id: 19, name: \"Meteorite Mansion Den\" },\n  { id: 20, name: \"Black Hole Bungalow\" },\n  { id: 21, name: \"Warp World Workshop\" },\n  { id: 22, name: \"Photon Particle Pod\" },\n  { id: 23, name: \"Dark Matter Den\" },\n  { id: 24, name: \"Event Horizon Home\" },\n  { id: 25, name: \"Solar Flare Studio\" },\n  { id: 26, name: \"Quantum Leap Lounge\" },\n  { id: 27, name: \"Supernova Sun Suite\" },\n  { id: 28, name: \"Eclipse Edge Enclave\" },\n  { id: 29, name: \"Galaxy Garden Gazebo\" },\n  { id: 30, name: \"Time Traveler Terrace\" },\n  { id: 31, name: \"Orbital Observatory Outpost\" },\n  { id: 32, name: \"Gravity Grove Grotto\" },\n  { id: 33, name: \"Cmuktas Cottage Core\" },\n  { id: 34, name: \"Space-Time Spiral Studio\" },\n  { id: 35, name: \"Alien Array Atrium\" },\n  { id: 36, name: \"Dimensional Dome Dwelling\" },\n  { id: 37, name: \"Vortex Valley Villa\" },\n  { id: 38, name: \"Starship Station Studio\" },\n  { id: 39, name: \"Quantum Quasar Quarters\" },\n  { id: 40, name: \"Planetary Plaza Penthouse\" },\n  { id: 41, name: \"Rocket Range Room\" },\n  { id: 42, name: \"Spectrum Spire Space\" },\n  { id: 43, name: \"Terraforming Tower Terrace\" },\n  { id: 44, name: \"Universe Utopia Unit\" },\n  { id: 45, name: \"Void Vista View\" },\n  { id: 46, name: \"Wormhole Wall Window\" },\n  { id: 47, name: \"Xenon Xeriscape Xanadu\" },\n  { id: 48, name: \"Yield Yacht Yard\" },\n  { id: 49, name: \"Zenith Zone Zephyr\" },\n  { id: 50, name: \"Alpha Aurora Atrium\" },\n  { id: 51, name: \"Beta Bridge Bastion\" },\n  { id: 52, name: \"Gamma Garden Gateway\" },\n  { id: 53, name: \"Delta Dome Den\" },\n  { id: 54, name: \"Epsilon Echo Estate\" },\n  { id: 55, name: \"Zeta Zenith Zone\" },\n  { id: 56, name: \"Eta Echo Enclave\" },\n  { id: 57, name: \"Theta Theater Thicket\" },\n  { id: 58, name: \"Iota Island Inn\" },\n  { id: 59, name: \"Kappa Keep Kiosk\" },\n  { id: 60, name: \"Lambda Loft Lounge\" },\n];\n",
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>radial/rotating text layout | @mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <div class=\"cursor\"></div>\n\n    <nav>\n      <a href=\"#\">mukta <span>/</span> 16 06 2024</a>\n      <p>Unlock Source Code with PRO</p>\n    </nav>\n\n    <footer>\n      <div class=\"links\">\n        <a href=\"#\">Subscribe</a>\n        <a href=\"#\">Instagram</a>\n        <a href=\"#\">Twitter</a>\n      </div>\n      <p>Link in description</p>\n    </footer>\n\n    <div class=\"container\">\n      <div class=\"gallery\"></div>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.3/gsap.min.js\"></script>\n    <script type=\"module\" src=\"./data.js\"></script>\n    <script type=\"module\" src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "import { interiors } from \"./data.js\";\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  const cursor = document.querySelector(\".cursor\");\n  const gallery = document.querySelector(\".gallery\");\n  const numberOfItems = 60;\n  const radius = 1100;\n  const centerX = window.innerWidth / 2;\n  const centerY = window.innerHeight / 2;\n  const angleIncrement = (2 * Math.PI) / numberOfItems;\n\n  for (let i = 0; i < numberOfItems; i++) {\n    const item = document.createElement(\"div\");\n    item.className = \"item\";\n    const p = document.createElement(\"p\");\n    const count = document.createElement(\"span\");\n    p.textContent = interiors[i].name;\n    count.textContent = `(${Math.floor(Math.random() * 50) + 1})`;\n    item.appendChild(p);\n    p.appendChild(count);\n    gallery.appendChild(item);\n\n    const angle = i * angleIncrement;\n    const x = centerX + radius * Math.cos(angle);\n    const y = centerY + radius * Math.sin(angle);\n    const rotation = (angle * 180) / Math.PI;\n\n    gsap.set(item, {\n      x: x + \"px\",\n      y: y + \"px\",\n      rotation: rotation,\n    });\n\n    item.addEventListener(\"mouseover\", function () {\n      const imgSrc = `./assets/img${i + 1}.jpg`;\n      const img = document.createElement(\"img\");\n      img.src = imgSrc;\n      img.style.clipPath = \" polygon(0% 100%, 100% 100%, 100% 100%, 0% 100%)\";\n      cursor.appendChild(img);\n\n      gsap.to(img, {\n        clipPath: \"polygon(0% 100%, 100% 100%, 100% 0%, 0% 0%)\",\n        duration: 1,\n        ease: \"power3.out\",\n      });\n    });\n\n    item.addEventListener(\"mouseout\", function () {\n      const imgs = cursor.getElementsByTagName(\"img\");\n      if (imgs.length) {\n        const lastImg = imgs[imgs.length - 1];\n        Array.from(imgs).forEach((img, index) => {\n          if (img !== lastImg) {\n            gsap.to(img, {\n              clipPath: \"polygon(0% 0%, 100% 0%, 100% 0%, 0% 0%)\",\n              duration: 1,\n              delay: 0.5,\n              ease: \"power3.out\",\n              onComplete: () => {\n                setTimeout(() => {\n                  img.remove();\n                }, 1000);\n              },\n            });\n          }\n        });\n\n        gsap.to(lastImg, {\n          clipPath: \"polygon(0% 0%, 100% 0%, 100% 0%, 0% 0%)\",\n          duration: 1,\n          ease: \"power3.out\",\n          delay: 0.25,\n        });\n      }\n    });\n  }\n\n  function updatePosition() {\n    const scrollAmount = window.scrollY * 0.0001;\n    document.querySelectorAll(\".item\").forEach(function (item, index) {\n      const angle = index * angleIncrement + scrollAmount;\n      const x = centerX + radius * Math.cos(angle);\n      const y = centerY + radius * Math.sin(angle);\n      const rotation = (angle * 180) / Math.PI;\n\n      gsap.to(item, {\n        duration: 0.05,\n        x: x + \"px\",\n        y: y + \"px\",\n        rotation: rotation,\n        ease: \"elastic.out(1,0.3)\",\n      });\n    });\n  }\n\n  updatePosition();\n  document.addEventListener(\"scroll\", updatePosition);\n\n  document.addEventListener(\"mousemove\", function (e) {\n    gsap.to(cursor, {\n      x: e.clientX - 150,\n      y: e.clientY - 200,\n      duration: 1,\n      ease: \"power3.out\",\n    });\n  });\n});\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  width: 100%;\n  height: 3000vh;\n  background: #000;\n  font-family: \"Circular Std\";\n}\n\nimg {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\n.cursor {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 300px;\n  height: 400px;\n  z-index: 0;\n  pointer-events: none;\n}\n\nnav,\nfooter {\n  position: fixed;\n  width: 100%;\n  padding: 2em;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  z-index: 2;\n  mix-blend-mode: difference;\n}\n\na,\np {\n  text-decoration: none;\n  color: #fff;\n  font-size: 14px;\n}\n\na span {\n  padding: 0 2em;\n}\n\n.links {\n  display: flex;\n  gap: 2em;\n}\n\nnav {\n  top: 0;\n}\nfooter {\n  bottom: 0;\n}\n\n.gallery {\n  position: fixed;\n  width: 200%;\n  height: 100%;\n  left: -75%;\n  overflow: hidden;\n}\n\n.item {\n  position: absolute;\n  top: 0;\n  left: 0;\n  transform: translate(-50%, -50%);\n  width: 800px;\n  height: 80px;\n  cursor: pointer;\n}\n\n.item p {\n  width: 100%;\n  font-size: 42px;\n  font-weight: 500;\n  text-transform: uppercase;\n  color: #fff;\n}\n\n.item p span {\n  padding: 0 20px;\n  font-size: 16px;\n}\n"
    }
  },
  {
    "title": "cg-text-hover-effect",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Text Hover Animation | @mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <div class=\"hero-copy\">\n      <p>\n        We are a digital agency. From concept to <span>execution</span>, we\n        design experiences, <span>products</span> and services that help our\n        international <span>clients</span> create emotional and meaningful\n        <span>connections</span> between their brand and people.\n      </p>\n    </div>\n    <nav>\n      <p>\n        mukta &nbsp;&nbsp;&nbsp;&nbsp; / &nbsp;&nbsp;&nbsp;&nbsp;26092017\n      </p>\n      <p>Youtube</p>\n    </nav>\n    <footer>\n      <p>Subscribe</p>\n      <p>muktaPRO</p>\n    </footer>\n    <div class=\"container\">\n      <div class=\"gallery\">\n        <div class=\"item\"></div>\n        <div class=\"item\"></div>\n        <div class=\"item\"></div>\n        <div class=\"item\"></div>\n        <div class=\"item\"></div>\n        <div class=\"item\"></div>\n        <div class=\"item\"></div>\n        <div class=\"item\"></div>\n        <div class=\"item\"></div>\n        <div class=\"item\"></div>\n        <div class=\"item\"></div>\n      </div>\n    </div>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.3/gsap.min.js\"></script>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "window.onload = function () {\n  const items = document.querySelectorAll(\".item\");\n  const container = document.querySelector(\".container\");\n  const spans = document.querySelectorAll(\".hero-copy span\");\n  const numberOfItems = items.length;\n  const angleIncrement = (2 * Math.PI) / numberOfItems;\n  const radius = 300;\n  let currentAngle = 0;\n  let isMouseOverSpan = false;\n  let targetX = 0,\n    targetY = 0;\n  let currentX = 0,\n    currentY = 0;\n\n  const basePath = \"./assets/\";\n  items.forEach((item, index) => {\n    let img = document.createElement(\"img\");\n    img.src = basePath + \"img\" + (index + 1) + \".jpg\";\n    img.alt = \"Image \" + (index + 1);\n    item.appendChild(img);\n  });\n\n  const updateGallery = (mouseX, mouseY, show = true) => {\n    targetX = mouseX - container.getBoundingClientRect().left;\n    targetY = mouseY - container.getBoundingClientRect().top;\n\n    currentX += (targetX - currentX) * 0.1;\n    currentY += (targetY - currentY) * 0.1;\n\n    items.forEach(function (item, index) {\n      const angle = currentAngle + index * angleIncrement;\n      const x = currentX + radius * Math.cos(angle) - item.offsetWidth / 2;\n      const y = currentY + radius * Math.sin(angle) - item.offsetHeight / 2;\n\n      gsap.to(item, {\n        x: x,\n        y: y,\n        opacity: show ? 1 : 0,\n        duration: 0.5,\n        ease: \"power1.out\",\n      });\n    });\n  };\n\n  spans.forEach((span) => {\n    span.addEventListener(\"mouseenter\", (e) => {\n      isMouseOverSpan = true;\n      updateGallery(e.clientX, e.clientY, true);\n    });\n\n    span.addEventListener(\"mousemove\", (e) => {\n      if (isMouseOverSpan) {\n        targetX = e.clientX - 800;\n        targetY = e.clientY - 450;\n      }\n    });\n\n    span.addEventListener(\"mouseleave\", () => {\n      isMouseOverSpan = false;\n      updateGallery(0, 0, false);\n    });\n  });\n\n  gsap.ticker.add(() => {\n    currentAngle += 0.005;\n    if (currentAngle > 2 * Math.PI) {\n      currentAngle -= 2 * Math.PI;\n    }\n    if (isMouseOverSpan) {\n      updateGallery(targetX, targetY, true);\n    }\n  });\n\n  document.querySelectorAll(\".hero-copy span\").forEach((span) => {\n    span.addEventListener(\"mouseenter\", () => {\n      span.parentNode.style.color = \"#545454\";\n    });\n\n    span.addEventListener(\"mouseleave\", () => {\n      span.parentNode.style.color = \"#fff\";\n    });\n  });\n};\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  width: 100%;\n  height: 100vh;\n  font-family: \"Timmons NY\", sans-serif;\n  background: #000;\n}\n\nimg {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\nnav,\nfooter {\n  position: fixed;\n  width: 100%;\n  display: flex;\n  justify-content: space-between;\n  padding: 1em;\n  text-transform: uppercase;\n  font-size: 30px;\n  color: #fff;\n}\n\nnav {\n  top: 0;\n}\n\nfooter {\n  bottom: 0;\n}\n\n.container {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  pointer-events: none;\n}\n\n.gallery {\n  pointer-events: none;\n}\n\n.item {\n  pointer-events: none;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 100px;\n  height: 70px;\n  background: #b0b0b0;\n  margin: 10px;\n  opacity: 0;\n}\n\n.hero-copy {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.hero-copy p {\n  font-size: 50px;\n  font-family: \"FK Grotesk Neue\";\n  color: #fff;\n  text-align: center;\n  letter-spacing: -0.04em;\n  line-height: 110%;\n}\n\n.hero-copy p span {\n  cursor: pointer;\n  font-family: \"FK Raster Grotesk\";\n  position: relative;\n  z-index: 1;\n  display: inline-block;\n}\n\n.hero-copy p span:hover {\n  color: #fff;\n}\n"
    }
  },
  {
    "title": "cg-text-shuffle-animation-updated",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>\n      Text Shuffle Animation | Awwwards Rebuild - Reframed | mukta\n    </title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <div class=\"container\">\n      <nav>\n        <div id=\"item-1\">ideas</div>\n        <div id=\"item-2\">about</div>\n      </nav>\n      <footer>\n        <div id=\"item-3\">save</div>\n        <div id=\"item-4\">contact</div>\n      </footer>\n\n      <div class=\"header\">\n        <div class=\"placeholder\">CGPRO</div>\n        <p id=\"subheader\">One subscription. Endless web design.</p>\n      </div>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js\"></script>\n    <script>\n      const subHeaders = [\n        \"top-notch web design components.\",\n        \"forging ahead with elite web designs.\",\n        \"take the fast lane to mastery.\",\n        \"bring your projects to life, quicker than ever.\"\n      ];\n      const items = document.querySelectorAll('#item-1, #item-2, #item-3, #item-4');\n      const placeholder = document.querySelector('.placeholder');\n      const subheader = document.querySelector('#subheader');\n\n      function changeColors() {\n        gsap.to('.container', { backgroundColor: '#000', duration: 0.5 });\n        gsap.to('.placeholder, nav, footer, p', { color: '#fff', duration: 0.5 });\n      }\n\n      function revertColors() {\n        gsap.to('.container', { backgroundColor: '#e3e3e3', duration: 0.5 });\n        gsap.to('.placeholder, nav, footer, p', { color: '#000', duration: 0.5 });\n      }\n\n      items.forEach((item) => {\n        item.addEventListener('mouseover', changeColors);\n        item.addEventListener('mouseout', revertColors);\n      });\n\n      function animateScale(element, scaleValue) {\n        gsap.fromTo(element, { scale: 1 }, { scale: scaleValue, duration: 2, ease: \"power1.out\" });\n      }\n\n      function wrapLetters(text) {\n        placeholder.innerHTML = '';\n        [...text].forEach(letter => {\n          const span = document.createElement('span');\n          span.style.filter = 'blur(8px)';\n          span.textContent = letter;\n          placeholder.appendChild(span);\n        });\n      }\n\n      function animateBlurEffect() {\n        const letters = placeholder.children;\n        let index = 0;\n\n        function clearNextLetter() {\n          if (index < letters.length) {\n            gsap.to(letters[index], { filter: 'blur(0px)', duration: 0.5 });\n            index++;\n            if (index < letters.length) {\n              setTimeout(clearNextLetter, 100);\n            }\n          }\n        }\n\n        setTimeout(clearNextLetter, 0);\n      }\n\n      function shuffleLetters(finalText) {\n        wrapLetters('');\n        wrapLetters(finalText.replace(/./g, ' '));\n\n        let textArray = finalText.split('');\n        let shufflingCounter = 0;\n        let intervalHandles = [];\n\n        function shuffle(index) {\n          if (shufflingCounter < 30) {\n            textArray[index] = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 26)];\n            placeholder.children[index].textContent = textArray[index];\n          } else {\n            placeholder.children[index].textContent = finalText.charAt(index);\n            clearInterval(intervalHandles[index]);\n          }\n        }\n\n        for (let i = 0; i < finalText.length; i++) {\n          intervalHandles[i] = setInterval(shuffle, 80, i);\n        }\n\n        setTimeout(() => {\n          shufflingCounter = 30;\n          for (let i = 0; i < finalText.length; i++) {\n            placeholder.children[i].textContent = finalText.charAt(i);\n            clearInterval(intervalHandles[i]);\n          }\n          animateBlurEffect();\n        }, 1000);\n      }\n\n      function updatePlaceholderText(event) {\n        const newText = event.target.textContent.toUpperCase();\n        const itemIndex = Array.from(items).indexOf(event.target);\n        const newSubHeaderText = subHeaders[itemIndex];\n        shuffleLetters(newText);\n\n        gsap.to('#subheader', { opacity: 0, duration: 0.3, delay: -0.1, onComplete: () => {\n          gsap.to('#subheader', { opacity: 1, duration: 0.5, delay: 0.3 });\n        }, });\n\n        setTimeout(() => {\n            subheader.textContent = newSubHeaderText;\n        }, 450)\n        animateScale(placeholder, 1.25);\n      }\n\n      function resetPlaceholderText() {\n        const defaultText = 'CGPRO';\n        const defaultSubHeaderText = 'ONE SUBSCRIPTION. ENDLESS WEB DESIGNS.';\n        shuffleLetters(defaultText);\n\n        gsap.to('#subheader', { opacity: 0, duration: 0.3, delay: -0.1, onComplete: () => {\n          gsap.to('#subheader', { opacity: 1, duration: 0.5, delay: 0.3 });\n        }});\n\n        setTimeout(() => {\n            subheader.textContent = defaultSubHeaderText;\n        }, 450)\n        animateScale(placeholder, 1.25);\n      }\n\n      items.forEach((item) => {\n        item.addEventListener('mouseover', updatePlaceholderText);\n        item.addEventListener('mouseout', resetPlaceholderText);\n      });\n    </script>\n  </body>\n</html>\n",
      "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nhtml, body {\n    width: 100vw;\n    height: 100vh;\n    overflow: hidden;\n}\n\n.container {\n    width: 100%;\n    height: 100%;\n    font-family: \"Neue Montreal\";\n    text-transform: uppercase;\n    background: #e3e3e3;\n}\n\nnav, footer {\n    position: absolute;\n    padding: 2em;\n    width: 100%;\n    display: flex;\n    justify-content: space-between;\n}\n\nfooter {\n    bottom: 0;\n}\n\nnav > div, footer > div {\n  padding: 2em;\n  cursor: pointer;\n}\n\n.header {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    width: 75%;\n}\n\np {\n  text-align: center;\n  font-size: 12px;\n}\n\n.placeholder {\n    text-align: center;\n    font-family: \"Torwelten\";\n    font-size: 80px;\n    color: #000;\n    line-height: 2.25;\n}"
    }
  },
  {
    "title": "cg-var-font-anim",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>ScrollTrigger Variable Fonts + Marquee Animation | @mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <div class=\"container\">\n      <section class=\"hero\">\n        <img src=\"./assets/hero.jpg\" alt=\"\" />\n      </section>\n\n      <section class=\"about\">\n        <p>\n          Step into a surreal and immersive experience with our Dreamy 3D World\n          Dystopian series. This captivating realm invites you to explore a\n          world where reality and fantasy intertwine, creating a unique blend of\n          striking visuals and thought-provoking narratives.\n        </p>\n      </section>\n\n      <section class=\"marquees\">\n        <div class=\"marquee-container\" id=\"marquee-1\">\n          <div class=\"marquee\">\n            <div class=\"item\"><img src=\"./assets/img1.jpg\" alt=\"\" /></div>\n            <div class=\"item with-text\"><h1>Unique</h1></div>\n            <div class=\"item\"><img src=\"./assets/img2.jpg\" alt=\"\" /></div>\n            <div class=\"item\"><img src=\"./assets/img3.jpg\" alt=\"\" /></div>\n            <div class=\"item\"><img src=\"./assets/img4.jpg\" alt=\"\" /></div>\n          </div>\n        </div>\n        <div class=\"marquee-container\" id=\"marquee-2\">\n          <div class=\"marquee\">\n            <div class=\"item\"><img src=\"./assets/img5.jpg\" alt=\"\" /></div>\n            <div class=\"item\"><img src=\"./assets/img6.jpg\" alt=\"\" /></div>\n            <div class=\"item\"><img src=\"./assets/img7.jpg\" alt=\"\" /></div>\n            <div class=\"item with-text\"><h1>Release</h1></div>\n            <div class=\"item\"><img src=\"./assets/img8.jpg\" alt=\"\" /></div>\n          </div>\n        </div>\n        <div class=\"marquee-container\" id=\"marquee-3\">\n          <div class=\"marquee\">\n            <div class=\"item\"><img src=\"./assets/img9.jpg\" alt=\"\" /></div>\n            <div class=\"item with-text\"><h1>2500</h1></div>\n            <div class=\"item\"><img src=\"./assets/img10.jpg\" alt=\"\" /></div>\n            <div class=\"item\"><img src=\"./assets/img11.jpg\" alt=\"\" /></div>\n            <div class=\"item\"><img src=\"./assets/img12.jpg\" alt=\"\" /></div>\n          </div>\n        </div>\n        <div class=\"marquee-container\" id=\"marquee-4\">\n          <div class=\"marquee\">\n            <div class=\"item\"><img src=\"./assets/img13.jpg\" alt=\"\" /></div>\n            <div class=\"item\"><img src=\"./assets/img14.jpg\" alt=\"\" /></div>\n            <div class=\"item\"><img src=\"./assets/img15.jpg\" alt=\"\" /></div>\n            <div class=\"item with-text\"><h1>Rarity</h1></div>\n            <div class=\"item\"><img src=\"./assets/img16.jpg\" alt=\"\" /></div>\n          </div>\n        </div>\n      </section>\n\n      <section class=\"services\">\n        <p>\n          In this meticulously designed dystopian world, you'll find yourself\n          immersed in stories of resilience and intrigue.\n        </p>\n      </section>\n\n      <section class=\"footer\">\n        <h1>The End</h1>\n      </section>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js\"></script>\n    <script src=\"https://unpkg.com/split-type\"></script>\n    <script src=\"https://unpkg.com/lenis@1.1.5/dist/lenis.min.js\"></script>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "document.addEventListener(\"DOMContentLoaded\", () => {\n  gsap.registerPlugin(ScrollTrigger);\n\n  function animateChars(chars, reverse = false) {\n    const staggerOptions = {\n      each: 0.35,\n      from: reverse ? \"start\" : \"end\",\n      ease: \"linear\",\n    };\n\n    gsap.fromTo(\n      chars,\n      { fontWeight: 100 },\n      {\n        fontWeight: 900,\n        duration: 1,\n        ease: \"none\",\n        stagger: staggerOptions,\n        scrollTrigger: {\n          trigger: chars[0].closest(\".marquee-container\"),\n          start: \"50% bottom\",\n          end: \"top top\",\n          scrub: true,\n        },\n      }\n    );\n  }\n\n  const splitText = new SplitType(\".item h1\", { types: \"chars\" });\n\n  const marqueeContainers = document.querySelectorAll(\".marquee-container\");\n\n  marqueeContainers.forEach((container, index) => {\n    let start = \"0%\";\n    let end = \"-15%\";\n\n    if (index % 2 === 0) {\n      start = \"0%\";\n      end = \"10%\";\n    }\n\n    const marquee = container.querySelector(\".marquee\");\n    const words = marquee.querySelectorAll(\".item h1\");\n\n    gsap.fromTo(\n      marquee,\n      {\n        x: start,\n      },\n      {\n        x: end,\n        scrollTrigger: {\n          trigger: container,\n          start: \"top bottom\",\n          end: \"150% top\",\n          scrub: true,\n        },\n      }\n    );\n\n    words.forEach((word) => {\n      const chars = Array.from(word.querySelectorAll(\".char\"));\n      if (chars.length) {\n        const reverse = index % 2 !== 0;\n        animateChars(chars, reverse);\n      }\n    });\n  });\n\n  const lenis = new Lenis();\n  lenis.on(\"scroll\", ScrollTrigger.update);\n  gsap.ticker.add((time) => lenis.raf(time * 1000));\n  gsap.ticker.lagSmoothing(0);\n});\n",
      "styles.css": "@font-face {\n  font-family: \"Big Shoulders Display\";\n  src: url(\"./fonts/BigShouldersDisplay.ttf\") format(\"woff2-variations\");\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  width: 100%;\n  height: 100%;\n  font-family: \"Big Shoulders Display\";\n  overflow-x: hidden;\n}\n\nimg {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\np {\n  font-size: 42px;\n  font-weight: 500;\n  text-transform: uppercase;\n}\n\nsection {\n  width: 100%;\n  height: 100vh;\n}\n\nsection.about,\nsection.services {\n  padding: 4em;\n  background: #87795f;\n}\n\nsection.footer {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: #13120e;\n  color: #87795f;\n}\n\nsection.footer h1 {\n  font-size: 10vw;\n  text-transform: uppercase;\n}\n\nsection.marquees {\n  height: 150vh;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  background-color: #fff;\n}\n\n.marquee-container {\n  position: relative;\n  width: 125%;\n  height: 250px;\n  display: flex;\n  gap: 1em;\n  margin-bottom: 1em;\n  overflow: hidden;\n}\n\n.marquee {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 50%;\n  left: 0;\n  transform: translateY(-50%);\n  display: flex;\n  gap: 1em;\n}\n\n#marquee-1 .marquee,\n#marquee-3 .marquee {\n  left: -15%;\n}\n\n.item {\n  flex: 1;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.item.with-text {\n  flex: 1.5;\n}\n\n.item h1 {\n  text-transform: uppercase;\n  font-size: 140px;\n}\n\n@media (max-width: 900px) {\n  section.marquees {\n    height: 100vh;\n  }\n\n  .marquee-container {\n    width: 250%;\n    height: 150px;\n  }\n\n  #marquee-2 .marquee,\n  #marquee-4 .marquee {\n    left: -35%;\n  }\n\n  .item.with-text {\n    flex: 1;\n  }\n\n  .item h1 {\n    font-size: 60px;\n  }\n}\n\n/* lenis scroll */\nhtml.lenis,\nhtml.lenis body {\n  height: auto;\n}\n\n.lenis.lenis-smooth {\n  scroll-behavior: auto !important;\n}\n\n.lenis.lenis-smooth [data-lenis-prevent] {\n  overscroll-behavior: contain;\n}\n\n.lenis.lenis-stopped {\n  overflow: hidden;\n}\n\n.lenis.lenis-smooth iframe {\n  pointer-events: none;\n}\n"
    }
  },
  {
    "title": "mukta-menuxl-text-displacement-animation",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>MenuXL Text Displacement Animation | mukta</title>\n    <link rel=\"stylesheet\" href=\"/styles.css\" />\n  </head>\n  <body>\n    <div class=\"container\">\n      <h1 class=\"anime-header\">one subscription</h1>\n\n      <p class=\"anime-text\">\n        Sharing all the sauce behind building dope interactive experiences and\n        the finest websites that truly stand out. Recently, muktaPRO was\n        introduced, a subscription-based service tailored to the needs of\n        passionate web designers. As a PRO member, you gain exclusive access to\n        source code for each tutorial and monthly website templates. These\n        resources are carefully curated to support and inspire your creativity,\n        helping you take your web design skills to the next level. muktaPRO\n        opens up a realm of opportunities for professional growth and empowers\n        you to bring your ideas to life with ease. Delve into coding without\n        clutter. Access the source code for every tutorial published on the\n        mukta YouTube channel and build elegant website components\n        effortlessly. Take the fast lane to mastery. Each month, you'll receive\n        a fresh complete responsive website template. Inspired by award winning\n        web experiences, these templates allow you to build standout websites\n        without starting from scratch, serving as the perfect foundation for\n        your next project.\n      </p>\n\n      <h1 class=\"anime-header\">endless web design</h1>\n    </div>\n\n    <script type=\"module\" src=\"/script.js\"></script>\n  </body>\n</html>\n",
      "package.json": "{\n  \"name\": \"mukta-menuxl-text-displacement-animation\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"host\": \"vite --host\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"vite\": \"^6.2.1\"\n  }\n}\n",
      "script.js": "document.addEventListener(\"DOMContentLoaded\", () => {\n  const animateTextElements = (selector, splitBy) => {\n    const textContainers = document.querySelectorAll(selector);\n\n    textContainers.forEach((textContainer) => {\n      let elements = [];\n      let elementType = \"\";\n\n      if (splitBy === \"words\") {\n        elements = textContainer.textContent.trim().split(/\\s+/);\n        elementType = \"word\";\n      } else if (splitBy === \"letters\") {\n        const words = textContainer.textContent.trim().split(/\\s+/);\n        elements = [];\n\n        words.forEach((word, wordIndex) => {\n          for (let i = 0; i < word.length; i++) {\n            elements.push(word[i]);\n          }\n\n          if (wordIndex < words.length - 1) {\n            elements.push(\" \");\n          }\n        });\n\n        elementType = \"letter\";\n      }\n\n      textContainer.textContent = \"\";\n\n      const animatedElements = [];\n\n      elements.forEach((element, index) => {\n        if (splitBy === \"letters\" && element === \" \") {\n          textContainer.appendChild(document.createTextNode(\" \"));\n          return;\n        }\n\n        const elementSpan = document.createElement(\"span\");\n        elementSpan.classList.add(elementType);\n        elementSpan.textContent = element;\n        textContainer.appendChild(elementSpan);\n\n        if (splitBy === \"words\" && index < elements.length - 1) {\n          textContainer.appendChild(document.createTextNode(\" \"));\n        }\n\n        animatedElements.push({\n          element: elementSpan,\n          originalX: 0,\n          originalY: 0,\n          currentX: 0,\n          currentY: 0,\n          targetX: 0,\n          targetY: 0,\n        });\n      });\n\n      setTimeout(() => {\n        animatedElements.forEach((element) => {\n          const rect = element.element.getBoundingClientRect();\n          element.originalX = rect.left + rect.width / 2;\n          element.originalY = rect.top + rect.height / 2;\n          element.currentX = 0;\n          element.currentY = 0;\n          element.targetX = 0;\n          element.targetY = 0;\n        });\n      }, 100);\n\n      document.addEventListener(\"mousemove\", (e) => {\n        const mouseX = e.clientX;\n        const mouseY = e.clientY;\n\n        const radius = 150;\n        const maxDisplacement = 300;\n\n        animatedElements.forEach((element) => {\n          const originalX = element.originalX;\n          const originalY = element.originalY;\n\n          const dx = originalX - mouseX;\n          const dy = originalY - mouseY;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n\n          if (distance < radius) {\n            const force = (1 - distance / radius) * maxDisplacement;\n\n            element.targetX = (dx / distance) * force;\n            element.targetY = (dy / distance) * force;\n          } else {\n            element.targetX = 0;\n            element.targetY = 0;\n          }\n        });\n      });\n\n      const animate = () => {\n        const lerpFactor = 0.1;\n\n        animatedElements.forEach((element) => {\n          element.currentX += (element.targetX - element.currentX) * lerpFactor;\n          element.currentY += (element.targetY - element.currentY) * lerpFactor;\n\n          element.element.style.transform = `translate(${element.currentX}px, ${element.currentY}px)`;\n        });\n\n        requestAnimationFrame(animate);\n      };\n\n      animate();\n    });\n  };\n\n  animateTextElements(\".anime-text\", \"words\");\n  animateTextElements(\".anime-header\", \"letters\");\n});\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n  user-select: none;\n}\n\nbody {\n  background-color: #1a1a1a;\n  color: #fff;\n  font-family: \"TWK Lausanne\", monospace;\n}\n\n.container {\n  position: relative;\n  width: 100vw;\n  height: 100vh;\n  padding: 2em;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  gap: 4em;\n  overflow: hidden;\n}\n\n.anime-text {\n  font-size: 16px;\n  font-weight: 400;\n  line-height: 1.25;\n  text-align: justify;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anime-header {\n  font-size: 10vw;\n  font-weight: 400;\n}\n\n.word {\n  position: relative;\n  margin-right: 0.75em;\n  margin-bottom: 0.5em;\n  display: inline-block;\n  will-change: transform;\n}\n\n.letter {\n  position: relative;\n  display: inline-block;\n  will-change: transform;\n}\n"
    }
  },
  {
    "title": "mukta-telescope-text-animation",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Telescope Scroll-Powered Text Animation | mukta</title>\n    <link rel=\"stylesheet\" href=\"/styles.css\" />\n  </head>\n  <body>\n    <section class=\"intro\">\n      <h1>Scroll begins</h1>\n    </section>\n\n    <section class=\"animated-titles\">\n      <div class=\"title\">\n        <div class=\"title-container\"><h1>Subtle Phase</h1></div>\n      </div>\n      <div class=\"title\">\n        <div class=\"title-container\"><h1>Hidden Flow</h1></div>\n      </div>\n      <div class=\"title\">\n        <div class=\"title-container\"><h1>Calm Glide</h1></div>\n      </div>\n    </section>\n\n    <section class=\"outro\">\n      <h1>End of motion</h1>\n    </section>\n\n    <script type=\"module\" src=\"/script.js\"></script>\n  </body>\n</html>\n",
      "package.json": "{\n  \"name\": \"mukta-telescope-text-animation\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"dev\": \"vite\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\",\n  \"dependencies\": {\n    \"gsap\": \"^3.13.0\",\n    \"lenis\": \"^1.3.11\",\n    \"vite\": \"^7.1.9\"\n  }\n}\n",
      "script.js": "import gsap from \"gsap\";\nimport { ScrollTrigger } from \"gsap/ScrollTrigger\";\nimport { SplitText } from \"gsap/SplitText\";\nimport Lenis from \"lenis\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  gsap.registerPlugin(ScrollTrigger, SplitText);\n\n  const lenis = new Lenis();\n  lenis.on(\"scroll\", ScrollTrigger.update);\n  gsap.ticker.add((time) => {\n    lenis.raf(time * 1000);\n  });\n  gsap.ticker.lagSmoothing(0);\n\n  const titleHeadings = gsap.utils.toArray(\".title h1\");\n  const splits = [];\n\n  titleHeadings.forEach((heading) => {\n    const split = SplitText.create(heading, {\n      type: \"chars\",\n      charsClass: \"char\",\n    });\n    splits.push(split);\n\n    split.chars.forEach((char, i) => {\n      const charInitialY = i % 2 === 0 ? -150 : 150;\n      gsap.set(char, { y: charInitialY });\n    });\n  });\n\n  const titles = gsap.utils.toArray(\".title\");\n\n  titles.forEach((title, index) => {\n    const titleContainer = title.querySelector(\".title-container\");\n    const titleContainerInitialX = index === 1 ? -100 : 100;\n    const split = splits[index];\n    const charCount = split.chars.length;\n\n    ScrollTrigger.create({\n      trigger: title,\n      start: \"top bottom\",\n      end: \"top -25%\",\n      scrub: 1,\n      onUpdate: (self) => {\n        const titleContainerX =\n          titleContainerInitialX - self.progress * titleContainerInitialX;\n        gsap.set(titleContainer, { x: `${titleContainerX}%` });\n\n        split.chars.forEach((char, i) => {\n          let charStaggerIndex;\n          if (index === 1) {\n            charStaggerIndex = charCount - 1 - i;\n          } else {\n            charStaggerIndex = i;\n          }\n\n          const charStartDelay = 0.1;\n          const charTimelineSpan = 1 - charStartDelay;\n          const staggerFactor = Math.min(0.75, charTimelineSpan * 0.75);\n          const delay =\n            charStartDelay + (charStaggerIndex / charCount) * staggerFactor;\n          const duration =\n            charTimelineSpan - (staggerFactor * (charCount - 1)) / charCount;\n          const start = delay;\n\n          let charProgress = 0;\n          if (self.progress >= start) {\n            charProgress = Math.min(1, (self.progress - start) / duration);\n          }\n\n          const charInitialY = i % 2 === 0 ? -150 : 150;\n          const charY = charInitialY - charProgress * charInitialY;\n          gsap.set(char, { y: charY });\n        });\n      },\n    });\n  });\n});\n",
      "styles.css": "@import url(\"https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap\");\n\n:root {\n  --bg: #f4f3ef;\n  --fg: #141414;\n  --accent: #e3f794;\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: \"Manrope\";\n  background-color: var(--bg);\n  color: var(--fg);\n}\n\nh1 {\n  font-size: 10rem;\n  font-weight: 500;\n  line-height: 1;\n  letter-spacing: -0.25rem;\n}\n\nsection {\n  position: relative;\n  width: 100%;\n  overflow: hidden;\n}\n\n.intro,\n.outro {\n  height: 100svh;\n  text-align: center;\n  align-content: center;\n}\n\n.title {\n  height: 85svh;\n  display: flex;\n  align-items: center;\n}\n\n.title-container {\n  position: relative;\n  width: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  will-change: transform;\n}\n\n.title:nth-child(1),\n.title:nth-child(3) {\n  background-color: var(--accent);\n}\n\n.title:nth-child(2) {\n  background-color: var(--bg);\n}\n\n.char {\n  position: relative;\n  display: inline-block;\n  will-change: transform;\n}\n\n@media (max-width: 1000px) {\n  h1 {\n    font-size: 3rem;\n    letter-spacing: 0;\n  }\n}\n"
    }
  },
  {
    "title": "text-hover-effect-js",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>text hover effect js</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <div class=\"hero-img\">\n      <img src=\"./hero.jpg\" alt=\"\" />\n    </div>\n    <div class=\"container\">\n      <div class=\"word\">\n        <span>T</span>\n        <span>H</span>\n        <span>E</span>\n      </div>\n      <div class=\"word\">\n        <span>C</span>\n        <span>L</span>\n        <span>E</span>\n        <span>V</span>\n        <span>E</span>\n        <span>L</span>\n        <span>A</span>\n        <span>N</span>\n        <span>D</span>\n      </div>\n      <div class=\"word\">\n        <span>M</span>\n        <span>U</span>\n        <span>S</span>\n        <span>E</span>\n        <span>U</span>\n        <span>M</span>\n      </div>\n      <div class=\"word\">\n        <span>A</span>\n        <span>R</span>\n        <span>T</span>\n        <span>I</span>\n        <span>S</span>\n        <span>T</span>\n        <span>S</span>\n      </div>\n    </div>\n\n    <script>\n      const textContainers = document.querySelectorAll(\".word\");\n      const defaultScale = 1;\n      const maxScale = 2;\n      const neighborScale = 1.5;\n\n      textContainers.forEach((textContainer) => {\n        const spans = textContainer.querySelectorAll(\"span\");\n\n        textContainer.addEventListener(\"mousemove\", (e) => {\n          const target = e.target;\n          const index = Array.from(spans).indexOf(target);\n\n          spans.forEach((span, i) => {\n            let scale = defaultScale;\n\n            if (i === index) {\n              // Scale the hovered span to 2\n              scale = maxScale;\n            } else if (i === index - 1 || i === index + 1) {\n              // Scale the side neighbors to 1.5\n              scale = neighborScale;\n            }\n\n            span.style.transform = `scaleY(${scale})`;\n          });\n        });\n\n        textContainer.addEventListener(\"mouseleave\", () => {\n          spans.forEach((span) => {\n            span.style.transform = `scaleY(${defaultScale})`;\n          });\n        });\n      });\n    </script>\n  </body>\n</html>\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n  background: #cac3bb;\n  display: flex;\n  flex-direction: column;\n}\n\n.hero-img {\n  position: relative;\n  width: 100vw;\n  height: 100vh;\n}\n\n.hero-img:after {\n  position: absolute;\n  content: \"\";\n  display: block;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  background: linear-gradient(\n    180deg,\n    rgba(251, 0, 255, 0) 0%,\n    rgb(36, 36, 36) 100%\n  );\n}\n\nimg {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\n.container {\n  position: absolute;\n  bottom: 0;\n  width: 100%;\n  padding: 2em;\n  display: flex;\n  justify-content: space-between;\n}\n\n.word {\n  display: flex;\n}\n\n.word span {\n  cursor: pointer;\n  font-family: \"Druk LCG\";\n  font-weight: bolder;\n  text-transform: uppercase;\n  font-size: 10vw;\n  transition: 400ms cubic-bezier(0.075, 0.82, 0.165, 1);\n  transform-origin: bottom;\n  color: rgb(162, 31, 31);\n}\n"
    }
  },
  {
    "title": "text-shuffle-hover-mukta",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>locomotive-ca-hover | @mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <h1>Featured Work</h1>\n    <div class=\"container\">\n      <div class=\"item item-1\">\n        <div class=\"word w1\">Pangram</div>\n        <div class=\"img\">\n          <img src=\"./images/img1.jpg\" alt=\"\" />\n        </div>\n        <div class=\"word w2\">Pangram</div>\n      </div>\n      <div class=\"item item-2\">\n        <div class=\"word w1\">Bailat</div>\n        <div class=\"img\">\n          <img src=\"./images/img2.jpg\" alt=\"\" />\n        </div>\n        <div class=\"word w2\">Studio</div>\n      </div>\n      <div class=\"item item-3\">\n        <div class=\"word w1\">Age of</div>\n        <div class=\"img\">\n          <img src=\"./images/img3.jpg\" alt=\"\" />\n        </div>\n        <div class=\"word w2\">Union</div>\n      </div>\n      <div class=\"item item-4\">\n        <div class=\"word w1\">Not So</div>\n        <div class=\"img\">\n          <img src=\"./images/img4.jpg\" alt=\"\" />\n        </div>\n        <div class=\"word w2\">Violent</div>\n      </div>\n    </div>\n    <script>\n      document.addEventListener(\"DOMContentLoaded\", () => {\n        const items = document.querySelectorAll(\".item\");\n\n        items.forEach((item) => {\n          item.addEventListener(\"mouseenter\", shuffleAnimation);\n        });\n      });\n\n      function getRandomCharacter() {\n        const chars =\n          \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        return chars[Math.floor(Math.random() * chars.length)];\n      }\n\n      function shuffleAnimation(event) {\n        const target = event.currentTarget;\n\n        if (target.dataset.animating) {\n          return;\n        }\n\n        target.dataset.animating = true;\n\n        const words = target.querySelectorAll(\".word\");\n        const originalWords = Array.from(words).map((word) => word.textContent);\n\n        let shuffles = 0;\n        const maxShuffles = 10;\n        const intervalDuration = 500 / maxShuffles;\n\n        let animationInterval = setInterval(() => {\n          if (shuffles >= maxShuffles) {\n            clearInterval(animationInterval);\n            words.forEach((word, index) => {\n              word.textContent = originalWords[index];\n            });\n\n            delete target.dataset.animating;\n          } else {\n            words.forEach((word) => {\n              const length = word.textContent.length;\n              let shuffledText = \"\";\n              for (let i = 0; i < length; i++) {\n                shuffledText += getRandomCharacter();\n              }\n              word.textContent = shuffledText;\n            });\n            shuffles++;\n          }\n        }, intervalDuration);\n      }\n    </script>\n  </body>\n</html>\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  margin: 0;\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n  font-family: \"Libre Caslon Condensed\";\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n  gap: 50px;\n}\n\nh1 {\n  font-size: 30px;\n  font-family: \"Acid Grotesk\";\n  font-weight: 500;\n  text-transform: uppercase;\n}\n\n.container {\n  width: 100%;\n  padding: 0 2em;\n}\n\n.container .item {\n  width: 100%;\n  padding: 0.125em 0;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  gap: 10px;\n  font-size: 80px;\n  border-bottom: 2px solid #000;\n  cursor: pointer;\n  transition: all 0.3s ease-in-out;\n}\n\n.item:nth-child(1) {\n  border-top: 2px solid #000;\n}\n\n.img {\n  width: 125px;\n  height: 80px;\n  background-color: #000;\n  transition: all 1s cubic-bezier(0.165, 0.84, 0.44, 1);\n  overflow: hidden;\n  flex: 0;\n}\n\nimg {\n  width: 125px;\n  height: auto;\n  object-fit: cover;\n}\n\n.item:hover {\n  gap: 20px;\n}\n\n.item:hover .img {\n  flex: 0.5;\n}\n\n.word {\n  flex: 2.5;\n}\n\n.w1 {\n  text-align: right;\n}\n"
    }
  },
  {
    "title": "-",
    "description": "-",
    "code": "Documentation\n\n\nSetup: External Scripts\n\n\nCopy\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.14.1/dist/gsap.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.14.1/dist/SplitText.min.js\"></script>\nStep 1: Add HTML\n\n\nCopy\n<h1 data-font-weight-hover data-radius=\"400\" data-min=\"200\" data-max=\"1000\" class=\"font-weight__heading\">\n  Looooook at this!<br>It&#x27;s so smooth.\n</h1>\nStep 2: Add CSS\n\n\nCopy\n.font-weight__heading {\n  font-variation-settings: \"wght\" 540;\n  letter-spacing: -.02em;\n  margin-top: 0;\n  margin-bottom: 0;\n  font-family: Haffer VF, Arial, sans-serif;\n  font-size: clamp(2em, 6vw, 8em);\n  line-height: 1;\n}\nStep 3: Add Javascript\n\n\nCopy\nfunction initVariableFontWeightHover() {\n  // Return on touchscreens or when user prefers reduced motion\n  const isTouch = window.matchMedia(\"(hover: none), (pointer: coarse)\").matches;\n  const reduceMotion = window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\n  if (isTouch || reduceMotion) return;\n  \n  const targets = document.querySelectorAll(\"[data-font-weight-hover]\");\n  if (!targets.length) return;\n\n  const rangeDefault = 500;\n\n  const mouse = { x: 0, y: 0 };\n  let hasPointer = false;\n  let isActive = false;\n\n  const chars = [];\n\n  function clamp(v, min, max) {\n    return v < min ? min : v > max ? max : v;\n  }\n\n  function numAttr(el, key, fallback) {\n    const v = parseFloat(el.dataset[key]);\n    return Number.isFinite(v) ? v : fallback;\n  }\n\n  function readFontWeight(el) {\n    const fw = getComputedStyle(el).fontWeight;\n    const parsed = parseFloat(fw);\n    if (Number.isFinite(parsed)) return parsed;\n    if (fw === \"bold\") return 700;\n    return 400; // \"normal\" fallback\n  }\n\n  function weightFromDistance(dist, minw, maxw, range) {\n    if (dist >= range) return minw;\n    const t = 1 - dist / range;\n    return minw + (maxw - minw) * t;\n  }\n\n  function calculatePositions() {\n    for (let i = 0; i < chars.length; i++) {\n      const r = chars[i].el.getBoundingClientRect();\n      chars[i].cx = r.left + r.width / 2 + window.scrollX;\n      chars[i].cy = r.top + r.height / 2 + window.scrollY;\n    }\n  }\n\n  function splitChars(el) {\n    if (el.dataset.fontWeightHoverInit === \"true\") return null;\n    el.dataset.fontWeightHoverInit = \"true\";\n\n    el.fontWeightHoverSplit =\n      el.fontWeightHoverSplit ||\n      new SplitText(el, { type: \"chars,words\", charsClass: \"char\" });\n\n    return el.fontWeightHoverSplit.chars || [];\n  }\n\n  function activate() {\n    if (isActive) return;\n    isActive = true;\n\n    // Apply variable-font wiring without changing the visible weight\n    for (let i = 0; i < chars.length; i++) {\n      const d = chars[i];\n      d.el.style.setProperty(\"--wght\", d.startw);\n      d.el.style.fontVariationSettings = \"'wght' var(--wght)\";\n    }\n\n    calculatePositions();\n  }\n\n  targets.forEach((el) => {\n    const minw = numAttr(el, \"min\", 300);\n    const maxw = numAttr(el, \"max\", 900);\n    const range = numAttr(el, \"range\", rangeDefault);\n\n    const split = splitChars(el);\n    if (!split) return;\n\n    split.forEach((ch) => {\n      const startw = readFontWeight(ch);\n\n      chars.push({\n        el: ch,\n        cx: 0,\n        cy: 0,\n        startw,\n        minw,\n        maxw,\n        range,\n        setw: gsap.quickTo(ch, \"--wght\", {\n          duration: 0.4,\n          ease: \"power2.out\",\n          overwrite: \"auto\",\n        }),\n      });\n    });\n  });\n\n  window.addEventListener(\n    \"pointermove\",\n    (e) => {\n      hasPointer = true;\n      mouse.x = e.pageX;\n      mouse.y = e.pageY;\n\n      if (!isActive) activate();\n    },\n    { passive: true }\n  );\n\n  window.addEventListener(\"resize\", () => isActive && calculatePositions(), { passive: true });\n  window.addEventListener(\"scroll\", () => isActive && calculatePositions(), { passive: true });\n\n  if (document.fonts?.ready) {\n    document.fonts.ready.then(() => isActive && calculatePositions()).catch(() => {});\n  }\n\n  if (\"ResizeObserver\" in window) {\n    const ro = new ResizeObserver(() => isActive && calculatePositions());\n    targets.forEach((el) => ro.observe(el));\n  }\n\n  gsap.ticker.add(() => {\n    if (!hasPointer || !isActive) return;\n\n    for (let i = 0; i < chars.length; i++) {\n      const d = chars[i];\n      const dist = Math.hypot(mouse.x - d.cx, mouse.y - d.cy);\n      const w = weightFromDistance(dist, d.minw, d.maxw, d.range);\n      d.setw(clamp(w, d.minw, d.maxw));\n    }\n  });\n}\n\n// Init Variable Font Weight Hover\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  initVariableFontWeightHover();\n});\nImplementation\nThis script creates a 'variable font weight hover' effect by splitting text into characters and smoothly adjusting each character\u2019s variable weight based on how close the pointer is to it. For the effect to work, the font used on the target element needs to be a variable font that supports the wght axis.\n\nTarget\nUse [data-font-weight-hover] to mark a text element as interactive so its characters respond to pointer distance by changing variable font weight.\n\n<h2 data-font-weight-hover data-min=\"300\" data-max=\"900\" data-range=\"500\">\n  Variable font heading\n</h2>\nVariable font requirement\nUse a variable font that supports the wght axis so changes to font-variation-settings: 'wght' ... can visually interpolate the font weight per character.\n\nMinimum font-weight\nUse [data-min=\"300\"] (default 300) to define the lowest variable font weight a character can animate down to when the pointer is outside the influence range.\n\nMaximum font-weight\nUse [data-max=\"900\"] (default 900) to define the highest variable font weight a character can animate up to when the pointer is closest to its center.\n\nInfluence range\nUse [data-range=\"500\"] (default 500px) to define the maximum distance from each character\u2019s center where the pointer still affects the weight animation. A higher number means your letters will be affected even if the mouse is further away. A lower number means the mouse will have to be closer to the text before it animates.\n\nStarting weight from CSS\nUse the element\u2019s existing CSS font-weight as the starting point so characters keep their original styling until the user moves the pointer for the first time.\n\nTouchscreens\nThe script detects touchscreens (like a mobile device) to disable the effect. The text stays at the CSS-defined font weight.\n\nAccessibility\nThe script also checks if the user prefers reduced motion, to disable the hover animation and preserve the CSS-defined font-weight, ensuring the interaction does not create unnecessary motion for users who opt out."
  },
  {
    "title": "SVG Text Masking Testing",
    "description": "",
    "code": "index.html: <div class=\"container\"> <img class=\"cutout\" src=\"https://assets.codepen.io/64141/cutout.png?format=auto\" alt=\"Jason Lengstorf\" /> <svg viewBox=\"0 0 400 400\" width=\"400\" height=\"400\"> <defs> <clipPath id=\"boops\"> <text x=\"40\" y=\"45\" text-anchor=\"middle\" transform=\"rotate(3)\" style=\"font-size: 25px\">BOOP</text> <text x=\"328\" y=\"44\" text-anchor=\"middle\" transform=\"rotate(-1)\" style=\"font-size: 25px\">BOOP</text> <text x=\"361\" y=\"110\" text-anchor=\"middle\" transform=\"rotate(-12)\" style=\"font-size: 20px\">BOOP</text> <text x=\"109\" y=\"145\" text-anchor=\"middle\" transform=\"rotate(3)\" style=\"font-size: 80px\">BOOP</text> <text x=\"227\" y=\"47\" text-anchor=\"middle\" transform=\"rotate(-2)\" style=\"font-size: 60px\">BOOP</text> <text x=\"187\" y=\"103\" text-anchor=\"middle\" transform=\"rotate(1)\" style=\"font-size: 90px\">BOOP</text> <text x=\"224\" y=\"166\" text-anchor=\"middle\" transform=\"rotate(-4)\" style=\"font-size: 90px\">BOOP</text> <text x=\"58\" y=\"171\" text-anchor=\"middle\" transform=\"rotate(1)\" style=\"font-size: 40px\">BOOP</text> <text x=\"320\" y=\"195\" text-anchor=\"middle\" transform=\"rotate(-3)\" style=\"font-size: 50px\">BOOP</text> <text x=\"190\" y=\"245\" text-anchor=\"middle\" transform=\"rotate(3)\" style=\"font-size: 105px\">BOOP</text> <text x=\"64\" y=\"258\" text-anchor=\"middle\" transform=\"rotate(-1)\" style=\"font-size: 40px\">BOOP</text> <text x=\"332\" y=\"254\" text-anchor=\"middle\" transform=\"rotate(-2)\" style=\"font-size: 30px\">BOOP</text> <text x=\"296\" y=\"269\" text-anchor=\"middle\" transform=\"rotate(4)\" style=\"font-size: 42px\">BOOP</text> <text x=\"140\" y=\"299\" text-anchor=\"middle\" transform=\"rotate(-3)\" style=\"font-size: 75px\">BOOP</text> <text x=\"223\" y=\"357\" text-anchor=\"middle\" transform=\"rotate(2)\" style=\"font-size: 90px\">BOOP</text> <text x=\"299\" y=\"378\" text-anchor=\"middle\" transform=\"rotate(-2)\" style=\"font-size: 20px\">BOOP</text> <text x=\"61\" y=\"330\" text-anchor=\"middle\" transform=\"rotate(1)\" style=\"font-size: 30px\">BOOP</text> <text x=\"65\" y=\"343\" text-anchor=\"middle\" transform=\"rotate(-1)\" style=\"font-size: 26px\">BOOP</text> <text x=\"70\" y=\"387\" text-anchor=\"middle\" transform=\"rotate(2)\" style=\"font-size: 39px\">BOOP</text> </clipPath> </defs> <foreignObject x=\"0\" y=\"0\" width=\"400\" height=\"400\" clip-path=\"url(#boops)\"> <img src=\"https://res.cloudinary.com/jlengstorf/image/upload/w_400,h_400,c_fill,g_faces,q_auto,f_auto/press/jason-lengstorf-ac-alley3.jpg\" srcset=\"https://res.cloudinary.com/jlengstorf/image/upload/w_400,h_400,c_fill,g_faces,q_auto,f_auto/press/jason-lengstorf-ac-alley3.jpg 1x, https://res.cloudinary.com/jlengstorf/image/upload/w_800,h_800,c_fill,g_faces,q_auto,f_auto/press/jason-lengstorf-ac-alley3.jpg 2x\" alt=\"Jason Lengstorf smiling with his hands in his pockets in an alley.\" /> </foreignObject> </svg> </div>\nstyle.css: .container { background-size: 116.25% auto; background-position: center 8%; margin: 1rem auto; position: relative; width: min(100%, 600px); } .cutout { position: absolute; height: 101%; left: 50%; transform: translate(-55.2%, -1%); width: auto; } svg { height: auto; width: 100%; } clipPath text { font-family: mallory-ultra; font-size: 30px; letter-spacing: -0.075em; line-height: 1; transform-origin: center; } .animate { animation: pop-in cubic-bezier(0.19, -0.42, 0.53, 1.31) 350ms; animation-delay: attr(data-animation-delay); } @keyframes pop-in { 0% { scale: 0; } 100% { scale: 1; } }\nscript.js: document.querySelectorAll(\"text\").forEach((el, i) => { const styles = el.style; el.style.animationDelay = `${25 * i}ms`; el.classList.add(\"animate\"); });",
    "id": "svg-text-masking-testing"
  },
  {
    "title": "Jello Stretchy Variable Font",
    "description": "",
    "code": "index.html: <div class=\"stage\"> <div class=\"content\"> <h1 class=\"txt\">Jello</h1> </div> </div>\nstyle.css: @font-face { \tfont-family: 'GT-Flexa'; \tsrc: url('https://assets.codepen.io/61488/GT-Flexa-VF-Trial.woff2'); \tfont-display: block; \tfont-style: normal italic; \tfont-weight: 100 800; \tfont-stretch: 10% 200%; } :root { --fw: 600; // font weight target 100-800 \t--fs: 150; // font stretch target 10-150% --fontSize: 15; // vw units --baseColor: \"red\"; } html { \tbox-sizing: border-box; } *, *:before, *:after { \tbox-sizing: inherit; } html, body { \twidth: 100%; \theight: 100%; } body { display: flex; align-items: center; justify-content: center; background-color: #FF7F99; font-family: 'GT-Flexa'; font-size: 20px; color: white; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; cursor: url(\"data:image/svg+xml,%3Csvg width='64px' height='64px' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 700 700'%3E%3Cpath d='M419.99,560.0013c83.627,0,151.67-68.041,151.67-151.67v-198.33A46.6565,46.6565,0,0,0,499.047,171.22a46.6714,46.6714,0,0,0-70-23.3323,46.7853,46.7853,0,0,0-44.055-31.219,46.2641,46.2641,0,0,0-23.332,6.2773V46.669a46.668,46.668,0,1,0-93.336,0v272.79l-64.145-32.082a70.2983,70.2983,0,0,0-31.289-7.375,44.6638,44.6638,0,0,0-31.5,76.23l150.88,150.87A179.4167,179.4167,0,0,0,420,560ZM172.9,303.33a21.3182,21.3182,0,0,0-15.0035,36.379l150.9,150.88a156.058,156.058,0,0,0,111.18,46.082c70.77,0,128.36-57.562,128.36-128.33V210.001a23.332,23.332,0,1,0-46.664,0v58.332a11.668,11.668,0,0,1-23.336,0V186.669a23.332,23.332,0,1,0-46.664,0v81.668a11.668,11.668,0,0,1-23.336,0v-105a23.332,23.332,0,0,0-46.664,0v105a11.668,11.668,0,0,1-23.336,0V46.677a23.332,23.332,0,0,0-46.664,0v291.67a11.66,11.66,0,0,1-16.8712,10.43l-81.035-40.508a46.9273,46.9273,0,0,0-20.863-4.9258Z' transform='translate(0 -0.001)' fill='%23fff'/%3E%3Cpath d='M420,560a179.4167,179.4167,0,0,1-127.73-52.898L141.39,356.232a44.6638,44.6638,0,0,1,31.5-76.23,70.2983,70.2983,0,0,1,31.289,7.375l64.145,32.082V46.669a46.668,46.668,0,1,1,93.336,0v76.277a46.2641,46.2641,0,0,1,23.332-6.2773,46.7853,46.7853,0,0,1,44.055,31.219,46.6714,46.6714,0,0,1,70,23.3323A46.6565,46.6565,0,0,1,571.66,210.0013v198.33c0,83.629-68.043,151.67-151.67,151.67ZM172.9,303.33a21.3182,21.3182,0,0,0-15.0035,36.379l150.9,150.88a156.058,156.058,0,0,0,111.18,46.082c70.77,0,128.36-57.562,128.36-128.33V210.001a23.332,23.332,0,1,0-46.664,0v58.332a11.668,11.668,0,0,1-23.336,0V186.669a23.332,23.332,0,1,0-46.664,0v81.668a11.668,11.668,0,0,1-23.336,0v-105a23.332,23.332,0,0,0-46.664,0v105a11.668,11.668,0,0,1-23.336,0V46.677a23.332,23.332,0,0,0-46.664,0v291.67a11.66,11.66,0,0,1-16.8712,10.43l-81.035-40.508a46.9273,46.9273,0,0,0-20.863-4.9258Z' transform='translate(0 -0.001)'/%3E%3C/svg%3E%0A\") 32 32, pointer; } .stage { \tposition: relative; display: grid; place-items: center; \twidth: 100%; \theight: 100%; \tvisibility: hidden; } .content { text-align: center; } .txt { margin: 0; font-size: calc(var(--fontSize)*1vw); \tfont-weight: var(--fw); // 100-800 \tfont-stretch: calc(var(--fs) * 1%); // 10-150% line-height: 0.6; letter-spacing: -1vw; // text-transform: uppercase; user-select: none; text-shadow: 0 0.05em 0 #FFB0C0, 0 0.1em 0.1em rgba(70,0,35, 0.3), 0 0.4em 0.3em rgba(70,0,35, 0.1); } .char { padding-top: 1.08vw; text-align: center; will-change: font-weight, font-stretch, transform; &:hover { // cursor: grab; } } .grab { cursor: url(\"data:image/svg+xml,%3Csvg width='64px' height='64px' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 700 700'%3E%3Cpath d='M419.9949,560.0013a179.4167,179.4167,0,0,1-127.73-52.898l-46.691-46.668a81.2138,81.2138,0,0,1-23.914-57.77v-35.352a81.1643,81.1643,0,0,1,23.918-57.75l22.75-22.723v-53.504a46.6566,46.6566,0,0,1,72.613-38.7813,46.691,46.691,0,0,1,88.106,0,46.6714,46.6714,0,0,1,70,23.3323,46.6566,46.6566,0,0,1,72.613,38.7813v151.67c0,83.625-68.039,151.66-151.67,151.66Zm-151.6526-221.66a11.666,11.666,0,1,0,23.332,0v-46.645a.19.19,0,0,1,.0039-.0469V233.34a23.332,23.332,0,1,1,46.664,0v35a11.666,11.666,0,1,0,23.332,0l.0039-58.336a23.332,23.332,0,1,1,46.664,0V268.34a11.666,11.666,0,1,0,23.332,0l.0039-35a23.332,23.332,0,1,1,46.664,0v35a11.666,11.666,0,1,0,23.332,0l.0039-11.668a23.332,23.332,0,1,1,46.664,0l-.0039,151.67c0,70.768-57.59,128.33-128.36,128.33a156.1776,156.1776,0,0,1-111.21-46.059l-46.691-46.668a58.0537,58.0537,0,0,1-17.078-41.254v-35.352a57.9448,57.9448,0,0,1,17.082-41.254l6.2539-6.2539Z' fill='%23fff'/%3E%3Cpath d='M419.9949,560.0013a179.4167,179.4167,0,0,1-127.73-52.898l-46.691-46.668a81.2138,81.2138,0,0,1-23.914-57.77v-35.352a81.1643,81.1643,0,0,1,23.918-57.75l22.75-22.723v-53.504a46.6566,46.6566,0,0,1,72.613-38.7813,46.691,46.691,0,0,1,88.106,0,46.6714,46.6714,0,0,1,70,23.3323,46.6566,46.6566,0,0,1,72.613,38.7813v151.67c0,83.625-68.039,151.66-151.67,151.66Zm-151.66-240.17-6.2539,6.2539a57.9448,57.9448,0,0,0-17.082,41.254v35.352a58.0537,58.0537,0,0,0,17.078,41.254l46.691,46.668a156.1776,156.1776,0,0,0,111.21,46.059c70.77,0,128.36-57.562,128.36-128.33l.0039-151.67a23.332,23.332,0,1,0-46.664,0l-.0039,11.668a11.666,11.666,0,1,1-23.332,0v-35a23.332,23.332,0,1,0-46.664,0l-.0039,35a11.666,11.666,0,1,1-23.332,0v-58.336a23.332,23.332,0,1,0-46.664,0l-.0039,58.336a11.666,11.666,0,1,1-23.332,0v-35a23.332,23.332,0,1,0-46.664,0v58.309a.19.19,0,0,0-.0039.0469v46.645a11.666,11.666,0,1,1-23.332,0Z'/%3E%3C/svg%3E\") 32 32, pointer; } p { margin: 32px 0 0; } // Drag Hand by icon 54 from NounProject.com // Link Select by icon 54 from NounProject.com\nscript.js: console.clear(); select = e => document.querySelector(e); selectAll = e => document.querySelectorAll(e); const style = getComputedStyle(document.body) const stage = select('.stage'); const weightInit = style.getPropertyValue('--fw'); // 600 in example const weightTarget = 400; // 100-800 const weightDiff = weightInit - weightTarget; const stretchInit = style.getPropertyValue('--fs'); // 150 in example const stretchTarget = 80; // 10-200 const stretchDiff = stretchInit - stretchTarget; const maxYScale = 2.5; const body = document.body; let mySplitText = new SplitText('.txt', {type:\"chars\", charsClass:\"char\", position: \"relative\" }); let chars = selectAll('.char'); let txt = select('.txt'); let numChars = chars.length; let isMouseDown = false; let letters = selectAll('.char'); let mouseInitialY = 0; let mouseFinalY = 0; let distY = 0; let charIndexSelected = 0; let charH = 0; let elasticDropOff = 0.8; // The higher the value the less dispersion of elasticity. let dragYScale = 0; function init() { resize(); gsap.set(stage, { autoAlpha: 1 }); gsap.set(chars, { transformOrigin: 'center bottom' }) animInTxt(); } function animInTxt() { let elem = document.querySelector('.char'); let rect = elem.getBoundingClientRect(); gsap.from(chars, { y: ()=> { return -1*(rect.y + charH + 500); // add an extra 100px buffer to make sure off screen }, fontWeight: weightTarget, fontStretch: stretchTarget, scaleY: 2, ease: \"elastic(0.2, 0.1)\", duration: 1.5, delay: 0.5, stagger: { each: 0.05, from: 'random' }, onComplete: initEvents }) } function initEvents() { body.onmouseup = function(e) { if(isMouseDown) { mouseFinalY = e.clientY; isMouseDown = false; snapBackText(); body.classList.remove(\"grab\"); } } body.onmousemove = function(e) { if(isMouseDown) { mouseFinalY = e.clientY; calcDist(); setFontDragDimensions(); } } body.addEventListener(\"mouseleave\", (event) => { if (event.clientY <= 0 || event.clientX <= 0 || (event.clientX >= window.innerWidth || event.clientY >= window.innerHeight)) { snapBackText(); isMouseDown = false; } }); chars.forEach((char, index) => { char.addEventListener(\"mousedown\", function(e) { mouseInitialY = e.clientY; charIndexSelected = index; charSelected = e.target; isMouseDown = true; body.classList.add(\"grab\"); console.clear(); }); }) } function calcDist() { let maxYDragDist = charH*(maxYScale-1); distY = mouseInitialY - mouseFinalY; dragYScale = distY/maxYDragDist; if(dragYScale>(maxYScale-1)) { dragYScale = maxYScale-1; } else if (dragYScale<-0.5) { dragYScale = -0.5; } } function setFontDragDimensions() { gsap.to(chars, { y: (index, target) => { let fracDispersion = calcfracDispersion(index); return fracDispersion*-50; }, fontWeight: (index, target) => { let fracDispersion = calcfracDispersion(index); return (weightInit - (fracDispersion*weightDiff)); }, fontStretch: (index, target) => { let fracDispersion = calcfracDispersion(index); return (stretchInit - (fracDispersion*stretchDiff)); }, scaleY: (index, target) => { let fracDispersion = calcfracDispersion(index); let scaleY = 1 + fracDispersion; if(scaleY<0.5) scaleY = 0.5; return scaleY; }, ease: \"power4\", duration: 0.6 }); } function calcfracDispersion(index) { let dispersion = 1 - (Math.abs(index-charIndexSelected)/(numChars*elasticDropOff)); // fractional index dispersion return dispersion*dragYScale; } function snapBackText() { gsap.to(chars, { y: 0, fontWeight: weightInit, fontStretch: stretchInit, scale: 1, ease: \"elastic(0.35, 0.1)\", duration: 1, stagger: { each: 0.02, from: charIndexSelected } }) } function resize() { charH = txt.offsetHeight; } window.onload = () => { \tinit(); }; window.onresize = () => { \tresize(); };",
    "id": "jello-stretchy-variable-font"
  },
  {
    "title": "[gsap/scrambletext] \u274d Canvas Scramble Text Experiment GSAP - Challenge #1 / Entry 3",
    "description": "",
    "code": "index.html: <div class=\"main-container\"> <header class=\"header\"> <div class=\"header-word-left\">EXPLORE</div> <div class=\"header-word-center\">DISCOVER</div> <div class=\"header-word-right\">IMAGINE</div> </header> <div class=\"grid-container\"> <div class=\"main-title\" id=\"creativity-text\"> True creativity emerges when we strip away what we think we know. In that empty space, possibility breathes. The most profound art doesn't come from adding \u2013 it comes from removing the unnecessary until only truth remains. </div> <div class=\"canvas-container\" id=\"canvas-container\"> <canvas id=\"canvas\" width=\"800\" height=\"800\"></canvas> </div> </div> <footer class=\"footer\"> <div class=\"coordinates\">41.8781\u00b0 N, 87.6298\u00b0 W</div> <div class=\"mysterious-message\">THE VOID BETWEEN PATTERNS REVEALS MORE THAN THE PATTERNS THEMSELVES.</div> </footer> </div>\nstyle.css: @import url(\"https://fonts.cdnfonts.com/css/pp-neue-montreal\"); @import url(\"https://fonts.cdnfonts.com/css/thegoodmonolith\"); :root { --grid-columns: 12; --grid-padding: 2rem; --grid-gutter: 1rem; /* Font variables */ --font-primary: \"PP Neue Montreal\", sans-serif; --font-mono: \"TheGoodMonolith\", sans-serif; --font-weight-normal: 400; --font-weight-bold: 800; --letter-spacing-tight: -0.02em; } * { margin: 0; padding: 0; box-sizing: border-box; } body { margin: 0; background: #111; color: #eee; overflow-x: hidden; font-family: var(--font-primary); min-height: 100vh; display: flex; flex-direction: column; font-weight: var(--font-weight-bold); letter-spacing: var(--letter-spacing-tight); } .main-container { display: flex; flex-direction: column; min-height: 100vh; } .grid-container { display: grid; grid-template-columns: repeat(var(--grid-columns), 1fr); grid-gap: var(--grid-gutter); padding: var(--grid-padding); padding-top: 0; padding-bottom: 0; max-width: 100vw; margin: 0 auto; width: 100%; flex: 1; } .header { display: grid; grid-template-columns: repeat(var(--grid-columns), 1fr); grid-gap: var(--grid-gutter); width: 100%; padding: var(--grid-padding); font-weight: var(--font-weight-bold); font-size: 1.5rem; letter-spacing: var(--letter-spacing-tight); align-items: start; } .header-word-left { grid-column: 1 / span 3; text-align: left; } .header-word-center { grid-column: 7 / span 3; text-align: left; } .header-word-right { grid-column: 10 / span 3; text-align: right; } .main-title { grid-column: 1 / span 4; align-self: flex-end; font-size: clamp(1rem, 0.75rem + 2vw, 2.25rem); line-height: 1.2; padding-top: 4rem; padding-bottom: 4rem; } .canvas-container { grid-column: 7 / span 6; width: 100%; height: auto; aspect-ratio: 1 / 1; align-self: flex-end; padding-bottom: 4rem; opacity: 0; /* Start with opacity 0 for fade-in effect */ transition: opacity 0.8s ease-in-out; /* Add transition for fade-in */ } .canvas-container.visible { opacity: 1; /* Will be added via JavaScript */ } canvas { width: 100%; height: 100%; background: black; touch-action: none; cursor: pointer; border-radius: 4px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3); } .footer { display: grid; grid-template-columns: repeat(var(--grid-columns), 1fr); grid-gap: var(--grid-gutter); width: 100%; padding: var(--grid-padding); font-family: var(--font-mono); font-size: 0.75rem; letter-spacing: 0.05em; opacity: 0.7; text-transform: uppercase; align-items: end; } .coordinates { grid-column: 1 / span 4; text-align: left; } .mysterious-message { grid-column: 7 / span 6; text-align: right; } @media (max-width: 1024px) { .main-title { grid-column: 1 / span 4; } .canvas-container { grid-column: 5 / span 8; } .header-word-center { grid-column: 5 / span 3; } .header-word-right { grid-column: 8 / span 5; } .mysterious-message { grid-column: 5 / span 8; } } @media (max-width: 768px) { .grid-container, .header, .footer { grid-template-columns: 1fr; } .header-word-left, .header-word-center, .header-word-right { grid-column: 1; text-align: left; margin-bottom: 0.5rem; } .main-title { grid-column: 1; margin-bottom: 2rem; } .canvas-container { grid-column: 1; max-width: 100%; } .coordinates, .mysterious-message { grid-column: 1; text-align: left; margin-bottom: 1rem; } }\nscript.js: document.addEventListener(\"DOMContentLoaded\", () => { // Register plugins gsap.registerPlugin(ScrambleTextPlugin, SplitText); const creativityText = document.getElementById(\"creativity-text\"); const split = new SplitText(creativityText, { type: \"lines\", mask: \"lines\", // Using the new masking feature linesClass: \"line\" }); // Set initial state (hidden) gsap.set(split.lines, { y: \"100%\", opacity: 0 }); gsap.to(split.lines, { y: \"0%\", opacity: 1, duration: 0.6, stagger: 0.08, ease: \"power3.out\", delay: 0.2 }); }); class TextHeatReveal { constructor(canvas, imgSrc, options = {}) { this.canvas = canvas; this.ctx = canvas.getContext(\"2d\", { willReadFrequently: true }); this.W = canvas.width; this.H = canvas.height; this.res = options.resolution || 96; this.characters = options.characters || \"GSAPHEATEFFECT!@#$%&*()_+\"; this.fontSize = options.fontSize || 10; this.fontFamily = options.fontFamily || \"monospace\"; this.words = options.words || [ \"CREATE\", \"INSPIRE\", \"DESIGN\", \"IMAGINE\", \"VISION\", \"IDEA\", \"DREAM\" ]; this.heat = { current: new Float32Array(this.res * this.res).fill(0), lastTime: 0, active: false, maxValue: 0 }; this.P = { grid: { size: options.gridSize || 20, weight: options.textWeight || 1, contrast: options.contrast || 1.2, minBrightness: options.minBrightness || 0.25, textOpacity: options.textOpacity || 0.85 }, effect: { strength: options.strength || 16.5, diffusion: options.diffusion || 0.92, decay: options.decay || 0.98, threshold: options.threshold || 0.04 }, image: { brightness: options.imageBrightness || 1.2, contrast: options.imageContrast || 1.3 } }; this.scrambleInterval = options.scrambleInterval || 500; this.scrambleAmount = options.scrambleAmount || 0.08; this.scrambleActive = true; this.coverCanvas = document.createElement(\"canvas\"); this.coverCanvas.width = this.W; this.coverCanvas.height = this.H; this.coverCtx = this.coverCanvas.getContext(\"2d\"); this.coverData = null; this.staticCanvas = document.createElement(\"canvas\"); this.staticCanvas.width = this.W; this.staticCanvas.height = this.H; this.staticCtx = this.staticCanvas.getContext(\"2d\"); this.staticRendered = false; this.lastFrameTime = 0; this.frameCount = 0; this.fps = 0; this.lowPerformanceMode = false; this.charGrid = []; this.img = new Image(); this.img.crossOrigin = \"anonymous\"; this.img.onload = () => this._prepareCover(); this.img.onerror = () => { this.img.src = \"https://assets.codepen.io/7558/bw-spheres-003.jpg\"; }; this.img.src = imgSrc; // Store the container element for fade-in effect this.container = document.getElementById(\"canvas-container\"); } _prepareCover() { this.coverCtx.fillStyle = \"black\"; this.coverCtx.fillRect(0, 0, this.W, this.H); const scale = Math.max(this.W / this.img.width, this.H / this.img.height); const sw = this.img.width * scale, sh = this.img.height * scale; const ox = (this.W - sw) / 2, oy = (this.H - sh) / 2; this.coverCtx.filter = `brightness(${this.P.image.brightness}) contrast(${this.P.image.contrast})`; this.coverCtx.drawImage(this.img, ox, oy, sw, sh); this.coverCtx.filter = \"none\"; this.coverData = this.coverCtx.getImageData(0, 0, this.W, this.H); this._clearHeat(); this._generateCharGrid(); this._placeWordsInGrid(); this._renderStaticGrid(); this._render(); this._bindEvents(); this._startScrambling(); this._monitorPerformance(); // Start the fade-in of the canvas container setTimeout(() => { this.container.classList.add(\"visible\"); }, 100); // Small delay to ensure DOM is ready // Then start the character animation this._createInitialAnimation(); } _createInitialAnimation() { // Create a deep copy of the character grid const originalGrid = []; for (let i = 0; i < this.charGrid.length; i++) { originalGrid.push({ ...this.charGrid[i] }); } // Clear the char grid but preserve word characters for visibility this.charGrid.forEach((cell) => { // Preserve word characters but make other characters empty if (!cell.isWordChar) { cell.char = \" \"; cell.brightness = 0; } else { // Keep word characters but make them slightly visible from the start cell.brightness = 0.25; // Reduced from 0.3 } }); // Render initial state with visible word characters this._renderStaticGrid(); this._render(); // Animate in each character in sequence let count = 0; const totalCells = this.charGrid.length; const duration = 800; // Create a sequence of indices to animate with word cells at the end const indices = this._createAnimationIndices(); // Animation timer const startTime = performance.now(); const animateIn = () => { const now = performance.now(); const elapsed = now - startTime; const progress = Math.min(1, elapsed / duration); // Calculate how many cells should be visible based on progress const visibleCount = Math.floor(progress * totalCells); // Reveal cells according to our pattern for (let i = 0; i < visibleCount; i++) { const idx = indices[i]; // Set non-word cells to random characters with increasing brightness if (i >= count && !this.charGrid[idx].isWordChar) { const originalCell = originalGrid[idx]; this.charGrid[idx].char = this._getRandomChar(); // Add fade-in effect by gradually increasing brightness const fadeProgress = Math.min(1, progress * 1.5); // Faster fade-in this.charGrid[idx].brightness = originalCell.brightness * fadeProgress; count = i; } } // After all cells are revealed, stabilize them to their original state if (progress >= 1) { // Restore all non-word cells to their original state for (let i = 0; i < this.charGrid.length; i++) { if (!this.charGrid[i].isWordChar) { this.charGrid[i] = { ...originalGrid[i] }; } } this._renderStaticGrid(); this._render(); return; } // Render current state this._renderStaticGrid(); this._render(); // Continue animation requestAnimationFrame(animateIn); }; // Start animation animateIn(); } _createAnimationIndices() { // Create array of indices, putting word characters last to ensure they're visible const nonWordIndices = []; const wordIndices = []; // Separate word and non-word indices for (let i = 0; i < this.charGrid.length; i++) { if (this.charGrid[i].isWordChar) { wordIndices.push(i); } else { nonWordIndices.push(i); } } // Shuffle non-word indices for interesting reveal this._shuffleArray(nonWordIndices); // Combine arrays with word indices at the end return [...nonWordIndices, ...wordIndices]; } _shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; } _getRandomChar() { return this.characters.charAt( Math.floor(Math.random() * this.characters.length) ); } _monitorPerformance() { const checkPerformance = () => { this.frameCount++; const now = performance.now(); if (now - this.lastFrameTime >= 1000) { this.fps = this.frameCount; this.frameCount = 0; this.lastFrameTime = now; if (this.fps < 30 && !this.lowPerformanceMode) { this.lowPerformanceMode = true; this.scrambleInterval = 1000; this.scrambleAmount = 0.05; clearInterval(this.scrambleTimer); this._startScrambling(); } else if (this.fps > 50 && this.lowPerformanceMode) { this.lowPerformanceMode = false; this.scrambleInterval = 500; this.scrambleAmount = 0.08; clearInterval(this.scrambleTimer); this._startScrambling(); } } requestAnimationFrame(checkPerformance); }; checkPerformance(); } _placeWordsInGrid() { const { W, H, P } = this; const gridSize = P.grid.size; const cols = Math.floor(W / gridSize); const rows = Math.floor(H / gridSize); // Reset any previously marked word characters this.charGrid.forEach((cell) => { cell.isWordChar = false; }); // Place each word this.words.forEach((word) => { // Try multiple placements for each word const placementCount = Math.max(1, Math.floor(Math.random() * 2) + 1); for (let placement = 0; placement < placementCount; placement++) { // Choose random direction: 0=horizontal, 1=vertical, 2=diagonal const direction = Math.floor(Math.random() * 3); // Try to find a valid placement let startX, startY, valid = false; let attempts = 0; while (!valid && attempts < 20) { attempts++; // Random starting position startX = Math.floor(Math.random() * cols); startY = Math.floor(Math.random() * rows); // Check if word fits in chosen direction valid = true; if (direction === 0) { // Horizontal if (startX + word.length > cols) valid = false; } else if (direction === 1) { // Vertical if (startY + word.length > rows) valid = false; } else { // Diagonal if (startX + word.length > cols || startY + word.length > rows) valid = false; } if (valid) { // Place the word in the grid for (let i = 0; i < word.length; i++) { let x, y; // Calculate position based on direction if (direction === 0) { // Horizontal x = (startX + i) * gridSize; y = startY * gridSize; } else if (direction === 1) { // Vertical x = startX * gridSize; y = (startY + i) * gridSize; } else { // Diagonal x = (startX + i) * gridSize; y = (startY + i) * gridSize; } // Find the matching cell by coordinates const cellIndex = this.charGrid.findIndex( (cell) => cell.x === x && cell.y === y ); if (cellIndex !== -1) { // Set the character and mark as word character this.charGrid[cellIndex].char = word[i]; this.charGrid[cellIndex].isWordChar = true; this.charGrid[cellIndex].brightness = Math.max( this.charGrid[cellIndex].brightness, 0.65 ); } } } } } }); } _generateCharGrid() { const { W, H, P } = this; const gridSize = P.grid.size; const minBrightness = P.grid.minBrightness; // Clear existing grid this.charGrid = []; // Create grid cells for (let y = 0; y < H; y += gridSize) { for (let x = 0; x < W; x += gridSize) { // Sample image brightness at this position const pi = (Math.floor(y) * W + Math.floor(x)) * 4; let gray = (this.coverData.data[pi] * 0.299 + this.coverData.data[pi + 1] * 0.587 + this.coverData.data[pi + 2] * 0.114) / 255; // Apply contrast with minimum brightness gray = Math.max( minBrightness, Math.min(1, (gray - 0.5) * P.grid.contrast + 0.5) ); // Create cell with random character const randomChar = this.characters.charAt( Math.floor(Math.random() * this.characters.length) ); this.charGrid.push({ x, y, char: randomChar, weight: gray * P.grid.weight, brightness: gray, isWordChar: false }); } } } _renderStaticGrid() { const { staticCtx, W, H, P } = this; // Clear canvas staticCtx.clearRect(0, 0, W, H); staticCtx.fillStyle = \"black\"; staticCtx.fillRect(0, 0, W, H); // Set default font staticCtx.font = `${this.fontSize}px ${this.fontFamily}`; staticCtx.textAlign = \"center\"; staticCtx.textBaseline = \"middle\"; // Draw each character this.charGrid.forEach((cell) => { const { x, y, char, brightness, isWordChar } = cell; // Calculate font size based on brightness const sizeFactor = isWordChar ? 0.8 : 0.5; // Make word chars bigger const size = this.fontSize * (sizeFactor + brightness * 0.8); // Set font with bold for word characters staticCtx.font = `${isWordChar ? \"bold\" : \"\"} ${size}px ${ this.fontFamily }`; // Calculate color with higher brightness for word characters, but less bright than before const colorFactor = isWordChar ? 1.3 : 1.1; const finalBrightness = Math.min(1, brightness * colorFactor) * P.grid.textOpacity; // Set fill style staticCtx.fillStyle = `rgba(255, 255, 255, ${finalBrightness})`; // Draw the character staticCtx.fillText(char, x + P.grid.size / 2, y + P.grid.size / 2); }); this.staticRendered = true; } _startScrambling() { this.scrambleTimer = setInterval(() => { if ( this.scrambleActive && (!this.heat.active || this.lowPerformanceMode) ) { this._scrambleRandomChars(); } }, this.scrambleInterval); } _scrambleRandomChars() { if (this.heat.active && this.heat.maxValue > 0.5) { return; } const numChars = Math.floor(this.charGrid.length * this.scrambleAmount); for (let i = 0; i < numChars; i++) { const randomIndex = Math.floor(Math.random() * this.charGrid.length); const cell = this.charGrid[randomIndex]; // Only scramble non-word characters if (!cell.isWordChar) { cell.char = this.characters.charAt( Math.floor(Math.random() * this.characters.length) ); } } this._renderStaticGrid(); if (!this.heat.active) { this._render(); } } _bindEvents() { const c = this.canvas; c.addEventListener(\"pointermove\", (e) => this._move(e), { passive: true }); c.addEventListener(\"pointerdown\", (e) => this._down(e), { passive: true }); c.addEventListener(\"pointerleave\", () => this._leave(), { passive: true }); c.addEventListener(\"pointercancel\", () => this._leave(), { passive: true }); document.addEventListener(\"visibilitychange\", () => { this.scrambleActive = !document.hidden; }); } _start() { if (!this.heat.active) { this.heat.active = true; this._anim(); } } _stop() { this.heat.active = false; cancelAnimationFrame(this._raf); this._render(); } _anim = () => { this._update(); this._render(); if (this.heat.active) { this._raf = requestAnimationFrame(this._anim); } }; _render() { const { ctx, W, H, res, P, heat, coverCanvas, staticCanvas } = this; ctx.clearRect(0, 0, W, H); ctx.drawImage(staticCanvas, 0, 0); if (heat.active || heat.maxValue > 0) { const gridSize = P.grid.size; const threshold = P.effect.threshold; for (let y = 0; y < H; y += gridSize) { for (let x = 0; x < W; x += gridSize) { const idx = Math.floor((y / H) * res) * res + Math.floor((x / W) * res); if (heat.current[idx] > threshold) { ctx.save(); ctx.beginPath(); ctx.rect(x, y, gridSize, gridSize); ctx.clip(); ctx.drawImage(coverCanvas, 0, 0); ctx.restore(); } } } } } _update() { const now = performance.now(); if (!this.heat.lastTime) { this.heat.lastTime = now; return; } const dt = Math.min(30, now - this.heat.lastTime) / 16.67; this.heat.lastTime = now; const H = this.heat; const P = this.P.effect; H.maxValue = 0; const tempGrid = new Float32Array(this.res * this.res); const res = this.res; for (let y = 1; y < res - 1; y++) { for (let x = 1; x < res - 1; x++) { const idx = y * res + x; if ( H.current[idx] < P.threshold && H.current[idx - res] < P.threshold && H.current[idx + res] < P.threshold && H.current[idx - 1] < P.threshold && H.current[idx + 1] < P.threshold ) { continue; } const up = H.current[idx - res]; const down = H.current[idx + res]; const left = H.current[idx - 1]; const right = H.current[idx + 1]; const upLeft = H.current[idx - res - 1]; const upRight = H.current[idx - res + 1]; const downLeft = H.current[idx + res - 1]; const downRight = H.current[idx + res + 1]; const neighbors = (up + down + left + right) * 0.15 + (upLeft + upRight + downLeft + downRight) * 0.05; tempGrid[idx] = H.current[idx] * (1 - P.diffusion) + neighbors * P.diffusion; tempGrid[idx] *= P.decay; if (tempGrid[idx] < P.threshold) { tempGrid[idx] = 0; } else { H.maxValue = Math.max(H.maxValue, tempGrid[idx]); } } } H.current.set(tempGrid); for (let i = 0; i < res; i++) { H.current[i] *= P.decay; H.current[(res - 1) * res + i] *= P.decay; H.current[i * res] *= P.decay; H.current[i * res + (res - 1)] *= P.decay; } if (H.maxValue <= P.threshold) { this._stop(); } } _addHeat(px, py, amount = 1) { const nx = (px / this.W) * this.res; const ny = (py / this.H) * this.res; const rad = this.lowPerformanceMode ? 8 : 12; for (let i = -rad; i <= rad; i++) { for (let j = -rad; j <= rad; j++) { const x = Math.floor(nx + i); const y = Math.floor(ny + j); if (x < 0 || x >= this.res || y < 0 || y >= this.res) continue; const idx = y * this.res + x; const d = Math.hypot(i, j); if (d <= rad) { const intensity = amount * Math.pow(1 - d / rad, 1.5); this.heat.current[idx] += intensity; this.heat.current[idx] = Math.min(1, this.heat.current[idx]); this.heat.maxValue = Math.max( this.heat.maxValue, this.heat.current[idx] ); } } } this._start(); } _move(e) { const now = performance.now(); if (now - (this._lastEvt || 0) < 30) return; this._lastEvt = now; const { x, y } = this._coords(e); if (this._lastX != null) { const d = Math.hypot(x - this._lastX, y - this._lastY); if (d > 2) this._addHeat(x, y, Math.min(d * 0.03, 0.8)); } this._lastX = x; this._lastY = y; } _down(e) { const { x, y } = this._coords(e); this._addHeat(x, y, 1.5); this._lastX = x; this._lastY = y; } _leave() { this._lastX = this._lastY = null; } _coords(e) { const r = this.canvas.getBoundingClientRect(); const cx = (e.clientX !== undefined ? e.clientX : e.touches[0].clientX) - r.left; const cy = (e.clientY !== undefined ? e.clientY : e.touches[0].clientY) - r.top; return { x: cx * (this.W / r.width), y: cy * (this.H / r.height) }; } _clearHeat() { this.heat.current.fill(0); this.heat.lastTime = 0; this.heat.maxValue = 0; } destroy() { if (this.scrambleTimer) { clearInterval(this.scrambleTimer); } this._stop(); this.canvas.removeEventListener(\"pointermove\", this._move); this.canvas.removeEventListener(\"pointerdown\", this._down); this.canvas.removeEventListener(\"pointerleave\", this._leave); this.canvas.removeEventListener(\"pointercancel\", this._leave); document.removeEventListener(\"visibilitychange\", this._visibilityChange); } } const image = new TextHeatReveal( document.getElementById(\"canvas\"), \"https://cdn.cosmos.so/a8bf7aec-4414-4a8f-991b-d7d2f970a626?format=jpeg\", { gridSize: 12, fontSize: 10, characters: \"\u2726\u274dQWERTYUIOPASDFGHJKLZXCVBNM*+\", resolution: 96, diffusion: 0.92, decay: 0.98, threshold: 0.04, contrast: 1.25, minBrightness: 0.15, textOpacity: 0.55, imageBrightness: 1, imageContrast: 1.0, scrambleInterval: 1500, scrambleAmount: 0.08, words: [\"CREATE\", \"INSPIRE\", \"DESIGN\", \"IMAGINE\", \"VISION\", \"IDEA\", \"DREAM\"] } ); window.addEventListener(\"beforeunload\", () => { if (image) image.destroy(); });",
    "id": "gsapscrambletext--canvas-scramble-text-experiment-gsap---challenge-1--entry-3"
  },
  {
    "title": "Text scroll and hover effect with GSAP and clip",
    "description": "",
    "code": "index.html: <div class=\"container\"> <h1 class=\"text\">TEXT EFFECT<span>WOAH</span></h1> <h1 class=\"text\">GSAP<span>AND CLIPPING</span></h1> <h1 class=\"text\">CRAZYYY<span>CRAZYYY</span></h1> <h1 class=\"text\">HOVER ON ME<span><a href=\"https://stacksorted.com/text-effects/minh-pham\" target=\"_blank\">SOURCE</a></span></h1> <h1 class=\"text\">LIKE THIS?<span><a href=\"https://twitter.com/juxtopposed\" target=\"_blank\">LET'S CONNECT</a></span></h1> </div>\nstyle.css: body { margin: 0; padding: 0; font-family: 'Poppins', sans-serif; background-color: #0D0D0D; margin: 10%; } .container { display: flex; flex-direction: column; justify-content: center; align-items: flex-start; height: 200vh; } .text { font-size: 10vw; letter-spacing: -.01em; line-height: 100%; margin: 0; width: 100%; color: rgb(182, 182, 182, 0.2); background: linear-gradient(to right, #b6b6b6, #b6b6b6) no-repeat; -webkit-background-clip: text; background-clip: text; background-size: 0%; transition: background-size cubic-bezier(.1,.5,.5,1) 0.5s; border-bottom: 1px solid #2F2B28; display: flex; flex-direction: column; align-items: flex-start; justify-content: center; position: relative; } span { position: absolute; width: 100%; height: 100%; background-color: #4246ce; color: #0D0D0D; clip-path: polygon(0 50%, 100% 50%, 100% 50%, 0 50%); transform-origin: center; transition: all cubic-bezier(.1,.5,.5,1) 0.4s; display: flex; flex-direction: column; justify-content: center; } .text:hover > span { clip-path: polygon(0 0, 100% 0, 100% 100%, 0% 100%); } a { text-decoration: none; color: inherit; }\nscript.js: gsap.registerPlugin(ScrollTrigger); const textElements = gsap.utils.toArray('.text'); textElements.forEach(text => { gsap.to(text, { backgroundSize: '100%', ease: 'none', scrollTrigger: { trigger: text, start: 'center 80%', end: 'center 20%', scrub: true, }, }); });",
    "id": "text-scroll-and-hover-effect-with-gsap-and-clip"
  },
  {
    "title": "Text on a Tank Tread",
    "description": "",
    "code": "index.html: <div id=\"root\"></div>\nstyle.css: @use \"sass:math\"; * { \tborder: 0; \tbox-sizing: border-box; \tmargin: 0; \tpadding: 0; } :root { \t--hue: 223; \t--bg: hsl(var(--hue), 90%, 50%); \t--front: hsl(var(--hue), 90%, 95%); \t--back: hsl(var(--hue), 90%, 5%); \t--trans-dur: 0.3s; \tfont-size: clamp(1rem, 0.9rem + 0.5vw, 1.5rem); } body { \tbackground-color: var(--bg); \tcolor: var(--back); \tdisplay: grid; \tplace-items: center; \tfont: 1em/1.5 -apple-system, BlinkMacSystemFont, \"Helvetica Neue\", Helvetica, sans-serif; \theight: 100vh; } .tot { \tposition: relative; \twidth: 20em; \theight: 20em; \t&__layer, \t&__tread { \t\tposition: absolute; \t\ttop: 50%; \t\tleft: 50%; \t} \t&__layer { \t\tcolor: transparent; \t\tdirection: ltr; \t\tfont: { \t\t\tsize: 3em; \t\t\tweight: 900; \t\t}; \t\tline-height: 1; \t\ttransform: translate(-50%, -50%) rotateX(45deg) rotateZ(45deg); \t\ttransform-style: preserve-3d; \t} \t&__tread { \t\tanimation: { \t\t\tname: letter-tread-back; \t\t\ttiming-function: linear; \t\t\titeration-count: infinite; \t\t}; \t\tbackface-visibility: hidden; \t\tcolor: var(--back); \t\toverflow: hidden; \t\theight: 100%; \t\ttransform: translate(-50%, -50%); \t\ttransition: color var(--trans-dur); \t\t&-window { \t\t\t&:before { \t\t\t\tcontent: attr(data-text); \t\t\t\tdisplay: block; \t\t\t\twhite-space: nowrap; \t\t\t\ttransform: rotateY(180deg); \t\t\t} \t\t} \t} \t&__layer:last-child &__tread { \t\tanimation-name: letter-tread-front; \t\tcolor: var(--front); \t\t&-window { \t\t\t&:before { \t\t\t\ttransform: rotateY(0); \t\t\t} \t\t} \t} } /* Animations */ $treadHalf: 8rem; $treadRadius: 2rem; $treadCircle: 2 * math.$pi * $treadRadius; $treadLength: $treadHalf * 4 + $treadCircle; @debug $treadLength; @keyframes letter-tread-back { \tfrom { \t\ttransform: translate(-50%, -50%) translateX(0) rotateY(0) translateZ(-$treadRadius); \t} \t#{($treadHalf / $treadLength) * 100%} { \t\ttransform: translate(-50%, -50%) translateX($treadHalf) rotateY(0) translateZ(-$treadRadius); \t} \t#{(($treadHalf + $treadCircle * 0.5) / $treadLength) * 100%} { \t\ttransform: translate(-50%, -50%) translateX($treadHalf) rotateY(-180deg) translateZ(-$treadRadius); \t} \t#{(($treadHalf * 2 + $treadCircle * 0.5) / $treadLength) * 100%} { \t\ttransform: translate(-50%, -50%) translateX(0) rotateY(-180deg) translateZ(-$treadRadius); \t} \t#{(($treadHalf * 3 + $treadCircle * 0.5) / $treadLength) * 100%} { \t\ttransform: translate(-50%, -50%) translateX(-$treadHalf) rotateY(-180deg) translateZ(-$treadRadius); \t} \t#{(($treadHalf * 3 + $treadCircle) / $treadLength) * 100%} { \t\ttransform: translate(-50%, -50%) translateX(-$treadHalf) rotateY(-360deg) translateZ(-$treadRadius); \t} \tto { \t\ttransform: translate(-50%, -50%) translateX(0) rotateY(-360deg) translateZ(-$treadRadius); \t} } @keyframes letter-tread-front { \tfrom { \t\ttransform: translate(-50%, -50%) translateX(0) rotateY(0) translateZ($treadRadius); \t} \t#{($treadHalf / $treadLength) * 100%} { \t\ttransform: translate(-50%, -50%) translateX(-$treadHalf) rotateY(0) translateZ($treadRadius); \t} \t#{(($treadHalf + $treadCircle * 0.5) / $treadLength) * 100%} { \t\ttransform: translate(-50%, -50%) translateX(-$treadHalf) rotateY(-180deg) translateZ($treadRadius); \t} \t#{(($treadHalf * 2 + $treadCircle * 0.5) / $treadLength) * 100%} { \t\ttransform: translate(-50%, -50%) translateX(0) rotateY(-180deg) translateZ($treadRadius); \t} \t#{(($treadHalf * 3 + $treadCircle * 0.5) / $treadLength) * 100%} { \t\ttransform: translate(-50%, -50%) translateX($treadHalf) rotateY(-180deg) translateZ($treadRadius); \t} \t#{(($treadHalf * 3 + $treadCircle) / $treadLength) * 100%} { \t\ttransform: translate(-50%, -50%) translateX($treadHalf) rotateY(-360deg) translateZ($treadRadius); \t} \tto { \t\ttransform: translate(-50%, -50%) translateX(0) rotateY(-360deg) translateZ($treadRadius); \t} }\nscript.js: import React, { createContext, StrictMode, useContext, useState } from \"https://esm.sh/react\"; import { createRoot } from \"https://esm.sh/react-dom/client\"; const TextOnTreadContext = createContext<TextOnTreadContextType | undefined>(undefined); const TextOnTreadProvider: React.FC<TextOnTreadProviderProps> = ({ children, value }) => { const [text] = useState<string>(value); return ( <TextOnTreadContext.Provider value={{ text }}> {children} </TextOnTreadContext.Provider> ); }; createRoot(document.getElementById(\"root\")!).render( \t<StrictMode> \t\t<TextOnTreadProvider value=\"RESILIENCE\"> \t\t\t<TextOnTread /> \t\t</TextOnTreadProvider> \t</StrictMode> ); function TextOnTread() { \tconst duration = 8000; // in ms \tconst treadLength = 44.57; // from \"https://esm.sh/$treadLength\" in SCSS \tconst treadFragments = 80; \tconst treadFragmentWidth = treadLength / treadFragments; \tconst backTreadArray: React.ReactNode[] = []; \tconst frontTreadArray: React.ReactNode[] = []; \tfor (let f = 0; f < treadFragments; ++f) { \t\tconst backKey = `back-${f}`; \t\tconst frontKey = `front-${f}`; \t\tconst percent = f / treadFragments; \t\tconst moveX = f * treadFragmentWidth; \t\tbackTreadArray.push( \t\t\t<TextOnTreadFragment \t\t\t\tkey={backKey} \t\t\t\tdelay={-duration + (percent * duration)} \t\t\t\tduration={duration} \t\t\t\tmoveX={-moveX} \t\t\t\twidth={treadFragmentWidth} \t\t\t/> \t\t); \t\tfrontTreadArray.push( \t\t\t<TextOnTreadFragment \t\t\t\tkey={frontKey} \t\t\t\tdelay={-duration + ((percent - 0.5) * duration)} \t\t\t\tduration={duration} \t\t\t\tmoveX={moveX} \t\t\t\twidth={treadFragmentWidth} \t\t\t/> \t\t); \t} \treturn ( \t\t<div className=\"tot\"> \t\t\t<TextOnTreadLayer layerFragments={frontTreadArray} /> \t\t\t<TextOnTreadLayer layerFragments={backTreadArray} ariaHidden={true} /> \t\t</div> \t); } function TextOnTreadFragment({ delay, duration, moveX, width }: TextOnTreadFragmentProps) { \tconst context = useContext(TextOnTreadContext); \tif (!context) { throw new Error(\"`TextOnTreadFragment` must be used within `TextOnTreadProvider`\"); } \tconst { text } = context; \tconst treadStyle = { \t\tanimationDuration: `${duration}ms`, \t\tanimationDelay: `${delay}ms`, \t\twidth: `calc(${width}rem + 1px)` // extra 1px for bleed \t}; \tconst windowStyle = { \t\ttransform: `translateX(${moveX}rem)` \t}; \treturn ( \t\t<div className=\"tot__tread\" style={treadStyle}> \t\t\t<div className=\"tot__tread-window\" aria-hidden=\"true\" data-text={text} style={windowStyle}></div> \t\t</div> \t); } function TextOnTreadLayer({ layerFragments, ariaHidden }: TextOnTreadLayerProps) { \tconst context = useContext(TextOnTreadContext); \tif (!context) { \t\tthrow new Error(\"`TextOnTreadLayer` must be used within `TextOnTreadProvider`\"); \t} \tconst { text } = context; \treturn ( \t\t<div className=\"tot__layer\" aria-hidden={ariaHidden}> \t\t\t{text}{layerFragments} \t\t</div> \t); }",
    "id": "text-on-a-tank-tread"
  },
  {
    "title": "Clip text hero",
    "description": "",
    "code": "index.html: <div class=\"hero\"> <img class=\"hero__cover\" src=\"https://images.pexels.com/photos/906097/pexels-photo-906097.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=1080&amp;w=1920\" alt=\"\" width=\"1080\" height=\"1920\"> <h1 class=\"hero__body\">One Ressort</h1> </div> <div class=\"hero hero--3\"> <img class=\"hero__cover\" src=\"https://picsum.photos/id/678/1920/1080\" alt=\"\" width=\"1080\" height=\"1920\"> <h1 class=\"hero__body\">One Ressort</h1> </div> <div class=\"hero hero--2\"> <img class=\"hero__cover\" src=\"https://picsum.photos/id/872/1920/1080\" alt=\"\" width=\"1080\" height=\"1920\"> <h1 class=\"hero__body\">One Ressort</h1> </div> <div class=\"spacer\"> </div>\nstyle.css: :root { background: #000; color: rgba(255,255,255,.5); font-family: system-ui; } img { max-width: 100%; height: auto; } html { scroll-timeline: --page-scroll block; scroll-behavior: smooth; } body { margin: 0; } .hero { display: grid; grid-template-areas: \"stack\"; view-timeline-name: --hero; view-timeline-axis: block; overflow: clip; max-width: fit-content; margin: auto; --hero-bg: url('https://images.pexels.com/photos/906097/pexels-photo-906097.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=1080&amp;w=1920'); &--2 { --hero-bg: url('https://picsum.photos/id/872/1920/1080'); } &--3 { --hero-bg: url('https://picsum.photos/id/678/1920/1080'); } &__cover { display: block; grid-area: stack; } &__body { grid-area: stack; display: grid ; justify-content: center; align-items: center; text-align: center; padding: 1rem; line-height: 1; font-size: clamp(4rem, 14vw, 10rem); // transform: translate(0, 1rem); background-image: var(--hero-bg); background-size: auto 133%; background-clip: text; background-position: 50% 50%; color: rgba(255,255,255,.05); margin: 0; animation: linear parallax both; animation-timeline: --hero; //animation-timeline: view(block); //animation-range: contain -15% contain; //animation-timeline: view(block); } } @keyframes parallax { to { //transform: translate(0, 1rem); background-position: 50% -100%; } } .spacer { aspect-ratio: 1 / 2; }\nscript.js: ",
    "id": "clip-text-hero"
  },
  {
    "title": "Flip Text on Hover - Syntax challenge",
    "description": "",
    "code": "index.html: <div class=\"wrapper\"> \t<a href=\"#\" class=\"word\" aria-label=\"tiktok\"> \t\t<span aria-hidden=\"true\">t</span> \t\t<span aria-hidden=\"true\">i</span> \t\t<span aria-hidden=\"true\">k</span> \t\t<span aria-hidden=\"true\">t</span> \t\t<span aria-hidden=\"true\">o</span> \t\t<span aria-hidden=\"true\">k</span> \t</a> \t<a href=\"#\" class=\"word\" aria-label=\"instagram\"> \t\t<span aria-hidden=\"true\">i</span> \t\t<span aria-hidden=\"true\">n</span> \t\t<span aria-hidden=\"true\">s</span> \t\t<span aria-hidden=\"true\">t</span> \t\t<span aria-hidden=\"true\">a</span> \t\t<span aria-hidden=\"true\">g</span> \t\t<span aria-hidden=\"true\">r</span> \t\t<span aria-hidden=\"true\">a</span> \t\t<span aria-hidden=\"true\">m</span> \t</a> \t<a href=\"#\" class=\"word\" aria-label=\"youtube\"> \t\t<span aria-hidden=\"true\">y</span> \t\t<span aria-hidden=\"true\">o</span> \t\t<span aria-hidden=\"true\">u</span> \t\t<span aria-hidden=\"true\">t</span> \t\t<span aria-hidden=\"true\">u</span> \t\t<span aria-hidden=\"true\">b</span> \t\t<span aria-hidden=\"true\">e</span> \t</a> \t<a href=\"#\" class=\"word\" aria-label=\"twitch\"> \t\t<span aria-hidden=\"true\">t</span> \t\t<span aria-hidden=\"true\">w</span> \t\t<span aria-hidden=\"true\">i</span> \t\t<span aria-hidden=\"true\">t</span> \t\t<span aria-hidden=\"true\">c</span> \t\t<span aria-hidden=\"true\">h</span> \t</a> </div>\nstyle.css: @import url(https://fonts.bunny.net/css?family=bayon:400); @layer base, demo; @layer demo { \tbody{ \t\tfont-family: 'Bayon', sans-serif; \t} \t.word { \t\t--translate-distance: -1lh; \t\t--trans-duration: 3000ms; \t\t--trans-delay-factor: 20ms; \t\t--trans-timimg-function: linear(0, 0.011 0.6%, 0.041 1.2%, 0.173 2.6%, 0.894 7.4%, 1.128 9.3%, 1.271 11.1%, 1.311 12%, 1.333 13%, 1.328 14.4%, 1.286 15.9%, 1.031 21%, 0.95 23%, 0.907 24.7%, 0.888 26.5%, 0.89 27.9%, 0.904 29.4%, 1.034 42.5%, 0.997 49.3%, 0.987 53.3%, 1.004 66.5%, 1); \t\t--text-color-hover: rgb(0 132 209); \t\t--font-size: clamp(3rem, 8.5vw + .045rem, 8rem); \t\t \t\t \t\t \t\t \t\ttext-decoration: none; \t\ttext-transform: uppercase; \t\tmargin: 0; \t\tfont-size: var(--font-size); \t\tfont-weight: 700; \t\t \t\t \t\ttext-grow: per-line/consistent scale; /* not working yet on standard browser */ \t\tcolor: var(--clr-txt); \t\tline-height: .8; \t\tdisplay: flex; \t\toverflow: hidden; \t\t&:visited{ \t\t\tcolor: var(--clr-txt); \t\t} \t\t&::selection { \t\t\tbackground: transparent; \t\t} \t\t& > span{ \t\t\t--i: sibling-index(); \t\t\t--translate: calc(var(--translate-distance) * 2); \t\t\t--trans-delay: calc(var(--i) * var(--trans-delay-factor)); \t\t\ttext-shadow: 0 1lh var(--text-color-hover); \t\t\tdisplay: inline-block; \t\t\ttransition: translate var(--trans-duration) var(--trans-timimg-function) var(--trans-delay); \t\t} \t\t&:hover > span { \t\t\t translate: 0 var(--translate-distance); \t\t} \t} /* general styling not relevant for this demo */ @layer base { \t* { \t\tbox-sizing: border-box; \t} \t:root { \t\tcolor-scheme: light dark; \t\t--bg-dark: rgb(16, 24, 40); \t\t--bg-light: rgb(255, 237, 212); \t\t--txt-light: rgb(10, 10, 10); \t\t--txt-dark: rgb(245, 245, 245);); \t\t--line-light: rgba(0 0 0 / .25); \t\t--line-dark: rgba(255 255 255 / .25); --clr-bg: light-dark(var(--bg-light), var(--bg-dark)); --clr-txt: light-dark(var(--txt-light), var(--txt-dark)); --clr-lines: light-dark(var(--line-light), var(--line-dark)); \t} \tbody { \t\tbackground-color: var(--clr-bg); \t\tcolor: var(--clr-txt); \t\tmin-height: 100svh; \t\tmargin: 0; \t\tpadding: 2rem; \t\tfont-family: system-ui, sans-serif; \t\tfont-size: 1rem; \t\tline-height: 1.5; display: grid; place-items: center; gap: 2rem; \t\t& > * { \t\t\t/*outline: 1px dashed red;*/ \t\t} \t} \th1 { \t\tmargin: 0; \t\tfont-size: 1.2rem; \t} /* screen-reader only */ .sr-only { position: absolute !important; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; } \t.msg-supports { \t\tfont-size: 0.8rem; \t\t/* @supports (animation-timeline: scroll()) { \t\t\tdisplay: none; \t\t} @supports (order:sibling-index()) { \t\t\tdisplay: none; \t\t} @supports (x: attr(x type(*))) { \t\t\tdisplay: none; \t\t} */ \t} }\nscript.js: ",
    "id": "flip-text-on-hover---syntax-challenge"
  },
  {
    "title": "liquid text mask",
    "description": "",
    "code": "index.html: <div class=\"mask\">MIATA</div>\nstyle.css: @import url(https://fonts.googleapis.com/css?family=Montserrat:700); @property --o {syntax: \"<number>\";initial-value:1;inherits: true} body { margin: 0; height: 100vh; background: conic-gradient(rgb(0 0 0/var(--o)) 0 0), url('https://assets.codepen.io/32887/91-brg.jpg') 50%/cover no-repeat; animation: --o 3s forwards ease-out 1s; } @keyframes --o {to{--o:0}} .mask { position: fixed; inset: 0; display: grid; place-items: center; place-content: center; font: bold 5vmax Montserrat, sans-serif; background: url('https://assets.codepen.io/32887/91-brg.jpg') 50%/cover no-repeat; -webkit-background-clip: text; background-clip: text; color: #0000; -webkit-text-fill-color: #0000; scale: 2; animation: reveal 3s forwards ease-out 1s; } @keyframes reveal { to { scale: 1; font-size: 180vmax; } }\nscript.js: ",
    "id": "liquid-text-mask"
  },
  {
    "title": "Grainy & Gradients text",
    "description": "",
    "code": "index.html: <main> <h1 contenteditable>Hello.</h1> </main>\nstyle.css: @font-face { font-family: \"Mona Sans\"; src: url(\"https://assets.codepen.io/64/Mona-Sans.woff2\") format(\"woff2 supports variations\"), url(\"https://assets.codepen.io/64/Mona-Sans.woff2\") format(\"woff2-variations\"); font-weight: 100 1000; } @property --bg-1-x { syntax: \"<number>\"; inherits: true; initial-value: 0; } @property --bg-2-x { syntax: \"<number>\"; inherits: true; initial-value: 0; } @property --bg-2-y { syntax: \"<number>\"; inherits: true; initial-value: 0; } @property --bg-3-x { syntax: \"<number>\"; inherits: true; initial-value: 0; } @property --bg-3-y { syntax: \"<number>\"; inherits: true; initial-value: 0; } :root { --bg-color: hsl(240deg 10% 12%); --bg-grain: url(\"https://assets.codepen.io/64/svgNoise2.svg\"); // In case you want to use an image instead of a data-uri --bg-grain: url(\"data:image/svg+xml,%3Csvg viewBox='0 0 600 600' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E\"); --shadow-size: max(140px, 40vw); --shadow-size-fallback: 40vw; --shadow-blur: 60; --color-1: #6328da; --color-2: #ff1bf1; --color-3: #008cea; --bg-1-x: 0; --bg-1-y: 0; --bg-2-x: 0; --bg-2-y: 0; --bg-3-x: 0; --bg-3-y: 0; } @supports (color: color(display-p3 1 1 1)) { :root { --color-1: color(display-p3 0.36 0.17 0.82); --color-2: color(display-p3 0.95 0.04 0.95); --color-3: color(display-p3 0.01 0.53 0.99); } } @media (min-width: 960px) { :root { --shadow-size: max(72px, 25vw); --shadow-size-fallback: 25vw; --shadow-blur: 80; } } * { box-sizing: border-box; outline: calc(var(--debug) * 1px) dashed red; &:before, &:after { outline: calc(var(--debug) * 1px) dashed red; } } html, body { width: 100%; height: 100%; padding: 0; margin: 0; } body { font-family: \"Mona Sans\", sans-serif; display: grid; grid-template-columns: repeat(1, 1fr); background: var(--bg-color); z-index: 1; // If i remove the next line, the debug view bugs \u00af\\_(\u30c4)_/\u00af position: relative; &:before { content: \"\"; position: absolute; display: block; width: 100%; height: 100%; z-index: 1; background: radial-gradient( circle var(--shadow-size, var(--shadow-size-fallback)) at 20vw 0, var(--color-1, red) 100%, transparent 0 ), radial-gradient( circle var(--shadow-size, var(--shadow-size-fallback)) at 100vw 0, var(--color-2, red) 100%, transparent 0 ), radial-gradient( circle calc(var(--shadow-size, var(--shadow-size-fallback)) * 1.2) at 50vw 115vh, var(--color-3, red) 100%, transparent 0 ); top: 0; left: 0; opacity: 0.5; filter: blur(calc(var(--shadow-blur) * 1px)); mix-blend-mode: hue; } &:after { content: \"\"; display: block; width: 100%; height: 100%; position: absolute; z-index: -1; top: 0; left: 0; filter: contrast(145%) brightness(650%) invert(100%); mix-blend-mode: screen; background: var(--bg-grain); background-size: 500px; } } main { width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: grid; place-items: center; z-index: 2; h1 { color: white; font-size: max(72px, 15vw); mix-blend-mode: lighten; font-weight: 650; font-stretch: 110%; letter-spacing: -0.04em; background: var(--bg-grain), conic-gradient( from 140deg at calc(var(--bg-1-x) * 1%) 90%, hsl(30deg 100% 5%), hsl(238deg 100% 5%), hsl(60deg 100% 99%), hsl(248deg 100% 31%), hsl(315deg 64% 51%), hsl(25deg 95% 61%), hsl(55deg 100% 75%), hsl(60deg 100% 99%), hsl(199deg 94% 74%), hsl(236deg 95% 28%), hsl(244deg 100% 4%) ), radial-gradient( ellipse at calc(var(--bg-2-x) * 1%) calc(var(--bg-2-y) * 1%), white 12%, transparent 35% ), radial-gradient( ellipse at calc(var(--bg-3-x) * 1%) calc(var(--bg-3-y) * 1%), hsl(212deg 94% 68%), transparent 35% ); background-repeat: repeat; background-size: 500px, cover; background-blend-mode: color-burn; -webkit-background-clip: text; -webkit-text-fill-color: transparent; opacity: 1; animation: bg 20s linear infinite alternate; } } @keyframes bg { 0% { --bg-1-x: calc(50 / 2); --bg-2-y: calc(80 / 2); --bg-2-x: calc(70 / 2); --bg-3-y: calc(40 / 2); --bg-3-x: calc(90 / 2); } 25% { --bg-1-x: 30; --bg-2-y: 50; --bg-2-x: 80; --bg-3-y: 20; --bg-3-x: 70; } 50% { --bg-1-x: 10; --bg-2-y: 40; --bg-2-x: 30; --bg-3-y: 80; --bg-3-x: 50; } 75% { --bg-1-x: 70; --bg-2-y: 10; --bg-2-x: 50; --bg-3-y: 30; --bg-3-x: 40; } 100% { --bg-1-x: calc(50 / 2); --bg-2-y: calc(80 / 2); --bg-2-x: calc(70 / 2); --bg-3-y: calc(40 / 2); --bg-3-x: calc(90 / 2); } }\nscript.js: function getTooltipGradientColor() { const tooltip = document.querySelector(\".tooltip\"); const tooltipRect = tooltip.getBoundingClientRect(); const gradientX = tooltipRect.left + tooltipRect.width / 2; const gradientY = tooltipRect.top + tooltipRect.height; const gradient = window.getComputedStyle(tooltip).getPropertyValue(\"background-image\"); const canvas = document.createElement(\"canvas\"); canvas.width = 1; canvas.height = 1; const ctx = canvas.getContext(\"2d\"); ctx.rect(0, 0, 1, 1); const gradientObj = ctx.createLinearGradient(0, 0, 0, 1); gradientObj.style = gradient; ctx.fillStyle = gradientObj; ctx.fill(); const imageData = ctx.getImageData(0, 0, 1, 1); const red = imageData.data[0]; const green = imageData.data[1]; const blue = imageData.data[2]; return `rgb(${red}, ${green}, ${blue})`; } function updateTooltipPosition(event) { const tooltip = event.currentTarget; const tooltipRect = tooltip.getBoundingClientRect(); const positionX = (event.clientX - tooltipRect.left) / tooltipRect.width * 100; const positionY = (event.clientY - tooltipRect.top) / tooltipRect.height * 100; tooltip.style.setProperty(\"--position-x\", positionX); tooltip.style.setProperty(\"--position-y\", positionY); const gradient = window.getComputedStyle(tooltip).getPropertyValue(\"background-image\"); const tooltipGradientColor = getTooltipGradientColor(gradient); console.log(tooltipGradientColor); } const tooltips = document.querySelectorAll(\".tooltip\"); tooltips.forEach((tooltip) => //tooltip.addEventListener(\"mousemove\", updateTooltipPosition) null );",
    "id": "grainy--gradients-text"
  },
  {
    "title": "[gsap/splittext] \u274d Kinetic Typography Experiment GSAP - Challenge #1",
    "description": "",
    "code": "index.html: <div class=\"background-frame\"></div> <div class=\"background-image default\" id=\"default-bg\"></div> <div class=\"background-image focus\" id=\"focus-bg\"></div> <div class=\"background-image presence\" id=\"presence-bg\"></div> <div class=\"background-image feel\" id=\"feel-bg\"></div> <div class=\"bottom-gradient\"></div> <div class=\"text-background\"> <div class=\"text-item\" style=\"top: 5%; left: 8%;\" data-text=\"BE\">BE</div> <div class=\"text-item\" style=\"top: 5%; left: 15%;\" data-text=\"PRESENT\">PRESENT</div> <div class=\"text-item\" style=\"top: 5%; left: 28%;\" data-text=\"LISTEN\">LISTEN</div> <div class=\"text-item\" style=\"top: 5%; left: 42%;\" data-text=\"DEEPLY\">DEEPLY</div> <div class=\"text-item\" style=\"top: 5%; left: 55%;\" data-text=\"OBSERVE\">OBSERVE</div> <div class=\"text-item\" style=\"top: 5%; left: 75%;\" data-text=\"&\">& </div> <div class=\"text-item\" style=\"top: 5%; left: 85%;\" data-text=\"FEEL\">FEEL</div> <div class=\"text-item\" style=\"top: 10%; left: 12%;\" data-text=\"MAKE\">MAKE</div> <div class=\"text-item\" style=\"top: 10%; left: 45%;\" data-text=\"BETTER\">BETTER</div> <div class=\"text-item\" style=\"top: 10%; right: 20%;\" data-text=\"DECISIONS\">DECISIONS</div> <div class=\"text-item\" style=\"top: 15%; left: 8%;\" data-text=\"THE\">THE</div> <div class=\"text-item\" style=\"top: 15%; left: 30%;\" data-text=\"CREATIVE\">CREATIVE</div> <div class=\"text-item\" style=\"top: 15%; left: 55%;\" data-text=\"PROCESS\">PROCESS</div> <div class=\"text-item\" style=\"top: 15%; right: 20%;\" data-text=\"IS\">IS</div> <div class=\"text-item\" style=\"top: 15%; right: 5%;\" data-text=\"MYSTERIOUS\">MYSTERIOUS</div> <div class=\"text-item\" style=\"top: 25%; left: 5%;\" data-text=\"S\">S</div> <div class=\"text-item\" style=\"top: 25%; left: 10%;\" data-text=\"I\">I</div> <div class=\"text-item\" style=\"top: 25%; left: 15%;\" data-text=\"M\">M</div> <div class=\"text-item\" style=\"top: 25%; left: 20%;\" data-text=\"P\">P</div> <div class=\"text-item\" style=\"top: 25%; left: 25%;\" data-text=\"L\">L</div> <div class=\"text-item\" style=\"top: 25%; left: 30%;\" data-text=\"I\">I</div> <div class=\"text-item\" style=\"top: 25%; left: 35%;\" data-text=\"C\">C</div> <div class=\"text-item\" style=\"top: 25%; left: 40%;\" data-text=\"I\">I</div> <div class=\"text-item\" style=\"top: 25%; left: 45%;\" data-text=\"T\">T</div> <div class=\"text-item\" style=\"top: 25%; left: 50%;\" data-text=\"Y\">Y</div> <div class=\"text-item\" style=\"top: 25%; right: 5%;\" data-text=\"IS THE KEY\">IS THE KEY</div> <div class=\"text-item\" style=\"top: 35%; left: 25%;\" data-text=\"FIND YOUR VOICE\">FIND YOUR VOICE</div> <div class=\"text-item\" style=\"top: 35%; left: 65%;\" data-text=\"TRUST INTUITION\">TRUST INTUITION</div> <div class=\"text-item\" style=\"top: 50%; left: 5%;\" data-text=\"EMBRACE SILENCE\">EMBRACE SILENCE</div> <div class=\"text-item\" style=\"top: 50%; right: 5%;\" data-text=\"QUESTION EVERYTHING\">QUESTION EVERYTHING</div> <div class=\"text-item\" style=\"top: 75%; left: 20%;\" data-text=\"TRUTH\">TRUTH</div> <div class=\"text-item\" style=\"top: 75%; right: 20%;\" data-text=\"WISDOM\">WISDOM</div> <div class=\"text-item\" style=\"top: 80%; left: 10%;\" data-text=\"FOCUS\">FOCUS</div> <div class=\"text-item\" style=\"top: 80%; left: 35%;\" data-text=\"ATTENTION\">ATTENTION</div> <div class=\"text-item\" style=\"top: 80%; left: 65%;\" data-text=\"AWARENESS\">AWARENESS</div> <div class=\"text-item\" style=\"top: 80%; right: 10%;\" data-text=\"PRESENCE\">PRESENCE</div> <div class=\"text-item\" style=\"top: 85%; left: 25%;\" data-text=\"SIMPLIFY\">SIMPLIFY</div> <div class=\"text-item\" style=\"top: 85%; right: 25%;\" data-text=\"REFINE\">REFINE</div> </div> <div class=\"main-content\"> <div class=\"sliced-container\"> <div class=\"text-row\" data-row-id=\"focus\"> <div class=\"text-content\" data-text=\"FOCUS\">FOCUS</div> <div class=\"interactive-area\"></div> </div> <div class=\"text-row\" data-row-id=\"presence\"> <div class=\"text-content\" data-text=\"PRESENCE\">PRESENCE</div> <div class=\"interactive-area\"></div> </div> <div class=\"text-row\" data-row-id=\"feel\"> <div class=\"text-content\" data-text=\"FEEL\">FEEL</div> <div class=\"interactive-area\"></div> </div> </div> </div> <div class=\"type\" id=\"kinetic-type\" aria-hidden=\"true\"> <div class=\"type-line odd\">focus focus focus</div> <div class=\"type-line even\">presence presence presence</div> <div class=\"type-line odd\">feel feel feel</div> <div class=\"type-line even\">focus focus focus</div> <div class=\"type-line odd\">presence presence presence</div> <div class=\"type-line even\">focus focus focus</div> <div class=\"type-line odd\">focus focus focus</div> <div class=\"type-line even\">presence presence presence</div> <div class=\"type-line odd\">feel feel feel</div> <div class=\"type-line even\">focus focus focus</div> <div class=\"type-line odd\">presence presence presence</div> <div class=\"type-line even\">focus focus focus</div> </div>\nstyle.css: /* Shhhh I'm using three different fonts, but i don't care */ @import url(\"https://fonts.cdnfonts.com/css/longsile\"); @import url(\"https://fonts.cdnfonts.com/css/thegoodmonolith\"); @import url(\"https://fonts.cdnfonts.com/css/pp-neue-montreal\"); * { margin: 0; padding: 0; box-sizing: border-box; } :root { --text: #ffcc00; --bg: #000000; --highlight-bg: #ffcc00; --type-line-opacity: 0.05; } body { background-color: var(--bg); min-height: 100vh; overflow: hidden; font-family: \"Longsile\", sans-serif; position: relative; } .background-frame { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; background-image: url(\"https://assets.codepen.io/7558/web03.webp\"); background-size: 100% 100%; background-position: center; z-index: 0; pointer-events: none; } .bottom-gradient { position: fixed; bottom: 0; left: 0; width: 100%; height: 40vh; background: linear-gradient( to top, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 0) 100% ); z-index: 1; pointer-events: none; } .background-image { position: fixed; width: calc(100%); height: calc(100vh); background-size: cover; background-position: center; opacity: 0; z-index: 1; mix-blend-mode: multiply; transition: opacity 0.8s ease-in-out; } .background-image.default { background-image: url(\"https://assets.codepen.io/7558/wave-bg-001.webp\"); opacity: 1; } .background-image.focus { background-image: url(\"https://assets.codepen.io/7558/wave-bg-002.webp\"); } .background-image.presence { background-image: url(\"https://assets.codepen.io/7558/wave-bg-003.webp\"); } .background-image.feel { background-image: url(\"https://assets.codepen.io/7558/wave-bg-004.webp\"); } .text-background { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; } .text-item { position: absolute; color: var(--text); font-size: 0.8rem; text-transform: uppercase; opacity: 0.8; white-space: nowrap; font-family: \"TheGoodMonolith\", monospace; z-index: 0; } .text-item::after { content: \"\"; position: absolute; top: -2px; left: -4px; width: 0; height: calc(100% + 4px); background-color: var(--highlight-bg); z-index: 1; transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); } .text-item.highlight::after { width: calc(100% + 8px); } .text-item.highlight-reverse::after { width: 0; right: -4px; left: auto; } .main-content { position: relative; z-index: 10; height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; } .sliced-container { position: relative; width: auto; max-width: 100%; margin: 0 auto; transform: translateZ(0); } .text-row { position: relative; width: 100%; height: 140px; margin: 10px 0; display: flex; align-items: center; justify-content: center; overflow: visible; z-index: 100; } .text-content, .char, .char-inner { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-rendering: optimizeLegibility; transform: translateZ(0); will-change: transform; backface-visibility: hidden; } .text-content { position: relative; font-size: 10rem; font-weight: normal; text-transform: uppercase; height: 100%; display: flex; align-items: center; justify-content: center; z-index: 1; color: var(--text); letter-spacing: 0px; transition: letter-spacing 0.5s ease; visibility: hidden; transform: translate3d(0, 0, 0); } .text-row:hover .text-content { letter-spacing: 5px; } .interactive-area { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; cursor: pointer; } .char { display: inline-block; position: relative; overflow: hidden; max-width: 80px; transition: max-width 0.64s cubic-bezier(0.86, 0, 0.07, 1); margin-right: 0px; } .text-row.active .char::after { content: \"\"; position: absolute; top: 0; right: 0; width: 1px; height: 80%; background-color: rgba(255, 204, 0, 0.2); transform: none; opacity: 0; animation: fadeIn 0.3s forwards; animation-delay: calc(var(--char-index, 0) * 0.05s); } @keyframes fadeIn { to { opacity: 1; } } .char.narrow-char { max-width: 40px; } .char:last-child::after { display: none; } .char-inner { position: relative; display: inline-block; width: 100%; height: 100%; will-change: transform; transform: translate3d(-20px, 0, 0); } .type { position: fixed; height: 100vmax; width: 100vmax; text-transform: uppercase; display: none; justify-content: center; align-content: center; text-align: center; top: 50%; left: 50%; margin-top: -50vmax; margin-left: -50vmax; will-change: transform; z-index: 5; transform-style: preserve-3d; pointer-events: none; } .type-line { white-space: nowrap; font-size: clamp(7rem, 18.75vh, 15rem); line-height: 0.75; font-weight: bold; font-family: \"PP Neue Montreal\", sans-serif; color: #ffffff; opacity: var(--type-line-opacity); user-select: none; will-change: transform, opacity; position: relative; } .type-line.odd { z-index: 50; } .type-line.even { z-index: 150; } /* Mobile Optimization */ /* For tablets and smaller screens */ @media screen and (max-width: 992px) { .text-content { font-size: 7rem; } .text-row { height: 110px; } .type-line { font-size: clamp(5rem, 12vh, 10rem); } } /* For mobile phones */ @media screen and (max-width: 768px) { .text-content { font-size: 5rem; } .text-row { height: 80px; margin: 8px 0; } .type-line { font-size: clamp(3.5rem, 8vh, 7rem); } .text-item { font-size: 0.7rem; } } /* For very small screens */ @media screen and (max-width: 480px) { .text-content { font-size: 3.5rem; } .text-row { height: 60px; margin: 6px 0; } .type-line { font-size: clamp(2.5rem, 6vh, 5rem); } .text-item { font-size: 0.6rem; } }\nscript.js: // TODO: Fix mobile/touch optimization for better experience on touch devices // TODO: Interactive area was removed due to issues with the middle title element and overall elements overlaping and causing sequence cancellation // TODO: Fix issue where the text is not returning to initial position when quickly hovering gsap.registerPlugin(CustomEase, SplitText, ScrambleTextPlugin); document.addEventListener(\"DOMContentLoaded\", function () { CustomEase.create(\"customEase\", \"0.86, 0, 0.07, 1\"); CustomEase.create(\"mouseEase\", \"0.25, 0.1, 0.25, 1\"); document.fonts.ready.then(() => { initializeAnimation(); }); function initializeAnimation() { const backgroundTextItems = document.querySelectorAll(\".text-item\"); const backgroundImages = { default: document.getElementById(\"default-bg\"), focus: document.getElementById(\"focus-bg\"), presence: document.getElementById(\"presence-bg\"), feel: document.getElementById(\"feel-bg\") }; function switchBackgroundImage(id) { Object.values(backgroundImages).forEach((bg) => { gsap.to(bg, { opacity: 0, duration: 0.8, ease: \"customEase\" }); }); if (backgroundImages[id]) { gsap.to(backgroundImages[id], { opacity: 1, duration: 0.8, ease: \"customEase\", delay: 0.2 }); } else { gsap.to(backgroundImages.default, { opacity: 1, duration: 0.8, ease: \"customEase\", delay: 0.2 }); } } const alternativeTexts = { focus: { BE: \"BECOME\", PRESENT: \"MINDFUL\", LISTEN: \"HEAR\", DEEPLY: \"INTENTLY\", OBSERVE: \"NOTICE\", \"&\": \"+\", FEEL: \"SENSE\", MAKE: \"CREATE\", BETTER: \"IMPROVED\", DECISIONS: \"CHOICES\", THE: \"YOUR\", CREATIVE: \"ARTISTIC\", PROCESS: \"JOURNEY\", IS: \"FEELS\", MYSTERIOUS: \"MAGICAL\", S: \"START\", I: \"INSPIRE\", M: \"MAKE\", P: \"PURE\", L: \"LIGHT\", C: \"CREATE\", T: \"TRANSFORM\", Y: \"YOURS\", \"IS THE KEY\": \"UNLOCKS ALL\", \"FIND YOUR VOICE\": \"SPEAK YOUR TRUTH\", \"TRUST INTUITION\": \"FOLLOW INSTINCT\", \"EMBRACE SILENCE\": \"WELCOME STILLNESS\", \"QUESTION EVERYTHING\": \"CHALLENGE NORMS\", TRUTH: \"HONESTY\", WISDOM: \"INSIGHT\", FOCUS: \"CONCENTRATE\", ATTENTION: \"AWARENESS\", AWARENESS: \"CONSCIOUSNESS\", PRESENCE: \"BEING\", SIMPLIFY: \"MINIMIZE\", REFINE: \"PERFECT\" }, presence: { BE: \"EVOLVE\", PRESENT: \"ENGAGED\", LISTEN: \"ABSORB\", DEEPLY: \"FULLY\", OBSERVE: \"ANALYZE\", \"&\": \"\u2192\", FEEL: \"EXPERIENCE\", MAKE: \"BUILD\", BETTER: \"STRONGER\", DECISIONS: \"SYSTEMS\", THE: \"EACH\", CREATIVE: \"ITERATIVE\", PROCESS: \"METHOD\", IS: \"BECOMES\", MYSTERIOUS: \"REVEALING\", S: \"STRUCTURE\", I: \"ITERATE\", M: \"METHOD\", P: \"PRACTICE\", L: \"LEARN\", C: \"CONSTRUCT\", T: \"TECHNIQUE\", Y: \"YIELD\", \"IS THE KEY\": \"DRIVES SUCCESS\", \"FIND YOUR VOICE\": \"DEVELOP YOUR STYLE\", \"TRUST INTUITION\": \"FOLLOW THE FLOW\", \"EMBRACE SILENCE\": \"VALUE PAUSES\", \"QUESTION EVERYTHING\": \"EXAMINE DETAILS\", TRUTH: \"CLARITY\", WISDOM: \"KNOWLEDGE\", FOCUS: \"DIRECTION\", ATTENTION: \"PRECISION\", AWARENESS: \"UNDERSTANDING\", PRESENCE: \"ENGAGEMENT\", SIMPLIFY: \"STREAMLINE\", REFINE: \"OPTIMIZE\" }, feel: { BE: \"SEE\", PRESENT: \"FOCUSED\", LISTEN: \"UNDERSTAND\", DEEPLY: \"CLEARLY\", OBSERVE: \"PERCEIVE\", \"&\": \"=\", FEEL: \"KNOW\", MAKE: \"ACHIEVE\", BETTER: \"CLEARER\", DECISIONS: \"VISION\", THE: \"THIS\", CREATIVE: \"INSIGHTFUL\", PROCESS: \"THINKING\", IS: \"BRINGS\", MYSTERIOUS: \"ILLUMINATING\", S: \"SHARP\", I: \"INSIGHT\", M: \"MINDFUL\", P: \"PRECISE\", L: \"LUCID\", C: \"CLEAR\", T: \"TRANSPARENT\", Y: \"YES\", \"IS THE KEY\": \"REVEALS TRUTH\", \"FIND YOUR VOICE\": \"DISCOVER YOUR VISION\", \"TRUST INTUITION\": \"BELIEVE YOUR EYES\", \"EMBRACE SILENCE\": \"SEEK STILLNESS\", \"QUESTION EVERYTHING\": \"CLARIFY ASSUMPTIONS\", TRUTH: \"REALITY\", WISDOM: \"PERCEPTION\", FOCUS: \"CLARITY\", ATTENTION: \"OBSERVATION\", AWARENESS: \"RECOGNITION\", PRESENCE: \"ALERTNESS\", SIMPLIFY: \"DISTILL\", REFINE: \"SHARPEN\" } }; backgroundTextItems.forEach((item) => { item.dataset.originalText = item.textContent; item.dataset.text = item.textContent; // Make background text fully opaque by default gsap.set(item, { opacity: 1 }); }); const typeLines = document.querySelectorAll(\".type-line\"); typeLines.forEach((line, index) => { if (index % 2 === 0) { line.classList.add(\"odd\"); } else { line.classList.add(\"even\"); } }); const oddLines = document.querySelectorAll(\".type-line.odd\"); const evenLines = document.querySelectorAll(\".type-line.even\"); const TYPE_LINE_OPACITY = 0.015; const state = { activeRowId: null, kineticAnimationActive: false, activeKineticAnimation: null, textRevealAnimation: null, transitionInProgress: false // New state to track transitions }; const textRows = document.querySelectorAll(\".text-row\"); const splitTexts = {}; textRows.forEach((row, index) => { const textElement = row.querySelector(\".text-content\"); const text = textElement.dataset.text; const rowId = row.dataset.rowId; splitTexts[rowId] = new SplitText(textElement, { type: \"chars\", charsClass: \"char\", mask: true, reduceWhiteSpace: false, propIndex: true }); textElement.style.visibility = \"visible\"; }); function updateCharacterWidths() { const isMobile = window.innerWidth < 1024; textRows.forEach((row, index) => { const rowId = row.dataset.rowId; const textElement = row.querySelector(\".text-content\"); const computedStyle = window.getComputedStyle(textElement); const currentFontSize = computedStyle.fontSize; const chars = splitTexts[rowId].chars; chars.forEach((char, i) => { const charText = char.textContent || (char.querySelector(\".char-inner\") ? char.querySelector(\".char-inner\").textContent : \"\"); if (!charText && i === 0) return; let charWidth; if (isMobile) { const fontSizeValue = parseFloat(currentFontSize); const standardCharWidth = fontSizeValue * 0.6; charWidth = standardCharWidth; if (!char.querySelector(\".char-inner\") && charText) { char.textContent = \"\"; const innerSpan = document.createElement(\"span\"); innerSpan.className = \"char-inner\"; innerSpan.textContent = charText; char.appendChild(innerSpan); innerSpan.style.transform = \"translate3d(0, 0, 0)\"; } char.style.width = `${charWidth}px`; char.style.maxWidth = `${charWidth}px`; char.dataset.charWidth = charWidth; char.dataset.hoverWidth = charWidth; } else { const tempSpan = document.createElement(\"span\"); tempSpan.style.position = \"absolute\"; tempSpan.style.visibility = \"hidden\"; tempSpan.style.fontSize = currentFontSize; tempSpan.style.fontFamily = \"Longsile, sans-serif\"; tempSpan.textContent = charText; document.body.appendChild(tempSpan); const actualWidth = tempSpan.offsetWidth; document.body.removeChild(tempSpan); const fontSizeValue = parseFloat(currentFontSize); const fontSizeRatio = fontSizeValue / 160; const padding = 10 * fontSizeRatio; charWidth = Math.max(actualWidth + padding, 30 * fontSizeRatio); if (!char.querySelector(\".char-inner\") && charText) { char.textContent = \"\"; const innerSpan = document.createElement(\"span\"); innerSpan.className = \"char-inner\"; innerSpan.textContent = charText; char.appendChild(innerSpan); innerSpan.style.transform = \"translate3d(0, 0, 0)\"; } char.style.width = `${charWidth}px`; char.style.maxWidth = `${charWidth}px`; char.dataset.charWidth = charWidth; const hoverWidth = Math.max(charWidth * 1.8, 85 * fontSizeRatio); char.dataset.hoverWidth = hoverWidth; } char.style.setProperty(\"--char-index\", i); }); }); } updateCharacterWidths(); window.addEventListener(\"resize\", function () { clearTimeout(window.resizeTimer); window.resizeTimer = setTimeout(function () { updateCharacterWidths(); }, 250); }); textRows.forEach((row, rowIndex) => { const rowId = row.dataset.rowId; const chars = splitTexts[rowId].chars; gsap.set(chars, { opacity: 0, filter: \"blur(15px)\" }); gsap.to(chars, { opacity: 1, filter: \"blur(0px)\", duration: 0.8, stagger: 0.09, ease: \"customEase\", delay: 0.15 * rowIndex }); }); function forceResetKineticAnimation() { if (state.activeKineticAnimation) { state.activeKineticAnimation.kill(); state.activeKineticAnimation = null; } const kineticType = document.getElementById(\"kinetic-type\"); gsap.killTweensOf([kineticType, typeLines, oddLines, evenLines]); // FIXED: Always ensure kinetic type is visible and properly set up gsap.set(kineticType, { display: \"grid\", scale: 1, rotation: 0, opacity: 1, visibility: \"visible\" // Added visibility property }); gsap.set(typeLines, { opacity: TYPE_LINE_OPACITY, x: \"0%\" }); state.kineticAnimationActive = false; } function startKineticAnimation(text) { // First ensure any existing animation is properly cleaned up forceResetKineticAnimation(); const kineticType = document.getElementById(\"kinetic-type\"); // FIXED: Explicitly ensure the element is visible with inline styles kineticType.style.display = \"grid\"; kineticType.style.opacity = \"1\"; kineticType.style.visibility = \"visible\"; const repeatedText = `${text} ${text} ${text}`; typeLines.forEach((line) => { line.textContent = repeatedText; }); // FIXED: Add a small delay before starting animation to ensure element is visible setTimeout(() => { const timeline = gsap.timeline({ onComplete: () => { state.kineticAnimationActive = false; } }); timeline.to(kineticType, { duration: 1.4, ease: \"customEase\", scale: 2.7, rotation: -90 }); timeline.to( oddLines, { keyframes: [ { x: \"20%\", duration: 1, ease: \"customEase\" }, { x: \"-200%\", duration: 1.5, ease: \"customEase\" } ], stagger: 0.08 }, 0 ); timeline.to( evenLines, { keyframes: [ { x: \"-20%\", duration: 1, ease: \"customEase\" }, { x: \"200%\", duration: 1.5, ease: \"customEase\" } ], stagger: 0.08 }, 0 ); timeline.to( typeLines, { keyframes: [ { opacity: 1, duration: 1, ease: \"customEase\" }, { opacity: 0, duration: 1.5, ease: \"customEase\" } ], stagger: 0.05 }, 0 ); state.kineticAnimationActive = true; state.activeKineticAnimation = timeline; }, 20); // Small delay to ensure DOM updates } function fadeOutKineticAnimation() { if (!state.kineticAnimationActive) return; if (state.activeKineticAnimation) { state.activeKineticAnimation.kill(); state.activeKineticAnimation = null; } const kineticType = document.getElementById(\"kinetic-type\"); // FIXED: Don't set display to none on fadeout completion const fadeOutTimeline = gsap.timeline({ onComplete: () => { gsap.set(kineticType, { scale: 1, rotation: 0, opacity: 1 // Removed setting display: none }); gsap.set(typeLines, { opacity: TYPE_LINE_OPACITY, x: \"0%\" }); state.kineticAnimationActive = false; } }); fadeOutTimeline.to(kineticType, { opacity: 0, scale: 0.8, duration: 0.5, ease: \"customEase\" }); } // FIXED: New function to handle transitions between rows function transitionBetweenRows(fromRow, toRow) { if (state.transitionInProgress) return; state.transitionInProgress = true; const fromRowId = fromRow.dataset.rowId; const toRowId = toRow.dataset.rowId; // 1. Clean up the previous row fromRow.classList.remove(\"active\"); const fromChars = splitTexts[fromRowId].chars; const fromInners = fromRow.querySelectorAll(\".char-inner\"); gsap.killTweensOf(fromChars); gsap.killTweensOf(fromInners); // 2. Update state and prepare new row toRow.classList.add(\"active\"); state.activeRowId = toRowId; const toText = toRow.querySelector(\".text-content\").dataset.text; const toChars = splitTexts[toRowId].chars; const toInners = toRow.querySelectorAll(\".char-inner\"); // 3. Force reset kinetic animation (don't fade out, just reset) forceResetKineticAnimation(); // 4. Update background switchBackgroundImage(toRowId); // 5. Start new animations startKineticAnimation(toText); if (state.textRevealAnimation) { state.textRevealAnimation.kill(); } state.textRevealAnimation = createTextRevealAnimation(toRowId); // 6. Reset the previous row instantly gsap.set(fromChars, { maxWidth: (i, target) => parseFloat(target.dataset.charWidth) }); gsap.set(fromInners, { x: 0 }); // 7. Animate the new row const timeline = gsap.timeline({ onComplete: () => { state.transitionInProgress = false; } }); timeline.to( toChars, { maxWidth: (i, target) => parseFloat(target.dataset.hoverWidth), duration: 0.64, stagger: 0.04, ease: \"customEase\" }, 0 ); timeline.to( toInners, { x: -35, duration: 0.64, stagger: 0.04, ease: \"customEase\" }, 0.05 ); } function createTextRevealAnimation(rowId) { const timeline = gsap.timeline(); // Fade out other background text items timeline.to(backgroundTextItems, { opacity: 0.3, duration: 0.5, ease: \"customEase\" }); timeline.call(() => { backgroundTextItems.forEach((item) => { item.classList.add(\"highlight\"); }); }); timeline.call( () => { backgroundTextItems.forEach((item) => { const originalText = item.dataset.text; if ( alternativeTexts[rowId] && alternativeTexts[rowId][originalText] ) { item.textContent = alternativeTexts[rowId][originalText]; } }); }, null, \"+=0.5\" ); timeline.call(() => { backgroundTextItems.forEach((item) => { item.classList.remove(\"highlight\"); item.classList.add(\"highlight-reverse\"); }); }); timeline.call( () => { backgroundTextItems.forEach((item) => { item.classList.remove(\"highlight-reverse\"); }); }, null, \"+=0.5\" ); return timeline; } function resetBackgroundTextWithAnimation() { const timeline = gsap.timeline(); timeline.call(() => { backgroundTextItems.forEach((item) => { item.classList.add(\"highlight\"); }); }); timeline.call( () => { backgroundTextItems.forEach((item) => { item.textContent = item.dataset.originalText; }); }, null, \"+=0.5\" ); timeline.call(() => { backgroundTextItems.forEach((item) => { item.classList.remove(\"highlight\"); item.classList.add(\"highlight-reverse\"); }); }); timeline.call( () => { backgroundTextItems.forEach((item) => { item.classList.remove(\"highlight-reverse\"); }); }, null, \"+=0.5\" ); // Restore full opacity to all background text items timeline.to(backgroundTextItems, { opacity: 1, duration: 0.5, ease: \"customEase\" }); return timeline; } // FIXED: Modified activateRow function to use the transition function function activateRow(row) { const rowId = row.dataset.rowId; // If already active, do nothing if (state.activeRowId === rowId) return; // If a transition is already in progress, don't start another one if (state.transitionInProgress) return; // Check if there's already an active row const activeRow = document.querySelector(\".text-row.active\"); if (activeRow) { // Use the transition function to switch between rows transitionBetweenRows(activeRow, row); } else { // No active row, just activate this one normally row.classList.add(\"active\"); state.activeRowId = rowId; const text = row.querySelector(\".text-content\").dataset.text; const chars = splitTexts[rowId].chars; const innerSpans = row.querySelectorAll(\".char-inner\"); switchBackgroundImage(rowId); startKineticAnimation(text); if (state.textRevealAnimation) { state.textRevealAnimation.kill(); } state.textRevealAnimation = createTextRevealAnimation(rowId); // Simplified animation without mouse move effects const timeline = gsap.timeline(); timeline.to( chars, { maxWidth: (i, target) => parseFloat(target.dataset.hoverWidth), duration: 0.64, stagger: 0.04, ease: \"customEase\" }, 0 ); timeline.to( innerSpans, { x: -35, duration: 0.64, stagger: 0.04, ease: \"customEase\" }, 0.05 ); } } function deactivateRow(row) { const rowId = row.dataset.rowId; if (state.activeRowId !== rowId) return; // If a transition is already in progress, don't interfere if (state.transitionInProgress) return; state.activeRowId = null; row.classList.remove(\"active\"); switchBackgroundImage(\"default\"); fadeOutKineticAnimation(); if (state.textRevealAnimation) { state.textRevealAnimation.kill(); } state.textRevealAnimation = resetBackgroundTextWithAnimation(); const chars = splitTexts[rowId].chars; const innerSpans = row.querySelectorAll(\".char-inner\"); const timeline = gsap.timeline(); timeline.to( innerSpans, { x: 0, duration: 0.64, stagger: 0.03, ease: \"customEase\" }, 0 ); timeline.to( chars, { maxWidth: (i, target) => parseFloat(target.dataset.charWidth), duration: 0.64, stagger: 0.03, ease: \"customEase\" }, 0.05 ); } function initializeParallax() { const container = document.querySelector(\"body\"); const backgroundElements = [ ...document.querySelectorAll(\"[id$='-bg']\"), ...document.querySelectorAll(\".bg-text-container\") ]; const parallaxLayers = [0.02, 0.03, 0.04, 0.05]; backgroundElements.forEach((el, index) => { el.dataset.parallaxSpeed = parallaxLayers[index % parallaxLayers.length]; gsap.set(el, { transformOrigin: \"center center\", force3D: true }); }); let lastParallaxTime = 0; const throttleParallax = 20; container.addEventListener(\"mousemove\", (e) => { const now = Date.now(); if (now - lastParallaxTime < throttleParallax) return; lastParallaxTime = now; const centerX = window.innerWidth / 2; const centerY = window.innerHeight / 2; const offsetX = (e.clientX - centerX) / centerX; const offsetY = (e.clientY - centerY) / centerY; backgroundElements.forEach((el) => { const speed = parseFloat(el.dataset.parallaxSpeed); if (el.id && el.id.endsWith(\"-bg\") && el.style.opacity === \"0\") { return; } const moveX = offsetX * 100 * speed; const moveY = offsetY * 50 * speed; gsap.to(el, { x: moveX, y: moveY, duration: 1.0, ease: \"mouseEase\", overwrite: \"auto\" }); }); }); container.addEventListener(\"mouseleave\", () => { backgroundElements.forEach((el) => { gsap.to(el, { x: 0, y: 0, duration: 1.5, ease: \"customEase\" }); }); }); backgroundElements.forEach((el, index) => { const delay = index * 0.2; const floatAmount = 5 + (index % 3) * 2; gsap.to(el, { y: `+=${floatAmount}`, duration: 3 + (index % 2), ease: \"sine.inOut\", repeat: -1, yoyo: true, delay: delay }); }); } // Keep the event listeners but remove the mouse move functionality textRows.forEach((row) => { const interactiveArea = row.querySelector(\".interactive-area\"); interactiveArea.addEventListener(\"mouseenter\", () => { activateRow(row); }); interactiveArea.addEventListener(\"mouseleave\", () => { if (state.activeRowId === row.dataset.rowId) { deactivateRow(row); } }); // Add click event as a backup for mouseenter row.addEventListener(\"click\", () => { activateRow(row); }); }); // Add a global function to manually test the animation window.testKineticAnimation = function (rowId) { const row = document.querySelector(`.text-row[data-row-id=\"${rowId}\"]`); if (row) { activateRow(row); setTimeout(() => { deactivateRow(row); }, 3000); } }; function scrambleRandomText() { const randomIndex = Math.floor( Math.random() * backgroundTextItems.length ); const randomItem = backgroundTextItems[randomIndex]; const originalText = randomItem.dataset.text; gsap.to(randomItem, { duration: 1, scrambleText: { text: originalText, chars: \"\u25a0\u25aa\u258c\u2590\u25ac\", revealDelay: 0.5, speed: 0.3 }, ease: \"none\" }); const delay = 0.5 + Math.random() * 2; setTimeout(scrambleRandomText, delay * 1000); } setTimeout(scrambleRandomText, 1000); const simplicity = document.querySelector( '.text-item[data-text=\"IS THE KEY\"]' ); if (simplicity) { const splitSimplicity = new SplitText(simplicity, { type: \"chars\", charsClass: \"simplicity-char\" }); gsap.from(splitSimplicity.chars, { opacity: 0, scale: 0.5, duration: 1, stagger: 0.015, ease: \"customEase\", delay: 1 }); } backgroundTextItems.forEach((item, index) => { const delay = index * 0.1; gsap.to(item, { opacity: 0.85, duration: 2 + (index % 3), repeat: -1, yoyo: true, ease: \"sine.inOut\", delay: delay }); }); initializeParallax(); // FIXED: Add stronger CSS rules to ensure kinetic type is visible const style = document.createElement(\"style\"); style.textContent = ` #kinetic-type { z-index: 200 !important; display: grid !important; visibility: visible !important; opacity: 1; pointer-events: none; } `; document.head.appendChild(style); } });",
    "id": "gsapsplittext--kinetic-typography-experiment-gsap---challenge-1"
  },
  {
    "title": "Seamless SVG text on path animation",
    "description": "",
    "code": "index.html: <div class=\"ellipse\"> <svg viewBox=\"0 0 240 240\" xmlns=\"http://www.w3.org/2000/svg\"> <path d=\"M227 120C227 142.091 178.871 160 119.5 160C60.1294 160 12 142.091 12 120C12 97.9086 60.1294 80 119.5 80C178.871 80 227 97.9086 227 120Z\" fill=\"none\" /> </svg> </div> <footer>Made with <a href=\"https://ccrch.com/playground\" rel=\"noopener noreferrer\" target=\"_blank\"><<span>\u2764</span>/></a> at <a href=\"https://vettvangur.is\" rel=\"noopener noreferrer\" target=\"_blank\">Vettvangur</a></footer>\nstyle.css: @import url('https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&display=swap'); body { display: flex; flex-flow: column nowrap; align-items: center; justify-content: center; height: 100vh; overflow: hidden; background: color-mix(in srgb, #212121, black 21%); color: #e0e0e0; font-family: 'DM Sans', sans-serif; } .ellipse { width: min(63vw, 63vh); svg { transform: rotate(-40deg); width: 100%; height: 100%; text { fill: #e0e0e0; } } } footer { position: fixed; inset: auto max(21px, 2.1vw) max(21px, 2.1vw) auto; z-index: 1; font-family: \"DM Sans\", sans-serif; font-size: max(10px, 0.7vw); font-weight: 400; line-height: 1; a { color: inherit; text-decoration: none; span { color: #ff3d00; } &:not(:has(span)) { text-decoration: underline; text-decoration-color: #ff3d00; text-decoration-thickness: 1px; text-underline-offset: max(2px, 0.21vw); } } }\nscript.js: const createAnimation = ({ duration = 21, reversed = false, target, text, textProperties = undefined }) => { const pathId = `path-${gsap.utils.random(100000, 999999, 1)}` const props = { duration, ease: 'none', repeat: -1 } gsap.set(target.querySelector('path'), { attr: { fill: 'none', id: pathId, stroke: 'none' }, }) target.insertAdjacentHTML( 'beforeend', ` <text> <textPath href='#${pathId}' startOffset=\"0%\">${text}</textPath> <textPath href='#${pathId}' startOffset=\"0%\">${text}</textPath> </text> ` ) if (textProperties) { gsap.set(target.querySelectorAll('textPath'), textProperties) } gsap.fromTo( target.querySelectorAll('textPath')[0], { attr: { startOffset: '0%', }, }, { attr: { startOffset: reversed ? '-100%' : '100%' }, ...props, } ) gsap.fromTo( target.querySelectorAll('textPath')[1], { attr: { startOffset: reversed ? '100%' : '-100%', }, }, { attr: { startOffset: '0%' }, ...props, } ) } createAnimation({ duration: 21, reversed: true, target: document.querySelector('.ellipse svg'), text: 'lorem ipsum dolor sit amet consectetur adipiscing elit sed do', // textProperties: { fontSize: \"17.5px\", letterSpacing: \"-0.47px\" } // textProperties: { fontSize: \"17px\" } // Apparently iPhone decides 17px is not 17px \ud83d\ude43 textProperties: { fontSize: /iPhone/.test(navigator.userAgent) ? '19px' : '17px' }, })",
    "id": "seamless-svg-text-on-path-animation"
  },
  {
    "title": "Silent Movie Text Effect",
    "description": "",
    "code": "index.html: <main role=\"main\" class=\"main-content\" id=\"main-content\"> <div class=\"titleCont\"> <h1 class=\"main-title\" id=\"main-title\"> \"Here, in the forest,<br><span style=\"padding-left:100px\">dark and deep,</span><br><span style=\"padding-right:110px\">I offer you,</span><br><span style=\"padding-left:-20px\">eternal sleep.\"</span> </h1> </div> <canvas id=\"noise\" class=\"noise\"></canvas> <div class=\"vignette\"></div> </main>\nstyle.css: .main-content { overflow:hidden; position: relative; display: flex; align-items: center; justify-content: center; flex-flow: column; height: 100vh; background: linear-gradient(to right, rgba(36,31,31,1) 0%, rgba(36,31,31,1) 32%, rgba(74,71,70,1) 100%); color: #fff; text-align: center; } .vignette{ position:absolute; width:100%; height:100%; box-shadow:inset 0px 0px 150px 20px black; mix-blend-mode: multiply; -webkit-animation: vignette-anim 3s infinite; /* Safari 4+ */ -moz-animation: vignette-anim 3s infinite; /* Fx 5+ */ -o-animation: vignette-anim 3s infinite; /* Opera 12+ */ animation: vignette-anim 3s infinite; /* IE 10+, Fx 29+ */ } .noise { z-index: 100; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: .15; } .line{ position:absolute; height:100%; width:1px; opacity:0.1; background-color:#000; } .titleCont{position:relative;} .main-title { padding: .3em 1em .25em; font-weight: 400; font-size: 40px; color: white; font-family: 'Bellefair', serif; position:relative; line-height:1.3; white-spacing: } .overTitle{ position:absolute; top:0; left:0; } .dot{ width:3px; height:2px; background-color:white; position:absolute; opacity:0.3; } @-webkit-keyframes vignette-anim { 0% , 100%{ opacity: 1; } 50% { opacity: 0.7; } } @-moz-keyframes vignette-anim { 0% , 100%{ opacity: 1; } 50% { opacity: 0.7; } } @-o-keyframes vignette-anim { 0% , 100%{ opacity: 1; } 50% { opacity: 0.7; } } @keyframes vignette-anim { 0% , 100%{ opacity: 1; } 50% { opacity: 0.7; } }\nscript.js: // embeded two forks of //Ibe's Pen Background Noise - Canvas. //https://codepen.io/IbeVanmeenen/full/vZzgvg/ //and // Diaco M.Lotfollahi's Pen GSAP Old Movie Style. //https://codepen.io/MAW/full/rxqqQG/",
    "id": "silent-movie-text-effect"
  },
  {
    "title": "animated underlines with SVG, random. inspired idea and removed dependencies. WIP.",
    "description": "",
    "code": "index.html: <!-- SVG Symbol Library --> <div class=\"symbol-library\"> <symbol> <symbol id=\"underline-1\" viewBox=\"0 0 310 40\" preserveAspectRatio=\"none\"> <path fill=\"none\" stroke=\"#e55050\" stroke-width=\"10\" d=\"M5 20.9999C26.7762 16.2245 49.5532 11.5572 71.7979 14.6666C84.9553 16.5057 97.0392 21.8432 109.987 24.3888C116.413 25.6523 123.012 25.5143 129.042 22.6388C135.981 19.3303 142.586 15.1422 150.092 13.3333C156.799 11.7168 161.702 14.6225 167.887 16.8333C181.562 21.7212 194.975 22.6234 209.252 21.3888C224.678 20.0548 239.912 17.991 255.42 18.3055C272.027 18.6422 288.409 18.867 305 17.9999\" /> </symbol> <symbol id=\"underline-2\" viewBox=\"0 0 310 40\" preserveAspectRatio=\"none\"> <path fill=\"none\" stroke=\"#e55050\" stroke-width=\"10\" d=\"M5 24.2592C26.233 20.2879 47.7083 16.9968 69.135 13.8421C98.0469 9.5853 128.407 4.02322 158.059 5.14674C172.583 5.69708 187.686 8.66104 201.598 11.9696C207.232 13.3093 215.437 14.9471 220.137 18.3619C224.401 21.4596 220.737 25.6575 217.184 27.6168C208.309 32.5097 197.199 34.281 186.698 34.8486C183.159 35.0399 147.197 36.2657 155.105 26.5837C158.11 22.9053 162.993 20.6229 167.764 18.7924C178.386 14.7164 190.115 12.1115 201.624 10.3984C218.367 7.90626 235.528 7.06127 252.521 7.49276C258.455 7.64343 264.389 7.92791 270.295 8.41825C280.321 9.25056 296 10.8932 305 13.0242\" /> </symbol> <symbol id=\"underline-3\" viewBox=\"0 0 310 40\" preserveAspectRatio=\"none\"> <path fill=\"none\" stroke=\"#e55050\" stroke-width=\"10\" d=\"M5 29.5014C9.61174 24.4515 12.9521 17.9873 20.9532 17.5292C23.7742 17.3676 27.0987 17.7897 29.6575 19.0014C33.2644 20.7093 35.6481 24.0004 39.4178 25.5014C48.3911 29.0744 55.7503 25.7731 63.3048 21.0292C67.9902 18.0869 73.7668 16.1366 79.3721 17.8903C85.1682 19.7036 88.2173 26.2464 94.4121 27.2514C102.584 28.5771 107.023 25.5064 113.276 20.6125C119.927 15.4067 128.83 12.3333 137.249 15.0014C141.418 16.3225 143.116 18.7528 146.581 21.0014C149.621 22.9736 152.78 23.6197 156.284 24.2514C165.142 25.8479 172.315 17.5185 179.144 13.5014C184.459 10.3746 191.785 8.74853 195.868 14.5292C199.252 19.3205 205.597 22.9057 211.621 22.5014C215.553 22.2374 220.183 17.8356 222.979 15.5569C225.4 13.5845 227.457 11.1105 230.742 10.5292C232.718 10.1794 234.784 12.9691 236.164 14.0014C238.543 15.7801 240.717 18.4775 243.356 19.8903C249.488 23.1729 255.706 21.2551 261.079 18.0014C266.571 14.6754 270.439 11.5202 277.146 13.6125C280.725 14.7289 283.221 17.209 286.393 19.0014C292.321 22.3517 298.255 22.5014 305 22.5014\" /> </symbol> <symbol id=\"underline-4\" viewBox=\"0 0 310 40\" preserveAspectRatio=\"none\"> <path fill=\"none\" stroke=\"#e55050\" stroke-width=\"10\" d=\"M17.0039 32.6826C32.2307 32.8412 47.4552 32.8277 62.676 32.8118C67.3044 32.807 96.546 33.0555 104.728 32.0775C113.615 31.0152 104.516 28.3028 102.022 27.2826C89.9573 22.3465 77.3751 19.0254 65.0451 15.0552C57.8987 12.7542 37.2813 8.49399 44.2314 6.10216C50.9667 3.78422 64.2873 5.81914 70.4249 5.96641C105.866 6.81677 141.306 7.58809 176.75 8.59886C217.874 9.77162 258.906 11.0553 300 14.4892\" /> </symbol> <symbol id=\"underline-5\" viewBox=\"0 0 310 40\" preserveAspectRatio=\"none\"> <path fill=\"none\" stroke=\"#e55050\" stroke-width=\"10\" d=\"M4.99805 20.9998C65.6267 17.4649 126.268 13.845 187.208 12.8887C226.483 12.2723 265.751 13.2796 304.998 13.9998\" /> </symbol> <symbol id=\"underline-6\" viewBox=\"0 0 310 40\" preserveAspectRatio=\"none\"> <path fill=\"none\" stroke=\"#e55050\" stroke-width=\"10\" d=\"M5 29.8857C52.3147 26.9322 99.4329 21.6611 146.503 17.1765C151.753 16.6763 157.115 15.9505 162.415 15.6551C163.28 15.6069 165.074 15.4123 164.383 16.4275C161.704 20.3627 157.134 23.7551 153.95 27.4983C153.209 28.3702 148.194 33.4751 150.669 34.6605C153.638 36.0819 163.621 32.6063 165.039 32.2029C178.55 28.3608 191.49 23.5968 204.869 19.5404C231.903 11.3436 259.347 5.83254 288.793 5.12258C294.094 4.99476 299.722 4.82265 305 5.45025\" /> </symbol> <symbol id=\"underline-7\" viewBox=\"0 0 310 40\" preserveAspectRatio=\"none\"> <path fill=\"none\" stroke=\"#e55050\" stroke-width=\"10\" fill=\"none\" stroke=\"#e55050\" stroke-width=\"10\" d=\"m21 40 64-10c29-4 59-10 89-9 21 2 6 20 14 11 3-4 107-9 133-3\" /> </symbol> <symbol id=\"underline-8\" viewBox=\"0 0 310 40\" preserveAspectRatio=\"none\"> <path fill=\"none\" stroke=\"#e55050\" stroke-width=\"10\" d=\"m21 40 64-10c29-4 59-10 89-9 21 2-56 26-48 17 3-4 80-10 92-12 34-5 69-4 103 3\" /> </symbol> <symbol id=\"underline-9\" viewBox=\"0 0 310 40\" preserveAspectRatio=\"none\"> <path fill=\"none\" stroke=\"#e55050\" stroke-width=\"10\" d=\"m21 40 35-8c29-4 56-12 86-11 21 2-56 26-48 17 3-4 112-10 124-12 3-1 7 12 11 11 4 0 9-14 13-14 26-2 53 0 79 6\" /> </symbol> </svg> </div> <div class=\"demo-section\"> <div class=\"demo-title\">Hover over the navigation items:</div> <nav class=\"nav-container\"> <a href=\"#\" class=\"nav-item\" data-draw-line> sharks <div class=\"underline-svg\" data-draw-line-box></div> </a> <a href=\"#\" class=\"nav-item\" data-draw-line> with <div class=\"underline-svg\" data-draw-line-box></div> </a> <a href=\"#\" class=\"nav-item\" data-draw-line> laser <div class=\"underline-svg\" data-draw-line-box></div> </a> <a href=\"#\" class=\"nav-item\" data-draw-line> beams <div class=\"underline-svg\" data-draw-line-box></div> </a> <a href=\"#\" class=\"nav-item\" data-draw-line> attached <div class=\"underline-svg\" data-draw-line-box></div> </a> <a href=\"#\" class=\"nav-item\" data-draw-line> to <div class=\"underline-svg\" data-draw-line-box></div> </a> <a href=\"#\" class=\"nav-item\" data-draw-line> their <div class=\"underline-svg\" data-draw-line-box></div> </a> <a href=\"#\" class=\"nav-item\" data-draw-line> friggin' <div class=\"underline-svg\" data-draw-line-box></div> </a> <a href=\"#\" class=\"nav-item\" data-draw-line> heads <div class=\"underline-svg\" data-draw-line-box></div> </a> </nav> </div> <div class=\"credits\"> Pure CSS Animation + SVG Symbols + Minimal JavaScript for Randomness </div>\nstyle.css: :root { --speed: .24s; --easing: ease-in-out; --offset: 12; } body { // font-family: Arial, sans-serif; padding: 50px; background: #f5f5f5; } /* SVG Symbol Library - Hidden */ .symbol-library { position: absolute; width: 0; height: 0; overflow: hidden; } /* Navigation Container */ .nav-container { display: flex; gap: 40px; flex-wrap: wrap; align-content: center; justify-content: center; } /* Individual Nav Items */ .nav-item { position: relative; display: inline-block; text-decoration: none; color: #333; font-size: 24px; font-weight: 600; padding: 10px 0; transition: color var(--speed) ease, transform var(--speed) var(--easing); font-family: 'whirly birdie', PP Neue Montreal, Arial, sans-serif; font-variation-settings: 'wght' 80, 'wdth' 96; &:hover { transform: scale(1.05); color: #e55050; } } .nav-item:hover { color: #e55050; } /* Underline SVG Container */ .underline-svg { --path-distance: var(--offset, 10); position: absolute; bottom: calc(var(--path-distance) * 1px); //-5px; left: 0; width: 100%; height: 12px; pointer-events: none; opacity: 0; } .underline-svg svg { width: 100%; height: 100%; overflow: visible; } .underline-svg path { stroke: currentColor; stroke-width: 10; stroke-linecap: round; fill: none; --path-length: 1000; stroke-dasharray: var(--path-length); stroke-dashoffset: var(--path-length); } /* Draw-in animation */ @keyframes drawIn { 0% { stroke-dashoffset: var(--path-length); } 100% { stroke-dashoffset: 0; } } /* Draw-out animation */ @keyframes drawOut { 0% { stroke-dashoffset: 0; } 100% { stroke-dashoffset: calc(var(--path-length) * -1); } } /* Hover Animation States */ .nav-item:hover .underline-svg { opacity: 1; } .nav-item:hover .underline-svg path { animation: drawIn calc(var(--speed) * 2) cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; } .nav-item:not(:hover) .underline-svg path { animation: drawOut 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; animation-delay: 0.1s; } /* Demo Styling */ .demo-section { margin-bottom: 60px; max-width: 60vw; margin-inline: auto; } .demo-title { font-size: 18px; color: #666; margin-bottom: 20px; } .credits { margin-top: 100px; text-align: center; color: #999; font-size: 14px; }\nscript.js: // Lightweight randomness logic - no GSAP needed! function initRandomUnderlines() { // const totalVariants = 6; // Number of symbol variants const totalVariants = document.querySelectorAll( '.symbol-library symbol[id^=\"underline-\"]' ).length; let nextIndex = Math.floor(Math.random() * totalVariants); // Random start document.querySelectorAll(\"[data-draw-line]\").forEach((container) => { const box = container.querySelector(\"[data-draw-line-box]\"); if (!box) return; container.addEventListener(\"mouseenter\", () => { // Get the symbol and clone its path const symbol = document.querySelector(`#underline-${nextIndex + 1}`); const originalPath = symbol.querySelector(\"path\"); if (originalPath) { // Create a new SVG with the cloned path const svgHTML = ` <svg viewBox=\"0 0 310 40\" preserveAspectRatio=\"none\"> ${originalPath.outerHTML} </svg> `; box.innerHTML = svgHTML; // Now we can properly access and measure the path const path = box.querySelector(\"path\"); if (path) { const length = path.getTotalLength(); // Set precise dasharray and initial offset path.style.strokeDasharray = length; path.style.strokeDashoffset = length; path.style.setProperty(\"--path-length\", length); } } // Advance to next variant for next hover (across all items) nextIndex = (nextIndex + 1) % totalVariants; }); // Optional: Clear SVG on mouse leave for performance container.addEventListener(\"mouseleave\", () => { // Small delay to allow exit animation to complete setTimeout(() => { if (!container.matches(\":hover\")) { box.innerHTML = \"\"; } }, 700); }); }); } // Initialize when DOM is ready document.addEventListener(\"DOMContentLoaded\", initRandomUnderlines);",
    "id": "animated-underlines-with-svg-random-inspired-idea-and-removed-dependencies-wip"
  },
  {
    "title": "VFX-JS text shadow effect",
    "description": "",
    "code": "index.html: <h1>Thru.</h1>\nstyle.css: html, body { height: 100%; margin: 0; } body { background: black; display: flex; justify-content: center; align-items: center; } h1 { color: white; font-size: 20vw; font-weight: 900; }\nscript.js: // Built with VFX-JS // https://amagi.dev/vfx-js import { VFX } from \"https://esm.sh/@vfx-js/core@0.6.0\"; const shader = ` precision highp float; uniform vec2 resolution; uniform vec2 offset; uniform vec2 mouse; uniform float time; uniform sampler2D src; #define PI 3.141593 #define SAMPLES 64. float hash(vec2 p) { return fract(sin(dot(p, vec2(489., 589.))) * 492.) * 2. - 1.; } float hash(vec3 p) { return fract(sin(dot(p, vec3(489., 589., 58.))) * 492.) * 2. - 1.; } vec2 hash2(vec3 p) { return vec2(hash(p), hash(p + 1.)); } vec4 readTex(vec2 uv) { if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) { return vec4(0); } return texture2D(src, uv); } vec3 spectrum(float x) { return cos((x - vec3(0, .5, 1)) * vec3(.6, 1., .5) * PI); } void main() { vec2 uv = (gl_FragCoord.xy - offset) / resolution; if (readTex(uv).r > 0.) { discard; } vec2 p = uv * 2. - 1.; p.x *= resolution.x / resolution.y; // Determine light position vec2 mp = (mouse - offset) / resolution; mp = mp * 2. - 1.; mp.x *= resolution.x / resolution.y; vec2 rp = p; vec2 d = (mp - p) / SAMPLES; float acc = 0.; for (float i = 0.; i < SAMPLES; i++) { rp += d; rp += hash2(vec3(rp, i)) * 0.5 / SAMPLES; vec2 uv2 = rp; uv2.x /= resolution.x / resolution.y; uv2 = uv2 * 0.5 + 0.5; acc += readTex(uv2).r / SAMPLES; } // Light float lm = length(p - mp); vec4 c = vec4(smoothstep(0., 1., pow(.1 / lm, .2))); c -= acc; // shadow c += vec4((spectrum(cos(acc * 3.5))), 1) * acc * 2.5; // rainbow c -= hash(vec3(uv.xyy)) * 0.01; // dither gl_FragColor = c; } `; const vfx = new VFX(); vfx.add(document.querySelector('h1'), { shader, overflow: true, overlay: true });",
    "id": "vfx-js-text-shadow-effect"
  },
  {
    "title": "3d CSS letters + punch hole effect",
    "description": "",
    "code": "index.html: <dialog open> </dialog> <h1 data-splittext>Around the World</h1> <!-- slitting the text in JS because I am lazy --> <p>As seen on <a href=\"https://okpalette.color.pizza/\" target=\"_blank\">OKPalette</a></p>\nstyle.css: @layer base, text, box; @layer settings { :root { --radius: 25vmin; --radius-text: calc(var(--radius) + 7vmin); --blur: 8px; --spinDuration: 25s; --speedYMod: -3; --speedXMod: 1; --speedZMod: 0; --perspective: 1000px; } body { perspective: var(--perspective); } body, h1 { transform-style: preserve-3d; /* <- make sure everything is in the same 3d scene */ } } @layer text { h1 { position: relative; animation: spin3d var(--spinDuration) linear infinite; span { position: absolute; top: 50%; left: 50%; transform: translate3d(-50%,-50%, 0) rotateY(calc(var(--i) * 360deg)) translateZ(var(--radius-text)); backface-visibility: visible; } } @keyframes spin3d { 0% { transform: rotateX(0deg) rotateZ(0deg) rotateY(0deg); } 100% { transform: rotateX( calc(360deg * var(--speedXMod)) ) rotateZ( calc(360deg * var(--speedZMod)) ) rotateY( calc(360deg * var(--speedYMod)) ); } } } @layer box { dialog { width: calc(2 * var(--radius)); backdrop-filter: blur(var(--blur)); transform: translateZ(0); background: radial-gradient(var(--c-bg) 20%, rgb(from var(--c-bg) r g b / 0)); &:hover { backdrop-filter: unset; background-image: radial-gradient( circle at 50% 50%, transparent 0% 35%, var(--c-bg) 35% 100% ); background-repeat: repeat; background-size: 3px 3px; } } } @layer base { :root { --c-black: #202126; --c-white: #fff; --s-line: 1px; --c-line: var(--c-black); --c-bg: var(--c-white); --c-onBg: var(--c-black); font-family: Iosevka Web, system-ui, -apple-system, sans-serif; } * { text-box: trim-both cap alphabetic; } body { display: grid; place-content: center; align-items: center; min-height: 100dvh; background: var(--c-bg); color: var(--c-onBg); & > * { grid-area: 1 / 1; } } h1 { margin: 0; padding: 0; font-weight: 200; font-size: calc(var(--radius) * 1.1); pointer-events: none; } dialog { position: relative; grid-area: 1 / 1; border: var(--s-line) solid var(--c-line); padding: 0; border-radius: 50%; aspect-ratio: 1; background: none; } slide-vars { grid-area: unset; } p { position: absolute; right: 1.5rem; bottom: 1.5rem; } }\nscript.js: const $h1 = document.querySelector(\"[data-splittext]\"); const letters = $h1.textContent.split(\"\"); $h1.innerHTML = letters .map( (char, i) => `<span style=\"--i: ${i / (letters.length + 1)};\">${char}</span>` ) .join(\"\"); // letters.length + 1 because I want an extra space after the last letter. // \u2193 -- settings panel -- \u2193 // import { slideVars } from \"https://esm.sh/@codepen/slidevars\"; slideVars.init({ \"--radius\": { type: \"slider\", min: 1, max: 80, default: 25, unit: \"vmin\" }, \"--spinDuration\": { type: \"slider\", min: 1, max: 100, default: 25, unit: \"s\" }, \"--speedYMod\": { type: \"slider\", min: -10, max: 10, default: -3, unit: \"\" }, \"--speedXMod\": { type: \"slider\", min: -10, max: 10, default: 1, unit: \"\" }, \"--speedZMod\": { type: \"slider\", min: -10, max: 10, default: 0, unit: \"\" }, \"--perspective\": { type: \"slider\", min: 100, max: 2000, default: 1000, unit: \"px\" }, \"--blur\": { type: \"slider\", min: 0, max: 100, default: 8, unit: \"px\" }, \"--c-black\": { type: \"color\", default: \"#202116\" }, \"--c-white\": { type: \"color\", default: \"#fff\" } });",
    "id": "3d-css-letters--punch-hole-effect"
  },
  {
    "title": "Lando Norris Text Effect Syntax Challenge",
    "description": "",
    "code": "index.html: <nav> \t<a href=\"#\" class=\"split\" style=\"--font-width: 125\"> \t\tTikTok \t</a> \t<a href=\"#\" class=\"split\"> \t\tInstagram \t</a> \t<a href=\"#\" class=\"split\" style=\"--font-width: 94.5\"> \t\tTwitter \t</a> \t<a href=\"#\" class=\"split\" style=\"--font-width: 93\"> \t\tBluesky \t</a> \t<a href=\"#\" class=\"split\" style=\"--font-width: 92\"> \t\tYouTube \t</a> </nav>\nstyle.css: @import url(\"https://fonts.googleapis.com/css2?family=Mona+Sans:ital,wdth,wght@0,75..125,200..900;1,75..125,200..900&display=swap\"); body { \tbackground: #282c20; \tdisplay: grid; \tmin-block-size: 100dvb; \tplace-items: center; } nav { \talign-items: center; \tdisplay: flex; \tflex-direction: column; \tgap: 0.5em; } a { \tcolor: #f4f4ed; \tdisplay: flex; \tfont-family: \"Mona Sans\", sans-serif; \tfont-optical-sizing: auto; \tfont-size: 2rem; \tfont-style: normal; \tfont-variation-settings: \"wdth\" var(--font-width, 77); \tfont-weight: 900; \tline-height: 0.8; \toverflow: hidden; \ttext-decoration: none; \ttext-shadow: 0 1em 0 #f4f4ed; \ttext-transform: uppercase; \tspan { \t\t/* this is extremely extra, but wanted to Use The Platform\u2122 */ \t\t--i: var(--char); \t\t@supports (flex-grow: sibling-index()) { \t\t\t--i: sibling-index(); \t\t} \t\ttext-box: trim-both cap alphabetic; \t\ttransition: 300ms translate cubic-bezier(0.2, 0, 0.5, 1); \t\ttranslate: 0; \t\ttransition-delay: calc(40ms + var(--i, 0) * 20ms); \t} \t&:hover span { \t\ttranslate: 0 -1em; \t} }\nscript.js: let split = SplitText.create(\".split\", { \ttype: \"chars\", \ttag: \"span\", \tpropIndex: true });",
    "id": "lando-norris-text-effect-syntax-challenge"
  }
]