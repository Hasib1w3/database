[
  {
    "title": "Animated WebGL Starfield Shader Background",
    "description": "Full-screen canvas component that renders an animated starfield via GLSL fragment shader. Uses WebGL, resizes with viewport, and suits dynamic page headers, hero sections, or interactive backgrounds.",
    "code": "<canvas id=\"shader-canvas\" class=\"absolute inset-0 -z-10\">\n  <script id=\"fragShader\" type=\"x-shader/x-fragment\">\n    precision highp float;\n\nuniform vec2 iResolution;\nuniform float iTime;\n\nvec3 hash( vec3 p ) {\n  p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n            dot(p,vec3(269.5,183.3,246.1)),\n            dot(p,vec3(113.5,271.9,124.6)));\n  return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p ) {\n  vec3 i = floor( p );\n  vec3 f = fract( p );\n  vec3 u = f*f*(3.0-2.0*f);\n  return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ),\n                      dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                 mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ),\n                      dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n            mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ),\n                      dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                 mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ),\n                      dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  vec3 stars_direction = normalize(vec3(uv * 2.0 - 1.0, 1.0));\n  float stars_threshold = 8.0;\n  float stars_exposure = 200.0;\n  float stars = pow(clamp(noise(stars_direction * 200.0), 0.0, 1.0), stars_threshold) * stars_exposure;\n  stars *= mix(0.4, 1.4, noise(stars_direction * 100.0 + vec3(iTime)));\n  gl_FragColor = vec4(vec3(stars),1.0);\n}\n</script>\n  <script>\n    const canvas = document.getElementById('shader-canvas');\nconst gl = canvas.getContext('webgl');\n\nfunction resize() {\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n}\nwindow.addEventListener('resize', resize);\nresize();\n\nfunction compileShader(gl, source, type) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    throw new Error(gl.getShaderInfoLog(shader));\n  }\n  return shader;\n}\n\nconst vertSrc = `\nattribute vec2 position;\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\nconst fragSrc = document.getElementById('fragShader').textContent;\n\nconst vertShader = compileShader(gl, vertSrc, gl.VERTEX_SHADER);\nconst fragShader = compileShader(gl, fragSrc, gl.FRAGMENT_SHADER);\n\nconst program = gl.createProgram();\ngl.attachShader(program, vertShader);\ngl.attachShader(program, fragShader);\ngl.linkProgram(program);\nif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n  throw new Error(gl.getProgramInfoLog(program));\n}\ngl.useProgram(program);\n\nconst posLoc = gl.getAttribLocation(program, 'position');\nconst buffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer);\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n  -1, -1, 1, -1, -1, 1,\n  -1, 1, 1, -1, 1, 1,\n]), gl.STATIC_DRAW);\ngl.enableVertexAttribArray(posLoc);\ngl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);\n\nconst iResolution = gl.getUniformLocation(program, 'iResolution');\nconst iTime = gl.getUniformLocation(program, 'iTime');\n\nfunction render(time) {\n  gl.uniform2f(iResolution, canvas.width, canvas.height);\n  gl.uniform1f(iTime, time * 0.001);\n  gl.drawArrays(gl.TRIANGLES, 0, 6);\n  requestAnimationFrame(render);\n}\nrequestAnimationFrame(render);\n  </script>\n</canvas>",
    "id": "animated-webgl-starfield-shader-background"
  },
  {
    "title": "Animated Aurora WebGL Background with Three.js",
    "description": "Fullscreen canvas background using Three.js ShaderMaterial to generate a dynamic, colorful aurora effect. Auto-animated and responsive to window resize, perfect for landing pages, hero sections, or immersive app backdrops.",
    "code": "<canvas id=\"aurora-canvas\">\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n  <style>\n    canvas { position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: -10; }\n  </style>\n  <script>\n    // WebGL Aurora Background\n    const scene = new THREE.Scene();\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    const renderer = new THREE.WebGLRenderer();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(renderer.domElement);\n\n    const material = new THREE.ShaderMaterial({\n        uniforms: {\n            iTime: { value: 0 },\n            iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }\n        },\n        vertexShader: `\n            void main() {\n                gl_Position = vec4(position, 1.0);\n            }\n        `,\n        fragmentShader: `\n            uniform float iTime;\n            uniform vec2 iResolution;\n\n            #define NUM_OCTAVES 3\n\n            float rand(vec2 n) { \n                return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n            }\n\n            float noise(vec2 p){\n                vec2 ip = floor(p);\n                vec2 u = fract(p);\n                u = u*u*(3.0-2.0*u);\n                \n                float res = mix(\n                    mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n                    mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n                return res*res;\n            }\n\n            float fbm(vec2 x) {\n                float v = 0.0;\n                float a = 0.3;\n                vec2 shift = vec2(100);    \n                mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n                for (int i = 0; i < NUM_OCTAVES; ++i) {\n                    v += a * noise(x);\n                    x = rot * x * 2.0 + shift;\n                    a *= 0.4;\n                }\n                return v;\n            }\n\n            void main() {\n                vec2 shake = vec2(sin(iTime * 1.2) * 0.005, cos(iTime * 2.1) * 0.005);\n                \n                vec2 p = ((gl_FragCoord.xy + shake * iResolution.xy) - iResolution.xy * 0.5) / iResolution.y * mat2(6.0, -4.0, 4.0, 6.0);\n                vec2 v;\n                vec4 o = vec4(0.0);\n                \n                float f = 2.0 + fbm(p + vec2(iTime * 5.0, 0.0)) * 0.5; \n                \n                for(float i = 0.0; i++ < 35.0;)\n                {\n                    v = p + cos(i * i + (iTime + p.x * 0.08) * 0.025 + i * vec2(13.0, 11.0)) * 3.5 + vec2(sin(iTime * 3.0 + i) * 0.003, cos(iTime * 3.5 - i) * 0.003);\n                    \n                    float tailNoise = fbm(v + vec2(iTime * 0.5, i)) * 0.3 * (1.0 - (i / 35.0)); \n                    \n                    vec4 auroraColors = vec4(\n                        0.1 + 0.3 * sin(i * 0.2 + iTime * 0.4),\n                        0.3 + 0.5 * cos(i * 0.3 + iTime * 0.5),\n                        0.7 + 0.3 * sin(i * 0.4 + iTime * 0.3),\n                        1.0\n                    );\n                    \n                    vec4 currentContribution = auroraColors * exp(sin(i * i + iTime * 0.8)) / length(max(v, vec2(v.x * f * 0.015, v.y * 1.5)));\n                    \n                    float thinnessFactor = smoothstep(0.0, 1.0, i / 35.0) * 0.6; \n                    o += currentContribution * (1.0 + tailNoise * 0.8) * thinnessFactor;\n                }\n                \n                o = tanh(pow(o / 100.0, vec4(1.6)));\n                gl_FragColor = o * 1.5;\n            }\n        `\n    });\n\n    const geometry = new THREE.PlaneGeometry(2, 2);\n    const mesh = new THREE.Mesh(geometry, material);\n    scene.add(mesh);\n\n    function animate() {\n        requestAnimationFrame(animate);\n        material.uniforms.iTime.value += 0.016;\n        renderer.render(scene, camera);\n    }\n\n    window.addEventListener('resize', () => {\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);\n    });\n\n    animate();\n  </script>\n</canvas>",
    "id": "animated-aurora-webgl-background-with-threejs"
  },
  {
    "title": "Interactive Iridescent WebGL Background Shader",
    "description": "Absolute positioned container that injects an OGL-based WebGL canvas rendering an animated iridescent shader. Mouse-responsive color shift, configurable speed and amplitude make it perfect for immersive hero banners or full-screen decorative backdrops.",
    "code": "<div class=\"shader-container absolute inset-0 -z-10\">\n  <script type=\"module\">\n    import { Renderer, Program, Mesh, Color, Triangle } from 'https://cdn.skypack.dev/ogl';\n\n    const vertexShader = `\n    attribute vec2 uv;\n    attribute vec2 position;\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = vec4(position, 0, 1);\n    }`;\n\n    const fragmentShader = `\n    precision highp float;\n    uniform float uTime;\n    uniform vec3 uColor;\n    uniform vec3 uResolution;\n    uniform vec2 uMouse;\n    uniform float uAmplitude;\n    uniform float uSpeed;\n    varying vec2 vUv;\n    void main() {\n      float mr = min(uResolution.x, uResolution.y);\n      vec2 uv = (vUv.xy * 2.0 - 1.0) * uResolution.xy / mr;\n      uv += (uMouse - vec2(0.5)) * uAmplitude;\n      float d = -uTime * 0.5 * uSpeed;\n      float a = 0.0;\n      for (float i = 0.0; i < 8.0; ++i) {\n        a += cos(i - d - a * uv.x);\n        d += sin(uv.y * i + a);\n      }\n      d += uTime * 0.5 * uSpeed;\n      vec3 col = vec3(cos(uv * vec2(d, a)) * 0.6 + 0.4, cos(a + d) * 0.5 + 0.5);\n      col = cos(col * cos(vec3(d, a, 2.5)) * 0.5 + 0.5) * uColor;\n      gl_FragColor = vec4(col, 1.0);\n    }`;\n\n    class IridescenceShader {\n        constructor(container, options = {}) {\n            this.container = container;\n            this.color = options.color || [1, 0.8, 0.9];\n            this.speed = options.speed || 1.0;\n            this.amplitude = options.amplitude || 0.15;\n            this.mouseReact = options.mouseReact !== false;\n            this.mousePos = { x: 0.5, y: 0.5 };\n            this.init();\n        }\n\n        init() {\n            this.renderer = new Renderer();\n            this.gl = this.renderer.gl;\n            this.gl.clearColor(0, 0, 0, 1);\n            \n            this.setupGeometry();\n            this.setupEventListeners();\n            this.resize();\n            this.animate();\n            \n            this.container.appendChild(this.gl.canvas);\n        }\n\n        setupGeometry() {\n            const geometry = new Triangle(this.gl);\n            this.program = new Program(this.gl, {\n                vertex: vertexShader,\n                fragment: fragmentShader,\n                uniforms: {\n                    uTime: { value: 0 },\n                    uColor: { value: new Color(...this.color) },\n                    uResolution: { value: new Color(1, 1, 1) },\n                    uMouse: { value: new Float32Array([0.5, 0.5]) },\n                    uAmplitude: { value: this.amplitude },\n                    uSpeed: { value: this.speed },\n                },\n            });\n            this.mesh = new Mesh(this.gl, { geometry, program: this.program });\n        }\n\n        setupEventListeners() {\n            this.handleResize = this.resize.bind(this);\n            this.handleMouseMove = this.onMouseMove.bind(this);\n            \n            window.addEventListener('resize', this.handleResize);\n            if (this.mouseReact) {\n                this.container.addEventListener('mousemove', this.handleMouseMove);\n            }\n        }\n\n        resize() {\n            const rect = this.container.getBoundingClientRect();\n            this.renderer.setSize(rect.width, rect.height);\n            if (this.program) {\n                this.program.uniforms.uResolution.value = new Color(\n                    this.gl.canvas.width,\n                    this.gl.canvas.height,\n                    this.gl.canvas.width / this.gl.canvas.height\n                );\n            }\n        }\n\n        onMouseMove(e) {\n            const rect = this.container.getBoundingClientRect();\n            const x = (e.clientX - rect.left) / rect.width;\n            const y = 1.0 - (e.clientY - rect.top) / rect.height;\n            this.mousePos = { x, y };\n            this.program.uniforms.uMouse.value[0] = x;\n            this.program.uniforms.uMouse.value[1] = y;\n        }\n\n        animate(t = 0) {\n            this.animationId = requestAnimationFrame(this.animate.bind(this));\n            this.program.uniforms.uTime.value = t * 0.001;\n            this.renderer.render({ scene: this.mesh });\n        }\n    }\n\n    document.addEventListener('DOMContentLoaded', () => {\n        const container = document.querySelector('.shader-container');\n        new IridescenceShader(container, {\n            color: [0.8, 0.4, 1],\n            speed: 0.6,\n            amplitude: 0.12\n        });\n    });\n  </script>\n</div>",
    "id": "interactive-iridescent-webgl-background-shader"
  },
  {
    "title": "Three.js Silk Shader Background Canvas",
    "description": "Animated silk-like shader background built with Three.js. Renders a responsive WebGL canvas overlay with customizable color, speed and scale, ideal for hero sections, headers or immersive UI backdrops.",
    "code": "\n<div id=\"shader-canvas\" class=\"absolute inset-0 -z-10\">\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n  <script>\n    class SilkShader {\n        constructor(container) {\n            this.container = container;\n            this.scene = new THREE.Scene();\n            this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n            this.clock = new THREE.Clock();\n            \n            this.init();\n            this.createShaderMaterial();\n            this.createMesh();\n            this.animate();\n            this.handleResize();\n            \n            window.addEventListener('resize', () => this.handleResize());\n        }\n        \n        init() {\n            this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);\n            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n            this.container.appendChild(this.renderer.domElement);\n        }\n        \n        hexToNormalizedRGB(hex) {\n            hex = hex.replace(\"#\", \"\");\n            return new THREE.Vector3(\n                parseInt(hex.slice(0, 2), 16) / 255,\n                parseInt(hex.slice(2, 4), 16) / 255,\n                parseInt(hex.slice(4, 6), 16) / 255\n            );\n        }\n        \n        createShaderMaterial() {\n            const vertexShader = `\n                varying vec2 vUv;\n                varying vec3 vPosition;\n                \n                void main() {\n                    vPosition = position;\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            `;\n            \n            const fragmentShader = `\n                varying vec2 vUv;\n                varying vec3 vPosition;\n                \n                uniform float uTime;\n                uniform vec3 uColor;\n                uniform float uSpeed;\n                uniform float uScale;\n                uniform float uRotation;\n                uniform float uNoiseIntensity;\n                \n                const float e = 2.71828182845904523536;\n                \n                float noise(vec2 texCoord) {\n                    float G = e;\n                    vec2 r = (G * sin(G * texCoord));\n                    return fract(r.x * r.y * (1.0 + texCoord.x));\n                }\n                \n                vec2 rotateUvs(vec2 uv, float angle) {\n                    float c = cos(angle);\n                    float s = sin(angle);\n                    mat2 rot = mat2(c, -s, s, c);\n                    return rot * uv;\n                }\n                \n                void main() {\n                    float rnd = noise(gl_FragCoord.xy);\n                    vec2 uv = rotateUvs(vUv * uScale, uRotation);\n                    vec2 tex = uv * uScale;\n                    float tOffset = uSpeed * uTime;\n                    \n                    tex.y += 0.03 * sin(8.0 * tex.x - tOffset);\n                    \n                    float pattern = 0.6 +\n                                  0.4 * sin(5.0 * (tex.x + tex.y +\n                                                  cos(3.0 * tex.x + 5.0 * tex.y) +\n                                                  0.02 * tOffset) +\n                                          sin(20.0 * (tex.x + tex.y - 0.1 * tOffset)));\n                    \n                    vec4 col = vec4(uColor, 1.0) * vec4(pattern) - rnd / 15.0 * uNoiseIntensity;\n                    col.a = 0.8;\n                    gl_FragColor = col;\n                }\n            `;\n            \n            this.uniforms = {\n                uTime: { value: 0 },\n                uSpeed: { value: 2 },\n                uScale: { value: 1.5 },\n                uNoiseIntensity: { value: 1.2 },\n                uColor: { value: this.hexToNormalizedRGB(\"#6366F1\") },\n                uRotation: { value: 0.5 }\n            };\n            \n            this.material = new THREE.ShaderMaterial({\n                uniforms: this.uniforms,\n                vertexShader,\n                fragmentShader,\n                transparent: true\n            });\n        }\n        \n        createMesh() {\n            const geometry = new THREE.PlaneGeometry(2, 2);\n            this.mesh = new THREE.Mesh(geometry, this.material);\n            this.scene.add(this.mesh);\n        }\n        \n        handleResize() {\n            this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);\n        }\n        \n        animate() {\n            requestAnimationFrame(() => this.animate());\n            \n            const delta = this.clock.getDelta();\n            this.uniforms.uTime.value += 0.1 * delta;\n            \n            this.renderer.render(this.scene, this.camera);\n        }\n    }\n    \n    // Initialize the shader when the page loads\n    document.addEventListener('DOMContentLoaded', () => {\n        const container = document.getElementById('shader-canvas');\n        new SilkShader(container);\n    });\n</script>\n</div>",
    "id": "threejs-silk-shader-background-canvas"
  },
  {
    "title": "Animated Waves Background with Vanta.js",
    "description": "Absolute-positioned component that renders interactive, customizable wave animations via Vanta.js and Three.js. Adds a dynamic, responsive backdrop ideal for hero sections, full-page backgrounds, or overlays.",
    "code": "<div id=\"vanta-bg\" class=\"absolute inset-0 z-0 opacity-60\">\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js\"></script>\n  <script src=\"https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.waves.min.js\"></script>\n  <script>\n    document.addEventListener('DOMContentLoaded', function() {\n      VANTA.WAVES({\n        el: \"#vanta-bg\",\n        mouseControls: true,\n        touchControls: true,\n        gyroControls: false,\n        minHeight: 200.00,\n        minWidth: 200.00,\n        scale: 1.00,\n        scaleMobile: 1.00,\n        color: 0x0055ff,\n        shininess: 35.00,\n        waveHeight: 15.00,\n        waveSpeed: 0.75,\n        zoom: 0.65\n      });\n    });\n  </script>\n</div>",
    "id": "animated-waves-background-with-vantajs"
  },
  {
    "title": "Full-Screen WebGL Shader Background Canvas",
    "description": "Full-width/height canvas that runs a GPU fragment shader to render animated, rotating concentric rings. Auto-resizes with viewport and sits behind content, making it a dynamic decorative background for hero sections, landing pages, or interactive sites. Uses Tailwind utility classes.",
    "code": "<canvas id=\"shader-canvas\" class=\"w-full h-full absolute top-0 left-0 -z-10\">\n    <script>\n    window.onload = function() {\n      const canvas = document.getElementById('shader-canvas');\n      const gl = canvas.getContext('webgl');\n      function resize() {\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n      }\n      resize();\n      window.addEventListener('resize', resize);\n\n      const vertexShaderSource = `\n        attribute vec2 aPosition;\n        void main() {\n          gl_Position = vec4(aPosition, 0.0, 1.0);\n        }\n      `;\n      const fragmentShaderSource = `\n        precision highp float;\n        uniform float iTime;\n        uniform vec2 iResolution;\n        mat2 rotate2d(float angle){\n          float c = cos(angle), s = sin(angle);\n          return mat2(c, -s, s, c);\n        }\n        float variation(vec2 v1, vec2 v2, float strength, float speed) {\n          return sin(\n              dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n          ) / 100.0;\n        }\n        vec3 paintCircle (vec2 uv, vec2 center, float rad, float width) {\n          vec2 diff = center-uv;\n          float len = length(diff);\n          len += variation(diff, vec2(0.0, 1.0), 5.0, 2.0);\n          len -= variation(diff, vec2(1.0, 0.0), 5.0, 2.0);\n          float circle = smoothstep(rad-width, rad, len) - smoothstep(rad, rad+width, len);\n          return vec3(circle);\n        }\n        void main() {\n          vec2 uv = gl_FragCoord.xy / iResolution.xy;\n          uv.x *= 1.5;\n          uv.x -= 0.25;\n          vec3 color = vec3(0.0);\n          float radius = 0.35;\n          vec2 center = vec2(0.5);\n          color += paintCircle(uv, center, radius, 0.035);\n          color += paintCircle(uv, center, radius - 0.018, 0.01);\n          color += paintCircle(uv, center, radius + 0.018, 0.005);\n          vec2 v = rotate2d(iTime) * uv;\n          color *= vec3(v.x, v.y, 0.7-v.y*v.x);\n          color += paintCircle(uv, center, radius, 0.003);\n          gl_FragColor = vec4(color, 1.0);\n        }\n      `;\n      function compileShader(type, source) {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n          throw new Error(gl.getShaderInfoLog(shader));\n        }\n        return shader;\n      }\n      const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);\n      const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);\n      const program = gl.createProgram();\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        throw new Error(gl.getProgramInfoLog(program));\n      }\n      gl.useProgram(program);\n      const buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        -1, -1,\n         1, -1,\n        -1,  1,\n        -1,  1,\n         1, -1,\n         1,  1,\n      ]), gl.STATIC_DRAW);\n      const aPosition = gl.getAttribLocation(program, 'aPosition');\n      gl.enableVertexAttribArray(aPosition);\n      gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n      const iTimeLoc = gl.getUniformLocation(program, 'iTime');\n      const iResLoc = gl.getUniformLocation(program, 'iResolution');\n      function render(time) {\n        gl.uniform1f(iTimeLoc, time * 0.001);\n        gl.uniform2f(iResLoc, canvas.width, canvas.height);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        requestAnimationFrame(render);\n      }\n      requestAnimationFrame(render);\n    };\n    </script>\n</canvas>",
    "id": "full-screen-webgl-shader-background-canvas"
  },
  {
    "title": "WebGL Light Rays Animated Background",
    "description": "Full-viewport WebGL canvas background rendering animated crimson light rays with configurable origin, spread, length, saturation, and subtle mouse interaction. Ideal as a dynamic atmospheric backdrop for landing pages or hero sections. Has mouse following",
    "code": "<div class=\"light-rays-container\" id=\"lightRaysWrap\"></div>\n\n<style>\n.light-rays-container {\n  position: absolute;\n  top: 0; left: 0;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  pointer-events: none; /* så att den inte stör klick */\n  z-index: -1; /* bakgrund */\n}\n\ncanvas#light-rays-canvas {\n  width: 100%;\n  height: 100%;\n  display: block;\n}\n</style>\n\n<script>\n(function(){\n  const container = document.getElementById('lightRaysWrap');\n  const canvas = document.createElement('canvas');\n  canvas.id = 'light-rays-canvas';\n  container.appendChild(canvas);\n\n  const gl = canvas.getContext('webgl', { alpha: true, antialias: true });\n  if (!gl) { console.error('WebGL not supported'); return; }\n\n  // --- Shader helpers ---\n  function compileShader(gl,type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){console.error(gl.getShaderInfoLog(s));gl.deleteShader(s);return null;}return s;}\n  function createProgram(gl,vs,fs){const v=compileShader(gl,gl.VERTEX_SHADER,vs),f=compileShader(gl,gl.FRAGMENT_SHADER,fs);if(!v||!f)return null;const p=gl.createProgram();gl.attachShader(p,v);gl.attachShader(p,f);gl.linkProgram(p);if(!gl.getProgramParameter(p,gl.LINK_STATUS)){console.error(gl.getProgramInfoLog(p));gl.deleteProgram(p);return null;}return p;}\n\n  const vertexSrc = `attribute vec2 a_position; varying vec2 vUv; void main(){vUv=a_position*0.5+0.5; gl_Position=vec4(a_position,0.0,1.0);}`;\n  const fragmentSrc = `precision highp float;\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec2 rayPos;\nuniform vec2 rayDir;\nuniform vec3 raysColor;\nuniform float raysSpeed;\nuniform float lightSpread;\nuniform float rayLength;\nuniform float pulsating;\nuniform float fadeDistance;\nuniform float saturation;\nuniform vec2 mousePos;\nuniform float mouseInfluence;\nuniform float noiseAmount;\nuniform float distortion;\nvarying vec2 vUv;\nfloat noise(vec2 st){return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);}\nfloat rayStrength(vec2 raySource,vec2 rayRefDirection,vec2 coord,float seedA,float seedB,float speed){\n  vec2 sourceToCoord=coord-raySource;\n  vec2 dirNorm=normalize(sourceToCoord);\n  float cosAngle=dot(dirNorm,rayRefDirection);\n  float distortedAngle=cosAngle+distortion*sin(iTime*2.0+length(sourceToCoord)*0.01)*0.2;\n  float spreadFactor=pow(max(distortedAngle,0.0),1.0/max(lightSpread,0.001));\n  float distance=length(sourceToCoord);\n  float maxDistance=iResolution.x*rayLength;\n  float lengthFalloff=clamp((maxDistance-distance)/maxDistance,0.0,1.0);\n  float fadeFalloff=clamp((iResolution.x*fadeDistance-distance)/(iResolution.x*fadeDistance),0.5,1.0);\n  float pulse=pulsating>0.5?(0.8+0.2*sin(iTime*speed*3.0)):1.0;\n  float baseStrength=clamp((0.45+0.15*sin(distortedAngle*seedA+iTime*speed))+(0.3+0.2*cos(-distortedAngle*seedB+iTime*speed)),0.0,1.0);\n  return baseStrength*lengthFalloff*fadeFalloff*spreadFactor*pulse;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n  vec2 coord=vec2(fragCoord.x,iResolution.y-fragCoord.y);\n  vec2 finalRayDir=rayDir;\n  if(mouseInfluence>0.0){vec2 mouseScreenPos=mousePos*iResolution.xy;vec2 mouseDirection=normalize(mouseScreenPos-rayPos);finalRayDir=normalize(mix(rayDir,mouseDirection,mouseInfluence));}\n  vec4 rays1=vec4(1.0)*rayStrength(rayPos,finalRayDir,coord,36.2214,21.11349,1.5*raysSpeed);\n  vec4 rays2=vec4(1.0)*rayStrength(rayPos,finalRayDir,coord,22.3991,18.0234,1.1*raysSpeed);\n  fragColor=rays1*0.5+rays2*0.4;\n  if(noiseAmount>0.0){float n=noise(coord*0.01+iTime*0.1);fragColor.rgb*=(1.0-noiseAmount+noiseAmount*n);}\n  float brightness=1.0-(coord.y/iResolution.y);\n  fragColor.x*=(0.1+brightness*0.8);\n  fragColor.y*=(0.3+brightness*0.6);\n  fragColor.z*=(0.5+brightness*0.5);\n  if(saturation!=1.0){float gray=dot(fragColor.rgb,vec3(0.299,0.587,0.114));fragColor.rgb=mix(vec3(gray),fragColor.rgb,saturation);}\n  fragColor.rgb*=raysColor;\n}\nvoid main(){vec4 color; mainImage(color,gl_FragCoord.xy); gl_FragColor=color;}`;\n\n  const program = createProgram(gl, vertexSrc, fragmentSrc);\n  gl.useProgram(program);\n\n  const posLoc = gl.getAttribLocation(program,'a_position');\n  const posBuf = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER,posBuf);\n  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),gl.STATIC_DRAW);\n  gl.enableVertexAttribArray(posLoc);\n  gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);\n\n  const uni = {};\n  ['iTime','iResolution','rayPos','rayDir','raysColor','raysSpeed','lightSpread','rayLength','pulsating','fadeDistance','saturation','mousePos','mouseInfluence','noiseAmount','distortion'].forEach(n=>uni[n]=gl.getUniformLocation(program,n));\n\n  // --- Component state (uppdaterade värden) ---\n  const state = {\n    raysColor:'#dc143c',\n    raysOrigin:'top',\n    raysSpeed:2.2,\n    lightSpread:3.0,\n    rayLength:4.9,\n    pulsating:false,\n    fadeDistance:2.0,\n    saturation:0.6,\n    mouseInfluence:0.12,\n    noiseAmount:0,\n    distortion:0\n  };\n\n  function hexToRgb(hex){const m=/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);return m?[parseInt(m[1],16)/255,parseInt(m[2],16)/255,parseInt(m[3],16)/255]:[1,1,1];}\n  function getAnchorAndDir(origin,w,h){const o=0.2;switch(origin){case'top-left':return{anchor:[0,-o*h],dir:[0,1]};case'top-right':return{anchor:[w,-o*h],dir:[0,1]};case'left':return{anchor:[-o*w,0.5*h],dir:[1,0]};case'right':return{anchor:[(1+o)*w,0.5*h],dir:[-1,0]};case'bottom-left':return{anchor:[0,(1+o)*h],dir:[0,-1]};case'bottom-center':return{anchor:[0.5*w,(1+o)*h],dir:[0,-1]};case'bottom-right':return{anchor:[w,(1+o)*h],dir:[0,-1]};default:return{anchor:[0.5*w,-o*h],dir:[0,1]};}}\n\n  const mouse={x:0.5,y:0.5},smoothMouse={x:0.5,y:0.5};\n  window.addEventListener('mousemove',e=>{const r=canvas.getBoundingClientRect();mouse.x=(e.clientX-r.left)/r.width;mouse.y=(e.clientY-r.top)/r.height;});\n\n  function resize(){const dpr=Math.min(window.devicePixelRatio||1,2);const w=Math.floor(container.clientWidth*dpr);const h=Math.floor(container.clientHeight*dpr);canvas.width=w;canvas.height=h;gl.viewport(0,0,w,h);}\n  window.addEventListener('resize',resize); resize();\n\n  function setUniforms(t){\n    gl.uniform1f(uni.iTime,t*0.001);\n    gl.uniform2f(uni.iResolution,canvas.width,canvas.height);\n    const {anchor,dir} = getAnchorAndDir(state.raysOrigin,canvas.width,canvas.height);\n    gl.uniform2f(uni.rayPos,anchor[0],anchor[1]);\n    gl.uniform2f(uni.rayDir,dir[0],dir[1]);\n    const c = hexToRgb(state.raysColor);\n    gl.uniform3f(uni.raysColor,c[0],c[1],c[2]);\n    gl.uniform1f(uni.raysSpeed,state.raysSpeed);\n    gl.uniform1f(uni.lightSpread,state.lightSpread);\n    gl.uniform1f(uni.rayLength,state.rayLength);\n    gl.uniform1f(uni.pulsating,state.pulsating?1:0);\n    gl.uniform1f(uni.fadeDistance,state.fadeDistance);\n    gl.uniform1f(uni.saturation,state.saturation);\n    gl.uniform2f(uni.mousePos,smoothMouse.x,smoothMouse.y);\n    gl.uniform1f(uni.mouseInfluence,state.mouseInfluence);\n    gl.uniform1f(uni.noiseAmount,state.noiseAmount);\n    gl.uniform1f(uni.distortion,state.distortion);\n  }\n\n  function frame(t){\n    const s=0.92;\n    smoothMouse.x=smoothMouse.x*s+(1-s)*mouse.x;\n    smoothMouse.y=smoothMouse.y*s+(1-s)*mouse.y;\n    setUniforms(t);\n    gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.drawArrays(gl.TRIANGLES,0,6);\n    requestAnimationFrame(frame);\n  }\n  requestAnimationFrame(frame);\n\n})();\n</script>\n\n",
    "id": "webgl-light-rays-animated-background"
  },
  {
    "title": "WebGL Lava Background",
    "description": "A high-performance WebGL shader creating a fluid, organic lava lamp background effect. Features multiple presets (Lava, Plasma, Pulse) via a custom noise implementation and fragment shader.",
    "code": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Lava Background</title>\n    <style>\n        :root {\n            --bg: #050505;\n        }\n\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        body {\n            background-color: var(--bg);\n            width: 100vw;\n            height: 100vh;\n            overflow: hidden;\n        }\n\n        #canvas {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            z-index: 0;\n        }\n\n        .noise {\n            position: absolute;\n            inset: 0;\n            background-image: url(\"https://framerusercontent.com/images/g0QcWrxr87K0ufOxIUFBakwYA8.png\");\n            background-size: 200px;\n            background-repeat: repeat;\n            opacity: 0.25;\n            pointer-events: none;\n            z-index: 1;\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"canvas\"></canvas>\n    <div class=\"noise\"></div>\n\n    <script>\n        const vertexShaderSource = `#version 300 es\n        layout(location = 0) in vec4 a_position;\n        void main() {\n            gl_Position = a_position;\n        }\n        `;\n\n        const fragmentShaderSource = `#version 300 es\n        precision highp float;\n\n        uniform float u_time;\n        uniform float u_pixelRatio;\n        uniform vec2 u_resolution;\n\n        uniform float u_scale;\n        uniform float u_rotation;\n        uniform vec4 u_color1;\n        uniform vec4 u_color2;\n        uniform vec4 u_color3;\n        uniform float u_proportion;\n        uniform float u_softness;\n        uniform float u_shape; // 0: Checks, 1: Stripes, 2: Edge\n        uniform float u_shapeScale;\n        uniform float u_distortion;\n        uniform float u_swirl;\n        uniform float u_swirlIterations;\n\n        out vec4 fragColor;\n\n        #define TWO_PI 6.28318530718\n        #define PI 3.14159265358979323846\n\n        vec2 rotate(vec2 uv, float th) {\n            return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n        }\n\n        float random(vec2 st) {\n            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n        }\n\n        float noise(vec2 st) {\n            vec2 i = floor(st);\n            vec2 f = fract(st);\n            float a = random(i);\n            float b = random(i + vec2(1.0, 0.0));\n            float c = random(i + vec2(0.0, 1.0));\n            float d = random(i + vec2(1.0, 1.0));\n            vec2 u = f * f * (3.0 - 2.0 * f);\n            float x1 = mix(a, b, u.x);\n            float x2 = mix(c, d, u.x);\n            return mix(x1, x2, u.y);\n        }\n\n        vec4 blend_colors(vec4 c1, vec4 c2, vec4 c3, float mixer, float edgesWidth, float edge_blur) {\n            vec3 color1 = c1.rgb * c1.a;\n            vec3 color2 = c2.rgb * c2.a;\n            vec3 color3 = c3.rgb * c3.a;\n\n            float r1 = smoothstep(.0 + .35 * edgesWidth, .7 - .35 * edgesWidth + .5 * edge_blur, mixer);\n            float r2 = smoothstep(.3 + .35 * edgesWidth, 1. - .35 * edgesWidth + edge_blur, mixer);\n\n            vec3 blended_color_2 = mix(color1, color2, r1);\n            float blended_opacity_2 = mix(c1.a, c2.a, r1);\n\n            vec3 c = mix(blended_color_2, color3, r2);\n            float o = mix(blended_opacity_2, c3.a, r2);\n            return vec4(c, o);\n        }\n\n        void main() {\n            vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n            \n            float t = .5 * u_time;\n            float noise_scale = .0005 + .006 * u_scale;\n\n            uv -= .5;\n            uv *= (noise_scale * u_resolution);\n            uv = rotate(uv, u_rotation * .5 * PI);\n            uv /= u_pixelRatio;\n            uv += .5;\n\n            float n1 = noise(uv * 1. + t);\n            float n2 = noise(uv * 2. - t);\n            float angle = n1 * TWO_PI;\n            uv.x += 4. * u_distortion * n2 * cos(angle);\n            uv.y += 4. * u_distortion * n2 * sin(angle);\n\n            float iterations_number = ceil(clamp(u_swirlIterations, 1., 30.));\n            for (float i = 1.; i <= iterations_number; i++) {\n                uv.x += clamp(u_swirl, 0., 2.) / i * cos(t + i * 1.5 * uv.y);\n                uv.y += clamp(u_swirl, 0., 2.) / i * cos(t + i * 1. * uv.x);\n            }\n\n            float proportion = clamp(u_proportion, 0., 1.);\n            float shape = 0.;\n            float mixer = 0.;\n\n            if (u_shape < .5) {\n                // Checks\n                vec2 checks_shape_uv = uv * (.5 + 3.5 * u_shapeScale);\n                shape = .5 + .5 * sin(checks_shape_uv.x) * cos(checks_shape_uv.y);\n                mixer = shape + .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);\n            } else if (u_shape < 1.5) {\n                // Stripes\n                vec2 stripes_shape_uv = uv * (.25 + 3. * u_shapeScale);\n                float f = fract(stripes_shape_uv.y);\n                shape = smoothstep(.0, .55, f) * smoothstep(1., .45, f);\n                mixer = shape + .48 * sign(proportion - .5) * pow(abs(proportion - .5), .5);\n            } else {\n                // Edge\n                float sh = 1. - uv.y;\n                sh -= .5;\n                sh /= (noise_scale * u_resolution.y);\n                sh += .5;\n                float shape_scaling = .2 * (1. - u_shapeScale);\n                shape = smoothstep(.45 - shape_scaling, .55 + shape_scaling, sh + .3 * (proportion - .5));\n                mixer = shape;\n            }\n\n            vec4 color_mix = blend_colors(u_color1, u_color2, u_color3, mixer, 1. - clamp(u_softness, 0., 1.), .01 + .01 * u_scale);\n            fragColor = vec4(color_mix.rgb, color_mix.a);\n        }\n        `;\n\n        // WebGL Setup\n        const canvas = document.getElementById('canvas');\n        const gl = canvas.getContext('webgl2', { preserveDrawingBuffer: true });\n\n        if (!gl) {\n            console.error('WebGL2 not supported');\n        }\n\n        function createShader(gl, type, source) {\n            const shader = gl.createShader(type);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                console.error('Shader compile error:', gl.getShaderInfoLog(shader));\n                gl.deleteShader(shader);\n                return null;\n            }\n            return shader;\n        }\n\n        function createProgram(gl, vertexShader, fragmentShader) {\n            const program = gl.createProgram();\n            gl.attachShader(program, vertexShader);\n            gl.attachShader(program, fragmentShader);\n            gl.linkProgram(program);\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                console.error('Program link error:', gl.getProgramInfoLog(program));\n                return null;\n            }\n            return program;\n        }\n\n        const program = createProgram(\n            gl,\n            createShader(gl, gl.VERTEX_SHADER, vertexShaderSource),\n            createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource)\n        );\n\n        const positionAttributeLocation = gl.getAttribLocation(program, \"a_position\");\n        const positionBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n            -1, -1,\n            1, -1,\n            -1, 1,\n            -1, 1,\n            1, -1,\n            1, 1,\n        ]), gl.STATIC_DRAW);\n\n        const vao = gl.createVertexArray();\n        gl.bindVertexArray(vao);\n        gl.enableVertexAttribArray(positionAttributeLocation);\n        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n\n        // Helper Functions\n        function hexToRgba(hex) {\n            hex = hex.replace('#', '');\n            if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');\n            const bigint = parseInt(hex, 16);\n            const r = (bigint >> 16) & 255;\n            const g = (bigint >> 8) & 255;\n            const b = bigint & 255;\n            return [r / 255, g / 255, b / 255, 1.0];\n        }\n\n        function lerp(start, end, amt) {\n            return (1 - amt) * start + amt * end;\n        }\n\n        // Presets Data\n        const SHAPES = { Checks: 0, Stripes: 1, Edge: 2 };\n\n        const rawPresets = {\n            Prism: {\n                color1: \"#050505\", color2: \"#66B3FF\", color3: \"#FFFFFF\",\n                rotation: -50, proportion: 1, scale: 0.01, speed: 30,\n                distortion: 0, swirl: 50, swirlIterations: 16, softness: 47,\n                offset: -299, shape: \"Checks\", shapeSize: 45\n            },\n            Lava: {\n                color1: \"#FF9F21\", color2: \"#FF0303\", color3: \"#000000\",\n                rotation: 114, proportion: 100, scale: 0.52, speed: 30,\n                distortion: 7, swirl: 18, swirlIterations: 20, softness: 100,\n                offset: 717, shape: \"Edge\", shapeSize: 12\n            },\n            Plasma: {\n                color1: \"#B566FF\", color2: \"#000000\", color3: \"#000000\",\n                rotation: 0, proportion: 63, scale: 0.75, speed: 30,\n                distortion: 5, swirl: 61, swirlIterations: 5, softness: 100,\n                offset: -168, shape: \"Checks\", shapeSize: 28\n            },\n            Pulse: {\n                color1: \"#66FF85\", color2: \"#000000\", color3: \"#000000\",\n                rotation: -167, proportion: 92, scale: 0, speed: 20,\n                distortion: 54, swirl: 75, swirlIterations: 3, softness: 28,\n                offset: -813, shape: \"Checks\", shapeSize: 79\n            },\n            Vortex: {\n                color1: \"#000000\", color2: \"#FFFFFF\", color3: \"#000000\",\n                rotation: 50, proportion: 41, scale: 0.4, speed: 20,\n                distortion: 0, swirl: 100, swirlIterations: 3, softness: 5,\n                offset: -744, shape: \"Stripes\", shapeSize: 80\n            },\n            Mist: {\n                color1: \"#050505\", color2: \"#FF66B8\", color3: \"#050505\",\n                rotation: 0, proportion: 33, scale: 0.48, speed: 39,\n                distortion: 4, swirl: 65, swirlIterations: 5, softness: 100,\n                offset: -235, shape: \"Edge\", shapeSize: 48\n            }\n        };\n\n        // Process presets to be interpolation-friendly\n        const presets = {};\n        for (const key in rawPresets) {\n            const p = rawPresets[key];\n            presets[key] = {\n                color1: hexToRgba(p.color1),\n                color2: hexToRgba(p.color2),\n                color3: hexToRgba(p.color3),\n                rotation: p.rotation * (Math.PI / 180),\n                proportion: p.proportion / 100,\n                scale: p.scale,\n                speed: p.speed,\n                distortion: p.distortion / 50,\n                swirl: p.swirl / 100,\n                swirlIterations: p.swirlIterations,\n                softness: p.softness / 100,\n                shape: SHAPES[p.shape],\n                shapeScale: p.shapeSize / 100,\n                offset: p.offset // keep this separate for logic\n            };\n        }\n\n        // State - DEFAULT TO LAVA\n        let targetState = { ...presets.Lava };\n        let currentState = { ...presets.Lava };\n        let totalTime = rawPresets.Lava.offset * 10;\n\n        // Uniform Locations\n        const uniforms = {\n            u_time: gl.getUniformLocation(program, \"u_time\"),\n            u_pixelRatio: gl.getUniformLocation(program, \"u_pixelRatio\"),\n            u_resolution: gl.getUniformLocation(program, \"u_resolution\"),\n            u_scale: gl.getUniformLocation(program, \"u_scale\"),\n            u_rotation: gl.getUniformLocation(program, \"u_rotation\"),\n            u_color1: gl.getUniformLocation(program, \"u_color1\"),\n            u_color2: gl.getUniformLocation(program, \"u_color2\"),\n            u_color3: gl.getUniformLocation(program, \"u_color3\"),\n            u_proportion: gl.getUniformLocation(program, \"u_proportion\"),\n            u_softness: gl.getUniformLocation(program, \"u_softness\"),\n            u_shape: gl.getUniformLocation(program, \"u_shape\"),\n            u_shapeScale: gl.getUniformLocation(program, \"u_shapeScale\"),\n            u_distortion: gl.getUniformLocation(program, \"u_distortion\"),\n            u_swirl: gl.getUniformLocation(program, \"u_swirl\"),\n            u_swirlIterations: gl.getUniformLocation(program, \"u_swirlIterations\"),\n        };\n\n        function resize() {\n            const displayWidth = window.innerWidth;\n            const displayHeight = window.innerHeight;\n            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {\n                canvas.width = displayWidth;\n                canvas.height = displayHeight;\n                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n            }\n        }\n\n        function updateState() {\n            const lerpFactor = 0.05;\n            \n            // Interpolate scalar values\n            currentState.rotation = lerp(currentState.rotation, targetState.rotation, lerpFactor);\n            currentState.proportion = lerp(currentState.proportion, targetState.proportion, lerpFactor);\n            currentState.scale = lerp(currentState.scale, targetState.scale, lerpFactor);\n            currentState.speed = lerp(currentState.speed, targetState.speed, lerpFactor);\n            currentState.distortion = lerp(currentState.distortion, targetState.distortion, lerpFactor);\n            currentState.swirl = lerp(currentState.swirl, targetState.swirl, lerpFactor);\n            currentState.softness = lerp(currentState.softness, targetState.softness, lerpFactor);\n            currentState.shapeScale = lerp(currentState.shapeScale, targetState.shapeScale, lerpFactor);\n            \n            currentState.swirlIterations = lerp(currentState.swirlIterations, targetState.swirlIterations, lerpFactor);\n            \n            currentState.shape = lerp(currentState.shape, targetState.shape, lerpFactor);\n\n            // Interpolate colors\n            for (let i = 0; i < 4; i++) {\n                currentState.color1[i] = lerp(currentState.color1[i], targetState.color1[i], lerpFactor);\n                currentState.color2[i] = lerp(currentState.color2[i], targetState.color2[i], lerpFactor);\n                currentState.color3[i] = lerp(currentState.color3[i], targetState.color3[i], lerpFactor);\n            }\n        }\n\n        function render(now) {\n            updateState();\n            \n            // Increment time\n            totalTime += 0.0005 * currentState.speed;\n\n            gl.useProgram(program);\n            gl.bindVertexArray(vao);\n\n            gl.uniform1f(uniforms.u_time, totalTime);\n            gl.uniform1f(uniforms.u_pixelRatio, window.devicePixelRatio);\n            gl.uniform2f(uniforms.u_resolution, canvas.width, canvas.height);\n            \n            gl.uniform1f(uniforms.u_scale, currentState.scale);\n            gl.uniform1f(uniforms.u_rotation, currentState.rotation);\n            gl.uniform4fv(uniforms.u_color1, currentState.color1);\n            gl.uniform4fv(uniforms.u_color2, currentState.color2);\n            gl.uniform4fv(uniforms.u_color3, currentState.color3);\n            gl.uniform1f(uniforms.u_proportion, currentState.proportion);\n            gl.uniform1f(uniforms.u_softness, currentState.softness);\n            gl.uniform1f(uniforms.u_shape, currentState.shape);\n            gl.uniform1f(uniforms.u_shapeScale, currentState.shapeScale);\n            gl.uniform1f(uniforms.u_distortion, currentState.distortion);\n            gl.uniform1f(uniforms.u_swirl, currentState.swirl);\n            gl.uniform1f(uniforms.u_swirlIterations, currentState.swirlIterations);\n\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n            requestAnimationFrame(render);\n        }\n\n        // Init\n        window.addEventListener('resize', resize);\n        resize();\n        requestAnimationFrame(render);\n    </script>\n</body>\n</html>"
  },
  {
    "title": "cg-canvas-animated-gradients 2",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>cg-canvas-animated-gradients | @mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <div class=\"container\">\n      <div class=\"header\">\n        <h1>mukta is a better way to build websites</h1>\n        <button>Get PRO</button>\n      </div>\n    </div>\n    <div class=\"glassy-overlay\"></div>\n    <canvas></canvas>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "const canvas = document.querySelector(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\n\nlet mouseMoved = false;\n\nconst pointer = {\n  x: 0.5 * window.innerWidth,\n  y: 0.5 * window.innerHeight,\n};\nconst params = {\n  pointsNumber: 40,\n  widthFactor: 10,\n  mouseThreshold: 0.5,\n  spring: 0.25,\n  friction: 0.5,\n};\n\nconst trail = new Array(params.pointsNumber);\nfor (let i = 0; i < params.pointsNumber; i++) {\n  trail[i] = {\n    x: pointer.x,\n    y: pointer.y,\n    dx: 0,\n    dy: 0,\n  };\n}\n\nwindow.addEventListener(\"click\", (e) => {\n  updateMousePosition(e.pageX, e.pageY);\n});\nwindow.addEventListener(\"mousemove\", (e) => {\n  mouseMoved = true;\n  updateMousePosition(e.pageX, e.pageY);\n});\nwindow.addEventListener(\"touchmove\", (e) => {\n  mouseMoved = true;\n  updateMousePosition(e.targetTouches[0].pageX, e.targetTouches[0].pageY);\n});\n\nfunction updateMousePosition(eX, eY) {\n  pointer.x = eX;\n  pointer.y = eY;\n}\n\nsetupCanvas();\nupdate(0);\nwindow.addEventListener(\"resize\", setupCanvas);\n\nfunction update(t) {\n  if (!mouseMoved) {\n    pointer.x =\n      (0.5 + 0.3 * Math.cos(0.002 * t) * Math.sin(0.005 * t)) *\n      window.innerWidth;\n    pointer.y =\n      (0.5 + 0.2 * Math.cos(0.005 * t) + 0.1 * Math.cos(0.01 * t)) *\n      window.innerHeight;\n  }\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  trail.forEach((p, pIdx) => {\n    const prev = pIdx === 0 ? pointer : trail[pIdx - 1];\n    const spring = pIdx === 0 ? 0.4 * params.spring : params.spring;\n    p.dx += (prev.x - p.x) * spring;\n    p.dy += (prev.y - p.y) * spring;\n    p.dx *= params.friction;\n    p.dy *= params.friction;\n    p.x += p.dx;\n    p.y += p.dy;\n  });\n\n  var gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);\n  gradient.addColorStop(0, \"rgba(160, 93, 134,1)\");\n  gradient.addColorStop(1, \"rgba(57, 34, 115,1)\");\n\n  ctx.strokeStyle = gradient;\n  ctx.lineCap = \"round\";\n  ctx.beginPath();\n  ctx.moveTo(trail[0].x, trail[0].y);\n\n  for (let i = 1; i < trail.length - 1; i++) {\n    const xc = 0.5 * (trail[i].x + trail[i + 1].x);\n    const yc = 0.5 * (trail[i].y + trail[i + 1].y);\n    ctx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);\n    ctx.lineWidth = params.widthFactor * (params.pointsNumber - i);\n    ctx.stroke();\n  }\n  ctx.lineTo(trail[trail.length - 1].x, trail[trail.length - 1].y);\n  ctx.stroke();\n\n  window.requestAnimationFrame(update);\n}\n\nfunction setupCanvas() {\n  canvas.width = window.innerWidth;\n  canvas.height = window.innerHeight;\n}\n",
      "styles.css": "@import url(\"https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap\");\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody,\nhtml {\n  background: #10092c;\n  padding: 0;\n  margin: 0;\n  overscroll-behavior: none;\n  font-family: \"Inter\";\n}\n\n.header {\n  padding: 4em;\n  opacity: 0.75;\n}\n\n.header h1 {\n  width: 60%;\n  background: #cfcfcf;\n  background: linear-gradient(to top, #cecece 0%, #ffffff 100%);\n  background-clip: text;\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  font-weight: 500;\n  font-size: 80px;\n  letter-spacing: -0.05em;\n  line-height: 1;\n}\n\nbutton {\n  margin: 3em 0;\n  padding: 1em 1.5em;\n  color: #fff;\n  font-size: 16px;\n  border: 1px solid rgba(149, 99, 255, 0.5);\n  outline: none;\n  border-radius: 0.75em;\n  backdrop-filter: blur(20px);\n  cursor: pointer;\n  background: linear-gradient(\n      180deg,\n      rgba(60, 8, 126, 0) 0%,\n      rgba(60, 8, 126, 0.32) 100%\n    ),\n    rgba(113, 47, 255, 0.12);\n  box-shadow: inset 0 0 12px #bf97ff3d;\n}\n\n.glassy-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(255, 255, 255, 0.05);\n  backdrop-filter: blur(50px);\n  pointer-events: none;\n}\n\n.container {\n  position: absolute;\n  top: 0;\n  z-index: 10000;\n}\n"
    }
  },
  {
    "title": "cg-lusion-fluid-particles",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Lusion Fluid Simulation | mukta</title>\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js\"></script>\n  </head>\n  <body>\n    <div class=\"header\">\n      <p>Is your big idea ready to go wild?</p>\n      <h1>\n        Let's work <br />\n        together!\n      </h1>\n      <button>Let's talk</button>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "let particles = [];\nconst particleCount = 250;\nconst particleSize = 12;\nconst spacing = particleSize * 12;\nlet gravity;\nlet deltaTime = 1 / 60;\nlet mousePrevX = 0;\nlet mousePrevY = 0;\n\nclass Particle {\n  constructor(x, y) {\n    this.pos = createVector(x, y);\n    this.vel = createVector(random(-20, 20), random(-20, 20));\n    this.acc = createVector(0, 0);\n    this.color = color(255, 255, 255);\n    this.lastPos = createVector(x, y);\n    this.densityFactor = 0;\n    this.rotation = random(TWO_PI);\n    this.rotationVel = random(-0.1, 0.1);\n    this.shapeType = random([\"triangle\", \"square\", \"circle\"]);\n  }\n\n  update() {\n    this.lastPos.x = this.pos.x;\n    this.lastPos.y = this.pos.y;\n\n    this.rotation += this.rotationVel * deltaTime;\n\n    let gravityScale = map(this.densityFactor, 0, 5, 1, 0.7);\n    this.acc.add(p5.Vector.mult(gravity, 4 * gravityScale));\n\n    if (mouseIsPressed) {\n      let d = dist(this.pos.x, this.pos.y, mouseX, mouseY);\n      let maxDist = 250;\n      if (d < maxDist) {\n        let mouseVel = createVector(mouseX - mousePrevX, mouseY - mousePrevY);\n        let densityScale = map(this.densityFactor, 0, 5, 1, 0.85);\n        let force = mouseVel.copy().mult(10 * densityScale);\n        let strength = pow(map(d, 0, maxDist, 1, 0), 1.75);\n        force.mult(strength);\n        this.acc.add(force);\n        this.rotationVel += mouseVel.mag() * 0.01 * random(-1, 1);\n      }\n    }\n\n    let dampingFactor = map(this.densityFactor, 0, 5, 1, 1);\n    this.vel.add(p5.Vector.mult(this.acc, deltaTime * 15.0 * dampingFactor));\n\n    if (this.pos.y > height - particleSize * 2) {\n      this.vel.mult(0.92);\n      this.vel.x *= 0.94;\n      this.rotationVel *= 0.95;\n    } else {\n      this.vel.mult(0.985);\n      this.rotationVel *= 0.99;\n    }\n\n    this.pos.add(p5.Vector.mult(this.vel, deltaTime * 11.5));\n\n    let bounce = 0.45;\n    let buffer = particleSize;\n\n    if (this.pos.x < buffer) {\n      this.pos.x = buffer;\n      this.vel.x = abs(this.vel.x) * bounce;\n    }\n    if (this.pos.x > width - buffer) {\n      this.pos.x = width - buffer;\n      this.vel.x = -abs(this.vel.x) * bounce;\n    }\n    if (this.pos.y < buffer) {\n      this.pos.y = buffer;\n      this.vel.y = abs(this.vel.y) * bounce;\n    }\n    if (this.pos.y > height - buffer) {\n      this.pos.y = height - buffer;\n      this.vel.y = -abs(this.vel.y) * bounce;\n    }\n\n    this.acc.mult(0);\n    this.densityFactor = 0;\n  }\n\n  draw() {\n    noStroke();\n    fill(this.color);\n\n    let renderX = lerp(this.lastPos.x, this.pos.x, 0.5);\n    let renderY = lerp(this.lastPos.y, this.pos.y, 0.5);\n\n    push();\n    translate(renderX, renderY);\n    rotate(this.rotation);\n\n    let size = particleSize * 1;\n\n    switch (this.shapeType) {\n      case \"triangle\":\n        triangle(-size / 2, size / 2, size / 2, size / 2, 0, -size / 2);\n        break;\n      case \"square\":\n        rectMode(CENTER);\n        rect(0, 0, size, size);\n        break;\n      case \"circle\":\n        circle(0, 0, size);\n        break;\n    }\n\n    pop();\n  }\n\n  interact(other) {\n    let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);\n\n    if (d < spacing) {\n      let densityIncrease = map(d, 0, spacing, 1.2, 0.1);\n      this.densityFactor += densityIncrease;\n      other.densityFactor += densityIncrease;\n\n      let force = p5.Vector.sub(this.pos, other.pos);\n      force.normalize();\n\n      let strength = map(d, 0, spacing, 0.8, 0);\n      strength = pow(strength, 1.1);\n      force.mult(strength);\n\n      let overlap = spacing - d;\n      if (overlap > 0) {\n        let correctionStrength = map(overlap, 0, spacing, 0.15, 0.25);\n        let correction = force.copy().mult(overlap * correctionStrength);\n\n        let boundaryFactor = 1.0;\n        if (\n          this.pos.y > height - particleSize * 4 ||\n          other.pos.y > height - particleSize * 4\n        ) {\n          boundaryFactor = 0.7;\n        }\n\n        correction.mult(boundaryFactor);\n\n        let densityScale = map(\n          this.densityFactor + other.densityFactor,\n          0,\n          10,\n          1,\n          0.9\n        );\n\n        let correctionWeight = 0.15 * densityScale;\n        this.pos.add(p5.Vector.mult(correction, correctionWeight));\n        other.pos.sub(p5.Vector.mult(correction, correctionWeight));\n\n        let avgVel = p5.Vector.add(this.vel, other.vel).mult(0.5);\n        let velocityBlend = map(d, 0, spacing, 0.15, 0.02);\n        velocityBlend *= map(\n          this.densityFactor + other.densityFactor,\n          0,\n          10,\n          1.2,\n          0.95\n        );\n\n        if (d < spacing * 0.5) {\n          velocityBlend *= 1.5;\n        }\n\n        this.vel.lerp(avgVel, velocityBlend);\n        other.vel.lerp(avgVel, velocityBlend);\n      }\n\n      let accForce = force.copy().mult(0.4);\n      this.acc.add(accForce);\n      other.acc.sub(accForce);\n    }\n  }\n}\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  frameRate(60);\n  gravity = createVector(0, 2.2);\n  background(\"#1a2ffb\");\n\n  let availableWidth = width * 0.95;\n  let cols = floor(availableWidth / spacing);\n  let requiredRows = ceil(particleCount / cols);\n  let startX = (width - cols * spacing) * 0.5;\n  let startY = height * 0.05;\n\n  let count = 0;\n  let row = 0;\n\n  while (count < particleCount) {\n    for (let col = 0; col < cols && count < particleCount; col++) {\n      let x = startX + col * spacing + random(-5, 5);\n      let y = startY + row * spacing + random(-5, 5);\n      particles.push(new Particle(x, y));\n      count++;\n    }\n    row++;\n  }\n}\n\nfunction draw() {\n  background(\"#1a2ffb\");\n  deltaTime = 1 / frameRate();\n\n  let gridSize = spacing;\n  let grid = {};\n\n  for (let i = 0; i < particles.length; i++) {\n    let p = particles[i];\n    p.update();\n\n    let gridX = floor(p.pos.x / gridSize);\n    let gridY = floor(p.pos.y / gridSize);\n    let key = gridX + \",\" + gridY;\n\n    if (!grid[key]) {\n      grid[key] = [];\n    }\n    grid[key].push(i);\n  }\n\n  for (let key in grid) {\n    let cell = grid[key];\n    let [gx, gy] = key.split(\",\").map(Number);\n\n    for (let dx = -1; dx <= 1; dx++) {\n      for (let dy = -1; dy <= 1; dy++) {\n        let neighborKey = gx + dx + \",\" + (gy + dy);\n        if (grid[neighborKey]) {\n          for (let i of cell) {\n            for (let j of grid[neighborKey]) {\n              if (i < j) {\n                particles[i].interact(particles[j]);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  for (let p of particles) {\n    p.draw();\n  }\n\n  mousePrevX = mouseX;\n  mousePrevY = mouseY;\n}\n\nfunction windowResized() {\n  resizeCanvas(windowWidth, windowHeight);\n}\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  width: 100%;\n  height: 100%;\n  font-family: \"Aeonik\";\n  background-color: #1a2ffb;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.header {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  user-select: none;\n  z-index: 2;\n}\n\n.header p {\n  color: #fff;\n  text-transform: uppercase;\n  font-weight: 400;\n  margin-bottom: 1.5em;\n}\n\n.header h1 {\n  color: #fff;\n  text-align: center;\n  font-size: 7.5vw;\n  font-weight: 400;\n  line-height: 100%;\n  margin-bottom: 0.75em;\n}\n\nbutton {\n  border: none;\n  outline: none;\n  padding: 1.5em 3em;\n  text-transform: uppercase;\n  font-weight: 500;\n  background-color: #fff;\n  border-radius: 2em;\n}\n"
    }
  },
  {
    "title": "cg-webgl-interactive-gradient",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>WebGL Interactive Gradient | mukta</title>\n    <link rel=\"stylesheet\" href=\"/styles.css\" />\n  </head>\n  <body>\n    <nav>\n      <div class=\"logo\">\n        <p>Orbit Studio</p>\n      </div>\n      <div class=\"nav-items\">\n        <p>Index</p>\n        <p>Portfolio</p>\n        <p>Info</p>\n        <p>Contact</p>\n      </div>\n    </nav>\n    <section class=\"hero\">\n      <div class=\"gradient-canvas\"></div>\n\n      <div class=\"hero-logo\">\n        <img src=\"/logo_01.png\" alt=\"\" />\n      </div>\n\n      <div class=\"hero-footer\">\n        <p>Experiment 0469</p>\n        <p>Built by mukta</p>\n      </div>\n    </section>\n    <script type=\"module\" src=\"/shaders.js\"></script>\n    <script type=\"module\" src=\"/script.js\"></script>\n  </body>\n</html>\n",
      "package.json": "{\n  \"name\": \"cg-webgl-interactive-gradient\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"dev\": \"vite\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\",\n  \"dependencies\": {\n    \"leva\": \"^0.10.0\",\n    \"three\": \"^0.178.0\",\n    \"vite\": \"^7.0.2\"\n  }\n}\n",
      "script.js": "import * as THREE from \"three\";\nimport { vertexShader, fluidShader, displayShader } from \"./shaders.js\";\n\nconst config = {\n  brushSize: 25.0,\n  brushStrength: 0.5,\n  distortionAmount: 2.5,\n  fluidDecay: 0.98,\n  trailLength: 0.8,\n  stopDecay: 0.85,\n  color1: \"#b8fff7\",\n  color2: \"#6e3466\",\n  color3: \"#0133ff\",\n  color4: \"#66d1fe\",\n  colorIntensity: 1.0,\n  softness: 1.0,\n};\n\nfunction hexToRgb(hex) {\n  const r = parseInt(hex.slice(1, 3), 16) / 255;\n  const g = parseInt(hex.slice(3, 5), 16) / 255;\n  const b = parseInt(hex.slice(5, 7), 16) / 255;\n  return [r, g, b];\n}\n\nconst camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\nconst renderer = new THREE.WebGLRenderer({ antialias: true });\n\nconst gradientCanvas = document.querySelector(\".gradient-canvas\");\nrenderer.setSize(window.innerWidth, window.innerHeight);\ngradientCanvas.appendChild(renderer.domElement);\n\nconst fluidTarget1 = new THREE.WebGLRenderTarget(\n  window.innerWidth,\n  window.innerHeight,\n  {\n    minFilter: THREE.LinearFilter,\n    magFilter: THREE.LinearFilter,\n    format: THREE.RGBAFormat,\n    type: THREE.FloatType,\n  }\n);\n\nconst fluidTarget2 = new THREE.WebGLRenderTarget(\n  window.innerWidth,\n  window.innerHeight,\n  {\n    minFilter: THREE.LinearFilter,\n    magFilter: THREE.LinearFilter,\n    format: THREE.RGBAFormat,\n    type: THREE.FloatType,\n  }\n);\n\nlet currentFluidTarget = fluidTarget1;\nlet previousFluidTarget = fluidTarget2;\nlet frameCount = 0;\n\nconst fluidMaterial = new THREE.ShaderMaterial({\n  uniforms: {\n    iTime: { value: 0 },\n    iResolution: {\n      value: new THREE.Vector2(window.innerWidth, window.innerHeight),\n    },\n    iMouse: { value: new THREE.Vector4(0, 0, 0, 0) },\n    iFrame: { value: 0 },\n    iPreviousFrame: { value: null },\n    uBrushSize: { value: config.brushSize },\n    uBrushStrength: { value: config.brushStrength },\n    uFluidDecay: { value: config.fluidDecay },\n    uTrailLength: { value: config.trailLength },\n    uStopDecay: { value: config.stopDecay },\n  },\n  vertexShader: vertexShader,\n  fragmentShader: fluidShader,\n});\n\nconst displayMaterial = new THREE.ShaderMaterial({\n  uniforms: {\n    iTime: { value: 0 },\n    iResolution: {\n      value: new THREE.Vector2(window.innerWidth, window.innerHeight),\n    },\n    iFluid: { value: null },\n    uDistortionAmount: { value: config.distortionAmount },\n    uColor1: { value: new THREE.Vector3(...hexToRgb(config.color1)) },\n    uColor2: { value: new THREE.Vector3(...hexToRgb(config.color2)) },\n    uColor3: { value: new THREE.Vector3(...hexToRgb(config.color3)) },\n    uColor4: { value: new THREE.Vector3(...hexToRgb(config.color4)) },\n    uColorIntensity: { value: config.colorIntensity },\n    uSoftness: { value: config.softness },\n  },\n  vertexShader: vertexShader,\n  fragmentShader: displayShader,\n});\n\nconst geometry = new THREE.PlaneGeometry(2, 2);\nconst fluidPlane = new THREE.Mesh(geometry, fluidMaterial);\nconst displayPlane = new THREE.Mesh(geometry, displayMaterial);\n\nlet mouseX = 0,\n  mouseY = 0;\nlet prevMouseX = 0,\n  prevMouseY = 0;\nlet lastMoveTime = 0;\n\ndocument.addEventListener(\"mousemove\", (e) => {\n  const rect = gradientCanvas.getBoundingClientRect();\n  prevMouseX = mouseX;\n  prevMouseY = mouseY;\n  mouseX = e.clientX - rect.left;\n  mouseY = rect.height - (e.clientY - rect.top);\n  lastMoveTime = performance.now();\n  fluidMaterial.uniforms.iMouse.value.set(\n    mouseX,\n    mouseY,\n    prevMouseX,\n    prevMouseY\n  );\n});\n\ndocument.addEventListener(\"mouseleave\", () => {\n  fluidMaterial.uniforms.iMouse.value.set(0, 0, 0, 0);\n});\n\nfunction animate() {\n  requestAnimationFrame(animate);\n\n  const time = performance.now() * 0.001;\n  fluidMaterial.uniforms.iTime.value = time;\n  displayMaterial.uniforms.iTime.value = time;\n  fluidMaterial.uniforms.iFrame.value = frameCount;\n\n  if (performance.now() - lastMoveTime > 100) {\n    fluidMaterial.uniforms.iMouse.value.set(0, 0, 0, 0);\n  }\n\n  fluidMaterial.uniforms.uBrushSize.value = config.brushSize;\n  fluidMaterial.uniforms.uBrushStrength.value = config.brushStrength;\n  fluidMaterial.uniforms.uFluidDecay.value = config.fluidDecay;\n  fluidMaterial.uniforms.uTrailLength.value = config.trailLength;\n  fluidMaterial.uniforms.uStopDecay.value = config.stopDecay;\n\n  displayMaterial.uniforms.uDistortionAmount.value = config.distortionAmount;\n  displayMaterial.uniforms.uColorIntensity.value = config.colorIntensity;\n  displayMaterial.uniforms.uSoftness.value = config.softness;\n  displayMaterial.uniforms.uColor1.value.set(...hexToRgb(config.color1));\n  displayMaterial.uniforms.uColor2.value.set(...hexToRgb(config.color2));\n  displayMaterial.uniforms.uColor3.value.set(...hexToRgb(config.color3));\n  displayMaterial.uniforms.uColor4.value.set(...hexToRgb(config.color4));\n\n  fluidMaterial.uniforms.iPreviousFrame.value = previousFluidTarget.texture;\n  renderer.setRenderTarget(currentFluidTarget);\n  renderer.render(fluidPlane, camera);\n\n  displayMaterial.uniforms.iFluid.value = currentFluidTarget.texture;\n  renderer.setRenderTarget(null);\n  renderer.render(displayPlane, camera);\n\n  const temp = currentFluidTarget;\n  currentFluidTarget = previousFluidTarget;\n  previousFluidTarget = temp;\n\n  frameCount++;\n}\n\nwindow.addEventListener(\"resize\", () => {\n  const width = window.innerWidth;\n  const height = window.innerHeight;\n\n  renderer.setSize(width, height);\n  fluidMaterial.uniforms.iResolution.value.set(width, height);\n  displayMaterial.uniforms.iResolution.value.set(width, height);\n\n  fluidTarget1.setSize(width, height);\n  fluidTarget2.setSize(width, height);\n  frameCount = 0;\n});\n\nanimate();\n",
      "shaders.js": "export const vertexShader = `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n\nexport const fluidShader = `\n  uniform float iTime;\n  uniform vec2 iResolution;\n  uniform vec4 iMouse;\n  uniform int iFrame;\n  uniform sampler2D iPreviousFrame;\n  uniform float uBrushSize;\n  uniform float uBrushStrength;\n  uniform float uFluidDecay;\n  uniform float uTrailLength;\n  uniform float uStopDecay;\n  varying vec2 vUv;\n  \n  vec2 ur, U;\n  \n  float ln(vec2 p, vec2 a, vec2 b) {\n      return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n  }\n  \n  vec4 t(vec2 v, int a, int b) {\n      return texture2D(iPreviousFrame, fract((v+vec2(float(a),float(b)))/ur));\n  }\n  \n  vec4 t(vec2 v) {\n      return texture2D(iPreviousFrame, fract(v/ur));\n  }\n  \n  float area(vec2 a, vec2 b, vec2 c) {\n      float A = length(b-c), B = length(c-a), C = length(a-b), s = 0.5*(A+B+C);\n      return sqrt(s*(s-A)*(s-B)*(s-C));\n  }\n  \n  void main() {\n      U = vUv * iResolution;\n      ur = iResolution.xy;\n      \n      if (iFrame < 1) {\n          float w = 0.5+sin(0.2*U.x)*0.5;\n          float q = length(U-0.5*ur);\n          gl_FragColor = vec4(0.1*exp(-0.001*q*q),0,0,w);\n      } else {\n          vec2 v = U,\n               A = v + vec2( 1, 1),\n               B = v + vec2( 1,-1),\n               C = v + vec2(-1, 1),\n               D = v + vec2(-1,-1);\n          \n          for (int i = 0; i < 8; i++) {\n              v -= t(v).xy;\n              A -= t(A).xy;\n              B -= t(B).xy;\n              C -= t(C).xy;\n              D -= t(D).xy;\n          }\n          \n          vec4 me = t(v);\n          vec4 n = t(v, 0, 1),\n              e = t(v, 1, 0),\n              s = t(v, 0, -1),\n              w = t(v, -1, 0);\n          vec4 ne = .25*(n+e+s+w);\n          me = mix(t(v), ne, vec4(0.15,0.15,0.95,0.));\n          me.z = me.z - 0.01*((area(A,B,C)+area(B,C,D))-4.);\n          \n          vec4 pr = vec4(e.z,w.z,n.z,s.z);\n          me.xy = me.xy + 100.*vec2(pr.x-pr.y, pr.z-pr.w)/ur;\n          \n          me.xy *= uFluidDecay;\n          me.z *= uTrailLength;\n          \n          if (iMouse.z > 0.0) {\n              vec2 mousePos = iMouse.xy;\n              vec2 mousePrev = iMouse.zw;\n              vec2 mouseVel = mousePos - mousePrev;\n              float velMagnitude = length(mouseVel);\n              float q = ln(U, mousePos, mousePrev);\n              vec2 m = mousePos - mousePrev;\n              float l = length(m);\n              if (l > 0.0) m = min(l, 10.0) * m / l;\n              \n              float brushSizeFactor = 1e-4 / uBrushSize;\n              float strengthFactor = 0.03 * uBrushStrength;\n              \n              float falloff = exp(-brushSizeFactor*q*q*q);\n              falloff = pow(falloff, 0.5);\n              \n              me.xyw += strengthFactor * falloff * vec3(m, 10.);\n              \n              if (velMagnitude < 2.0) {\n                  float distToCursor = length(U - mousePos);\n                  float influence = exp(-distToCursor * 0.01);\n                  float cursorDecay = mix(1.0, uStopDecay, influence);\n                  me.xy *= cursorDecay;\n                  me.z *= cursorDecay;\n              }\n          }\n          \n          gl_FragColor = clamp(me, -0.4, 0.4);\n      }\n  }\n`;\n\nexport const displayShader = `\n  uniform float iTime;\n  uniform vec2 iResolution;\n  uniform sampler2D iFluid;\n  uniform float uDistortionAmount;\n  uniform vec3 uColor1;\n  uniform vec3 uColor2;\n  uniform vec3 uColor3;\n  uniform vec3 uColor4;\n  uniform float uColorIntensity;\n  uniform float uSoftness;\n  varying vec2 vUv;\n  \n  void main() {\n    vec2 fragCoord = vUv * iResolution;\n    \n    vec4 fluid = texture2D(iFluid, vUv);\n    vec2 fluidVel = fluid.xy;\n    \n    float mr = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / mr;\n    \n    uv += fluidVel * (0.5 * uDistortionAmount);\n    \n    float d = -iTime * 0.5;\n    float a = 0.0;\n    for (float i = 0.0; i < 8.0; ++i) {\n      a += cos(i - d - a * uv.x);\n      d += sin(uv.y * i + a);\n    }\n    d += iTime * 0.5;\n    \n    float mixer1 = cos(uv.x * d) * 0.5 + 0.5;\n    float mixer2 = cos(uv.y * a) * 0.5 + 0.5;\n    float mixer3 = sin(d + a) * 0.5 + 0.5;\n    \n    float smoothAmount = clamp(uSoftness * 0.1, 0.0, 0.9);\n    mixer1 = mix(mixer1, 0.5, smoothAmount);\n    mixer2 = mix(mixer2, 0.5, smoothAmount);\n    mixer3 = mix(mixer3, 0.5, smoothAmount);\n    \n    vec3 col = mix(uColor1, uColor2, mixer1);\n    col = mix(col, uColor3, mixer2);\n    col = mix(col, uColor4, mixer3 * 0.4);\n    \n    col *= uColorIntensity;\n    \n    gl_FragColor = vec4(col, 1.0);\n  }\n`;\n",
      "styles.css": "@import url(\"https://fonts.googleapis.com/css2?family=Host+Grotesk:ital,wght@0,300..800;1,300..800&display=swap\");\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: \"Host Grotesk\";\n}\n\nimg {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\np {\n  color: #fff;\n  font-size: 0.9rem;\n  font-weight: 450;\n}\n\nnav,\n.hero-footer {\n  position: absolute;\n  left: 0;\n  width: 100vw;\n  padding: 2rem;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  z-index: 2;\n}\n\n.nav-items {\n  display: flex;\n  gap: 4rem;\n}\n\nnav .logo p {\n  font-weight: 700;\n}\n\n.hero-footer {\n  bottom: 0;\n}\n\nsection {\n  position: relative;\n  width: 100vw;\n  height: 100svh;\n  overflow: hidden;\n}\n\n.hero-logo {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 25%;\n}\n\n.gradient-canvas {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n@media (max-width: 1000px) {\n  nav {\n    flex-direction: column;\n    gap: 2rem;\n  }\n}\n"
    }
  }
]
