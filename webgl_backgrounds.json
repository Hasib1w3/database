[
  {
    "title": "Fluid motion #webgpu version",
    "description": "",
    "code": "index.html: <section id='container'> <h1 class='a-title'>Scratch here</h1> <h2 class='a-second-title'>See the magic</h2> <canvas id=\"fluid-webgpu\"></canvas> </section> <!-- switcher light-dark--> <fieldset class=\"switcher\"> <legend class=\"switcher__legend\">Choose theme</legend> <label class=\"switcher__option\"> <input class=\"switcher__input\" type=\"radio\" name=\"theme\" value=\"light\" c-option=\"1\" checked /> <svg class=\"switcher__icon\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 36 36\"> <path fill=\"var(--c)\" fill-rule=\"evenodd\" d=\"M18 12a6 6 0 1 1 0 12 6 6 0 0 1 0-12Zm0 2a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z\" clip-rule=\"evenodd\" /> <path fill=\"var(--c)\" d=\"M17 6.038a1 1 0 1 1 2 0v3a1 1 0 0 1-2 0v-3ZM24.244 7.742a1 1 0 1 1 1.618 1.176L24.1 11.345a1 1 0 1 1-1.618-1.176l1.763-2.427ZM29.104 13.379a1 1 0 0 1 .618 1.902l-2.854.927a1 1 0 1 1-.618-1.902l2.854-.927ZM29.722 20.795a1 1 0 0 1-.619 1.902l-2.853-.927a1 1 0 1 1 .618-1.902l2.854.927ZM25.862 27.159a1 1 0 0 1-1.618 1.175l-1.763-2.427a1 1 0 1 1 1.618-1.175l1.763 2.427ZM19 30.038a1 1 0 0 1-2 0v-3a1 1 0 1 1 2 0v3ZM11.755 28.334a1 1 0 0 1-1.618-1.175l1.764-2.427a1 1 0 1 1 1.618 1.175l-1.764 2.427ZM6.896 22.697a1 1 0 1 1-.618-1.902l2.853-.927a1 1 0 1 1 .618 1.902l-2.853.927ZM6.278 15.28a1 1 0 1 1 .618-1.901l2.853.927a1 1 0 1 1-.618 1.902l-2.853-.927ZM10.137 8.918a1 1 0 0 1 1.618-1.176l1.764 2.427a1 1 0 0 1-1.618 1.176l-1.764-2.427Z\" /> </svg> </label> <label class=\"switcher__option\"> <input class=\"switcher__input\" type=\"radio\" name=\"theme\" value=\"dark\" c-option=\"2\" /> <svg class=\"switcher__icon\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 36 36\"> <path fill=\"var(--c)\" d=\"M12.5 8.473a10.968 10.968 0 0 1 8.785-.97 7.435 7.435 0 0 0-3.737 4.672l-.09.373A7.454 7.454 0 0 0 28.732 20.4a10.97 10.97 0 0 1-5.232 7.125l-.497.27c-5.014 2.566-11.175.916-14.234-3.813l-.295-.483C5.53 18.403 7.13 11.93 12.017 8.77l.483-.297Zm4.234.616a8.946 8.946 0 0 0-2.805.883l-.429.234A9 9 0 0 0 10.206 22.5l.241.395A9 9 0 0 0 22.5 25.794l.416-.255a8.94 8.94 0 0 0 2.167-1.99 9.433 9.433 0 0 1-2.782-.313c-5.043-1.352-8.036-6.535-6.686-11.578l.147-.491c.242-.745.573-1.44.972-2.078Z\" /> </svg> </label> <!-- <div class=\"switcher__toggle\"></div> --> <div class=\"switcher__filter\"> <svg> <filter id=\"switcher\" primitiveUnits=\"objectBoundingBox\"> <feImage result=\"map\" width=\"100%\" height=\"100%\" x=\"0\" y=\"0\" href=\"data:image/webp;base64,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\" /> <feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"0.04\" result=\"blur\" /> <feDisplacementMap id=\"disp\" in=\"blur\" in2=\"map\" scale=\"0.5\" xChannelSelector=\"R\" yChannelSelector=\"G\"> </feDisplacementMap> </filter> <filter id=\"toggler\" primitiveUnits=\"objectBoundingBox\"> <feImage result=\"map\" width=\"100%\" height=\"100%\" x=\"0\" y=\"0\" href=\"data:image/webp;base64,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\" /> <feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"0.01\" result=\"blur\" /> <feDisplacementMap id=\"disp\" in=\"blur\" in2=\"map\" scale=\"0.5\" xChannelSelector=\"R\" yChannelSelector=\"G\"> </feDisplacementMap> </filter> </svg> </div> </fieldset>\nstyle.css: html, body { overflow: clip; } :root { --c-glass: #bbbbbc; --c-light: #fff; --c-dark: #000; --c-content: #224; --c-action: #0052f5; --c-bg: #fff; --glass-reflex-dark: 1; --glass-reflex-light: 1; --saturation: 150%; font-size: 20px; font-family: sans-serif; font-optical-sizing: auto; transition: background 400ms cubic-bezier(1, 0, 0.4, 1), color 400ms cubic-bezier(1, 0, 0.4, 1); } body { margin: 0; position: absolute; width: 100%; height: 100%; } #container { margin: 0; padding: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; height: 100%; background: var(--c-bg); color: var(--c-content); } .a-title { position: absolute; color: transparent; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-image: conic-gradient(#ed0101, blue); pointer-events: none; mix-blend-mode: difference; filter: drop-shadow(2px 4px 6px black); } .a-second-title { position: absolute; margin-top: 25vh; pointer-events: none; -webkit-text-stroke: 1.3px white; letter-spacing: 1.125px; font-size: -webkit-xxx-large; font-weight: 900; mix-blend-mode: color-burn; :has(input[value=\"dark\"]:checked) & { mix-blend-mode: color-dodge; } } canvas { width: 100%; height: 100%; background: var(--c-bg); } /*glass switcher*/ :has(input[value=\"dark\"]:checked) { --c-glass: #bbbbbc; --c-light: #fff; --c-dark: #000; --c-content: #e1e1e1; --c-action: #ffdc03; --c-bg: #000; --glass-reflex-dark: 2; --glass-reflex-light: 0.3; --saturation: 150%; } .switcher { position: fixed; z-index: 2; top: 40px; left: 50%; translate: -50%; display: flex; align-items: center; gap: 8px; width: 168px; /* Adjusted for two options */ max-width: 168px; /* Adjusted for two options */ height: 70px; box-sizing: border-box; padding: 8px 12px 10px; margin: 0 auto; border: none; border-radius: 99em; font-size: var(--fz); background-color: color-mix(in srgb, var(--c-glass) 12%, transparent); backdrop-filter: blur(8px) url(#switcher) saturate(var(--saturation)); -webkit-backdrop-filter: blur(8px) saturate(var(--saturation)); box-shadow: inset 0 0 0 1px color-mix( in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent ), inset 1.8px 3px 0px -2px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 90%), transparent), inset -2px -2px 0px -2px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 80%), transparent), inset -3px -8px 1px -6px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 60%), transparent), inset -0.3px -1px 4px 0px color-mix( in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 12%), transparent ), inset -1.5px 2.5px 0px -2px color-mix( in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 20%), transparent ), inset 0px 3px 4px -2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 20%), transparent), inset 2px -6.5px 1px -4px color-mix( in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent ), 0px 1px 5px 0px color-mix( in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent ), 0px 6px 16px 0px color-mix( in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 8%), transparent ); transition: background-color 400ms cubic-bezier(1, 0, 0.4, 1), box-shadow 400ms cubic-bezier(1, 0, 0.4, 1); backdrop-filter: blur(5px); } .switcher__legend { position: absolute; width: 1px; height: 1px; margin: -1px; border: 0; padding: 0; white-space: nowrap; clip-path: inset(100%); clip: rect(0 0 0 0); overflow: hidden; } .switcher__input { clip: rect(0 0 0 0); clip-path: inset(100%); height: 1px; width: 1px; overflow: hidden; position: absolute; white-space: nowrap; } .switcher__icon { display: block; width: 100%; transition: scale 200ms cubic-bezier(0.5, 0, 0, 1); } .switcher__filter { position: absolute; width: 0; height: 0; z-index: -1; } .switcher__option { --c: var(--c-content); display: flex; justify-content: center; align-items: center; padding: 0 16px; width: 68px; height: 100%; box-sizing: border-box; border-radius: 99em; opacity: 1; transition: all 160ms; } .switcher__option:hover { --c: var(--c-action); cursor: pointer; } .switcher__option:hover .switcher__icon { scale: 1.2; } .switcher__option:has(input:checked) { --c: var(--c-content); cursor: auto; } .switcher__option:has(input:checked) .switcher__icon { scale: 1; } .switcher::after { content: \"\"; position: absolute; left: 4px; top: 4px; display: block; width: 84px; height: calc(100% - 10px); border-radius: 99em; background-color: color-mix(in srgb, var(--c-glass) 36%, transparent); z-index: -1; box-shadow: inset 0 0 0 1px color-mix( in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent ), inset 2px 1px 0px -1px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 90%), transparent), inset -1.5px -1px 0px -1px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 80%), transparent), inset -2px -6px 1px -5px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 60%), transparent), inset -1px 2px 3px -1px color-mix( in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 20%), transparent ), inset 0px -4px 1px -2px color-mix( in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent ), 0px 3px 6px 0px color-mix( in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 8%), transparent ); } .switcher:has(input[c-option=\"1\"]:checked)::after { translate: 0 0; transform-origin: right; transition: background-color 400ms cubic-bezier(1, 0, 0.4, 1), box-shadow 400ms cubic-bezier(1, 0, 0.4, 1), translate 400ms cubic-bezier(1, 0, 0.4, 1); animation: scaleToggle 440ms ease; } .switcher:has(input[c-option=\"2\"]:checked)::after { translate: 76px 0; transition: background-color 400ms cubic-bezier(1, 0, 0.4, 1), box-shadow 400ms cubic-bezier(1, 0, 0.4, 1), translate 400ms cubic-bezier(1, 0, 0.4, 1); animation: scaleToggle2 440ms ease; transform-origin: left; /* Set transform-origin for the second option */ } @keyframes scaleToggle { 0% { scale: 1 1; } 50% { scale: 1.1 1; } 100% { scale: 1 1; } } @keyframes scaleToggle2 { 0% { scale: 1 1; } 50% { scale: 1.1 1; /* Adjusted scale for consistency */ } 100% { scale: 1 1; } }\nscript.js: /*main*/ let settings = { grid_size: 64, dye_size: 256, sim_speed: 5, contain_fluid: true, velocity_add_intensity: 0.28, velocity_add_radius: 0.001, velocity_diffusion: 1, dye_add_intensity: 0.8, dye_add_radius: 0.0035, dye_diffusion: 0.96204, viscosity: 0, vorticity: 0, pressure_iterations: 8, buffer_view: \"dye\", input_symmetry: \"none\" }; let device, presentationFormat, canvas, context; const mouseInfos = { current: null, last: null, velocity: null }; // Buffers let velocity, velocity0, dye, dye0, divergence, divergence0, pressure, pressure0, vorticity; // Uniforms const globalUniforms = {}; let time, dt, mouse, grid, uSimSpeed, vel_force, vel_radius, vel_diff, dye_force, dye_radius, dye_diff; let viscosity, uVorticity, containFluid, uSymmetry, uRenderIntensity; // Programs let checkerProgram, updateDyeProgram, updateProgram, advectProgram, boundaryProgram, divergenceProgram; let boundaryDivProgram, pressureProgram, boundaryPressureProgram, gradientSubtractProgram, advectDyeProgram; let clearPressureProgram, vorticityProgram, vorticityConfinmentProgram, renderProgram; function handlePointerMove(e) { const pointer = e.touches ? e.touches[0] : e; const rect = canvas.getBoundingClientRect(); if (!mouseInfos.current) mouseInfos.current = []; mouseInfos.current[0] = (pointer.clientX - rect.left) / rect.width; mouseInfos.current[1] = 1 - (pointer.clientY - rect.top) / rect.height; // Invert Y } function onWebGPUDetectionError(error) { console.log(\"Could not initialize WebGPU: \" + error); document.querySelector(\".webgpu-not-supported\").style.visibility = \"visible\"; return false; } // Init the WebGPU context by checking first if everything is supported // Returns true on init success, false otherwise async function initContext() { if (navigator.gpu == null) return onWebGPUDetectionError(\"WebGPU NOT Supported\"); const adapter = await navigator.gpu.requestAdapter(); if (!adapter) return onWebGPUDetectionError(\"No adapter found\"); device = await adapter.requestDevice(); canvas = document.getElementById(\"fluid-webgpu\"); context = canvas.getContext(\"webgpu\"); if (!context) return onWebGPUDetectionError(\"Canvas does not support WebGPU\"); // If we got here, WebGPU seems to be supported // Init canvas canvas.style.width = \"100%\"; canvas.style.height = \"100%\"; canvas.addEventListener(\"mousemove\", handlePointerMove); canvas.addEventListener(\"touchmove\", (e) => { e.preventDefault(); handlePointerMove(e); }); canvas.addEventListener(\"touchstart\", (e) => { e.preventDefault(); handlePointerMove(e); mouseInfos.last = [...mouseInfos.current]; }); // Init context presentationFormat = navigator.gpu.getPreferredCanvasFormat(adapter); context.configure({ device, format: presentationFormat, usage: GPUTextureUsage.RENDER_ATTACHMENT, alphaMode: \"premultiplied\" }); // Init buffer sizes initSizes(); // Resize event let resizeTimeout; window.addEventListener(\"resize\", () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(refreshSizes, 150); }); return true; } function refreshSizes() { initSizes(); initBuffers(); initPrograms(); globalUniforms.gridSize.needsUpdate = [ settings.grid_w, settings.grid_h, settings.dye_w, settings.dye_h, settings.dx, settings.rdx, settings.dyeRdx ]; } // Init buffer & canvas dimensions to fit the screen while keeping the aspect ratio // and downscaling the dimensions if they exceed the browsers capabilities function initSizes() { const dpr = window.devicePixelRatio || 1; const aspectRatio = window.innerWidth / window.innerHeight; const maxBufferSize = device.limits.maxStorageBufferBindingSize; const maxCanvasSize = device.limits.maxTextureDimension2D; // Fit to screen while keeping the aspect ratio const getPreferredDimensions = (baseSize) => { let w, h; const scaledBaseSize = baseSize * dpr; if (aspectRatio > 1) { h = scaledBaseSize; w = Math.floor(h * aspectRatio); } else { w = scaledBaseSize; h = Math.floor(w / aspectRatio); } return getValidDimensions(w, h); }; // Downscale if necessary to prevent crashes const getValidDimensions = (w, h) => { let downRatio = 1; // Prevent buffer size overflow if (w * h * 4 >= maxBufferSize) downRatio = Math.sqrt(maxBufferSize / (w * h * 4)); // Prevent canvas size overflow if (w > maxCanvasSize) downRatio = maxCanvasSize / w; else if (h > maxCanvasSize) downRatio = maxCanvasSize / h; return { w: Math.floor(w * downRatio), h: Math.floor(h * downRatio) }; }; // Calculate simulation buffer dimensions let gridSize = getPreferredDimensions(settings.grid_size); settings.grid_w = gridSize.w; settings.grid_h = gridSize.h; // Calculate dye & canvas buffer dimensions let dyeSize = getPreferredDimensions(settings.dye_size); settings.dye_w = dyeSize.w; settings.dye_h = dyeSize.h; // Useful values for the simulation settings.rdx = settings.grid_size * 4; settings.dyeRdx = settings.dye_size * 4; settings.dx = 1 / settings.rdx; // Resize the canvas canvas.width = settings.dye_w; canvas.height = settings.dye_h; } /*shaders*/ const STRUCT_GRID_SIZE = ` struct GridSize { w : f32, h : f32, dyeW: f32, dyeH: f32, dx : f32, rdx : f32, dyeRdx : f32 }`; const STRUCT_MOUSE = ` struct Mouse { pos: vec2<f32>, vel: vec2<f32>, }`; // This code initialize the pos and index variables and target only interior cells const COMPUTE_START = ` var pos = vec2<f32>(global_id.xy); if (pos.x == 0 || pos.y == 0 || pos.x >= uGrid.w - 1 || pos.y >= uGrid.h - 1) { return; } let index = ID(pos.x, pos.y);`; const COMPUTE_START_DYE = ` var pos = vec2<f32>(global_id.xy); if (pos.x == 0 || pos.y == 0 || pos.x >= uGrid.dyeW - 1 || pos.y >= uGrid.dyeH - 1) { return; } let index = ID(pos.x, pos.y);`; // This code initialize the pos and index variables and target all cells const COMPUTE_START_ALL = ` var pos = vec2<f32>(global_id.xy); if (pos.x >= uGrid.w || pos.y >= uGrid.h) { return; } let index = ID(pos.x, pos.y);`; const SPLAT_CODE = ` var m = uMouse.pos; var v = uMouse.vel*2.; var splat = createSplat(p, m, v, uRadius); if (uSymmetry == 1. || uSymmetry == 3.) {splat += createSplat(p, vec2(1. - m.x, m.y), v * vec2(-1., 1.), uRadius);} if (uSymmetry == 2. || uSymmetry == 3.) {splat += createSplat(p, vec2(m.x, 1. - m.y), v * vec2(1., -1.), uRadius);} if (uSymmetry == 3. || uSymmetry == 4.) {splat += createSplat(p, vec2(1. - m.x, 1. - m.y), v * vec2(-1., -1.), uRadius);} `; /// APPLY FORCE SHADER /// const updateVelocityShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} struct Mouse { pos: vec2<f32>, vel: vec2<f32>, } @group(0) @binding(0) var<storage, read> x_in : array<f32>; @group(0) @binding(1) var<storage, read> y_in : array<f32>; @group(0) @binding(2) var<storage, read_write> x_out : array<f32>; @group(0) @binding(3) var<storage, read_write> y_out : array<f32>; @group(0) @binding(4) var<uniform> uGrid: GridSize; @group(0) @binding(5) var<uniform> uMouse: Mouse; @group(0) @binding(6) var<uniform> uForce : f32; @group(0) @binding(7) var<uniform> uRadius : f32; @group(0) @binding(8) var<uniform> uDiffusion : f32; @group(0) @binding(9) var<uniform> uDt : f32; @group(0) @binding(10) var<uniform> uTime : f32; @group(0) @binding(11) var<uniform> uSymmetry : f32; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.w); } fn inBetween(x : f32, lower : f32, upper : f32) -> bool { return x > lower && x < upper; } fn inBounds(pos : vec2<f32>, xMin : f32, xMax : f32, yMin: f32, yMax : f32) -> bool { return inBetween(pos.x, xMin * uGrid.w, xMax * uGrid.w) && inBetween(pos.y, yMin * uGrid.h, yMax * uGrid.h); } fn createSplat(pos : vec2<f32>, splatPos : vec2<f32>, vel : vec2<f32>, radius : f32) -> vec2<f32> { var p = pos - splatPos; p.x *= uGrid.w / uGrid.h; var v = vel; v.x *= uGrid.w / uGrid.h; var splat = exp(-dot(p, p) / radius) * v; return splat; } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START} let tmpT = uTime; var p = pos/vec2(uGrid.w, uGrid.h); ${SPLAT_CODE} splat *= uForce * uDt * 200.; x_out[index] = x_in[index]*uDiffusion + splat.x; y_out[index] = y_in[index]*uDiffusion + splat.y; }`; const updateDyeShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} struct Mouse { pos: vec2<f32>, vel: vec2<f32>, } @group(0) @binding(0) var<storage, read> x_in : array<f32>; @group(0) @binding(1) var<storage, read> y_in : array<f32>; @group(0) @binding(2) var<storage, read> z_in : array<f32>; @group(0) @binding(3) var<storage, read_write> x_out : array<f32>; @group(0) @binding(4) var<storage, read_write> y_out : array<f32>; @group(0) @binding(5) var<storage, read_write> z_out : array<f32>; @group(0) @binding(6) var<uniform> uGrid: GridSize; @group(0) @binding(7) var<uniform> uMouse: Mouse; @group(0) @binding(8) var<uniform> uForce : f32; @group(0) @binding(9) var<uniform> uRadius : f32; @group(0) @binding(10) var<uniform> uDiffusion : f32; @group(0) @binding(11) var<uniform> uTime : f32; @group(0) @binding(12) var<uniform> uDt : f32; @group(0) @binding(13) var<uniform> uSymmetry : f32; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.dyeW); } fn inBetween(x : f32, lower : f32, upper : f32) -> bool { return x > lower && x < upper; } fn inBounds(pos : vec2<f32>, xMin : f32, xMax : f32, yMin: f32, yMax : f32) -> bool { return inBetween(pos.x, xMin * uGrid.dyeW, xMax * uGrid.dyeW) && inBetween(pos.y, yMin * uGrid.dyeH, yMax * uGrid.dyeH); } // cosine based palette, 4 vec3 params fn palette(t : f32, a : vec3<f32>, b : vec3<f32>, c : vec3<f32>, d : vec3<f32> ) -> vec3<f32> { return a + b*cos( 6.28318*(c*t+d) ); } fn createSplat(pos : vec2<f32>, splatPos : vec2<f32>, vel : vec2<f32>, radius : f32) -> vec3<f32> { var p = pos - splatPos; p.x *= uGrid.w / uGrid.h; var v = vel; v.x *= uGrid.w / uGrid.h; var splat = exp(-dot(p, p) / radius) * length(v); return vec3(splat); } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START_DYE} let col_incr = 0.15; let col_start = palette(uTime/8., vec3(1), vec3(0.5), vec3(1), vec3(0, col_incr, col_incr*2.)); var p = pos/vec2(uGrid.dyeW, uGrid.dyeH); ${SPLAT_CODE} splat *= col_start * uForce * uDt * 100.; x_out[index] = max(0., x_in[index]*uDiffusion + splat.x); y_out[index] = max(0., y_in[index]*uDiffusion + splat.y); z_out[index] = max(0., z_in[index]*uDiffusion + splat.z); }`; /// ADVECT SHADER /// const advectShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} @group(0) @binding(0) var<storage, read> x_in : array<f32>; @group(0) @binding(1) var<storage, read> y_in : array<f32>; @group(0) @binding(2) var<storage, read> x_vel : array<f32>; @group(0) @binding(3) var<storage, read> y_vel : array<f32>; @group(0) @binding(4) var<storage, read_write> x_out : array<f32>; @group(0) @binding(5) var<storage, read_write> y_out : array<f32>; @group(0) @binding(6) var<uniform> uGrid : GridSize; @group(0) @binding(7) var<uniform> uDt : f32; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.w); } fn in(x : f32, y : f32) -> vec2<f32> { let id = ID(x, y); return vec2(x_in[id], y_in[id]); } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START} var x = pos.x - uDt * uGrid.rdx * x_vel[index]; var y = pos.y - uDt * uGrid.rdx * y_vel[index]; if (x < 0) { x = 0; } else if (x >= uGrid.w - 1) { x = uGrid.w - 1; } if (y < 0) { y = 0; } else if (y >= uGrid.h - 1) { y = uGrid.h - 1; } let x1 = floor(x); let y1 = floor(y); let x2 = x1 + 1; let y2 = y1 + 1; let TL = in(x1, y2); let TR = in(x2, y2); let BL = in(x1, y1); let BR = in(x2, y1); let xMod = fract(x); let yMod = fract(y); let bilerp = mix( mix(BL, BR, xMod), mix(TL, TR, xMod), yMod ); x_out[index] = bilerp.x; y_out[index] = bilerp.y; }`; const advectDyeShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} @group(0) @binding(0) var<storage, read> x_in : array<f32>; @group(0) @binding(1) var<storage, read> y_in : array<f32>; @group(0) @binding(2) var<storage, read> z_in : array<f32>; @group(0) @binding(3) var<storage, read> x_vel : array<f32>; @group(0) @binding(4) var<storage, read> y_vel : array<f32>; @group(0) @binding(5) var<storage, read_write> x_out : array<f32>; @group(0) @binding(6) var<storage, read_write> y_out : array<f32>; @group(0) @binding(7) var<storage, read_write> z_out : array<f32>; @group(0) @binding(8) var<uniform> uGrid : GridSize; @group(0) @binding(9) var<uniform> uDt : f32; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.dyeW); } fn in(x : f32, y : f32) -> vec3<f32> { let id = ID(x, y); return vec3(x_in[id], y_in[id], z_in[id]); } fn vel(x : f32, y : f32) -> vec2<f32> { let id = u32(i32(x) + i32(y) * i32(uGrid.w)); return vec2(x_vel[id], y_vel[id]); } fn vel_bilerp(x0 : f32, y0 : f32) -> vec2<f32> { var x = x0 * uGrid.w / uGrid.dyeW; var y = y0 * uGrid.h / uGrid.dyeH; if (x < 0) { x = 0; } else if (x >= uGrid.w - 1) { x = uGrid.w - 1; } if (y < 0) { y = 0; } else if (y >= uGrid.h - 1) { y = uGrid.h - 1; } let x1 = floor(x); let y1 = floor(y); let x2 = x1 + 1; let y2 = y1 + 1; let TL = vel(x1, y2); let TR = vel(x2, y2); let BL = vel(x1, y1); let BR = vel(x2, y1); let xMod = fract(x); let yMod = fract(y); return mix( mix(BL, BR, xMod), mix(TL, TR, xMod), yMod ); } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START_DYE} let V = vel_bilerp(pos.x, pos.y); var x = pos.x - uDt * uGrid.dyeRdx * V.x; var y = pos.y - uDt * uGrid.dyeRdx * V.y; if (x < 0) { x = 0; } else if (x >= uGrid.dyeW - 1) { x = uGrid.dyeW - 1; } if (y < 0) { y = 0; } else if (y >= uGrid.dyeH - 1) { y = uGrid.dyeH - 1; } let x1 = floor(x); let y1 = floor(y); let x2 = x1 + 1; let y2 = y1 + 1; let TL = in(x1, y2); let TR = in(x2, y2); let BL = in(x1, y1); let BR = in(x2, y1); let xMod = fract(x); let yMod = fract(y); let bilerp = mix( mix(BL, BR, xMod), mix(TL, TR, xMod), yMod ); x_out[index] = bilerp.x; y_out[index] = bilerp.y; z_out[index] = bilerp.z; }`; /// DIVERGENCE SHADER /// const divergenceShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} @group(0) @binding(0) var<storage, read> x_vel : array<f32>; @group(0) @binding(1) var<storage, read> y_vel : array<f32>; @group(0) @binding(2) var<storage, read_write> div : array<f32>; @group(0) @binding(3) var<uniform> uGrid : GridSize; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.w); } fn vel(x : f32, y : f32) -> vec2<f32> { let id = ID(x, y); return vec2(x_vel[id], y_vel[id]); } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START} let L = vel(pos.x - 1, pos.y).x; let R = vel(pos.x + 1, pos.y).x; let B = vel(pos.x, pos.y - 1).y; let T = vel(pos.x, pos.y + 1).y; div[index] = 0.5 * uGrid.rdx * ((R - L) + (T - B)); }`; /// PRESSURE SHADER /// const pressureShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} @group(0) @binding(0) var<storage, read> pres_in : array<f32>; @group(0) @binding(1) var<storage, read> div : array<f32>; @group(0) @binding(2) var<storage, read_write> pres_out : array<f32>; @group(0) @binding(3) var<uniform> uGrid : GridSize; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.w); } fn in(x : f32, y : f32) -> f32 { let id = ID(x, y); return pres_in[id]; } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START} let L = pos - vec2(1, 0); let R = pos + vec2(1, 0); let B = pos - vec2(0, 1); let T = pos + vec2(0, 1); let Lx = in(L.x, L.y); let Rx = in(R.x, R.y); let Bx = in(B.x, B.y); let Tx = in(T.x, T.y); let bC = div[index]; let alpha = -(uGrid.dx * uGrid.dx); let rBeta = .25; pres_out[index] = (Lx + Rx + Bx + Tx + alpha * bC) * rBeta; }`; /// GRADIENT SUBTRACT SHADER /// const gradientSubtractShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} @group(0) @binding(0) var<storage, read> pressure : array<f32>; @group(0) @binding(1) var<storage, read> x_vel : array<f32>; @group(0) @binding(2) var<storage, read> y_vel : array<f32>; @group(0) @binding(3) var<storage, read_write> x_out : array<f32>; @group(0) @binding(4) var<storage, read_write> y_out : array<f32>; @group(0) @binding(5) var<uniform> uGrid : GridSize; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.w); } fn pres(x : f32, y : f32) -> f32 { let id = ID(x, y); return pressure[id]; } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START} let L = pos - vec2(1, 0); let R = pos + vec2(1, 0); let B = pos - vec2(0, 1); let T = pos + vec2(0, 1); let xL = pres(L.x, L.y); let xR = pres(R.x, R.y); let yB = pres(B.x, B.y); let yT = pres(T.x, T.y); let finalX = x_vel[index] - .5 * uGrid.rdx * (xR - xL); let finalY = y_vel[index] - .5 * uGrid.rdx * (yT - yB); x_out[index] = finalX; y_out[index] = finalY; }`; /// VORTICITY SHADER /// const vorticityShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} @group(0) @binding(0) var<storage, read> x_vel : array<f32>; @group(0) @binding(1) var<storage, read> y_vel : array<f32>; @group(0) @binding(2) var<storage, read_write> vorticity : array<f32>; @group(0) @binding(3) var<uniform> uGrid : GridSize; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.w); } fn vel(x : f32, y : f32) -> vec2<f32> { let id = ID(x, y); return vec2(x_vel[id], y_vel[id]); } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START} let Ly = vel(pos.x - 1, pos.y).y; let Ry = vel(pos.x + 1, pos.y).y; let Bx = vel(pos.x, pos.y - 1).x; let Tx = vel(pos.x, pos.y + 1).x; vorticity[index] = 0.5 * uGrid.rdx * ((Ry - Ly) - (Tx - Bx)); }`; /// VORTICITY CONFINMENT SHADER /// const vorticityConfinmentShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} @group(0) @binding(0) var<storage, read> x_vel_in : array<f32>; @group(0) @binding(1) var<storage, read> y_vel_in : array<f32>; @group(0) @binding(2) var<storage, read> vorticity : array<f32>; @group(0) @binding(3) var<storage, read_write> x_vel_out : array<f32>; @group(0) @binding(4) var<storage, read_write> y_vel_out : array<f32>; @group(0) @binding(5) var<uniform> uGrid : GridSize; @group(0) @binding(6) var<uniform> uDt : f32; @group(0) @binding(7) var<uniform> uVorticity : f32; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.w); } fn vort(x : f32, y : f32) -> f32 { let id = ID(x, y); return vorticity[id]; } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START} let L = vort(pos.x - 1, pos.y); let R = vort(pos.x + 1, pos.y); let B = vort(pos.x, pos.y - 1); let T = vort(pos.x, pos.y + 1); let C = vorticity[index]; var force = 0.5 * uGrid.rdx * vec2(abs(T) - abs(B), abs(R) - abs(L)); let epsilon = 2.4414e-4; let magSqr = max(epsilon, dot(force, force)); force = force / sqrt(magSqr); force *= uGrid.dx * uVorticity * uDt * C * vec2(1, -1); x_vel_out[index] = x_vel_in[index] + force.x; y_vel_out[index] = y_vel_in[index] + force.y; }`; /// CLEAR PRESSURE SHADER /// const clearPressureShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} @group(0) @binding(0) var<storage, read> x_in : array<f32>; @group(0) @binding(1) var<storage, read_write> x_out : array<f32>; @group(0) @binding(2) var<uniform> uGrid : GridSize; @group(0) @binding(3) var<uniform> uVisc : f32; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.w); } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START_ALL} x_out[index] = x_in[index]*uVisc; }`; /// BOUNDARY SHADER /// const boundaryShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} @group(0) @binding(0) var<storage, read> x_in : array<f32>; @group(0) @binding(1) var<storage, read> y_in : array<f32>; @group(0) @binding(2) var<storage, read_write> x_out : array<f32>; @group(0) @binding(3) var<storage, read_write> y_out : array<f32>; @group(0) @binding(4) var<uniform> uGrid : GridSize; @group(0) @binding(5) var<uniform> containFluid : f32; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.w); } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START_ALL} // disable scale to disable contained bounds var scaleX = 1.; var scaleY = 1.; if (pos.x == 0) { pos.x += 1; scaleX = -1.; } else if (pos.x == uGrid.w - 1) { pos.x -= 1; scaleX = -1.; } if (pos.y == 0) { pos.y += 1; scaleY = -1.; } else if (pos.y == uGrid.h - 1) { pos.y -= 1; scaleY = -1.; } if (containFluid == 0.) { scaleX = 1.; scaleY = 1.; } x_out[index] = x_in[ID(pos.x, pos.y)] * scaleX; y_out[index] = y_in[ID(pos.x, pos.y)] * scaleY; }`; /// BOUNDARY PRESSURE SHADER /// const boundaryPressureShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} @group(0) @binding(0) var<storage, read> x_in : array<f32>; @group(0) @binding(1) var<storage, read_write> x_out : array<f32>; @group(0) @binding(2) var<uniform> uGrid : GridSize; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.w); } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START_ALL} if (pos.x == 0) { pos.x += 1; } else if (pos.x == uGrid.w - 1) { pos.x -= 1; } if (pos.y == 0) { pos.y += 1; } else if (pos.y == uGrid.h - 1) { pos.y -= 1; } x_out[index] = x_in[ID(pos.x, pos.y)]; }`; const checkerboardShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} @group(0) @binding(0) var<storage, read_write> x_out : array<f32>; @group(0) @binding(1) var<storage, read_write> y_out : array<f32>; @group(0) @binding(2) var<storage, read_write> z_out : array<f32>; @group(0) @binding(3) var<uniform> uGrid : GridSize; @group(0) @binding(4) var<uniform> uTime : f32; fn ID(x : f32, y : f32) -> u32 { return u32(x + y * uGrid.dyeW); } fn noise(p_ : vec3<f32>) -> f32 { var p = p_; \tvar ip=floor(p); p-=ip; var s=vec3(7.,157.,113.); var h=vec4(0.,s.y, s.z,s.y+s.z)+dot(ip,s); p=p*p*(3. - 2.*p); h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x); var r=mix(h.xz,h.yw,p.y); h.x = r.x; h.y = r.y; return mix(h.x,h.y,p.z); } fn fbm(p_ : vec3<f32>, octaveNum : i32) -> vec2<f32> { var p=p_; \tvar acc = vec2(0.);\t \tvar freq = 1.0; \tvar amp = 0.5; var shift = vec3(100.); \tfor (var i = 0; i < octaveNum; i++) { \t\tacc += vec2(noise(p), noise(p + vec3(0.,0.,10.))) * amp; p = p * 2.0 + shift; amp *= 0.5; \t} \treturn acc; } @compute @workgroup_size(8, 8) fn main(@builtin(global_invocation_id) global_id : vec3<u32>) { ${COMPUTE_START_DYE} var uv = pos/vec2(uGrid.dyeW, uGrid.dyeH); var zoom = 4.; var smallNoise = fbm(vec3(uv.x*zoom*2., uv.y*zoom*2., uTime+2.145), 7) - .5; var bigNoise = fbm(vec3(uv.x*zoom, uv.y*zoom, uTime*.1+30.), 7) - .5; var noise = max(length(bigNoise) * 0.035, 0.); var noise2 = max(length(smallNoise) * 0.035, 0.); noise = noise + noise2 * .05; var czoom = 4.; var n = fbm(vec3(uv.x*czoom, uv.y*czoom, uTime*.1+63.1), 7)*.75+.25; var n2 = fbm(vec3(uv.x*czoom, uv.y*czoom, uTime*.1+23.4), 7)*.75+.25; var col = vec3(1.); x_out[index] += noise * col.x; y_out[index] += noise * col.y; z_out[index] += noise * col.z; }`; /*render*/ const renderShader = /* wgsl */ ` ${STRUCT_GRID_SIZE} struct VertexOut { @builtin(position) position : vec4<f32>, @location(1) uv : vec2<f32>, }; @group(0) @binding(0) var<storage, read> fieldX : array<f32>; @group(0) @binding(1) var<storage, read> fieldY : array<f32>; @group(0) @binding(2) var<storage, read> fieldZ : array<f32>; @group(0) @binding(3) var<uniform> uGrid : GridSize; @group(0) @binding(4) var<uniform> multiplier : f32; @vertex fn vertex_main(@location(0) position: vec4<f32>) -> VertexOut { var output : VertexOut; output.position = position; output.uv = position.xy*.5+.5; return output; } @fragment fn fragment_main(fragData : VertexOut) -> @location(0) vec4<f32> { var w = uGrid.dyeW; var h = uGrid.dyeH; let fuv = vec2<f32>((floor(fragData.uv*vec2(w, h)))); let id = u32(fuv.x + fuv.y * w); let r = fieldX[id]; let g = fieldY[id]; let b = fieldZ[id]; let col = vec3(r, g, b); let alpha = clamp(length(col), 0.0, 1.0); return vec4(col * multiplier, alpha); } `; // Renders 3 (r, g, b) storage buffers to the canvas class RenderProgram { constructor() { const vertices = new Float32Array([ -1, -1, 0, 1, -1, 1, 0, 1, 1, -1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, 1, 1, 0, 1 ]); this.vertexBuffer = device.createBuffer({ size: vertices.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, mappedAtCreation: true }); new Float32Array(this.vertexBuffer.getMappedRange()).set(vertices); this.vertexBuffer.unmap(); const vertexBuffersDescriptors = [ { attributes: [ { shaderLocation: 0, offset: 0, format: \"float32x4\" } ], arrayStride: 16, stepMode: \"vertex\" } ]; const shaderModule = device.createShaderModule({ code: renderShader }); this.renderPipeline = device.createRenderPipeline({ layout: \"auto\", vertex: { module: shaderModule, entryPoint: \"vertex_main\", buffers: vertexBuffersDescriptors }, fragment: { module: shaderModule, entryPoint: \"fragment_main\", targets: [ { format: presentationFormat } ] }, primitive: { topology: \"triangle-list\" } }); // The r,g,b buffer containing the data to render this.buffer = new DynamicBuffer({ dims: 3, w: settings.dye_w, h: settings.dye_h }); // Uniforms const entries = [ ...this.buffer.buffers, globalUniforms.gridSize.buffer, globalUniforms.render_intensity_multiplier.buffer ].map((b, i) => ({ binding: i, resource: { buffer: b } })); this.renderBindGroup = device.createBindGroup({ layout: this.renderPipeline.getBindGroupLayout(0), entries }); this.renderPassDescriptor = { colorAttachments: [ { clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 0.0 }, loadOp: \"clear\", storeOp: \"store\" } ] }; } // Dispatch a draw command to render on the canvas dispatch(commandEncoder) { this.renderPassDescriptor.colorAttachments[0].view = context .getCurrentTexture() .createView(); const renderPassEncoder = commandEncoder.beginRenderPass( this.renderPassDescriptor ); renderPassEncoder.setPipeline(this.renderPipeline); renderPassEncoder.setBindGroup(0, this.renderBindGroup); renderPassEncoder.setVertexBuffer(0, this.vertexBuffer); renderPassEncoder.draw(6); renderPassEncoder.end(); } } /*utils*/ // Creates and manage multi-dimensional buffers by creating a buffer for each dimension class DynamicBuffer { constructor({ dims = 1, // Number of dimensions w = settings.grid_w, // Buffer width h = settings.grid_h // Buffer height } = {}) { this.dims = dims; this.bufferSize = w * h * 4; this.w = w; this.h = h; this.buffers = new Array(dims).fill().map((_) => device.createBuffer({ size: this.bufferSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST }) ); } // Copy each buffer to another DynamicBuffer's buffers. // If the dimensions don't match, the last non-empty dimension will be copied instead copyTo(buffer, commandEncoder) { for (let i = 0; i < Math.max(this.dims, buffer.dims); i++) { commandEncoder.copyBufferToBuffer( this.buffers[Math.min(i, this.buffers.length - 1)], 0, buffer.buffers[Math.min(i, buffer.buffers.length - 1)], 0, this.bufferSize ); } } // Reset all the buffers clear(queue) { for (let i = 0; i < this.dims; i++) { queue.writeBuffer(this.buffers[i], 0, new Float32Array(this.w * this.h)); } } } // Manage uniform buffers relative to the compute shaders class Uniform { constructor(name, { size, value } = {}) { this.name = name; this.size = size ?? (value && typeof value === \"object\" ? value.length : 1); this.needsUpdate = false; if (this.size === 1) { if (settings[name] == null) { settings[name] = value ?? 0; this.alwaysUpdate = true; } } if (this.size === 1 || value != null) { this.buffer = device.createBuffer({ mappedAtCreation: true, size: this.size * 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }); const arrayBuffer = this.buffer.getMappedRange(); const sourceValue = value ?? [settings[this.name]]; const sourceArray = typeof sourceValue === \"number\" ? [sourceValue] : Array.isArray(sourceValue) ? sourceValue : [0]; // Default to [0] if value is invalid new Float32Array(arrayBuffer).set(new Float32Array(sourceArray)); this.buffer.unmap(); } else { this.buffer = device.createBuffer({ size: this.size * 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }); } globalUniforms[name] = this; } setValue(value) { settings[this.name] = value; this.needsUpdate = true; } update(queue, value) { if (this.needsUpdate || this.alwaysUpdate || value != null) { if (typeof this.needsUpdate !== \"boolean\") value = this.needsUpdate; queue.writeBuffer( this.buffer, 0, new Float32Array(value ?? [parseFloat(settings[this.name])]), 0, this.size ); this.needsUpdate = false; } } } // Creates a shader module, compute pipeline & bind group to use with the GPU class Program { constructor({ buffers = [], // Storage buffers uniforms = [], // Uniform buffers shader, // WGSL Compute Shader as a string dispatchX = settings.grid_w, // Dispatch workers width dispatchY = settings.grid_h // Dispatch workers height }) { this.computePipeline = device.createComputePipeline({ layout: \"auto\", compute: { module: device.createShaderModule({ code: shader }), entryPoint: \"main\" } }); const storageEntries = buffers.map((b) => b.buffers).flat(); const uniformEntries = uniforms .filter((u) => u && u.buffer) .map((u) => u.buffer); const allEntries = [...storageEntries, ...uniformEntries].map( (buffer, i) => ({ binding: i, resource: { buffer } }) ); this.bindGroup = device.createBindGroup({ layout: this.computePipeline.getBindGroupLayout(0), entries: allEntries }); this.dispatchX = dispatchX; this.dispatchY = dispatchY; } dispatch(passEncoder) { passEncoder.setPipeline(this.computePipeline); passEncoder.setBindGroup(0, this.bindGroup); passEncoder.dispatchWorkgroups( Math.ceil(this.dispatchX / 8), Math.ceil(this.dispatchY / 8) ); } } /// Useful classes for cleaner understanding of the input and output buffers /// used in the declarations of programs & fluid simulation steps class AdvectProgram extends Program { constructor({ in_quantity, in_velocity, out_quantity, uniforms, shader = advectShader, ...props }) { uniforms ??= [globalUniforms.gridSize]; super({ buffers: [in_quantity, in_velocity, out_quantity], uniforms, shader, ...props }); } } class DivergenceProgram extends Program { constructor({ in_velocity, out_divergence, uniforms, shader = divergenceShader }) { uniforms ??= [globalUniforms.gridSize]; super({ buffers: [in_velocity, out_divergence], uniforms, shader }); } } class PressureProgram extends Program { constructor({ in_pressure, in_divergence, out_pressure, uniforms, shader = pressureShader }) { uniforms ??= [globalUniforms.gridSize]; super({ buffers: [in_pressure, in_divergence, out_pressure], uniforms, shader }); } } class GradientSubtractProgram extends Program { constructor({ in_pressure, in_velocity, out_velocity, uniforms, shader = gradientSubtractShader }) { uniforms ??= [globalUniforms.gridSize]; super({ buffers: [in_pressure, in_velocity, out_velocity], uniforms, shader }); } } class BoundaryProgram extends Program { constructor({ in_quantity, out_quantity, uniforms, shader = boundaryShader }) { uniforms ??= [globalUniforms.gridSize]; super({ buffers: [in_quantity, out_quantity], uniforms, shader }); } } class UpdateProgram extends Program { constructor({ in_quantity, out_quantity, uniforms, shader = updateVelocityShader, ...props }) { uniforms ??= [globalUniforms.gridSize]; super({ buffers: [in_quantity, out_quantity], uniforms, shader, ...props }); } } class VorticityProgram extends Program { constructor({ in_velocity, out_vorticity, uniforms, shader = vorticityShader, ...props }) { uniforms ??= [globalUniforms.gridSize]; super({ buffers: [in_velocity, out_vorticity], uniforms, shader, ...props }); } } class VorticityConfinmentProgram extends Program { constructor({ in_velocity, in_vorticity, out_velocity, uniforms, shader = vorticityConfinmentShader, ...props }) { uniforms ??= [globalUniforms.gridSize]; super({ buffers: [in_velocity, in_vorticity, out_velocity], uniforms, shader, ...props }); } } function initBuffers() { velocity = new DynamicBuffer({ dims: 2 }); velocity0 = new DynamicBuffer({ dims: 2 }); dye = new DynamicBuffer({ dims: 3, w: settings.dye_w, h: settings.dye_h }); dye0 = new DynamicBuffer({ dims: 3, w: settings.dye_w, h: settings.dye_h }); divergence = new DynamicBuffer(); divergence0 = new DynamicBuffer(); pressure = new DynamicBuffer(); pressure0 = new DynamicBuffer(); vorticity = new DynamicBuffer(); } function initUniforms() { time = new Uniform(\"time\"); dt = new Uniform(\"dt\"); mouse = new Uniform(\"mouseInfos\", { size: 4 }); grid = new Uniform(\"gridSize\", { size: 7, value: [ settings.grid_w, settings.grid_h, settings.dye_w, settings.dye_h, settings.dx, settings.rdx, settings.dyeRdx ] }); uSimSpeed = new Uniform(\"sim_speed\", { value: settings.sim_speed }); vel_force = new Uniform(\"velocity_add_intensity\", { value: settings.velocity_add_intensity }); vel_radius = new Uniform(\"velocity_add_radius\", { value: settings.velocity_add_radius }); vel_diff = new Uniform(\"velocity_diffusion\", { value: settings.velocity_diffusion }); dye_force = new Uniform(\"dye_add_intensity\", { value: settings.dye_add_intensity }); dye_radius = new Uniform(\"dye_add_radius\", { value: settings.dye_add_radius }); dye_diff = new Uniform(\"dye_diffusion\", { value: settings.dye_diffusion }); viscosity = new Uniform(\"viscosity\", { value: settings.viscosity }); uVorticity = new Uniform(\"vorticity\", { value: settings.vorticity }); containFluid = new Uniform(\"contain_fluid\", { value: settings.contain_fluid }); uSymmetry = new Uniform(\"mouse_type\", { value: 0 }); uRenderIntensity = new Uniform(\"render_intensity_multiplier\", { value: 1 }); } function initPrograms() { checkerProgram = new Program({ buffers: [dye], shader: checkerboardShader, dispatchX: settings.dye_w, dispatchY: settings.dye_h, uniforms: [grid, time] }); updateDyeProgram = new UpdateProgram({ in_quantity: dye, out_quantity: dye0, uniforms: [ grid, mouse, dye_force, dye_radius, dye_diff, time, dt, uSymmetry ], dispatchX: settings.dye_w, dispatchY: settings.dye_h, shader: updateDyeShader }); updateProgram = new UpdateProgram({ in_quantity: velocity, out_quantity: velocity0, uniforms: [ grid, mouse, vel_force, vel_radius, vel_diff, dt, time, uSymmetry ] }); advectProgram = new AdvectProgram({ in_quantity: velocity0, in_velocity: velocity0, out_quantity: velocity, uniforms: [grid, dt] }); boundaryProgram = new BoundaryProgram({ in_quantity: velocity, out_quantity: velocity0, uniforms: [grid, containFluid] }); divergenceProgram = new DivergenceProgram({ in_velocity: velocity0, out_divergence: divergence0 }); boundaryDivProgram = new BoundaryProgram({ in_quantity: divergence0, out_quantity: divergence, shader: boundaryPressureShader }); pressureProgram = new PressureProgram({ in_pressure: pressure, in_divergence: divergence, out_pressure: pressure0 }); boundaryPressureProgram = new BoundaryProgram({ in_quantity: pressure0, out_quantity: pressure, shader: boundaryPressureShader }); gradientSubtractProgram = new GradientSubtractProgram({ in_pressure: pressure, in_velocity: velocity0, out_velocity: velocity }); advectDyeProgram = new AdvectProgram({ in_quantity: dye0, in_velocity: velocity, out_quantity: dye, uniforms: [grid, dt], dispatchX: settings.dye_w, dispatchY: settings.dye_h, shader: advectDyeShader }); clearPressureProgram = new UpdateProgram({ in_quantity: pressure, out_quantity: pressure0, uniforms: [grid, viscosity], shader: clearPressureShader }); vorticityProgram = new VorticityProgram({ in_velocity: velocity, out_vorticity: vorticity }); vorticityConfinmentProgram = new VorticityConfinmentProgram({ in_velocity: velocity, in_vorticity: vorticity, out_velocity: velocity0, uniforms: [grid, dt, uVorticity] }); renderProgram = new RenderProgram(); } async function main() { // Init WebGPU Context const initializationSuccess = await initContext(); if (!initializationSuccess) return; // Init buffers, uniforms and programs initBuffers(); initUniforms(); initPrograms(); // Simulation reset function reset() { velocity.clear(device.queue); dye.clear(device.queue); pressure.clear(device.queue); settings.time = 0; } settings.reset = reset; // Fluid simulation step function dispatchComputePipeline(passEncoder) { // Add velocity and dye at the mouse position updateDyeProgram.dispatch(passEncoder); updateProgram.dispatch(passEncoder); // Advect the velocity field through itself advectProgram.dispatch(passEncoder); boundaryProgram.dispatch(passEncoder); // boundary conditions // Compute the divergence divergenceProgram.dispatch(passEncoder); boundaryDivProgram.dispatch(passEncoder); // boundary conditions // Solve the jacobi-pressure equation for (let i = 0; i < settings.pressure_iterations; i++) { pressureProgram.dispatch(passEncoder); boundaryPressureProgram.dispatch(passEncoder); // boundary conditions } // Subtract the pressure from the velocity field gradientSubtractProgram.dispatch(passEncoder); clearPressureProgram.dispatch(passEncoder); // Compute & apply vorticity confinment vorticityProgram.dispatch(passEncoder); vorticityConfinmentProgram.dispatch(passEncoder); // Advect the dye through the velocity field advectDyeProgram.dispatch(passEncoder); } let lastFrame = performance.now(); // Render loop async function step() { requestAnimationFrame(step); // Update time const now = performance.now(); settings.dt = Math.min(1 / 60, (now - lastFrame) / 1000) * settings.sim_speed; settings.time += settings.dt; lastFrame = now; // Update uniforms Object.values(globalUniforms).forEach((u) => u.update(device.queue)); // Update custom uniform if (mouseInfos.current) { let dx = mouseInfos.last ? mouseInfos.current[0] - mouseInfos.last[0] : 0; let dy = mouseInfos.last ? mouseInfos.current[1] - mouseInfos.last[1] : 0; const isMobile = \"ontouchstart\" in window || navigator.maxTouchPoints > 0; if (isMobile) { const touchStrengthMultiplier = 0.2; dx *= touchStrengthMultiplier; dy *= touchStrengthMultiplier; } mouseInfos.velocity = [dx, dy]; mouse.update(device.queue, [ ...mouseInfos.current, ...mouseInfos.velocity ]); mouseInfos.last = [...mouseInfos.current]; } // Compute fluid const commandEncoder = device.createCommandEncoder(); const passEncoder = commandEncoder.beginComputePass(); dispatchComputePipeline(passEncoder); passEncoder.end(); velocity0.copyTo(velocity, commandEncoder); pressure0.copyTo(pressure, commandEncoder); dye.copyTo(renderProgram.buffer, commandEncoder); // Draw fluid renderProgram.dispatch(commandEncoder); // Send commands to the GPU const gpuCommands = commandEncoder.finish(); device.queue.submit([gpuCommands]); } step(); } main();",
    "id": "fluid-motion-webgpu-version"
  },
  {
    "title": "Interactive Liquid Gradient using Three.js",
    "description": "",
    "code": "index.html: <head> <meta charset=\"UTF-8\"> <title>Interactive Liquid Gradient</title> <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"> <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin> <link href=\"https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=Syne:wght@400;500;600;700;800&family=Inter:wght@300;400;500;600;700;800&family=Bebas+Neue&family=Montserrat:wght@400;500;600;700;800&display=swap\" rel=\"stylesheet\"> </head> <body> <!-- Heading: Syne (Modern, Geometric) --> <h1 class=\"heading option1\">Liquid Gradient</h1> <!-- Color Scheme Controls --> <div class=\"color-controls\"> <button class=\"color-btn active\" data-scheme=\"1\">Scheme 1</button> <button class=\"color-btn\" data-scheme=\"2\">Scheme 2</button> <button class=\"color-btn\" data-scheme=\"3\">Scheme 3</button> <button class=\"color-btn\" data-scheme=\"4\">Scheme 4</button> <button class=\"color-btn\" data-scheme=\"5\">Scheme 5</button> </div> <!-- Color Adjuster Toggle Button --> <button class=\"toggle-adjuster-btn\" id=\"toggleAdjusterBtn\">Adjust Colors</button> <!-- Color Adjuster Panel --> <div class=\"color-adjuster-panel\" id=\"colorAdjusterPanel\"> <div class=\"color-adjuster-header\"> <h3 class=\"color-adjuster-title\">Color Adjuster</h3> <button class=\"color-adjuster-close\" id=\"closeAdjusterBtn\"></button> </div> <div class=\"color-picker-group\"> <div class=\"color-picker-label\"> <span>Color 1</span> </div> <div class=\"color-picker-wrapper\"> <input type=\"color\" class=\"color-picker-input\" id=\"colorPicker1\" data-color=\"1\"> <input type=\"text\" class=\"color-value-display\" id=\"colorValue1\" readonly> <button class=\"copy-btn\" data-copy=\"1\">Copy</button> </div> </div> <div class=\"color-picker-group\"> <div class=\"color-picker-label\"> <span>Color 2</span> </div> <div class=\"color-picker-wrapper\"> <input type=\"color\" class=\"color-picker-input\" id=\"colorPicker2\" data-color=\"2\"> <input type=\"text\" class=\"color-value-display\" id=\"colorValue2\" readonly> <button class=\"copy-btn\" data-copy=\"2\">Copy</button> </div> </div> <div class=\"color-picker-group\"> <div class=\"color-picker-label\"> <span>Color 3</span> </div> <div class=\"color-picker-wrapper\"> <input type=\"color\" class=\"color-picker-input\" id=\"colorPicker3\" data-color=\"3\"> <input type=\"text\" class=\"color-value-display\" id=\"colorValue3\" readonly> <button class=\"copy-btn\" data-copy=\"3\">Copy</button> </div> </div> <div class=\"color-picker-group\"> <div class=\"color-picker-label\"> <span>Color 4</span> </div> <div class=\"color-picker-wrapper\"> <input type=\"color\" class=\"color-picker-input\" id=\"colorPicker4\" data-color=\"4\"> <input type=\"text\" class=\"color-value-display\" id=\"colorValue4\" readonly> <button class=\"copy-btn\" data-copy=\"4\">Copy</button> </div> </div> <div class=\"color-picker-group\"> <div class=\"color-picker-label\"> <span>Color 5</span> </div> <div class=\"color-picker-wrapper\"> <input type=\"color\" class=\"color-picker-input\" id=\"colorPicker5\" data-color=\"5\"> <input type=\"text\" class=\"color-value-display\" id=\"colorValue5\" readonly> <button class=\"copy-btn\" data-copy=\"5\">Copy</button> </div> </div> <div class=\"color-picker-group\"> <div class=\"color-picker-label\"> <span>Color 6</span> </div> <div class=\"color-picker-wrapper\"> <input type=\"color\" class=\"color-picker-input\" id=\"colorPicker6\" data-color=\"6\"> <input type=\"text\" class=\"color-value-display\" id=\"colorValue6\" readonly> <button class=\"copy-btn\" data-copy=\"6\">Copy</button> </div> </div> <div class=\"color-adjuster-actions\"> <button class=\"export-btn\" id=\"exportAllBtn\">Export All Colors</button> </div> </div> <footer class=\"footer\"> <a href=\"https://madebybeings.com\" target=\"_blank\" rel=\"noopener noreferrer\">Made By Beings</a> </footer> <div class=\"custom-cursor\" id=\"customCursor\"></div> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script> </body>\nstyle.css: * { margin: 0; padding: 0; box-sizing: border-box; } body { overflow: hidden; font-family: sans-serif; } #webGLApp { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; } .heading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; color: white; text-align: center; white-space: nowrap; pointer-events: none; text-wrap: auto; font-family: \"Syne\", sans-serif; font-size: clamp(3.5rem, 9vw, 9rem); font-weight: 700; letter-spacing: -0.02em; text-transform: none; line-height: 1; } /* Show all options in a grid for comparison */ .headings-container { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 4rem; width: 80vw; max-width: 1200px; pointer-events: none; } .color-controls { position: fixed; top: 2rem; right: 2rem; z-index: 10; display: flex; gap: 1rem; pointer-events: auto; } .color-btn { min-width: 48px; height: 48px; padding: 0.75rem 1.25rem; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 24px; color: white; font-family: \"Syne\", sans-serif; font-size: 0.75rem; font-weight: 500; letter-spacing: 0.05em; text-transform: uppercase; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); display: flex; align-items: center; justify-content: center; white-space: nowrap; } .color-btn:hover { background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.5); transform: translateY(-2px); } .color-btn.active { background: rgba(255, 255, 255, 0.25); border-color: rgba(255, 255, 255, 0.6); } /* Color Adjuster Panel */ .color-adjuster-panel { position: fixed; top: 2rem; left: 2rem; z-index: 100; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 16px; padding: 1.5rem; min-width: 320px; max-width: 400px; pointer-events: auto; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); transition: all 0.3s ease; display: none; } .color-adjuster-panel.open { display: block; } .color-adjuster-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1); } .color-adjuster-title { color: white; font-family: \"Syne\", sans-serif; font-size: 1rem; font-weight: 600; letter-spacing: 0.05em; text-transform: uppercase; } .color-adjuster-close { background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; transition: opacity 0.3s ease; } .color-adjuster-close:hover { opacity: 0.7; } .color-picker-group { margin-bottom: 1.25rem; } .color-picker-label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; color: white; font-family: \"Inter\", sans-serif; font-size: 0.875rem; font-weight: 500; } .color-picker-wrapper { display: flex; gap: 0.75rem; align-items: center; } .color-picker-input { width: 60px; height: 40px; border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 8px; cursor: pointer; background: none; padding: 0; -webkit-appearance: none; appearance: none; } .color-picker-input::-webkit-color-swatch-wrapper { padding: 0; } .color-picker-input::-webkit-color-swatch { border: none; border-radius: 6px; } .color-value-display { flex: 1; background: rgba(0, 0, 0, 0.2); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; padding: 0.5rem 0.75rem; color: white; font-family: \"Inter\", monospace; font-size: 0.75rem; font-weight: 500; letter-spacing: 0.05em; cursor: text; user-select: all; transition: all 0.3s ease; } .color-value-display:hover { background: rgba(0, 0, 0, 0.3); border-color: rgba(255, 255, 255, 0.4); } .color-value-display:focus { outline: none; background: rgba(0, 0, 0, 0.4); border-color: rgba(255, 255, 255, 0.5); } .copy-btn { background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 6px; padding: 0.5rem 0.75rem; color: white; font-family: \"Inter\", sans-serif; font-size: 0.75rem; font-weight: 500; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); } .copy-btn:hover { background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.5); } .copy-btn.copied { background: rgba(76, 175, 80, 0.3); border-color: rgba(76, 175, 80, 0.5); } .color-adjuster-actions { margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; gap: 0.75rem; } .export-btn { flex: 1; background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px; padding: 0.75rem; color: white; font-family: \"Syne\", sans-serif; font-size: 0.875rem; font-weight: 500; letter-spacing: 0.05em; text-transform: uppercase; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); } .export-btn:hover { background: rgba(255, 255, 255, 0.25); border-color: rgba(255, 255, 255, 0.5); transform: translateY(-2px); } .toggle-adjuster-btn { position: fixed; top: 2rem; left: 2rem; z-index: 100; padding: 0.75rem 1.5rem; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); color: white; font-family: \"Syne\", sans-serif; font-size: 0.875rem; font-weight: 500; letter-spacing: 0.05em; text-transform: uppercase; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px); border-radius: 8px; pointer-events: auto; } .toggle-adjuster-btn:hover { background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.5); transform: translateY(-2px); } .footer { position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%); z-index: 10; color: white; font-family: \"Syne\", sans-serif; font-size: clamp(0.875rem, 1.5vw, 1.125rem); font-weight: 500; letter-spacing: 0.05em; text-transform: uppercase; text-align: center; pointer-events: auto; } .footer a { color: white; text-decoration: none; transition: opacity 0.3s ease; } .footer a:hover { opacity: 0.7; } .custom-cursor { position: fixed; width: 40px; height: 40px; border: 2px solid white; border-radius: 50%; pointer-events: none; z-index: 1000; transform: translate(-50%, -50%); transition: width 0.2s ease, height 0.2s ease, border-width 0.2s ease; background: transparent; will-change: transform; } .custom-cursor::before { content: \"\"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 8px; height: 8px; background: white; border-radius: 50%; } body { cursor: none; }\nscript.js: // TouchTexture class class TouchTexture { constructor() { this.size = 64; this.width = this.height = this.size; this.maxAge = 64; this.radius = 0.25 * this.size; // Much larger touch radius for more obvious effect this.speed = 1 / this.maxAge; this.trail = []; this.last = null; this.initTexture(); } initTexture() { this.canvas = document.createElement(\"canvas\"); this.canvas.width = this.width; this.canvas.height = this.height; this.ctx = this.canvas.getContext(\"2d\"); this.ctx.fillStyle = \"black\"; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.texture = new THREE.Texture(this.canvas); } update() { this.clear(); let speed = this.speed; // Use reverse iteration to safely remove items for (let i = this.trail.length - 1; i >= 0; i--) { const point = this.trail[i]; let f = point.force * speed * (1 - point.age / this.maxAge); point.x += point.vx * f; point.y += point.vy * f; point.age++; if (point.age > this.maxAge) { this.trail.splice(i, 1); } else { this.drawPoint(point); } } this.texture.needsUpdate = true; } clear() { this.ctx.fillStyle = \"black\"; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); } addTouch(point) { let force = 0; let vx = 0; let vy = 0; const last = this.last; if (last) { const dx = point.x - last.x; const dy = point.y - last.y; if (dx === 0 && dy === 0) return; const dd = dx * dx + dy * dy; let d = Math.sqrt(dd); vx = dx / d; vy = dy / d; force = Math.min(dd * 20000, 2.0); // Much stronger force for very noticeable effect } this.last = { x: point.x, y: point.y }; this.trail.push({ x: point.x, y: point.y, age: 0, force, vx, vy }); } drawPoint(point) { const pos = { x: point.x * this.width, y: (1 - point.y) * this.height }; let intensity = 1; if (point.age < this.maxAge * 0.3) { intensity = Math.sin((point.age / (this.maxAge * 0.3)) * (Math.PI / 2)); } else { const t = 1 - (point.age - this.maxAge * 0.3) / (this.maxAge * 0.7); intensity = -t * (t - 2); } intensity *= point.force; const radius = this.radius; let color = `${((point.vx + 1) / 2) * 255}, ${ ((point.vy + 1) / 2) * 255 }, ${intensity * 255}`; let offset = this.size * 5; this.ctx.shadowOffsetX = offset; this.ctx.shadowOffsetY = offset; this.ctx.shadowBlur = radius * 1; this.ctx.shadowColor = `rgba(${color},${0.2 * intensity})`; this.ctx.beginPath(); this.ctx.fillStyle = \"rgba(255,0,0,1)\"; this.ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2); this.ctx.fill(); } } // GradientBackground class class GradientBackground { constructor(sceneManager) { this.sceneManager = sceneManager; this.mesh = null; this.uniforms = { uTime: { value: 0 }, uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }, uColor1: { value: new THREE.Vector3(0.945, 0.353, 0.133) }, // F15A22 - Orange uColor2: { value: new THREE.Vector3(0.039, 0.055, 0.153) }, // 0a0e27 - Navy Blue uColor3: { value: new THREE.Vector3(0.945, 0.353, 0.133) }, // F15A22 - Orange uColor4: { value: new THREE.Vector3(0.039, 0.055, 0.153) }, // 0a0e27 - Navy Blue uColor5: { value: new THREE.Vector3(0.945, 0.353, 0.133) }, // F15A22 - Orange uColor6: { value: new THREE.Vector3(0.039, 0.055, 0.153) }, // 0a0e27 - Navy Blue uSpeed: { value: 1.2 }, // Faster animation uIntensity: { value: 1.8 }, uTouchTexture: { value: null }, uGrainIntensity: { value: 0.08 }, uZoom: { value: 1.0 }, // Zoom/scale control - lower = less zoomed (more visible) uDarkNavy: { value: new THREE.Vector3(0.039, 0.055, 0.153) }, // #0a0e27 - Dark navy base color uGradientSize: { value: 1.0 }, // Control gradient size (smaller = more gradients) uGradientCount: { value: 6.0 }, // Number of gradient centers uColor1Weight: { value: 1.0 }, // Weight for color1 (orange) - reduce for more navy uColor2Weight: { value: 1.0 } // Weight for color2 (navy) - increase for more navy }; } init() { const viewSize = this.sceneManager.getViewSize(); const geometry = new THREE.PlaneGeometry( viewSize.width, viewSize.height, 1, 1 ); const material = new THREE.ShaderMaterial({ uniforms: this.uniforms, vertexShader: ` varying vec2 vUv; void main() { vec3 pos = position.xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.); vUv = uv; } `, fragmentShader: ` uniform float uTime; uniform vec2 uResolution; uniform vec3 uColor1; uniform vec3 uColor2; uniform vec3 uColor3; uniform vec3 uColor4; uniform vec3 uColor5; uniform vec3 uColor6; uniform float uSpeed; uniform float uIntensity; uniform sampler2D uTouchTexture; uniform float uGrainIntensity; uniform float uZoom; uniform vec3 uDarkNavy; uniform float uGradientSize; uniform float uGradientCount; uniform float uColor1Weight; uniform float uColor2Weight; varying vec2 vUv; #define PI 3.14159265359 // Grain function for film grain effect float grain(vec2 uv, float time) { vec2 grainUv = uv * uResolution * 0.5; float grainValue = fract(sin(dot(grainUv + time, vec2(12.9898, 78.233))) * 43758.5453); return grainValue * 2.0 - 1.0; } vec3 getGradientColor(vec2 uv, float time) { // Dynamic gradient size based on uniform float gradientRadius = uGradientSize; // Multiple animated centers with different speeds and patterns // Support up to 12 centers for more gradient action vec2 center1 = vec2( 0.5 + sin(time * uSpeed * 0.4) * 0.4, 0.5 + cos(time * uSpeed * 0.5) * 0.4 ); vec2 center2 = vec2( 0.5 + cos(time * uSpeed * 0.6) * 0.5, 0.5 + sin(time * uSpeed * 0.45) * 0.5 ); vec2 center3 = vec2( 0.5 + sin(time * uSpeed * 0.35) * 0.45, 0.5 + cos(time * uSpeed * 0.55) * 0.45 ); vec2 center4 = vec2( 0.5 + cos(time * uSpeed * 0.5) * 0.4, 0.5 + sin(time * uSpeed * 0.4) * 0.4 ); vec2 center5 = vec2( 0.5 + sin(time * uSpeed * 0.7) * 0.35, 0.5 + cos(time * uSpeed * 0.6) * 0.35 ); vec2 center6 = vec2( 0.5 + cos(time * uSpeed * 0.45) * 0.5, 0.5 + sin(time * uSpeed * 0.65) * 0.5 ); // Additional centers for more gradient action (7-12) vec2 center7 = vec2( 0.5 + sin(time * uSpeed * 0.55) * 0.38, 0.5 + cos(time * uSpeed * 0.48) * 0.42 ); vec2 center8 = vec2( 0.5 + cos(time * uSpeed * 0.65) * 0.36, 0.5 + sin(time * uSpeed * 0.52) * 0.44 ); vec2 center9 = vec2( 0.5 + sin(time * uSpeed * 0.42) * 0.41, 0.5 + cos(time * uSpeed * 0.58) * 0.39 ); vec2 center10 = vec2( 0.5 + cos(time * uSpeed * 0.48) * 0.37, 0.5 + sin(time * uSpeed * 0.62) * 0.43 ); vec2 center11 = vec2( 0.5 + sin(time * uSpeed * 0.68) * 0.33, 0.5 + cos(time * uSpeed * 0.44) * 0.46 ); vec2 center12 = vec2( 0.5 + cos(time * uSpeed * 0.38) * 0.39, 0.5 + sin(time * uSpeed * 0.56) * 0.41 ); float dist1 = length(uv - center1); float dist2 = length(uv - center2); float dist3 = length(uv - center3); float dist4 = length(uv - center4); float dist5 = length(uv - center5); float dist6 = length(uv - center6); float dist7 = length(uv - center7); float dist8 = length(uv - center8); float dist9 = length(uv - center9); float dist10 = length(uv - center10); float dist11 = length(uv - center11); float dist12 = length(uv - center12); // Smaller, tighter influence areas based on uGradientSize float influence1 = 1.0 - smoothstep(0.0, gradientRadius, dist1); float influence2 = 1.0 - smoothstep(0.0, gradientRadius, dist2); float influence3 = 1.0 - smoothstep(0.0, gradientRadius, dist3); float influence4 = 1.0 - smoothstep(0.0, gradientRadius, dist4); float influence5 = 1.0 - smoothstep(0.0, gradientRadius, dist5); float influence6 = 1.0 - smoothstep(0.0, gradientRadius, dist6); float influence7 = 1.0 - smoothstep(0.0, gradientRadius, dist7); float influence8 = 1.0 - smoothstep(0.0, gradientRadius, dist8); float influence9 = 1.0 - smoothstep(0.0, gradientRadius, dist9); float influence10 = 1.0 - smoothstep(0.0, gradientRadius, dist10); float influence11 = 1.0 - smoothstep(0.0, gradientRadius, dist11); float influence12 = 1.0 - smoothstep(0.0, gradientRadius, dist12); // Multiple rotation layers for depth vec2 rotatedUv1 = uv - 0.5; float angle1 = time * uSpeed * 0.15; rotatedUv1 = vec2( rotatedUv1.x * cos(angle1) - rotatedUv1.y * sin(angle1), rotatedUv1.x * sin(angle1) + rotatedUv1.y * cos(angle1) ); rotatedUv1 += 0.5; vec2 rotatedUv2 = uv - 0.5; float angle2 = -time * uSpeed * 0.12; rotatedUv2 = vec2( rotatedUv2.x * cos(angle2) - rotatedUv2.y * sin(angle2), rotatedUv2.x * sin(angle2) + rotatedUv2.y * cos(angle2) ); rotatedUv2 += 0.5; float radialGradient1 = length(rotatedUv1 - 0.5); float radialGradient2 = length(rotatedUv2 - 0.5); float radialInfluence1 = 1.0 - smoothstep(0.0, 0.8, radialGradient1); float radialInfluence2 = 1.0 - smoothstep(0.0, 0.8, radialGradient2); // Blend all colors with dynamic intensities - increased for more contrast vec3 color = vec3(0.0); color += uColor1 * influence1 * (0.55 + 0.45 * sin(time * uSpeed)) * uColor1Weight; color += uColor2 * influence2 * (0.55 + 0.45 * cos(time * uSpeed * 1.2)) * uColor2Weight; color += uColor3 * influence3 * (0.55 + 0.45 * sin(time * uSpeed * 0.8)) * uColor1Weight; color += uColor4 * influence4 * (0.55 + 0.45 * cos(time * uSpeed * 1.3)) * uColor2Weight; color += uColor5 * influence5 * (0.55 + 0.45 * sin(time * uSpeed * 1.1)) * uColor1Weight; color += uColor6 * influence6 * (0.55 + 0.45 * cos(time * uSpeed * 0.9)) * uColor2Weight; // Add extra centers if uGradientCount > 6 if (uGradientCount > 6.0) { color += uColor1 * influence7 * (0.55 + 0.45 * sin(time * uSpeed * 1.4)) * uColor1Weight; color += uColor2 * influence8 * (0.55 + 0.45 * cos(time * uSpeed * 1.5)) * uColor2Weight; color += uColor3 * influence9 * (0.55 + 0.45 * sin(time * uSpeed * 1.6)) * uColor1Weight; color += uColor4 * influence10 * (0.55 + 0.45 * cos(time * uSpeed * 1.7)) * uColor2Weight; } if (uGradientCount > 10.0) { color += uColor5 * influence11 * (0.55 + 0.45 * sin(time * uSpeed * 1.8)) * uColor1Weight; color += uColor6 * influence12 * (0.55 + 0.45 * cos(time * uSpeed * 1.9)) * uColor2Weight; } // Add radial overlays - increased for more contrast, with color weighting color += mix(uColor1, uColor3, radialInfluence1) * 0.45 * uColor1Weight; color += mix(uColor2, uColor4, radialInfluence2) * 0.4 * uColor2Weight; // Clamp and apply intensity color = clamp(color, vec3(0.0), vec3(1.0)) * uIntensity; // Enhanced color saturation for more vibrant look float luminance = dot(color, vec3(0.299, 0.587, 0.114)); color = mix(vec3(luminance), color, 1.35); color = pow(color, vec3(0.92)); // Slight gamma adjustment for better contrast // Ensure minimum brightness (navy blue base instead of grey/black) // Use higher threshold to ensure navy blue shows through in low-intensity areas float brightness1 = length(color); float mixFactor1 = max(brightness1 * 1.2, 0.15); // Higher threshold for navy blue base color = mix(uDarkNavy, color, mixFactor1); // Cap maximum brightness - increased for more contrast float maxBrightness = 1.0; float brightness = length(color); if (brightness > maxBrightness) { color = color * (maxBrightness / brightness); } return color; } void main() { vec2 uv = vUv; // Apply water distortion from touch texture - very strong vec4 touchTex = texture2D(uTouchTexture, uv); float vx = -(touchTex.r * 2.0 - 1.0); float vy = -(touchTex.g * 2.0 - 1.0); float intensity = touchTex.b; // Much increased distortion strength for very obvious effect uv.x += vx * 0.8 * intensity; uv.y += vy * 0.8 * intensity; // Combined ripple and wave effect for better performance vec2 center = vec2(0.5); float dist = length(uv - center); float ripple = sin(dist * 20.0 - uTime * 3.0) * 0.04 * intensity; float wave = sin(dist * 15.0 - uTime * 2.0) * 0.03 * intensity; uv += vec2(ripple + wave); vec3 color = getGradientColor(uv, uTime); // Apply grain effect float grainValue = grain(uv, uTime); color += grainValue * uGrainIntensity; // Subtle color shifting - optimized with single calculation float timeShift = uTime * 0.5; color.r += sin(timeShift) * 0.02; color.g += cos(timeShift * 1.4) * 0.02; color.b += sin(timeShift * 1.2) * 0.02; // Ensure minimum brightness (navy blue base instead of grey/black) // Use higher threshold to ensure navy blue shows through in low-intensity areas float brightness2 = length(color); float mixFactor2 = max(brightness2 * 1.2, 0.15); // Higher threshold for navy blue base color = mix(uDarkNavy, color, mixFactor2); // Clamp to valid color range color = clamp(color, vec3(0.0), vec3(1.0)); // Cap maximum brightness - increased for more contrast float maxBrightness = 1.0; float brightness = length(color); if (brightness > maxBrightness) { color = color * (maxBrightness / brightness); } gl_FragColor = vec4(color, 1.0); } ` }); this.mesh = new THREE.Mesh(geometry, material); this.mesh.position.z = 0; this.sceneManager.scene.add(this.mesh); } update(delta) { if (this.uniforms.uTime) { this.uniforms.uTime.value += delta; } } onResize(width, height) { const viewSize = this.sceneManager.getViewSize(); if (this.mesh) { this.mesh.geometry.dispose(); this.mesh.geometry = new THREE.PlaneGeometry( viewSize.width, viewSize.height, 1, 1 ); } if (this.uniforms.uResolution) { this.uniforms.uResolution.value.set(width, height); } } } // App class class App { constructor() { this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: \"high-performance\", alpha: false, stencil: false, depth: false }); this.renderer.setSize(window.innerWidth, window.innerHeight); this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance this.renderer.setAnimationLoop(null); // We'll use our own tick loop document.body.appendChild(this.renderer.domElement); this.renderer.domElement.id = \"webGLApp\"; this.camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 10000 ); this.camera.position.z = 50; this.scene = new THREE.Scene(); this.scene.background = new THREE.Color(0x0a0e27); // Dark navy this.clock = new THREE.Clock(); this.touchTexture = new TouchTexture(); this.gradientBackground = new GradientBackground(this); this.gradientBackground.uniforms.uTouchTexture.value = this.touchTexture.texture; // Color schemes this.colorSchemes = { 1: { // Orange + Navy Blue color1: new THREE.Vector3(0.945, 0.353, 0.133), // F15A22 - Orange color2: new THREE.Vector3(0.039, 0.055, 0.153) // 0a0e27 - Navy Blue }, 2: { // Turquoise + Coral Red-Orange color1: new THREE.Vector3(1.0, 0.424, 0.314), // FF6C50 - Coral Red-Orange color2: new THREE.Vector3(0.251, 0.878, 0.816) // 40E0D0 - Turquoise }, 3: { // Orange + Navy + Turquoise (identical to scheme 1 but with turquoise added) color1: new THREE.Vector3(0.945, 0.353, 0.133), // F15A22 - Orange color2: new THREE.Vector3(0.039, 0.055, 0.153), // 0a0e27 - Navy Blue color3: new THREE.Vector3(0.251, 0.878, 0.816) // 40E0D0 - Turquoise }, 4: { // Based on Scheme 3: F26633 + 2D6B6D + D1AF9C color1: new THREE.Vector3(0.949, 0.4, 0.2), // F26633 - Orange/Coral color2: new THREE.Vector3(0.176, 0.42, 0.427), // 2D6B6D - Teal/Blue-Green color3: new THREE.Vector3(0.82, 0.686, 0.612) // D1AF9C - Beige/Peach }, 5: { // F15A22 + 004238 + F15A22 + 000000 + F15A22 + 000000 color1: new THREE.Vector3(0.945, 0.353, 0.133), // F15A22 - Orange color2: new THREE.Vector3(0.0, 0.259, 0.22), // 004238 - Dark Teal (0, 66, 56) color3: new THREE.Vector3(0.945, 0.353, 0.133), // F15A22 - Orange color4: new THREE.Vector3(0.0, 0.0, 0.0), // 000000 - Black color5: new THREE.Vector3(0.945, 0.353, 0.133), // F15A22 - Orange color6: new THREE.Vector3(0.0, 0.0, 0.0) // 000000 - Black } }; this.currentScheme = 1; this.init(); } setColorScheme(scheme) { if (!this.colorSchemes[scheme]) return; this.currentScheme = scheme; const colors = this.colorSchemes[scheme]; const uniforms = this.gradientBackground.uniforms; // Update all color uniforms if (scheme === 3) { // Scheme 3: Orange + Navy + Turquoise (identical to scheme 1 but with turquoise) uniforms.uColor1.value.copy(colors.color1); // Orange uniforms.uColor2.value.copy(colors.color2); // Navy uniforms.uColor3.value.copy(colors.color3); // Turquoise uniforms.uColor4.value.copy(colors.color1); // Orange uniforms.uColor5.value.copy(colors.color2); // Navy uniforms.uColor6.value.copy(colors.color3); // Turquoise } else if (scheme === 4) { // Scheme 4: Based on Scheme 3 with F26633, 2D6B6D, D1AF9C uniforms.uColor1.value.copy(colors.color1); // F26633 - Orange/Coral uniforms.uColor2.value.copy(colors.color2); // 2D6B6D - Teal/Blue-Green uniforms.uColor3.value.copy(colors.color3); // D1AF9C - Beige/Peach uniforms.uColor4.value.copy(colors.color1); // F26633 - Orange/Coral uniforms.uColor5.value.copy(colors.color2); // 2D6B6D - Teal/Blue-Green uniforms.uColor6.value.copy(colors.color3); // D1AF9C - Beige/Peach } else if (scheme === 5) { // Scheme 5: F15A22 + 004238 + F15A22 + 000000 + F15A22 + 000000 uniforms.uColor1.value.copy(colors.color1); // F15A22 - Orange uniforms.uColor2.value.copy(colors.color2); // 004238 - Dark Teal uniforms.uColor3.value.copy(colors.color3); // F15A22 - Orange uniforms.uColor4.value.copy(colors.color4); // 000000 - Black uniforms.uColor5.value.copy(colors.color5); // F15A22 - Orange uniforms.uColor6.value.copy(colors.color6); // 000000 - Black } else { uniforms.uColor1.value.copy(colors.color1); uniforms.uColor2.value.copy(colors.color2); uniforms.uColor3.value.copy(colors.color1); uniforms.uColor4.value.copy(colors.color2); uniforms.uColor5.value.copy(colors.color1); uniforms.uColor6.value.copy(colors.color2); } // Update background color and base color if (scheme === 1) { this.scene.background = new THREE.Color(0x0a0e27); // Navy blue for scheme 1 uniforms.uDarkNavy.value.set(0.039, 0.055, 0.153); // #0a0e27 - Navy blue base color // More gradient action: smaller gradients, more of them uniforms.uGradientSize.value = 0.45; // Smaller gradient radius for more defined gradients uniforms.uGradientCount.value = 12.0; // More gradient centers (12 instead of 6) uniforms.uSpeed.value = 1.5; // Slightly faster for more movement // Balance colors: reduce orange, increase navy uniforms.uColor1Weight.value = 0.5; // Reduce orange intensity uniforms.uColor2Weight.value = 1.8; // Increase navy intensity } else if (scheme === 6) { // Scheme 6: Identical to scheme 1 but with Orange, Navy, and Turquoise this.scene.background = new THREE.Color(0x0a0e27); // Navy blue (same as scheme 1) uniforms.uDarkNavy.value.set(0.039, 0.055, 0.153); // #0a0e27 - Navy blue base color (same as scheme 1) // More gradient action: smaller gradients, more of them (same as scheme 1) uniforms.uGradientSize.value = 0.45; // Smaller gradient radius for more defined gradients uniforms.uGradientCount.value = 12.0; // More gradient centers (12 instead of 6) uniforms.uSpeed.value = 1.5; // Slightly faster for more movement // Balance colors: reduce orange, increase navy (same as scheme 1) uniforms.uColor1Weight.value = 0.5; // Reduce orange intensity uniforms.uColor2Weight.value = 1.8; // Increase navy intensity } else if (scheme === 7) { // Scheme 7: Based on Scheme 6 with F26633, 2D6B6D, D1AF9C (same settings as Scheme 6) this.scene.background = new THREE.Color(0x0a0e27); // Navy blue (same as scheme 6) uniforms.uDarkNavy.value.set(0.039, 0.055, 0.153); // #0a0e27 - Navy blue base color (same as scheme 6) // More gradient action: smaller gradients, more of them (same as scheme 6) uniforms.uGradientSize.value = 0.45; // Smaller gradient radius for more defined gradients uniforms.uGradientCount.value = 12.0; // More gradient centers (12 instead of 6) uniforms.uSpeed.value = 1.5; // Slightly faster for more movement // Balance colors: same as scheme 6 uniforms.uColor1Weight.value = 0.5; // Reduce orange/coral intensity uniforms.uColor2Weight.value = 1.8; // Increase teal intensity } else if (scheme === 8) { // Scheme 8: Identical to Scheme 1 this.scene.background = new THREE.Color(0x0a0e27); // Navy blue for scheme 8 uniforms.uDarkNavy.value.set(0.039, 0.055, 0.153); // #0a0e27 - Navy blue base color // More gradient action: smaller gradients, more of them uniforms.uGradientSize.value = 0.45; // Smaller gradient radius for more defined gradients uniforms.uGradientCount.value = 12.0; // More gradient centers (12 instead of 6) uniforms.uSpeed.value = 1.5; // Slightly faster for more movement // Balance colors: reduce orange, increase navy uniforms.uColor1Weight.value = 0.5; // Reduce orange intensity uniforms.uColor2Weight.value = 1.8; // Increase navy intensity } else if (scheme === 5) { // Scheme 5: Same settings as Scheme 1 but with F15A22 + 004238 + F15A22 + 000000 + F15A22 + 000000 this.scene.background = new THREE.Color(0x0a0e27); // Navy blue for scheme 5 (same as scheme 1) uniforms.uDarkNavy.value.set(0.039, 0.055, 0.153); // #0a0e27 - Navy blue base color (same as scheme 1) // More gradient action: smaller gradients, more of them (same as scheme 1) uniforms.uGradientSize.value = 0.45; // Smaller gradient radius for more defined gradients uniforms.uGradientCount.value = 12.0; // More gradient centers (12 instead of 6) uniforms.uSpeed.value = 1.5; // Slightly faster for more movement // Balance colors: reduce orange, increase navy (same as scheme 1) uniforms.uColor1Weight.value = 0.5; // Reduce orange intensity uniforms.uColor2Weight.value = 1.8; // Increase navy intensity } else if (scheme === 4) { this.scene.background = new THREE.Color(0xffffff); // Off-white for scheme 4 uniforms.uDarkNavy.value.set(0, 0, 0); // #FAFAFA - Off-white base } else if (scheme === 2) { this.scene.background = new THREE.Color(0x0a0e27); // Default dark navy for scheme 2 uniforms.uDarkNavy.value.set(0.039, 0.055, 0.153); // #0a0e27 - Default dark navy uniforms.uGradientSize.value = 1.0; // Default size uniforms.uGradientCount.value = 6.0; // Default count uniforms.uSpeed.value = 1.2; // Default speed uniforms.uColor1Weight.value = 1.0; // Default weight uniforms.uColor2Weight.value = 1.0; // Default weight } else { this.scene.background = new THREE.Color(0x0a0e27); // Default dark navy uniforms.uDarkNavy.value.set(0.039, 0.055, 0.153); // #0a0e27 - Default dark navy uniforms.uGradientSize.value = 1.0; // Default size uniforms.uGradientCount.value = 6.0; // Default count uniforms.uSpeed.value = 1.2; // Default speed uniforms.uColor1Weight.value = 1.0; // Default weight uniforms.uColor2Weight.value = 1.0; // Default weight } } init() { this.gradientBackground.init(); // Apply Scheme 1 settings on startup this.setColorScheme(1); // Force initial render to wake up the browser this.render(); // Start animation loop this.tick(); window.addEventListener(\"resize\", () => this.onResize()); window.addEventListener(\"mousemove\", (ev) => this.onMouseMove(ev)); window.addEventListener(\"touchmove\", (ev) => this.onTouchMove(ev)); // Handle visibility changes to prevent throttling document.addEventListener(\"visibilitychange\", () => { if (!document.hidden) { // Force render when page becomes visible this.render(); } }); // Wake up animation on any user interaction const wakeUpAnimation = () => { this.render(); window.removeEventListener(\"click\", wakeUpAnimation); window.removeEventListener(\"touchstart\", wakeUpAnimation); window.removeEventListener(\"mousemove\", wakeUpAnimation); }; window.addEventListener(\"click\", wakeUpAnimation, { once: true }); window.addEventListener(\"touchstart\", wakeUpAnimation, { once: true }); window.addEventListener(\"mousemove\", wakeUpAnimation, { once: true }); } onTouchMove(ev) { const touch = ev.touches[0]; this.onMouseMove({ clientX: touch.clientX, clientY: touch.clientY }); } onMouseMove(ev) { this.mouse = { x: ev.clientX / window.innerWidth, y: 1 - ev.clientY / window.innerHeight }; this.touchTexture.addTouch(this.mouse); } getViewSize() { const fovInRadians = (this.camera.fov * Math.PI) / 180; const height = Math.abs( this.camera.position.z * Math.tan(fovInRadians / 2) * 2 ); return { width: height * this.camera.aspect, height }; } update(delta) { this.touchTexture.update(); this.gradientBackground.update(delta); } render() { const delta = this.clock.getDelta(); // Only update if delta is reasonable (prevents large jumps) const clampedDelta = Math.min(delta, 0.1); this.renderer.render(this.scene, this.camera); this.update(clampedDelta); } tick() { this.render(); // Use arrow function to maintain context and ensure continuous rendering requestAnimationFrame(() => this.tick()); } onResize() { this.camera.aspect = window.innerWidth / window.innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); this.gradientBackground.onResize(window.innerWidth, window.innerHeight); } } // Start the app const app = new App(); // Force animation to start immediately by triggering a render // This helps prevent browser throttling of requestAnimationFrame if (document.readyState === \"loading\") { document.addEventListener(\"DOMContentLoaded\", () => { app.render(); }); } else { // DOM already loaded, force immediate render setTimeout(() => app.render(), 0); } // Color scheme buttons const colorButtons = document.querySelectorAll(\".color-btn\"); colorButtons.forEach((btn) => { btn.addEventListener(\"click\", () => { const scheme = parseInt(btn.dataset.scheme); app.setColorScheme(scheme); // Update active state colorButtons.forEach((b) => b.classList.remove(\"active\")); btn.classList.add(\"active\"); // Update color pickers when scheme changes updateColorPickersFromScheme(); }); }); // Color Adjuster Panel Functions const colorAdjusterPanel = document.getElementById(\"colorAdjusterPanel\"); const toggleAdjusterBtn = document.getElementById(\"toggleAdjusterBtn\"); const closeAdjusterBtn = document.getElementById(\"closeAdjusterBtn\"); // Toggle panel toggleAdjusterBtn.addEventListener(\"click\", () => { colorAdjusterPanel.classList.toggle(\"open\"); if (colorAdjusterPanel.classList.contains(\"open\")) { updateColorPickersFromScheme(); toggleAdjusterBtn.style.display = \"none\"; } else { toggleAdjusterBtn.style.display = \"block\"; } }); closeAdjusterBtn.addEventListener(\"click\", () => { colorAdjusterPanel.classList.remove(\"open\"); toggleAdjusterBtn.style.display = \"block\"; }); // Convert RGB (0-1) to Hex function rgbToHex(r, g, b) { const toHex = (n) => { const hex = Math.round(n * 255).toString(16); return hex.length === 1 ? \"0\" + hex : hex; }; return \"#\" + toHex(r) + toHex(g) + toHex(b); } // Convert Hex to RGB (0-1) function hexToRgb(hex) { const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16) / 255, g: parseInt(result[2], 16) / 255, b: parseInt(result[3], 16) / 255 } : null; } // Update color pickers from current scheme function updateColorPickersFromScheme() { const uniforms = app.gradientBackground.uniforms; const colors = [ uniforms.uColor1.value, uniforms.uColor2.value, uniforms.uColor3.value, uniforms.uColor4.value, uniforms.uColor5.value, uniforms.uColor6.value ]; colors.forEach((color, index) => { const picker = document.getElementById(`colorPicker${index + 1}`); const display = document.getElementById(`colorValue${index + 1}`); const hex = rgbToHex(color.x, color.y, color.z); picker.value = hex; display.value = hex.toUpperCase(); }); } // Update gradient when color picker changes for (let i = 1; i <= 6; i++) { const picker = document.getElementById(`colorPicker${i}`); const display = document.getElementById(`colorValue${i}`); picker.addEventListener(\"input\", (e) => { const hex = e.target.value; const rgb = hexToRgb(hex); if (rgb) { const uniforms = app.gradientBackground.uniforms; const colorUniform = uniforms[`uColor${i}`]; if (colorUniform) { colorUniform.value.set(rgb.r, rgb.g, rgb.b); display.value = hex.toUpperCase(); } } }); } // Copy color value document.querySelectorAll(\".copy-btn\").forEach((btn) => { btn.addEventListener(\"click\", (e) => { const colorIndex = e.target.dataset.copy; const display = document.getElementById(`colorValue${colorIndex}`); const text = display.value; navigator.clipboard.writeText(text).then(() => { e.target.textContent = \"Copied!\"; e.target.classList.add(\"copied\"); setTimeout(() => { e.target.textContent = \"Copy\"; e.target.classList.remove(\"copied\"); }, 2000); }); }); }); // Export all colors const exportAllBtn = document.getElementById(\"exportAllBtn\"); exportAllBtn.addEventListener(\"click\", () => { const colors = []; for (let i = 1; i <= 6; i++) { const display = document.getElementById(`colorValue${i}`); colors.push(display.value); } const exportText = `Color Scheme:\\n${colors .map((c, i) => `Color ${i + 1}: ${c}`) .join(\"\\n\")}\\n\\nHex Array: [${colors.map((c) => `\"${c}\"`).join(\", \")}]`; navigator.clipboard.writeText(exportText).then(() => { exportAllBtn.textContent = \"Copied!\"; exportAllBtn.style.background = \"rgba(76, 175, 80, 0.3)\"; exportAllBtn.style.borderColor = \"rgba(76, 175, 80, 0.5)\"; setTimeout(() => { exportAllBtn.textContent = \"Export All Colors\"; exportAllBtn.style.background = \"\"; exportAllBtn.style.borderColor = \"\"; }, 2000); }); }); // Custom cursor const cursor = document.getElementById(\"customCursor\"); let mouseX = 0; let mouseY = 0; let cursorX = 0; let cursorY = 0; document.addEventListener(\"mousemove\", (e) => { mouseX = e.clientX; mouseY = e.clientY; }); let isCursorAnimating = false; function animateCursor() { if (!isCursorAnimating) return; // Instant following - no delay cursorX = mouseX; cursorY = mouseY; cursor.style.left = cursorX + \"px\"; cursor.style.top = cursorY + \"px\"; requestAnimationFrame(animateCursor); } // Only start animation when mouse moves document.addEventListener( \"mousemove\", () => { if (!isCursorAnimating) { isCursorAnimating = true; animateCursor(); } }, { once: false } ); // Cursor animation starts on first mouse move // Make cursor larger on hover over interactive elements const footerLink = document.querySelector(\".footer a\"); footerLink.addEventListener(\"mouseenter\", () => { cursor.style.width = \"50px\"; cursor.style.height = \"50px\"; cursor.style.borderWidth = \"3px\"; }); footerLink.addEventListener(\"mouseleave\", () => { cursor.style.width = \"40px\"; cursor.style.height = \"40px\"; cursor.style.borderWidth = \"2px\"; }); // Make cursor larger on hover over color buttons colorButtons.forEach((btn) => { btn.addEventListener(\"mouseenter\", () => { cursor.style.width = \"50px\"; cursor.style.height = \"50px\"; cursor.style.borderWidth = \"3px\"; }); btn.addEventListener(\"mouseleave\", () => { cursor.style.width = \"40px\"; cursor.style.height = \"40px\"; cursor.style.borderWidth = \"2px\"; }); }); // Make cursor larger on hover over toggle adjuster button toggleAdjusterBtn.addEventListener(\"mouseenter\", () => { cursor.style.width = \"50px\"; cursor.style.height = \"50px\"; cursor.style.borderWidth = \"3px\"; }); toggleAdjusterBtn.addEventListener(\"mouseleave\", () => { cursor.style.width = \"40px\"; cursor.style.height = \"40px\"; cursor.style.borderWidth = \"2px\"; }); // Optimized pulse effect - use requestAnimationFrame instead of setTimeout let lastMouseMoveTime = 0; let pulseFrame = null; function checkPulse() { if (Date.now() - lastMouseMoveTime > 100) { cursor.style.borderWidth = \"2px\"; pulseFrame = null; } else { pulseFrame = requestAnimationFrame(checkPulse); } } document.addEventListener(\"mousemove\", () => { lastMouseMoveTime = Date.now(); cursor.style.borderWidth = \"2.5px\"; if (!pulseFrame) { pulseFrame = requestAnimationFrame(checkPulse); } });",
    "id": "interactive-liquid-gradient-using-threejs"
  },
  {
    "title": "[threejs/webgl]  Yet another Metaballs Hero Section with ThreeJS",
    "description": "",
    "code": "index.html: <section class=\"section hero-section\"> <div id=\"container\"></div> <div id=\"stats\"></div> <div id=\"ui-container\"></div> <div class=\"header-area\"> <div class=\"logo-container\" id=\"theme-toggle\"> <div class=\"logo-circles\"> <div class=\"circle circle-1\"></div> <div class=\"circle circle-2\"></div> </div> </div> <div class=\"center-logo\"> <h1 id=\"logo-text\">Nexus.</h1> </div> </div> <div class=\"hero\"> <h1>Where matter becomes<br>thought and thought<br>becomes form</h1> <h2 id=\"story-text\"> our vessel drifts at coordinates (0.00, 0.00)<br> gravitational field extends 0.10 units into quantum foam<br> currently merging with 0 other entities </h2> </div> <div class=\"contact-info\"> <p class=\"contact-heading\">+Get in touch</p> <span class=\"contact-email\">hi@filip.fyi</span> </div> <div class=\"footer-links\"> <a href=\"#\" class=\"footer-link\">Fluid Dynamics</a> <a href=\"#\" class=\"footer-link\">Organic Shapes</a> <a href=\"#\" class=\"footer-link\">Interactive Forms</a> <a href=\"#\" class=\"footer-link\">Motion Studies</a> <a href=\"#\" class=\"footer-link\">Contact</a> </div> <div class=\"coordinates\"> <p>Nexus State  Active</p> <p>where consciousness flows</p> </div> </section> <section class=\"section fin-section\"> <div class=\"fin-text\">{ Fin }</div> </section>\nstyle.css: @import url(\"https://fonts.cdnfonts.com/css/pp-neue-montreal\"); @font-face { font-family: \"PPSupplyMono\"; src: url(\"https://assets.codepen.io/7558/PPSupplyMono-Regular.ttf\") format(\"truetype\"); font-weight: normal; font-style: normal; font-display: swap; } :root { --warm-off-white: #ffffff; --warm-off-white-dim: #cccccc; --text-primary: #ffffff; --text-secondary: #cccccc; --background-dark: #1a1a1a; --background-gradient-1: #222222; --background-gradient-2: #1a1a1a; --font-primary: \"PP Neue Montreal\", sans-serif; --font-secondary: \"PPSupplyMono\", monospace; --font-sans: \"PP Neue Montreal\", sans-serif; --font-size-small: 10px; --font-size-regular: 1rem; --font-size-medium: 1.5rem; --font-size-large: 4rem; --spacing-small: 0.5rem; --spacing-medium: 1rem; --spacing-large: 2rem; --transition-fast: 0.3s ease; --transition-medium: 0.5s cubic-bezier(0.445, 0.05, 0.55, 0.95); } *, *:before, *:after { margin: 0; padding: 0; box-sizing: border-box; } html { font-size: 16px; scroll-behavior: smooth; } @media (min-width: 768px) { html { font-size: 18px; } } @media (min-width: 1200px) { html { font-size: 20px; } } body { overflow-x: hidden; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; color: var(--text-primary); background-color: var(--background-dark); font-family: var(--font-secondary); font-size: var(--font-size-small); } .section { width: 100vw; height: 100vh; position: relative; } .hero-section { padding: var(--spacing-large); } .fin-section { display: flex; align-items: center; justify-content: center; background-color: var(--background-dark); z-index: 20; position: relative; } .fin-text { font-family: var(--font-primary); font-size: 3rem; color: var(--text-secondary); text-transform: none; letter-spacing: 0.05em; } body::after { content: \"\"; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-image: url(\"https://img.freepik.com/premium-photo/white-dust-scratches-black-background_279525-2.jpg?w=640\"); background-repeat: repeat; opacity: 0.2; mix-blend-mode: multiply; pointer-events: none; z-index: 1; filter: invert(0); } #container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #0f0f0f; z-index: 0; pointer-events: none; } #ui-container { position: fixed; top: 10px; right: 10px; z-index: 100; opacity: 0.8; transition: opacity var(--transition-fast); } #ui-container:hover { opacity: 1; } #stats { position: fixed; top: 10px; left: 10px; z-index: 100; } .header-area { position: fixed; top: var(--spacing-large); left: 0; width: 100%; padding: 0 var(--spacing-large); display: flex; justify-content: center; z-index: 10; } .logo-container { position: absolute; left: var(--spacing-large); top: 0; display: flex; align-items: center; height: 2rem; z-index: 10; cursor: pointer; } .logo-circles { position: relative; width: 100%; height: 100%; } .circle { position: absolute; border-radius: 50%; transition: transform var(--transition-medium); width: 1.4rem; height: 1.4rem; background-color: var(--text-primary); top: 50%; } .circle-1 { left: 0; transform: translate(0, -50%); } .circle-2 { left: 0.8rem; transform: translate(0, -50%); mix-blend-mode: exclusion; } .logo-container:hover .circle-1 { transform: translate(-0.5rem, -50%); } .logo-container:hover .circle-2 { transform: translate(0.5rem, -50%); } .center-logo { text-align: center; z-index: 10; height: 2rem; } #logo-text { font-family: var(--font-primary); font-weight: 400; font-size: var(--font-size-medium); line-height: 1; margin: 0; color: var(--text-primary); text-transform: none; } .hero { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 10; color: var(--text-primary); width: 90%; max-width: 800px; } .hero h1 { font-family: var(--font-primary); font-weight: 400; font-size: var(--font-size-large); line-height: 0.9; letter-spacing: -0.02em; color: var(--text-primary); text-transform: none; margin-bottom: 2rem; margin: 0 0 2rem 0; } .hero h2 { font-family: var(--font-secondary); font-size: var(--font-size-small); color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em; line-height: 1.4; opacity: 0.7; transition: opacity var(--transition-fast); font-weight: normal; margin: 0; } .hero:hover h2 { opacity: 1; } .contact-info { position: fixed; top: 50%; left: var(--spacing-large); transform: translateY(-50%); z-index: 10; font-family: var(--font-secondary); letter-spacing: 0.05em; font-size: var(--font-size-small); color: var(--text-primary); text-transform: uppercase; } .contact-heading { font-size: var(--font-size-small); color: var(--text-secondary); margin-bottom: var(--spacing-small); } .contact-email { display: block; color: var(--text-primary); text-decoration: none; transition: all var(--transition-fast); cursor: pointer; } .contact-email:hover { color: var(--text-secondary); } .footer-links { position: fixed; bottom: var(--spacing-large); left: var(--spacing-large); z-index: 10; display: flex; flex-direction: column; align-items: flex-start; gap: 0.25rem; font-family: var(--font-sans); font-weight: 400; font-size: var(--font-size-regular); } .footer-link { color: var(--text-secondary); text-decoration: none; transition: all var(--transition-fast); position: relative; padding-left: 0; text-transform: none; font-size: 1rem; } .footer-link::before { content: \"\"; position: absolute; left: 0; top: 50%; width: 0; height: 1px; background-color: var(--text-primary); transform: translateY(-50%); transition: width var(--transition-fast), opacity var(--transition-fast); opacity: 0; } .footer-link:hover { color: var(--text-primary); padding-left: 1.2rem; } .footer-link:hover::before { width: 0.8rem; opacity: 1; } .coordinates { position: fixed; bottom: var(--spacing-large); right: var(--spacing-large); text-align: right; z-index: 10; font-family: var(--font-secondary); font-size: var(--font-size-small); color: var(--text-secondary); } .tp-dfwv { min-width: 280px !important; } .section { transition: all 0.6s ease; } @media (max-width: 768px) { .hero h1 { font-size: 3rem; } .footer-links { gap: 0.4rem; } .coordinates { font-size: 10px; } .hero p { font-size: 10px; } .story-display { width: 90%; font-size: 0.8rem; } } @media (max-width: 480px) { .hero-section { padding: var(--spacing-medium); } .header-area, .contact-info, .footer-links, .coordinates { padding: 0 var(--spacing-medium); } .logo-container, .contact-info, .footer-links { left: var(--spacing-medium); } .coordinates { right: var(--spacing-medium); } .hero h1 { font-size: 2.2rem; } .circle { width: 1.2rem; height: 1.2rem; } .circle-2 { left: 0.7rem; } #logo-text { font-size: 1.3rem; } .contact-heading { font-size: 10px; } .contact-email { font-size: 10px; } .story-display { width: 95%; font-size: 0.75rem; } }\nscript.js: import * as THREE from \"https://esm.sh/three@0.178.0\"; import { Pane } from \"https://cdn.skypack.dev/tweakpane@4.0.4\"; let scene, camera, renderer, material; let clock, mouse = { x: 0, y: 0 }; let cursorSphere3D = new THREE.Vector3(0, 0, 0); let activeMerges = 0; let targetMousePosition = new THREE.Vector2(0.5, 0.5); let mousePosition = new THREE.Vector2(0.5, 0.5); let lastTime = performance.now(); let frameCount = 0; let fps = 0; // Enhanced device detection const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test( navigator.userAgent ); const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent); const isLowPowerDevice = isMobile || navigator.hardwareConcurrency <= 4; const devicePixelRatio = Math.min( window.devicePixelRatio || 1, isMobile ? 1.5 : 2 ); const presets = { moody: { sphereCount: isMobile ? 4 : 6, ambientIntensity: 0.02, diffuseIntensity: 0.6, specularIntensity: 1.8, specularPower: 8, fresnelPower: 1.2, backgroundColor: new THREE.Color(0x050505), sphereColor: new THREE.Color(0x000000), lightColor: new THREE.Color(0xffffff), lightPosition: new THREE.Vector3(1, 1, 1), smoothness: 0.3, contrast: 2.0, fogDensity: 0.12, cursorGlowIntensity: 0.4, cursorGlowRadius: 1.2, cursorGlowColor: new THREE.Color(0xffffff) }, cosmic: { sphereCount: isMobile ? 5 : 8, ambientIntensity: 0.03, diffuseIntensity: 0.8, specularIntensity: 1.6, specularPower: 6, fresnelPower: 1.4, backgroundColor: new THREE.Color(0x000011), sphereColor: new THREE.Color(0x000022), lightColor: new THREE.Color(0x88aaff), lightPosition: new THREE.Vector3(0.5, 1, 0.5), smoothness: 0.4, contrast: 2.0, fogDensity: 0.15, cursorGlowIntensity: 0.8, cursorGlowRadius: 1.5, cursorGlowColor: new THREE.Color(0x4477ff) }, minimal: { sphereCount: isMobile ? 2 : 3, ambientIntensity: 0.0, diffuseIntensity: 0.25, specularIntensity: 1.3, specularPower: 11, fresnelPower: 1.7, backgroundColor: new THREE.Color(0x0a0a0a), sphereColor: new THREE.Color(0x000000), lightColor: new THREE.Color(0xffffff), lightPosition: new THREE.Vector3(1, 0.5, 0.8), smoothness: 0.25, contrast: 2.0, fogDensity: 0.1, cursorGlowIntensity: 0.3, cursorGlowRadius: 1.0, cursorGlowColor: new THREE.Color(0xffffff) }, vibrant: { sphereCount: isMobile ? 6 : 10, ambientIntensity: 0.05, diffuseIntensity: 0.9, specularIntensity: 1.5, specularPower: 5, fresnelPower: 1.3, backgroundColor: new THREE.Color(0x0a0505), sphereColor: new THREE.Color(0x110000), lightColor: new THREE.Color(0xff8866), lightPosition: new THREE.Vector3(0.8, 1.2, 0.6), smoothness: 0.5, contrast: 2.0, fogDensity: 0.08, cursorGlowIntensity: 0.8, cursorGlowRadius: 1.3, cursorGlowColor: new THREE.Color(0xff6644) }, neon: { sphereCount: isMobile ? 4 : 7, ambientIntensity: 0.04, diffuseIntensity: 1.0, specularIntensity: 2.0, specularPower: 4, fresnelPower: 1.0, backgroundColor: new THREE.Color(0x000505), sphereColor: new THREE.Color(0x000808), lightColor: new THREE.Color(0x00ffcc), lightPosition: new THREE.Vector3(0.7, 1.3, 0.8), smoothness: 0.7, contrast: 2.0, fogDensity: 0.08, cursorGlowIntensity: 0.8, cursorGlowRadius: 1.4, cursorGlowColor: new THREE.Color(0x00ffaa) }, sunset: { sphereCount: isMobile ? 3 : 5, ambientIntensity: 0.04, diffuseIntensity: 0.7, specularIntensity: 1.4, specularPower: 7, fresnelPower: 1.5, backgroundColor: new THREE.Color(0x150505), sphereColor: new THREE.Color(0x100000), lightColor: new THREE.Color(0xff6622), lightPosition: new THREE.Vector3(1.2, 0.4, 0.6), smoothness: 0.35, contrast: 2.0, fogDensity: 0.1, cursorGlowIntensity: 0.8, cursorGlowRadius: 1.4, cursorGlowColor: new THREE.Color(0xff4422) }, midnight: { sphereCount: isMobile ? 3 : 4, ambientIntensity: 0.01, diffuseIntensity: 0.4, specularIntensity: 1.6, specularPower: 9, fresnelPower: 1.8, backgroundColor: new THREE.Color(0x000010), sphereColor: new THREE.Color(0x000015), lightColor: new THREE.Color(0x4466ff), lightPosition: new THREE.Vector3(0.9, 0.8, 1.0), smoothness: 0.28, contrast: 2.0, fogDensity: 0.14, cursorGlowIntensity: 0.8, cursorGlowRadius: 1.6, cursorGlowColor: new THREE.Color(0x3355ff) }, toxic: { sphereCount: isMobile ? 5 : 9, ambientIntensity: 0.06, diffuseIntensity: 0.85, specularIntensity: 1.7, specularPower: 6, fresnelPower: 1.1, backgroundColor: new THREE.Color(0x001000), sphereColor: new THREE.Color(0x001500), lightColor: new THREE.Color(0x66ff44), lightPosition: new THREE.Vector3(0.6, 1.1, 0.7), smoothness: 0.55, contrast: 2.0, fogDensity: 0.09, cursorGlowIntensity: 0.8, cursorGlowRadius: 1.7, cursorGlowColor: new THREE.Color(0x44ff22) }, pastel: { sphereCount: isMobile ? 4 : 6, ambientIntensity: 0.08, diffuseIntensity: 0.5, specularIntensity: 1.2, specularPower: 12, fresnelPower: 2.0, backgroundColor: new THREE.Color(0x101018), sphereColor: new THREE.Color(0x080814), lightColor: new THREE.Color(0xaabbff), lightPosition: new THREE.Vector3(1.0, 0.7, 0.9), smoothness: 0.38, contrast: 1.8, fogDensity: 0.07, cursorGlowIntensity: 0.35, cursorGlowRadius: 1.1, cursorGlowColor: new THREE.Color(0x8899ff) }, dithered: { sphereCount: isMobile ? 5 : 8, ambientIntensity: 0.1, diffuseIntensity: 0.8, specularIntensity: 1.5, specularPower: 6, fresnelPower: 1.2, backgroundColor: new THREE.Color(0x0a0520), sphereColor: new THREE.Color(0x000000), lightColor: new THREE.Color(0xff00ff), lightPosition: new THREE.Vector3(0.8, 0.8, 0.8), smoothness: 0.6, contrast: 1.8, fogDensity: 0.05, cursorGlowIntensity: 1.0, cursorGlowRadius: 2.0, cursorGlowColor: new THREE.Color(0x00ffff) }, holographic: { sphereCount: isMobile ? 4 : 6, ambientIntensity: 0.12, diffuseIntensity: 1.2, specularIntensity: 2.5, specularPower: 3, fresnelPower: 0.8, backgroundColor: new THREE.Color(0x0a0a15), sphereColor: new THREE.Color(0x050510), lightColor: new THREE.Color(0xccaaff), lightPosition: new THREE.Vector3(0.9, 0.9, 1.2), smoothness: 0.8, contrast: 1.6, fogDensity: 0.06, cursorGlowIntensity: 1.2, cursorGlowRadius: 2.2, cursorGlowColor: new THREE.Color(0xaa77ff) } }; const settings = { preset: \"holographic\", ...presets.holographic, fixedTopLeftRadius: 0.8, fixedBottomRightRadius: 0.9, smallTopLeftRadius: 0.3, smallBottomRightRadius: 0.35, cursorRadiusMin: 0.08, cursorRadiusMax: 0.15, animationSpeed: 0.6, movementScale: 1.2, mouseSmoothness: 0.1, mergeDistance: 1.5, mouseProximityEffect: true, minMovementScale: 0.3, maxMovementScale: 1.0 }; function getStoryText(x, y, radius, merges, fps) { if (isMobile) { return `vessel: (${x}, ${y})<br>field: ${radius}u<br>merges: ${merges}<br>flux: ${fps}hz`; } return `our vessel drifts at coordinates (${x}, ${y})<br>gravitational field extends ${radius} units into quantum foam<br>currently merging with ${merges} other entities<br>temporal flux: ${fps} cycles per second`; } init(); animate(); function init() { const container = document.getElementById(\"container\"); scene = new THREE.Scene(); camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10); camera.position.z = 1; clock = new THREE.Clock(); renderer = new THREE.WebGLRenderer({ antialias: !isMobile && !isLowPowerDevice, alpha: true, powerPreference: isMobile ? \"default\" : \"high-performance\", preserveDrawingBuffer: false, premultipliedAlpha: false }); // FIXED: Proper pixel ratio handling const pixelRatio = Math.min(devicePixelRatio, isMobile ? 1.5 : 2); renderer.setPixelRatio(pixelRatio); // Get actual viewport dimensions const viewportWidth = window.innerWidth; const viewportHeight = window.innerHeight; renderer.setSize(viewportWidth, viewportHeight); renderer.setClearColor(0x000000, 0); renderer.outputColorSpace = THREE.SRGBColorSpace; // Enhanced canvas styling const canvas = renderer.domElement; canvas.style.cssText = ` position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; z-index: 0 !important; display: block !important; `; container.appendChild(canvas); // Create material with improved shader material = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0 }, uResolution: { value: new THREE.Vector2(viewportWidth, viewportHeight) }, // FIXED: Pass actual canvas size including pixel ratio uActualResolution: { value: new THREE.Vector2( viewportWidth * pixelRatio, viewportHeight * pixelRatio ) }, uPixelRatio: { value: pixelRatio }, uMousePosition: { value: new THREE.Vector2(0.5, 0.5) }, uCursorSphere: { value: new THREE.Vector3(0, 0, 0) }, uCursorRadius: { value: settings.cursorRadiusMin }, uSphereCount: { value: settings.sphereCount }, uFixedTopLeftRadius: { value: settings.fixedTopLeftRadius }, uFixedBottomRightRadius: { value: settings.fixedBottomRightRadius }, uSmallTopLeftRadius: { value: settings.smallTopLeftRadius }, uSmallBottomRightRadius: { value: settings.smallBottomRightRadius }, uMergeDistance: { value: settings.mergeDistance }, uSmoothness: { value: settings.smoothness }, uAmbientIntensity: { value: settings.ambientIntensity }, uDiffuseIntensity: { value: settings.diffuseIntensity }, uSpecularIntensity: { value: settings.specularIntensity }, uSpecularPower: { value: settings.specularPower }, uFresnelPower: { value: settings.fresnelPower }, uBackgroundColor: { value: settings.backgroundColor }, uSphereColor: { value: settings.sphereColor }, uLightColor: { value: settings.lightColor }, uLightPosition: { value: settings.lightPosition }, uContrast: { value: settings.contrast }, uFogDensity: { value: settings.fogDensity }, uAnimationSpeed: { value: settings.animationSpeed }, uMovementScale: { value: settings.movementScale }, uMouseProximityEffect: { value: settings.mouseProximityEffect }, uMinMovementScale: { value: settings.minMovementScale }, uMaxMovementScale: { value: settings.maxMovementScale }, uCursorGlowIntensity: { value: settings.cursorGlowIntensity }, uCursorGlowRadius: { value: settings.cursorGlowRadius }, uCursorGlowColor: { value: settings.cursorGlowColor }, uIsSafari: { value: isSafari ? 1.0 : 0.0 }, uIsMobile: { value: isMobile ? 1.0 : 0.0 }, uIsLowPower: { value: isLowPowerDevice ? 1.0 : 0.0 } }, vertexShader: ` varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `, fragmentShader: ` ${ isMobile || isSafari || isLowPowerDevice ? \"precision mediump float;\" : \"precision highp float;\" } uniform float uTime; uniform vec2 uResolution; uniform vec2 uActualResolution; uniform float uPixelRatio; uniform vec2 uMousePosition; uniform vec3 uCursorSphere; uniform float uCursorRadius; uniform int uSphereCount; uniform float uFixedTopLeftRadius; uniform float uFixedBottomRightRadius; uniform float uSmallTopLeftRadius; uniform float uSmallBottomRightRadius; uniform float uMergeDistance; uniform float uSmoothness; uniform float uAmbientIntensity; uniform float uDiffuseIntensity; uniform float uSpecularIntensity; uniform float uSpecularPower; uniform float uFresnelPower; uniform vec3 uBackgroundColor; uniform vec3 uSphereColor; uniform vec3 uLightColor; uniform vec3 uLightPosition; uniform float uContrast; uniform float uFogDensity; uniform float uAnimationSpeed; uniform float uMovementScale; uniform bool uMouseProximityEffect; uniform float uMinMovementScale; uniform float uMaxMovementScale; uniform float uCursorGlowIntensity; uniform float uCursorGlowRadius; uniform vec3 uCursorGlowColor; uniform float uIsSafari; uniform float uIsMobile; uniform float uIsLowPower; varying vec2 vUv; const float PI = 3.14159265359; const float EPSILON = 0.001; const float MAX_DIST = 100.0; float smin(float a, float b, float k) { float h = max(k - abs(a - b), 0.0) / k; return min(a, b) - h * h * k * 0.25; } float sdSphere(vec3 p, float r) { return length(p) - r; } // FIXED: Use actual resolution for coordinate transformation vec3 screenToWorld(vec2 normalizedPos) { // normalizedPos is already 0-1, convert to -1 to 1 vec2 uv = normalizedPos * 2.0 - 1.0; // Apply aspect ratio correction using logical resolution uv.x *= uResolution.x / uResolution.y; return vec3(uv * 2.0, 0.0); } float getDistanceToCenter(vec2 pos) { float dist = length(pos - vec2(0.5, 0.5)) * 2.0; return smoothstep(0.0, 1.0, dist); } float sceneSDF(vec3 pos) { float result = MAX_DIST; // Fixed sphere positions using consistent coordinate system vec3 topLeftPos = screenToWorld(vec2(0.08, 0.92)); float topLeft = sdSphere(pos - topLeftPos, uFixedTopLeftRadius); vec3 smallTopLeftPos = screenToWorld(vec2(0.25, 0.72)); float smallTopLeft = sdSphere(pos - smallTopLeftPos, uSmallTopLeftRadius); vec3 bottomRightPos = screenToWorld(vec2(0.92, 0.08)); float bottomRight = sdSphere(pos - bottomRightPos, uFixedBottomRightRadius); vec3 smallBottomRightPos = screenToWorld(vec2(0.72, 0.25)); float smallBottomRight = sdSphere(pos - smallBottomRightPos, uSmallBottomRightRadius); float t = uTime * uAnimationSpeed; float dynamicMovementScale = uMovementScale; if (uMouseProximityEffect) { float distToCenter = getDistanceToCenter(uMousePosition); float mixFactor = smoothstep(0.0, 1.0, distToCenter); dynamicMovementScale = mix(uMinMovementScale, uMaxMovementScale, mixFactor); } // Optimized iterations for performance int maxIter = uIsMobile > 0.5 ? 4 : (uIsLowPower > 0.5 ? 6 : min(uSphereCount, 10)); for (int i = 0; i < 10; i++) { if (i >= uSphereCount || i >= maxIter) break; float fi = float(i); float speed = 0.4 + fi * 0.12; float radius = 0.12 + mod(fi, 3.0) * 0.06; float orbitRadius = (0.3 + mod(fi, 3.0) * 0.15) * dynamicMovementScale; float phaseOffset = fi * PI * 0.35; float distToCursor = length(vec3(0.0) - uCursorSphere); float proximityScale = 1.0 + (1.0 - smoothstep(0.0, 1.0, distToCursor)) * 0.5; orbitRadius *= proximityScale; vec3 offset; if (i == 0) { offset = vec3( sin(t * speed) * orbitRadius * 0.7, sin(t * 0.5) * orbitRadius, cos(t * speed * 0.7) * orbitRadius * 0.5 ); } else if (i == 1) { offset = vec3( sin(t * speed + PI) * orbitRadius * 0.5, -sin(t * 0.5) * orbitRadius, cos(t * speed * 0.7 + PI) * orbitRadius * 0.5 ); } else { offset = vec3( sin(t * speed + phaseOffset) * orbitRadius * 0.8, cos(t * speed * 0.85 + phaseOffset * 1.3) * orbitRadius * 0.6, sin(t * speed * 0.5 + phaseOffset) * 0.3 ); } vec3 toCursor = uCursorSphere - offset; float cursorDist = length(toCursor); if (cursorDist < uMergeDistance && cursorDist > 0.0) { float attraction = (1.0 - cursorDist / uMergeDistance) * 0.3; offset += normalize(toCursor) * attraction; } float movingSphere = sdSphere(pos - offset, radius); float blend = 0.05; if (cursorDist < uMergeDistance) { float influence = 1.0 - (cursorDist / uMergeDistance); blend = mix(0.05, uSmoothness, influence * influence * influence); } result = smin(result, movingSphere, blend); } float cursorBall = sdSphere(pos - uCursorSphere, uCursorRadius); float topLeftGroup = smin(topLeft, smallTopLeft, 0.4); float bottomRightGroup = smin(bottomRight, smallBottomRight, 0.4); result = smin(result, topLeftGroup, 0.3); result = smin(result, bottomRightGroup, 0.3); result = smin(result, cursorBall, uSmoothness); return result; } vec3 calcNormal(vec3 p) { float eps = uIsLowPower > 0.5 ? 0.002 : 0.001; return normalize(vec3( sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)), sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)), sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps)) )); } float ambientOcclusion(vec3 p, vec3 n) { if (uIsLowPower > 0.5) { float h1 = sceneSDF(p + n * 0.03); float h2 = sceneSDF(p + n * 0.06); float occ = (0.03 - h1) + (0.06 - h2) * 0.5; return clamp(1.0 - occ * 2.0, 0.0, 1.0); } else { float occ = 0.0; float weight = 1.0; for (int i = 0; i < 6; i++) { float dist = 0.01 + 0.015 * float(i * i); float h = sceneSDF(p + n * dist); occ += (dist - h) * weight; weight *= 0.85; } return clamp(1.0 - occ, 0.0, 1.0); } } float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) { if (uIsLowPower > 0.5) { float result = 1.0; float t = mint; for (int i = 0; i < 3; i++) { t += 0.3; if (t >= maxt) break; float h = sceneSDF(ro + rd * t); if (h < EPSILON) return 0.0; result = min(result, k * h / t); } return result; } else { float result = 1.0; float t = mint; for (int i = 0; i < 20; i++) { if (t >= maxt) break; float h = sceneSDF(ro + rd * t); if (h < EPSILON) return 0.0; result = min(result, k * h / t); t += h; } return result; } } float rayMarch(vec3 ro, vec3 rd) { float t = 0.0; int maxSteps = uIsMobile > 0.5 ? 16 : (uIsSafari > 0.5 ? 16 : 48); for (int i = 0; i < 48; i++) { if (i >= maxSteps) break; vec3 p = ro + rd * t; float d = sceneSDF(p); if (d < EPSILON) { return t; } if (t > 5.0) { break; } t += d * (uIsLowPower > 0.5 ? 1.2 : 0.9); } return -1.0; } vec3 lighting(vec3 p, vec3 rd, float t) { if (t < 0.0) { return vec3(0.0); } vec3 normal = calcNormal(p); vec3 viewDir = -rd; vec3 baseColor = uSphereColor; float ao = ambientOcclusion(p, normal); vec3 ambient = uLightColor * uAmbientIntensity * ao; vec3 lightDir = normalize(uLightPosition); float diff = max(dot(normal, lightDir), 0.0); float shadow = softShadow(p, lightDir, 0.01, 10.0, 20.0); vec3 diffuse = uLightColor * diff * uDiffuseIntensity * shadow; vec3 reflectDir = reflect(-lightDir, normal); float spec = pow(max(dot(viewDir, reflectDir), 0.0), uSpecularPower); float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), uFresnelPower); vec3 specular = uLightColor * spec * uSpecularIntensity * fresnel; vec3 fresnelRim = uLightColor * fresnel * 0.4; float distToCursor = length(p - uCursorSphere); if (distToCursor < uCursorRadius + 0.4) { float highlight = 1.0 - smoothstep(0.0, uCursorRadius + 0.4, distToCursor); specular += uLightColor * highlight * 0.2; float glow = exp(-distToCursor * 3.0) * 0.15; ambient += uLightColor * glow * 0.5; } vec3 color = (baseColor + ambient + diffuse + specular + fresnelRim) * ao; color = pow(color, vec3(uContrast * 0.9)); color = color / (color + vec3(0.8)); return color; } float calculateCursorGlow(vec3 worldPos) { float dist = length(worldPos.xy - uCursorSphere.xy); float glow = 1.0 - smoothstep(0.0, uCursorGlowRadius, dist); glow = pow(glow, 2.0); return glow * uCursorGlowIntensity; } void main() { // FIXED: Use actual resolution for proper coordinate calculation vec2 uv = (gl_FragCoord.xy * 2.0 - uActualResolution.xy) / uActualResolution.xy; uv.x *= uResolution.x / uResolution.y; vec3 ro = vec3(uv * 2.0, -1.0); vec3 rd = vec3(0.0, 0.0, 1.0); float t = rayMarch(ro, rd); vec3 p = ro + rd * t; vec3 color = lighting(p, rd, t); float cursorGlow = calculateCursorGlow(ro); vec3 glowContribution = uCursorGlowColor * cursorGlow; if (t > 0.0) { float fogAmount = 1.0 - exp(-t * uFogDensity); color = mix(color, uBackgroundColor.rgb, fogAmount * 0.3); color += glowContribution * 0.3; gl_FragColor = vec4(color, 1.0); } else { if (cursorGlow > 0.01) { gl_FragColor = vec4(glowContribution, cursorGlow * 0.8); } else { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); } } } `, transparent: true }); const geometry = new THREE.PlaneGeometry(2, 2); const mesh = new THREE.Mesh(geometry, material); scene.add(mesh); setupUI(); setupEventListeners(); // Initialize cursor position onPointerMove({ clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 }); } function setupEventListeners() { window.addEventListener(\"mousemove\", onPointerMove, { passive: true }); window.addEventListener(\"touchstart\", onTouchStart, { passive: false }); window.addEventListener(\"touchmove\", onTouchMove, { passive: false }); window.addEventListener(\"touchend\", onTouchEnd, { passive: false }); window.addEventListener(\"resize\", onWindowResize, { passive: true }); window.addEventListener( \"orientationchange\", () => { setTimeout(onWindowResize, 100); }, { passive: true } ); } function onTouchStart(event) { event.preventDefault(); if (event.touches.length > 0) { const touch = event.touches[0]; onPointerMove({ clientX: touch.clientX, clientY: touch.clientY }); } } function onTouchMove(event) { event.preventDefault(); if (event.touches.length > 0) { const touch = event.touches[0]; onPointerMove({ clientX: touch.clientX, clientY: touch.clientY }); } } function onTouchEnd(event) { event.preventDefault(); } function onPointerMove(event) { // Use consistent coordinate system for mouse targetMousePosition.x = event.clientX / window.innerWidth; targetMousePosition.y = 1.0 - event.clientY / window.innerHeight; // Convert to world coordinates using the same system as fixed spheres const normalizedX = targetMousePosition.x; const normalizedY = targetMousePosition.y; const worldPos = screenToWorldJS(normalizedX, normalizedY); cursorSphere3D.copy(worldPos); // Calculate merges and radius let closestDistance = 1000.0; activeMerges = 0; // Use consistent positioning for merge detection const fixedPositions = [ screenToWorldJS(0.08, 0.92), // top left screenToWorldJS(0.25, 0.72), // small top left screenToWorldJS(0.92, 0.08), // bottom right screenToWorldJS(0.72, 0.25) // small bottom right ]; fixedPositions.forEach((pos) => { const dist = cursorSphere3D.distanceTo(pos); closestDistance = Math.min(closestDistance, dist); if (dist < settings.mergeDistance) activeMerges++; }); const proximityFactor = Math.max( 0, 1.0 - closestDistance / settings.mergeDistance ); const smoothFactor = proximityFactor * proximityFactor * (3.0 - 2.0 * proximityFactor); const dynamicRadius = settings.cursorRadiusMin + (settings.cursorRadiusMax - settings.cursorRadiusMin) * smoothFactor; material.uniforms.uCursorSphere.value.copy(cursorSphere3D); material.uniforms.uCursorRadius.value = dynamicRadius; updateStory( cursorSphere3D.x, cursorSphere3D.y, dynamicRadius, activeMerges, fps ); } // JavaScript version of screenToWorld for consistency function screenToWorldJS(normalizedX, normalizedY) { const uv_x = normalizedX * 2.0 - 1.0; const uv_y = normalizedY * 2.0 - 1.0; const aspect = window.innerWidth / window.innerHeight; return new THREE.Vector3(uv_x * aspect * 2.0, uv_y * 2.0, 0.0); } function updateStory(x, y, radius, merges, fps) { const storyText = document.getElementById(\"story-text\"); if (storyText) { const newText = getStoryText( x.toFixed(2), y.toFixed(2), radius.toFixed(2), merges, fps || 0 ); storyText.innerHTML = newText; } } function applyPreset(presetName) { const preset = presets[presetName]; if (!preset) return; settings.preset = presetName; Object.keys(preset).forEach((key) => { if (settings.hasOwnProperty(key)) { settings[key] = preset[key]; } }); // Update uniforms material.uniforms.uSphereCount.value = settings.sphereCount; material.uniforms.uAmbientIntensity.value = settings.ambientIntensity; material.uniforms.uDiffuseIntensity.value = settings.diffuseIntensity; material.uniforms.uSpecularIntensity.value = settings.specularIntensity; material.uniforms.uSpecularPower.value = settings.specularPower; material.uniforms.uFresnelPower.value = settings.fresnelPower; material.uniforms.uBackgroundColor.value = settings.backgroundColor; material.uniforms.uSphereColor.value = settings.sphereColor; material.uniforms.uLightColor.value = settings.lightColor; material.uniforms.uLightPosition.value = settings.lightPosition; material.uniforms.uSmoothness.value = settings.smoothness; material.uniforms.uContrast.value = settings.contrast; material.uniforms.uFogDensity.value = settings.fogDensity; material.uniforms.uCursorGlowIntensity.value = settings.cursorGlowIntensity; material.uniforms.uCursorGlowRadius.value = settings.cursorGlowRadius; material.uniforms.uCursorGlowColor.value = settings.cursorGlowColor; } function setupUI() { const uiContainer = document.getElementById(\"ui-container\"); if (!uiContainer) return; const pane = new Pane({ container: uiContainer, title: \"Metaball Controls\", expanded: !isMobile }); pane .addBinding(settings, \"preset\", { options: { Moody: \"moody\", Cosmic: \"cosmic\", Minimal: \"minimal\", Vibrant: \"vibrant\", Neon: \"neon\", Sunset: \"sunset\", Midnight: \"midnight\", Toxic: \"toxic\", Pastel: \"pastel\", Psychedelic: \"dithered\", Holographic: \"holographic\" } }) .on(\"change\", (ev) => { applyPreset(ev.value); pane.refresh(); }); const metaballFolder = pane.addFolder({ title: \"Metaballs\" }); metaballFolder .addBinding(settings, \"fixedTopLeftRadius\", { min: 0.2, max: 2.0, step: 0.01, label: \"Top Left Size\" }) .on(\"change\", (ev) => { material.uniforms.uFixedTopLeftRadius.value = ev.value; }); metaballFolder .addBinding(settings, \"fixedBottomRightRadius\", { min: 0.2, max: 2.0, step: 0.01, label: \"Bottom Right Size\" }) .on(\"change\", (ev) => { material.uniforms.uFixedBottomRightRadius.value = ev.value; }); metaballFolder .addBinding(settings, \"smallTopLeftRadius\", { min: 0.1, max: 0.8, step: 0.01, label: \"Small Top Left\" }) .on(\"change\", (ev) => { material.uniforms.uSmallTopLeftRadius.value = ev.value; }); metaballFolder .addBinding(settings, \"smallBottomRightRadius\", { min: 0.1, max: 0.8, step: 0.01, label: \"Small Bottom Right\" }) .on(\"change\", (ev) => { material.uniforms.uSmallBottomRightRadius.value = ev.value; }); metaballFolder .addBinding(settings, \"sphereCount\", { min: 2, max: 10, step: 1, label: \"Moving Count\" }) .on(\"change\", (ev) => { material.uniforms.uSphereCount.value = ev.value; }); metaballFolder .addBinding(settings, \"smoothness\", { min: 0.1, max: 1.0, step: 0.01, label: \"Blend Smoothness\" }) .on(\"change\", (ev) => { material.uniforms.uSmoothness.value = ev.value; }); const mouseFolder = pane.addFolder({ title: \"Mouse Interaction\" }); mouseFolder .addBinding(settings, \"mouseProximityEffect\") .on(\"change\", (ev) => { material.uniforms.uMouseProximityEffect.value = ev.value; }); mouseFolder .addBinding(settings, \"minMovementScale\", { min: 0.1, max: 1.0, step: 0.05 }) .on(\"change\", (ev) => { material.uniforms.uMinMovementScale.value = ev.value; }); mouseFolder .addBinding(settings, \"maxMovementScale\", { min: 0.5, max: 2.0, step: 0.05 }) .on(\"change\", (ev) => { material.uniforms.uMaxMovementScale.value = ev.value; }); mouseFolder.addBinding(settings, \"mouseSmoothness\", { min: 0.01, max: 0.2, step: 0.01, label: \"Mouse Smoothness\" }); const cursorFolder = pane.addFolder({ title: \"Cursor\" }); cursorFolder.addBinding(settings, \"cursorRadiusMin\", { min: 0.05, max: 0.2, step: 0.01, label: \"Min Radius\" }); cursorFolder.addBinding(settings, \"cursorRadiusMax\", { min: 0.1, max: 0.25, step: 0.01, label: \"Max Radius\" }); const animationFolder = pane.addFolder({ title: \"Animation\" }); animationFolder .addBinding(settings, \"animationSpeed\", { min: 0.1, max: 3.0, step: 0.1 }) .on(\"change\", (ev) => { material.uniforms.uAnimationSpeed.value = ev.value; }); animationFolder .addBinding(settings, \"movementScale\", { min: 0.5, max: 2.0, step: 0.1 }) .on(\"change\", (ev) => { material.uniforms.uMovementScale.value = ev.value; }); const lightingFolder = pane.addFolder({ title: \"Lighting\" }); lightingFolder .addBinding(settings, \"ambientIntensity\", { min: 0, max: 0.5, step: 0.01 }) .on(\"change\", (ev) => { material.uniforms.uAmbientIntensity.value = ev.value; }); lightingFolder .addBinding(settings, \"diffuseIntensity\", { min: 0, max: 1.0, step: 0.01 }) .on(\"change\", (ev) => { material.uniforms.uDiffuseIntensity.value = ev.value; }); lightingFolder .addBinding(settings, \"specularIntensity\", { min: 0, max: 2.0, step: 0.01 }) .on(\"change\", (ev) => { material.uniforms.uSpecularIntensity.value = ev.value; }); lightingFolder .addBinding(settings, \"specularPower\", { min: 1, max: 64, step: 1 }) .on(\"change\", (ev) => { material.uniforms.uSpecularPower.value = ev.value; }); lightingFolder .addBinding(settings, \"fresnelPower\", { min: 1, max: 5, step: 0.1 }) .on(\"change\", (ev) => { material.uniforms.uFresnelPower.value = ev.value; }); lightingFolder .addBinding(settings, \"contrast\", { min: 0.5, max: 2.0, step: 0.1 }) .on(\"change\", (ev) => { material.uniforms.uContrast.value = ev.value; }); const glowFolder = pane.addFolder({ title: \"Cursor Glow\" }); glowFolder .addBinding(settings, \"cursorGlowIntensity\", { min: 0, max: 2.0, step: 0.1 }) .on(\"change\", (ev) => { material.uniforms.uCursorGlowIntensity.value = ev.value; }); glowFolder .addBinding(settings, \"cursorGlowRadius\", { min: 0.5, max: 3.0, step: 0.1 }) .on(\"change\", (ev) => { material.uniforms.uCursorGlowRadius.value = ev.value; }); glowFolder .addBinding(settings, \"fogDensity\", { min: 0, max: 0.5, step: 0.01 }) .on(\"change\", (ev) => { material.uniforms.uFogDensity.value = ev.value; }); } function onWindowResize() { const width = window.innerWidth; const height = window.innerHeight; const currentPixelRatio = Math.min(devicePixelRatio, isMobile ? 1.5 : 2); camera.updateProjectionMatrix(); renderer.setSize(width, height); renderer.setPixelRatio(currentPixelRatio); // FIXED: Update resolution uniforms with proper values material.uniforms.uResolution.value.set(width, height); material.uniforms.uActualResolution.value.set( width * currentPixelRatio, height * currentPixelRatio ); material.uniforms.uPixelRatio.value = currentPixelRatio; // Ensure canvas stays properly positioned const canvas = renderer.domElement; canvas.style.cssText = ` position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; z-index: 0 !important; display: block !important; `; if (renderer.info) { renderer.info.autoReset = true; } } function animate() { requestAnimationFrame(animate); render(); } function render() { const currentTime = performance.now(); frameCount++; if (currentTime - lastTime >= 1000) { fps = Math.round((frameCount * 1000) / (currentTime - lastTime)); updateStory( cursorSphere3D.x, cursorSphere3D.y, material.uniforms.uCursorRadius.value, activeMerges, fps ); frameCount = 0; lastTime = currentTime; } // Smooth mouse movement mousePosition.x += (targetMousePosition.x - mousePosition.x) * settings.mouseSmoothness; mousePosition.y += (targetMousePosition.y - mousePosition.y) * settings.mouseSmoothness; material.uniforms.uTime.value = clock.getElapsedTime(); material.uniforms.uMousePosition.value = mousePosition; // Periodic cleanup for better memory management if (performance.now() % 5000 < 16) { renderer.renderLists.dispose(); } renderer.render(scene, camera); } // Email functionality document.addEventListener(\"DOMContentLoaded\", function () { const emailLink = document.querySelector(\".contact-email\"); if (emailLink) { const originalText = emailLink.textContent; emailLink.addEventListener(\"click\", function (e) { e.preventDefault(); navigator.clipboard .writeText(\"hi@filip.fyi\") .then(() => { emailLink.textContent = \"transmission sent to clipboard\"; setTimeout(() => { emailLink.textContent = originalText; }, 2000); }) .catch(() => { window.location.href = \"mailto:hi@filip.fyi\"; }); }); } });",
    "id": "threejswebgl--yet-another-metaballs-hero-section-with-threejs"
  },
  {
    "title": "[threejs/gsap]  THREEJS Raymarching Layout Explorations with Gsap N3",
    "description": "",
    "code": "index.html: <!-- WebGL Container --> <div id=\"container\"></div> <!-- Stats Display --> <div id=\"stats\"></div> <!-- UI Controls --> <div id=\"ui-container\"></div> <!-- Header with logo --> <div class=\"header-area\"> <!-- Logo in top left --> <div class=\"logo-container\" id=\"theme-toggle\"> <div class=\"logo-circles\"> <div class=\"circle circle-1\"></div> <div class=\"circle circle-2\"></div> </div> </div> <!-- Center Logo --> <div class=\"center-logo\"> <h1 id=\"logo-text\">Mindspace.</h1> </div> </div> <!-- Hero Content (Center) --> <div class=\"hero\"> <h1>Find clarity<br>in cosmic<br>silence</h1> <p>( the art of mental spaciousness )</p> </div> <!-- Contact Info (Left) --> <div class=\"contact-info\"> <p class=\"contact-heading\">+Get In Touch</p> <span class=\"contact-email\">hi@filip.fyi</span> </div> <!-- Footer Links (Bottom Left) --> <div class=\"footer-links\"> <a href=\"#\" class=\"footer-link\">Visual Work</a> <a href=\"#\" class=\"footer-link\">Photography</a> <a href=\"#\" class=\"footer-link\">Bio</a> <a href=\"#\" class=\"footer-link\">Journal</a> <a href=\"#\" class=\"footer-link\">Contact</a> </div> <!-- Coordinates (Bottom Right) --> <div class=\"coordinates\"> <p>3405'24.0\"N 11824'39.6\"W</p> <p>the space between thoughts</p> </div>\nstyle.css: @import url(\"https://fonts.cdnfonts.com/css/thegoodmonolith\"); @font-face { src: url(\"https://fonts.cdnfonts.com/css/pp-neue-montreal\") format(\"woff2\"); font-family: \"PP Neue Montreal\", sans-serif; font-weight: 400; } :root { /* Colors */ --warm-off-white: #f5f5f0; --warm-off-white-dim: #d9d9d0; --text-primary: #f5f5f0; --text-secondary: #d9d9d0; --background-dark: #050505; --background-gradient-1: #1a1a1a; --background-gradient-2: #0a0a0a; /* Typography */ --font-primary: \"PP Neue Montreal\", sans-serif; --font-secondary: \"TheGoodMonolith\", sans-serif; --font-size-small: 0.825rem; --font-size-regular: 1rem; --font-size-medium: 1.5rem; --font-size-large: 4rem; /* Layout */ --spacing-small: 0.5rem; --spacing-medium: 1rem; --spacing-large: 2rem; /* Transitions */ --transition-fast: 0.3s ease; --transition-medium: 0.5s cubic-bezier(0.445, 0.05, 0.55, 0.95); } *, *:before, *:after { margin: 0; padding: 0; box-sizing: border-box; } /* Base font size - using a more controlled approach */ html { font-size: 16px; /* Base size */ } @media (min-width: 768px) { html { font-size: 18px; } } @media (min-width: 1200px) { html { font-size: 20px; } } body { overflow: hidden; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; color: var(--text-primary); background-color: var(--background-dark); padding: var(--spacing-large); } /* Dust/Scratches background effect for the entire site */ body::after { content: \"\"; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-image: url(\"https://img.freepik.com/premium-photo/white-dust-scratches-black-background_279525-2.jpg?w=640\"); background-repeat: repeat; opacity: 0.05; mix-blend-mode: screen; pointer-events: none; z-index: 1; } #container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient( circle at 30% 30%, var(--background-gradient-1) 0%, var(--background-gradient-2) 70%, var(--background-dark) 100% ); z-index: 0; } #ui-container { position: fixed; top: 10px; right: 10px; z-index: 100; opacity: 0.8; transition: opacity var(--transition-fast); } #ui-container:hover { opacity: 1; } #stats { position: fixed; top: 0; left: 0; z-index: 100; } .tp-dfwv { min-width: 280px !important; } /* Header area */ .header-area { position: fixed; top: var(--spacing-large); left: 0; width: 100%; padding: 0 var(--spacing-large); display: flex; justify-content: center; z-index: 10; } /* Logo in top left */ .logo-container { position: absolute; left: var(--spacing-large); top: 0; display: flex; align-items: center; height: 2rem; z-index: 10; } /* Logo circles */ .logo-circles { position: relative; width: 100%; height: 100%; } .circle { position: absolute; border-radius: 50%; transition: transform var(--transition-medium); width: 1.4rem; height: 1.4rem; background-color: var(--warm-off-white); top: 50%; } .circle-1 { left: 0; transform: translate(0, -50%); } .circle-2 { left: 0.8rem; transform: translate(0, -50%); mix-blend-mode: exclusion; } .logo-container:hover .circle-1 { transform: translate(-0.5rem, -50%); } .logo-container:hover .circle-2 { transform: translate(0.5rem, -50%); } /* Center Logo */ .center-logo { text-align: center; z-index: 10; height: 2rem; } #logo-text { font-family: var(--font-primary); font-weight: 400; font-size: var(--font-size-medium); line-height: 1; margin: 0; } /* Hero Section */ .hero { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 10; } .hero h1 { font-family: var(--font-primary); font-weight: 400; font-size: var(--font-size-large); line-height: 0.9; /* Reduced space between lines */ letter-spacing: -0.02em; } .hero p { font-family: var(--font-secondary); font-size: var(--font-size-small); color: var(--text-secondary); margin-top: 1.2rem; } /* Contact Info */ .contact-info { position: fixed; top: 50%; left: var(--spacing-large); transform: translateY(-50%); z-index: 10; font-family: var(--font-secondary); letter-spacing: -0.02em; font-size: var(--font-size-small); } .contact-heading { font-size: var(--font-size-regular); color: var(--text-secondary); margin-bottom: var(--spacing-small); } .contact-email { display: block; color: var(--text-primary); text-decoration: none; transition: all var(--transition-fast); cursor: pointer; } .contact-email:hover { color: var(--text-secondary); } /* Footer */ .footer-links { position: fixed; bottom: var(--spacing-large); left: var(--spacing-large); z-index: 10; display: flex; flex-direction: column; align-items: flex-start; gap: 0.25rem; font-family: var(--font-primary); font-weight: 400; font-size: var(--font-size-regular); } .footer-link { color: var(--warm-off-white-dim); text-decoration: none; transition: all var(--transition-fast); position: relative; padding-left: 0; } .footer-link::before { content: \"\"; position: absolute; left: 0; top: 50%; width: 0; height: 1px; background-color: var(--warm-off-white); transform: translateY(-50%); transition: width var(--transition-fast), opacity var(--transition-fast); opacity: 0; } .footer-link:hover { color: var(--warm-off-white); padding-left: 1.2rem; } .footer-link:hover::before { width: 0.8rem; opacity: 1; } /* Coordinates */ .coordinates { position: fixed; bottom: var(--spacing-large); right: var(--spacing-large); text-align: right; z-index: 10; font-family: var(--font-secondary); font-size: var(--font-size-small); color: var(--text-secondary); } /* Responsive adjustments */ @media (max-width: 768px) { .hero h1 { font-size: 3rem; } .footer-links { gap: 0.4rem; } .coordinates { font-size: 0.7rem; } .hero p { font-size: 0.8rem; } } @media (max-width: 480px) { body { padding: var(--spacing-medium); } .header-area, .contact-info, .footer-links, .coordinates { padding: 0 var(--spacing-medium); } .logo-container, .contact-info, .footer-links { left: var(--spacing-medium); } .coordinates { right: var(--spacing-medium); } .hero h1 { font-size: 2.2rem; } .circle { width: 1.2rem; height: 1.2rem; } .circle-2 { left: 0.7rem; } #logo-text { font-size: 1.3rem; } .contact-heading { font-size: 0.9rem; } .contact-email { font-size: 1rem; } }\nscript.js: // Import modules import * as THREE from \"https://esm.sh/three@0.175.0\"; import { Pane } from \"https://cdn.skypack.dev/tweakpane@4.0.4\"; import Stats from \"https://esm.sh/stats.js@0.17.0\"; import { EffectComposer } from \"https://esm.sh/three@0.175.0/examples/jsm/postprocessing/EffectComposer.js\"; import { RenderPass } from \"https://esm.sh/three@0.175.0/examples/jsm/postprocessing/RenderPass.js\"; import { UnrealBloomPass } from \"https://esm.sh/three@0.175.0/examples/jsm/postprocessing/UnrealBloomPass.js\"; import { ShaderPass } from \"https://esm.sh/three@0.175.0/examples/jsm/postprocessing/ShaderPass.js\"; import { FXAAShader } from \"https://esm.sh/three@0.175.0/examples/jsm/shaders/FXAAShader.js\"; import { GammaCorrectionShader } from \"https://esm.sh/three@0.175.0/examples/jsm/shaders/GammaCorrectionShader.js\"; // Scene setup let container, stats; let camera, scene, renderer; let bloomComposer, finalComposer; let material; let clock; let bloomPass; let mousePosition = new THREE.Vector2(0, 0); let targetMousePosition = new THREE.Vector2(0, 0); // Visual presets const presets = { moody: { sphereCount: 6, bloomStrength: 0.3, bloomThreshold: 0.2, bloomRadius: 0.5, ambientIntensity: 0.05, diffuseIntensity: 0.4, specularIntensity: 2, specularPower: 8, fresnelPower: 1.0, backgroundColor: new THREE.Color(0x050505), sphereColor: new THREE.Color(0x000000), lightColor: new THREE.Color(0xffffff), lightPosition: new THREE.Vector3(1, 1, 1), smoothness: 0.3, contrast: 1.2, fogDensity: 0.15, movementPattern: \"orbital\", movementSpeed: 1.0, movementScale: 1.0, individualRotation: true }, cosmic: { sphereCount: 8, bloomStrength: 0.8, bloomThreshold: 0.1, bloomRadius: 0.7, ambientIntensity: 0.1, diffuseIntensity: 0.5, specularIntensity: 1.2, specularPower: 16, fresnelPower: 2.0, backgroundColor: new THREE.Color(0x000011), sphereColor: new THREE.Color(0x000022), lightColor: new THREE.Color(0x88aaff), lightPosition: new THREE.Vector3(0.5, 1, 0.5), smoothness: 0.4, contrast: 1.4, fogDensity: 0.2, movementPattern: \"wave\", movementSpeed: 1.2, movementScale: 1.3, individualRotation: true }, minimal: { sphereCount: 3, bloomStrength: 0.2, bloomThreshold: 0.3, bloomRadius: 0.3, ambientIntensity: 0.08, diffuseIntensity: 0.3, specularIntensity: 0.6, specularPower: 48, fresnelPower: 4.0, backgroundColor: new THREE.Color(0x0a0a0a), sphereColor: new THREE.Color(0x000000), lightColor: new THREE.Color(0xffffff), lightPosition: new THREE.Vector3(1, 0.5, 0.8), smoothness: 0.25, contrast: 1.1, fogDensity: 0.1, movementPattern: \"pulse\", movementSpeed: 0.7, movementScale: 0.8, individualRotation: false }, vibrant: { sphereCount: 10, bloomStrength: 1.0, bloomThreshold: 0.1, bloomRadius: 0.8, ambientIntensity: 0.15, diffuseIntensity: 0.6, specularIntensity: 1.0, specularPower: 24, fresnelPower: 2.5, backgroundColor: new THREE.Color(0x0a0505), sphereColor: new THREE.Color(0x110000), lightColor: new THREE.Color(0xff8866), lightPosition: new THREE.Vector3(0.8, 1.2, 0.6), smoothness: 0.5, contrast: 1.5, fogDensity: 0.05, movementPattern: \"chaos\", movementSpeed: 1.5, movementScale: 1.2, individualRotation: true }, neon: { sphereCount: 7, bloomStrength: 1.5, bloomThreshold: 0.05, bloomRadius: 0.9, ambientIntensity: 0.12, diffuseIntensity: 0.7, specularIntensity: 1.8, specularPower: 20, fresnelPower: 2.2, backgroundColor: new THREE.Color(0x000505), sphereColor: new THREE.Color(0x000808), lightColor: new THREE.Color(0x00ffcc), lightPosition: new THREE.Vector3(0.7, 1.3, 0.8), smoothness: 0.45, contrast: 1.6, fogDensity: 0.08, movementPattern: \"wave\", movementSpeed: 1.4, movementScale: 1.1, individualRotation: true }, sunset: { sphereCount: 5, bloomStrength: 0.6, bloomThreshold: 0.15, bloomRadius: 0.6, ambientIntensity: 0.18, diffuseIntensity: 0.55, specularIntensity: 0.9, specularPower: 28, fresnelPower: 3.2, backgroundColor: new THREE.Color(0x150505), sphereColor: new THREE.Color(0x100000), lightColor: new THREE.Color(0xff6622), lightPosition: new THREE.Vector3(1.2, 0.4, 0.6), smoothness: 0.35, contrast: 1.3, fogDensity: 0.12, movementPattern: \"orbital\", movementSpeed: 0.9, movementScale: 1.0, individualRotation: false }, midnight: { sphereCount: 4, bloomStrength: 0.4, bloomThreshold: 0.25, bloomRadius: 0.4, ambientIntensity: 0.06, diffuseIntensity: 0.35, specularIntensity: 1.4, specularPower: 40, fresnelPower: 3.5, backgroundColor: new THREE.Color(0x000010), sphereColor: new THREE.Color(0x000015), lightColor: new THREE.Color(0x4466ff), lightPosition: new THREE.Vector3(0.9, 0.8, 1.0), smoothness: 0.28, contrast: 1.25, fogDensity: 0.18, movementPattern: \"pulse\", movementSpeed: 0.6, movementScale: 0.9, individualRotation: true }, toxic: { sphereCount: 9, bloomStrength: 0.9, bloomThreshold: 0.12, bloomRadius: 0.75, ambientIntensity: 0.14, diffuseIntensity: 0.65, specularIntensity: 1.1, specularPower: 22, fresnelPower: 2.8, backgroundColor: new THREE.Color(0x001000), sphereColor: new THREE.Color(0x001500), lightColor: new THREE.Color(0x66ff44), lightPosition: new THREE.Vector3(0.6, 1.1, 0.7), smoothness: 0.55, contrast: 1.45, fogDensity: 0.1, movementPattern: \"chaos\", movementSpeed: 1.3, movementScale: 1.4, individualRotation: true }, pastel: { sphereCount: 6, bloomStrength: 0.5, bloomThreshold: 0.18, bloomRadius: 0.5, ambientIntensity: 0.2, diffuseIntensity: 0.5, specularIntensity: 0.7, specularPower: 36, fresnelPower: 2.6, backgroundColor: new THREE.Color(0x101018), sphereColor: new THREE.Color(0x080814), lightColor: new THREE.Color(0xaabbff), lightPosition: new THREE.Vector3(1.0, 0.7, 0.9), smoothness: 0.38, contrast: 1.15, fogDensity: 0.07, movementPattern: \"wave\", movementSpeed: 0.8, movementScale: 0.9, individualRotation: false } }; // Current parameters let params = { preset: \"moody\", ...presets.moody, animationSpeed: 1.0, cameraDistance: 3.0, mouseProximityEffect: true, minMovementScale: 0.3, maxMovementScale: 1.0, mouseSmoothness: 0.1 }; // Initialize the scene init(); animate(); function init() { container = document.getElementById(\"container\"); // Create scene scene = new THREE.Scene(); // Create camera camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10); camera.position.z = 1; // Create clock for animation clock = new THREE.Clock(); // Create a plane that fills the screen const geometry = new THREE.PlaneGeometry(2, 2); // Create shader material with transparency material = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0 }, uResolution: { value: new THREE.Vector2() }, uSphereCount: { value: params.sphereCount }, uAmbientIntensity: { value: params.ambientIntensity }, uDiffuseIntensity: { value: params.diffuseIntensity }, uSpecularIntensity: { value: params.specularIntensity }, uSpecularPower: { value: params.specularPower }, uFresnelPower: { value: params.fresnelPower }, uBackgroundColor: { value: params.backgroundColor }, uSphereColor: { value: params.sphereColor }, uLightColor: { value: params.lightColor }, uLightPosition: { value: params.lightPosition }, uSmoothness: { value: params.smoothness }, uContrast: { value: params.contrast }, uFogDensity: { value: params.fogDensity }, uAnimationSpeed: { value: params.animationSpeed }, uCameraDistance: { value: params.cameraDistance }, uMovementPattern: { value: [\"orbital\", \"wave\", \"chaos\", \"pulse\"].indexOf( params.movementPattern ) }, uMovementSpeed: { value: params.movementSpeed }, uMovementScale: { value: params.movementScale }, uIndividualRotation: { value: params.individualRotation }, uMousePosition: { value: new THREE.Vector2(0.5, 0.5) }, uMouseProximityEffect: { value: params.mouseProximityEffect }, uMinMovementScale: { value: params.minMovementScale }, uMaxMovementScale: { value: params.maxMovementScale } }, vertexShader: vertexShader(), fragmentShader: fragmentShader(), glslVersion: THREE.GLSL3, transparent: true // Enable transparency }); // Create mesh const mesh = new THREE.Mesh(geometry, material); scene.add(mesh); // Create renderer with alpha renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true // Enable transparency }); renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(0x000000, 0); // Set clear color with alpha=0 renderer.outputColorSpace = THREE.SRGBColorSpace; container.appendChild(renderer.domElement); // Setup post-processing with bloom that preserves transparency setupCustomPostProcessing(); // Setup stats stats = new Stats(); document.getElementById(\"stats\").appendChild(stats.dom); // Setup UI setupUI(); // Handle window resize window.addEventListener(\"resize\", onWindowResize); onWindowResize(); // Add mouse move event listener window.addEventListener(\"mousemove\", onMouseMove); } function onMouseMove(event) { // Calculate normalized mouse position (0 to 1) targetMousePosition.x = event.clientX / window.innerWidth; targetMousePosition.y = 1.0 - event.clientY / window.innerHeight; // Invert Y for WebGL coordinates // Smooth mouse movement is applied in the render loop } // Custom post-processing setup that preserves transparency function setupCustomPostProcessing() { // Create render targets const renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } ); const bloomRenderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } ); // Create render passes const renderScene = new RenderPass(scene, camera); // Create bloom pass bloomPass = new UnrealBloomPass( new THREE.Vector2(window.innerWidth, window.innerHeight), params.bloomStrength, params.bloomRadius, params.bloomThreshold ); // Create a shader to combine the scene with bloom while preserving transparency const finalPass = new ShaderPass( new THREE.ShaderMaterial({ uniforms: { baseTexture: { value: null }, bloomTexture: { value: bloomRenderTarget.texture } }, vertexShader: ` varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `, fragmentShader: ` uniform sampler2D baseTexture; uniform sampler2D bloomTexture; varying vec2 vUv; void main() { vec4 baseColor = texture2D(baseTexture, vUv); vec4 bloomColor = texture2D(bloomTexture, vUv); // Only apply bloom where the original scene has content (alpha > 0) // This preserves transparency in the background gl_FragColor = vec4(baseColor.rgb + bloomColor.rgb * baseColor.a, baseColor.a); } `, transparent: true, depthWrite: false }), \"baseTexture\" ); // Create FXAA pass const fxaaPass = new ShaderPass(FXAAShader); fxaaPass.material.uniforms[\"resolution\"].value.set( 1 / window.innerWidth, 1 / window.innerHeight ); // Create gamma correction pass const gammaCorrectionPass = new ShaderPass(GammaCorrectionShader); // Setup bloom composer bloomComposer = new EffectComposer(renderer, bloomRenderTarget); bloomComposer.renderToScreen = false; bloomComposer.addPass(renderScene); bloomComposer.addPass(bloomPass); // Setup final composer finalComposer = new EffectComposer(renderer, renderTarget); finalComposer.addPass(renderScene); finalPass.uniforms.baseTexture.value = finalComposer.renderTarget2.texture; finalComposer.addPass(finalPass); finalComposer.addPass(fxaaPass); finalComposer.addPass(gammaCorrectionPass); } function setupUI() { const pane = new Pane({ container: document.getElementById(\"ui-container\"), title: \"Ray Marching Controls\", expanded: false }); // Presets dropdown pane .addBinding(params, \"preset\", { options: { Moody: \"moody\", Cosmic: \"cosmic\", Minimal: \"minimal\", Vibrant: \"vibrant\", Neon: \"neon\", Sunset: \"sunset\", Midnight: \"midnight\", Toxic: \"toxic\", Pastel: \"pastel\" } }) .on(\"change\", (ev) => { applyPreset(ev.value); // Update all UI controls to reflect the new preset values pane.refresh(); }); // Spheres folder const spheresFolder = pane.addFolder({ title: \"Spheres\" }); spheresFolder .addBinding(params, \"sphereCount\", { min: 1, max: 10, step: 1 }) .on(\"change\", (ev) => { material.uniforms.uSphereCount.value = ev.value; }); spheresFolder .addBinding(params, \"smoothness\", { min: 0.1, max: 1.0, step: 0.01, label: \"Blend Smoothness\" }) .on(\"change\", (ev) => { material.uniforms.uSmoothness.value = ev.value; }); // Movement folder const movementFolder = pane.addFolder({ title: \"Movement\" }); movementFolder .addBinding(params, \"movementPattern\", { options: { Orbital: \"orbital\", Wave: \"wave\", Chaos: \"chaos\", Pulse: \"pulse\" } }) .on(\"change\", (ev) => { material.uniforms.uMovementPattern.value = [ \"orbital\", \"wave\", \"chaos\", \"pulse\" ].indexOf(ev.value); }); movementFolder .addBinding(params, \"movementSpeed\", { min: 0.1, max: 3.0, step: 0.1 }) .on(\"change\", (ev) => { material.uniforms.uMovementSpeed.value = ev.value; }); movementFolder .addBinding(params, \"movementScale\", { min: 0.1, max: 2.0, step: 0.1 }) .on(\"change\", (ev) => { material.uniforms.uMovementScale.value = ev.value; }); movementFolder.addBinding(params, \"individualRotation\").on(\"change\", (ev) => { material.uniforms.uIndividualRotation.value = ev.value; }); movementFolder .addBinding(params, \"animationSpeed\", { min: 0.1, max: 3.0, step: 0.1 }) .on(\"change\", (ev) => { material.uniforms.uAnimationSpeed.value = ev.value; }); // Mouse interaction folder const mouseFolder = pane.addFolder({ title: \"Mouse Interaction\" }); mouseFolder.addBinding(params, \"mouseProximityEffect\").on(\"change\", (ev) => { material.uniforms.uMouseProximityEffect.value = ev.value; }); mouseFolder .addBinding(params, \"minMovementScale\", { min: 0.1, max: 1.0, step: 0.05 }) .on(\"change\", (ev) => { material.uniforms.uMinMovementScale.value = ev.value; }); mouseFolder .addBinding(params, \"maxMovementScale\", { min: 0.5, max: 2.0, step: 0.05 }) .on(\"change\", (ev) => { material.uniforms.uMaxMovementScale.value = ev.value; }); // Add mouse smoothness control mouseFolder.addBinding(params, \"mouseSmoothness\", { min: 0.01, max: 0.2, step: 0.01, label: \"Mouse Smoothness\" }); // Lighting folder const lightingFolder = pane.addFolder({ title: \"Lighting\" }); lightingFolder .addBinding(params, \"ambientIntensity\", { min: 0, max: 0.5, step: 0.01 }) .on(\"change\", (ev) => { material.uniforms.uAmbientIntensity.value = ev.value; }); lightingFolder .addBinding(params, \"diffuseIntensity\", { min: 0, max: 1.0, step: 0.01 }) .on(\"change\", (ev) => { material.uniforms.uDiffuseIntensity.value = ev.value; }); lightingFolder .addBinding(params, \"specularIntensity\", { min: 0, max: 2.0, step: 0.01 }) .on(\"change\", (ev) => { material.uniforms.uSpecularIntensity.value = ev.value; }); lightingFolder .addBinding(params, \"specularPower\", { min: 1, max: 64, step: 1 }) .on(\"change\", (ev) => { material.uniforms.uSpecularPower.value = ev.value; }); lightingFolder .addBinding(params, \"fresnelPower\", { min: 1, max: 5, step: 0.1 }) .on(\"change\", (ev) => { material.uniforms.uFresnelPower.value = ev.value; }); lightingFolder .addBinding(params, \"contrast\", { min: 0.5, max: 2.0, step: 0.1 }) .on(\"change\", (ev) => { material.uniforms.uContrast.value = ev.value; }); // Bloom folder const bloomFolder = pane.addFolder({ title: \"Bloom Effect\" }); bloomFolder .addBinding(params, \"bloomStrength\", { min: 0, max: 3, step: 0.01 }) .on(\"change\", (ev) => { bloomPass.strength = ev.value; }); bloomFolder .addBinding(params, \"bloomThreshold\", { min: 0, max: 1, step: 0.01 }) .on(\"change\", (ev) => { bloomPass.threshold = ev.value; }); bloomFolder .addBinding(params, \"bloomRadius\", { min: 0, max: 1, step: 0.01 }) .on(\"change\", (ev) => { bloomPass.radius = ev.value; }); // Camera folder const cameraFolder = pane.addFolder({ title: \"Camera\" }); cameraFolder .addBinding(params, \"cameraDistance\", { min: 1.0, max: 10.0, step: 0.1 }) .on(\"change\", (ev) => { material.uniforms.uCameraDistance.value = ev.value; }); cameraFolder .addBinding(params, \"fogDensity\", { min: 0, max: 0.5, step: 0.01 }) .on(\"change\", (ev) => { material.uniforms.uFogDensity.value = ev.value; }); } function applyPreset(presetName) { const preset = presets[presetName]; if (!preset) return; // Update params params.preset = presetName; Object.keys(preset).forEach((key) => { params[key] = preset[key]; }); // Update material uniforms material.uniforms.uSphereCount.value = params.sphereCount; material.uniforms.uAmbientIntensity.value = params.ambientIntensity; material.uniforms.uDiffuseIntensity.value = params.diffuseIntensity; material.uniforms.uSpecularIntensity.value = params.specularIntensity; material.uniforms.uSpecularPower.value = params.specularPower; material.uniforms.uFresnelPower.value = params.fresnelPower; material.uniforms.uBackgroundColor.value = params.backgroundColor; material.uniforms.uSphereColor.value = params.sphereColor; material.uniforms.uLightColor.value = params.lightColor; material.uniforms.uLightPosition.value = params.lightPosition; material.uniforms.uSmoothness.value = params.smoothness; material.uniforms.uContrast.value = params.contrast; material.uniforms.uFogDensity.value = params.fogDensity; material.uniforms.uMovementPattern.value = [ \"orbital\", \"wave\", \"chaos\", \"pulse\" ].indexOf(params.movementPattern); material.uniforms.uMovementSpeed.value = params.movementSpeed; material.uniforms.uMovementScale.value = params.movementScale; material.uniforms.uIndividualRotation.value = params.individualRotation; // Update bloom pass bloomPass.strength = params.bloomStrength; bloomPass.threshold = params.bloomThreshold; bloomPass.radius = params.bloomRadius; } function onWindowResize() { const width = window.innerWidth; const height = window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(width, height); bloomComposer.setSize(width, height); finalComposer.setSize(width, height); material.uniforms.uResolution.value.set(width, height); // Update FXAA pass const fxaaPass = finalComposer.passes.find( (pass) => pass.material && pass.material.uniforms && pass.material.uniforms.resolution ); if (fxaaPass) { fxaaPass.material.uniforms.resolution.value.set(1 / width, 1 / height); } } function animate() { requestAnimationFrame(animate); render(); stats.update(); } function render() { // Apply smooth mouse movement mousePosition.x += (targetMousePosition.x - mousePosition.x) * params.mouseSmoothness; mousePosition.y += (targetMousePosition.y - mousePosition.y) * params.mouseSmoothness; // Update shader uniform with smoothed mouse position material.uniforms.uMousePosition.value = mousePosition; material.uniforms.uTime.value = clock.getElapsedTime() * params.animationSpeed; // First render the scene with bloom bloomComposer.render(); // Then render the final composition finalComposer.render(); } // Vertex shader function vertexShader() { return ` out vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `; } // Fragment shader function fragmentShader() { return ` uniform float uTime; uniform vec2 uResolution; uniform int uSphereCount; uniform float uAmbientIntensity; uniform float uDiffuseIntensity; uniform float uSpecularIntensity; uniform float uSpecularPower; uniform float uFresnelPower; uniform vec3 uBackgroundColor; uniform vec3 uSphereColor; uniform vec3 uLightColor; uniform vec3 uLightPosition; uniform float uSmoothness; uniform float uContrast; uniform float uFogDensity; uniform float uAnimationSpeed; uniform float uCameraDistance; uniform int uMovementPattern; uniform float uMovementSpeed; uniform float uMovementScale; uniform bool uIndividualRotation; uniform vec2 uMousePosition; uniform bool uMouseProximityEffect; uniform float uMinMovementScale; uniform float uMaxMovementScale; in vec2 vUv; out vec4 fragColor; const float PI = 3.14159265359; const float EPSILON = 0.0001; const int MAX_STEPS = 100; const float MAX_DIST = 100.0; // Signed Distance Function for a sphere float sdSphere(vec3 p, float r) { return length(p) - r; } // Smooth minimum function for blending float smin(float a, float b, float k) { float h = max(k - abs(a - b), 0.0) / k; return min(a, b) - h * h * k * 0.25; } // Rotation matrix around the Y axis mat3 rotateY(float theta) { float c = cos(theta); float s = sin(theta); return mat3( c, 0, s, 0, 1, 0, -s, 0, c ); } // Rotation matrix around the X axis mat3 rotateX(float theta) { float c = cos(theta); float s = sin(theta); return mat3( 1, 0, 0, 0, c, -s, 0, s, c ); } // Rotation matrix around the Z axis mat3 rotateZ(float theta) { float c = cos(theta); float s = sin(theta); return mat3( c, -s, 0, s, c, 0, 0, 0, 1 ); } // Calculate distance to center for mouse proximity effect float getDistanceToCenter(vec2 pos) { // Use a smoother falloff function float dist = length(pos - vec2(0.5, 0.5)) * 2.0; // Normalized 0-1 // Apply easing curve for smoother transition return smoothstep(0.0, 1.0, dist); } // Scene SDF float sdf(vec3 pos) { // Base result starts with a large value float result = MAX_DIST; // Animation parameters float t = uTime * uMovementSpeed; // Calculate dynamic movement scale based on mouse position if enabled float dynamicMovementScale = uMovementScale; if (uMouseProximityEffect) { float distToCenter = getDistanceToCenter(uMousePosition); // Use smoother interpolation between min and max scale // Add a bias to make the effect more subtle float t = smoothstep(0.0, 1.0, distToCenter); dynamicMovementScale = mix(uMinMovementScale, uMaxMovementScale, t); } // Create spheres based on count for (int i = 0; i < 10; i++) { if (i >= uSphereCount) break; // Unique parameters for each sphere float speed = 0.5 + float(i) * 0.1; float radius = 0.15 + float(i % 3) * 0.1; float orbitRadius = (0.5 + float(i % 5) * 0.2) * dynamicMovementScale; float phaseOffset = float(i) * PI * 0.2; // Calculate position with unique animation based on pattern vec3 offset; // Special movement for first two spheres - one going up, one going down if (i == 0) { // First sphere: bottom to top movement offset = vec3( sin(t * speed) * orbitRadius * 0.5, sin(t * 0.5) * orbitRadius, // Vertical movement cos(t * speed * 0.7) * orbitRadius * 0.5 ); } else if (i == 1) { // Second sphere: top to bottom movement (opposite of first) offset = vec3( sin(t * speed + PI) * orbitRadius * 0.5, -sin(t * 0.5) * orbitRadius, // Opposite vertical movement cos(t * speed * 0.7 + PI) * orbitRadius * 0.5 ); } else if (uMovementPattern == 0) { // Orbital pattern offset = vec3( sin(t * speed + phaseOffset) * orbitRadius, cos(t * (speed * 0.7) + phaseOffset * 1.3) * (orbitRadius * 0.6), sin(t * (speed * 0.5) + phaseOffset * 0.9) * (orbitRadius * 0.8) ); } else if (uMovementPattern == 1) { // Wave pattern float wave = sin(t * 0.5) * 0.5; offset = vec3( sin(t * 0.2 + float(i) * 0.5) * orbitRadius, sin(t * 0.3 + float(i) * 0.7 + wave) * orbitRadius * 0.5, cos(t * 0.4 + float(i) * 0.6) * orbitRadius * 0.7 ); } else if (uMovementPattern == 2) { // Chaos pattern offset = vec3( sin(t * speed * 1.1 + sin(t * 0.4) * 2.0) * orbitRadius, cos(t * speed * 0.9 + sin(t * 0.5) * 1.5) * orbitRadius * 0.8, sin(t * speed * 0.7 + sin(t * 0.6) * 1.8) * orbitRadius * 0.6 ); } else { // Pulse pattern float pulse = (sin(t * 0.8) * 0.5 + 0.5) * 0.5 + 0.5; offset = vec3( sin(t * speed + phaseOffset) * orbitRadius * pulse, cos(t * (speed * 0.7) + phaseOffset * 1.3) * (orbitRadius * 0.6) * pulse, sin(t * (speed * 0.5) + phaseOffset * 0.9) * (orbitRadius * 0.8) * pulse ); } // Apply individual rotation if enabled if (uIndividualRotation) { float rotSpeed = t * (0.2 + float(i) * 0.05); mat3 rot = rotateY(rotSpeed) * rotateX(rotSpeed * 0.7); offset = rot * offset; } // Apply sphere float sphere = sdSphere(pos + offset, radius); // Blend with smooth minimum result = smin(result, sphere, uSmoothness); } return result; } // Calculate normal at a point vec3 calcNormal(vec3 p) { vec2 e = vec2(EPSILON, 0.0); return normalize(vec3( sdf(p + e.xyy) - sdf(p - e.xyy), sdf(p + e.yxy) - sdf(p - e.yxy), sdf(p + e.yyx) - sdf(p - e.yyx) )); } // Ray marching float raymarch(vec3 ro, vec3 rd) { float t = 0.0; for (int i = 0; i < MAX_STEPS; i++) { vec3 p = ro + rd * t; float d = sdf(p); // Hit check if (d < EPSILON) { return t; } // Distance check if (t > MAX_DIST) { break; } // Adaptive step size for better detail near surfaces t += d * 0.8; } return -1.0; // No hit } // Soft shadows calculation float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) { float result = 1.0; float t = mint; for (int i = 0; i < 32; i++) { if (t >= maxt) break; float h = sdf(ro + rd * t); if (h < EPSILON) { return 0.0; } result = min(result, k * h / t); t += h; } return result; } // Ambient occlusion calculation float ambientOcclusion(vec3 p, vec3 n) { float occ = 0.0; float weight = 1.0; for (int i = 0; i < 5; i++) { float dist = 0.01 + 0.02 * float(i * i); float h = sdf(p + n * dist); occ += (dist - h) * weight; weight *= 0.85; } return clamp(1.0 - occ, 0.0, 1.0); } // Lighting calculation vec3 lighting(vec3 p, vec3 rd, float t) { if (t < 0.0) { return vec3(0.0); // Return transparent color } vec3 normal = calcNormal(p); vec3 viewDir = -rd; // Base color vec3 baseColor = uSphereColor; // Ambient light vec3 ambient = baseColor * uAmbientIntensity; // Directional light vec3 lightDir = normalize(uLightPosition); float diff = max(dot(normal, lightDir), 0.0); vec3 diffuse = baseColor * uLightColor * diff * uDiffuseIntensity; // Specular highlight vec3 reflectDir = reflect(-lightDir, normal); float spec = pow(max(dot(viewDir, reflectDir), 0.0), uSpecularPower); vec3 specular = uLightColor * spec * uSpecularIntensity; // Fresnel effect float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), uFresnelPower); specular *= fresnel; // Ambient occlusion float ao = ambientOcclusion(p, normal); // Soft shadows float shadow = softShadow(p, lightDir, 0.01, 10.0, 16.0); // Combine lighting vec3 color = ambient * ao + (diffuse * shadow + specular) * ao; // Apply contrast color = pow(color, vec3(uContrast)); return color; } void main() { // Calculate UV coordinates vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / uResolution.y; // Camera setup vec3 ro = vec3(0.0, 0.0, -uCameraDistance); vec3 rd = normalize(vec3(uv, 1.0)); // Apply slight camera rotation for more interesting view float camRotY = sin(uTime * 0.1) * 0.1; float camRotX = cos(uTime * 0.08) * 0.05; rd = rotateY(camRotY) * rotateX(camRotX) * rd; // Ray marching float t = raymarch(ro, rd); // Calculate hit position vec3 p = ro + rd * t; // Calculate color vec3 color = lighting(p, rd, t); // Apply fog with transparency if (t > 0.0) { float fogAmount = 1.0 - exp(-t * uFogDensity); color = mix(color, uBackgroundColor, fogAmount); fragColor = vec4(color, 1.0); } else { // Transparent background fragColor = vec4(0.0, 0.0, 0.0, 0.0); } } `; } // Log a message to confirm the code is running console.log( \"Ray marching visualization finished: You look great dev, are awesome!\" ); document.addEventListener(\"DOMContentLoaded\", function () { const emailLink = document.querySelector(\".contact-email\"); const originalText = emailLink.textContent; emailLink.addEventListener(\"click\", function (e) { // Copy email to clipboard navigator.clipboard .writeText(\"hi@filip.fyi\") .then(function () { // Change text to show it was copied emailLink.textContent = \"e-mail copied to clipboard\"; // After 2 seconds, change back to original text setTimeout(function () { emailLink.textContent = originalText; }, 2000); }) .catch(function (err) { console.error(\"Could not copy email: \", err); }); }); });",
    "id": "threejsgsap--threejs-raymarching-layout-explorations-with-gsap-n3"
  },
  {
    "title": "Cyberspace Portal ",
    "description": "",
    "code": "index.html: <div id=\"portalCard\"> \t<div class=\"gooey-effect\"> \t\t<div class=\"gooey-blob\"></div> \t\t<div class=\"gooey-blob\"></div> \t\t<div class=\"gooey-blob\"></div> \t\t<div class=\"gooey-blob\"></div> \t</div> \t<div id=\"portalContent\"> \t\t<h1>ENTER<br>THE PORTAL</h1> \t\t<button id=\"portalButton\">GO</button> \t</div> \t<canvas class=\"card-bg\" id=\"cardBgEffect\"></canvas> </div> <div id=\"tunnelContainer\"> \t<canvas id=\"tunnelCanvas\"></canvas> </div>\nstyle.css: :root { \t--title: \"Cyberspace Portal\"; \t--author: \"Matt Cannon\"; \t--contact: \"mc@mattcannon.design\"; \t--description: \"An interactive card featuring a mesmerizing glow effect that invites you to enter a portal. Once activated, you are unexpectedly sucked into the matrix, traveling through a digital tunnel filled with floating code snippets and particles, immersing you in a journey through cyberspace.\"; \t--keywords: \"card glow, portal, interactive card, box-shadow, 3D tunnel, Three.js, animation, CSS animation, JavaScript animation, particle effects, glowing effects, codepenchallenge, cpc-card-glow, immersive web experience\"; \t--last-modified: \"2025-04-15\"; \t--content-language: \"en\"; \t--generator: \"HTML5, CSS3, JavaScript, Three.js, requestAnimationFrames,\"; } * { \tmargin: 0; \tpadding: 0; \tbox-sizing: border-box; } body { \toverflow: hidden; \tbackground: url(\"http://mattcannon.games/codepen/glow/background.png\") \t\tno-repeat center center fixed; \tbackground-size: cover; \tbackground-color: #0a0a0a; \tfont-family: \"Unica One\", sans-serif; \tdisplay: flex; \talign-items: center; \tjustify-content: center; \theight: 100vh; \tposition: relative; \tperspective: 2000px; } #portalCard { \tposition: absolute; \twidth: 300px; \theight: 350px; \tbackground: rgba(10, 12, 18, 0.6); \tbackdrop-filter: blur(10px); \tborder-radius: 20px; \tborder: 1px solid rgba(0, 255, 170, 0.8); \tbox-shadow: 0 0 30px rgba(0, 255, 170, 0.5), 0 0 50px rgba(0, 179, 255, 0.3), \t\tinset 0 0 20px rgba(0, 255, 170, 0.2); \tdisplay: flex; \tflex-direction: column; \talign-items: center; \tjustify-content: center; \ttransition: all 2.2s cubic-bezier(0.1, 1, 0.1, 1); \tz-index: 10; \toverflow: hidden; \ttransform-style: preserve-3d; \tposition: relative; \ttransform: scale(0.85); } #portalCard::before { \tcontent: \"\"; \tposition: absolute; \tinset: 0; \tborder-radius: 19px; \tpadding: 1px; \tbackground: linear-gradient(135deg, #00ffaa, #00a3ff); \t-webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0); \t-webkit-mask-composite: xor; \tmask-composite: exclude; \topacity: 0.9; \ttransition: opacity 1.5s ease; \tz-index: 2; \tbox-shadow: 0 0 20px rgba(0, 255, 170, 1); } #portalCard::after { \tcontent: \"\"; \tposition: absolute; \tinset: 0; \tborder-radius: 20px; \tbackground: linear-gradient( \t\t135deg, \t\trgba(0, 255, 170, 0.15) 0%, \t\trgba(0, 179, 255, 0.15) 100% \t); \topacity: 0.5; \tz-index: 1; } .gooey-effect { \tposition: absolute; \tinset: 0; \tborder-radius: 20px; \toverflow: hidden; \tz-index: 0; \topacity: 0.9; \tfilter: blur(2px); } .gooey-blob { \tposition: absolute; \tborder-radius: 50%; \tfilter: blur(12px); \tanimation: float-blob 15s infinite ease-in-out; \topacity: 0.9; } .gooey-blob:nth-child(1) { \twidth: 250px; \theight: 250px; \tleft: -50px; \ttop: 100px; \tbackground: radial-gradient( \t\tcircle, \t\trgba(0, 255, 170, 0.7) 0%, \t\trgba(0, 255, 170, 0) 70% \t); \tanimation-duration: 8s; } .gooey-blob:nth-child(2) { \twidth: 200px; \theight: 200px; \tright: -30px; \ttop: 50px; \tbackground: radial-gradient( \t\tcircle, \t\trgba(0, 179, 255, 0.7) 0%, \t\trgba(0, 179, 255, 0) 70% \t); \tanimation-duration: 8s; \tanimation-delay: -3s; } .gooey-blob:nth-child(3) { \twidth: 180px; \theight: 180px; \tright: 50px; \tbottom: 100px; \tbackground: radial-gradient( \t\tcircle, \t\trgba(0, 255, 170, 0.7) 0%, \t\trgba(0, 255, 170, 0) 70% \t); \tanimation-duration: 10s; \tanimation-delay: -4s; } .gooey-blob:nth-child(4) { \twidth: 220px; \theight: 220px; \tleft: 30px; \tbottom: 30px; \tbackground: radial-gradient( \t\tcircle, \t\trgba(0, 179, 255, 0.7) 0%, \t\trgba(0, 179, 255, 0) 70% \t); \tanimation-duration: 10s; \tanimation-delay: -4s; } @keyframes float-blob { \t0%, \t100% { \t\ttransform: translate(0, 0) scale(1); \t} \t20% { \t\ttransform: translate(30px, 20px) scale(1.05); \t} \t40% { \t\ttransform: translate(20px, 40px) scale(0.95); \t} \t60% { \t\ttransform: translate(-20px, 30px) scale(1.1); \t} \t80% { \t\ttransform: translate(-30px, -20px) scale(0.9); \t} } #portalCard:hover .cursor-blur { \ttransform: scale(1); \ttransition: transform 1s ease-out; } #portalCard h1 { \tcolor: white; \tfont-weight: 300; \tfont-size: 40px; \tmargin-bottom: 20px; \ttext-transform: uppercase; \tletter-spacing: 2px; \ttransition: all 0.8s ease; \ttext-shadow: 0 0 15px rgba(0, 255, 170, 0.7); \tposition: relative; \tz-index: 5; \tline-height: 1; \ttext-align: center; } #portalButton { \tpadding: 16px 38px; \tbackground: rgba(10, 12, 20, 0.3); \tborder: 2px solid #00ffaa; \tborder-radius: 50px; \tcolor: white; \tfont-family: \"Unica One\", sans-serif; \tfont-weight: 400; \tfont-size: 22px; \tletter-spacing: 1px; \tcursor: pointer; \ttransition: all 0.3s ease; \tposition: relative; \tz-index: 20; \tbackdrop-filter: blur(5px); \toverflow: hidden; \tbox-shadow: 0 0 10px rgba(0, 255, 170, 0.5); \ttext-shadow: 0 0 5px rgba(0, 255, 255, 0.5); } #portalButton::before { \tcontent: \"\"; \tposition: absolute; \ttop: 0; \tleft: 0; \twidth: 100%; \theight: 100%; \tbackground: linear-gradient( \t\t90deg, \t\trgba(0, 255, 170, 0.3), \t\trgba(0, 179, 255, 0.3) \t); \topacity: 0; \ttransition: opacity 0.3s ease; } #portalButton:hover { \ttransform: scale(1.05); \tbox-shadow: 0 0 15px rgba(0, 255, 170, 0.7); \ttext-shadow: 0 0 10px rgba(0, 255, 255, 0.8); \tborder-color: #00ffdd; } #portalButton:hover::before { \topacity: 1; } #tunnelCanvas { \tposition: absolute; \ttop: 0; \tleft: 0; \twidth: 100%; \theight: 100%; \tclip-path: circle(10% at 50% 50%); \ttransition: clip-path 1.8s ease-out; } #tunnelCanvas.active { \tclip-path: circle(150% at 50% 50%); } #portalContent { \ttransition: all 1.1s ease; \tdisplay: flex; \tflex-direction: column; \talign-items: center; \tjustify-content: center; \tz-index: 5; } #tunnelContainer { \tposition: absolute; \ttop: 0; \tleft: 0; \twidth: 100vw; \theight: 100vh; \tdisplay: flex; \talign-items: center; \tjustify-content: center; \tz-index: 1; \tpointer-events: none; \ttransform-style: preserve-3d; \ttransition: all 0s; } #tunnelContainer.active { \tpointer-events: all; \tz-index: 15; } #portalCard.zoomIn { \ttransform: translateZ(500px) scale(6); \topacity: 0; \ttransition: transform 2s ease-out, opacity 1.5s ease-in; } #portalCard.zoomIn::before, #portalCard.zoomIn::after { \topacity: 0; } #portalCard.zoomIn #portalContent { \topacity: 0; \ttransform: scale(0.5); } .card-bg { \tposition: absolute; \ttop: 0; \tleft: 0; \twidth: 100%; \theight: 100%; \topacity: 0.1; \tpointer-events: none; \tz-index: -1; }\nscript.js: (function () { \tconst canvas = document.getElementById(\"cardBgEffect\"), \t\tctx = canvas.getContext(\"2d\"); \tfunction resize() { \t\tcanvas.width = canvas.parentElement.offsetWidth; \t\tcanvas.height = canvas.parentElement.offsetHeight; \t} \tresize(); \twindow.addEventListener(\"resize\", resize); \tconst particles = [], \t\tparticleCount = 50; \tfor (let i = 0; i < particleCount; i++) { \t\tparticles.push({ \t\t\tx: Math.random() * canvas.width, \t\t\ty: Math.random() * canvas.height, \t\t\tradius: Math.random() * 2 + 1, \t\t\tvx: Math.random() * 2 - 1, \t\t\tvy: Math.random() * 2 - 1, \t\t\tcolor: `rgba(0, ${Math.floor(Math.random() * 150 + 150)}, ${Math.floor( \t\t\t\tMath.random() * 100 + 180 \t\t\t)}, 0.7)` \t\t}); \t} \tfunction animate() { \t\trequestAnimationFrame(animate); \t\tctx.clearRect(0, 0, canvas.width, canvas.height); \t\tfor (let i = 0; i < particleCount; i++) { \t\t\tconst p = particles[i]; \t\t\tp.x += p.vx; \t\t\tp.y += p.vy; \t\t\tif (p.x < 0 || p.x > canvas.width) p.vx *= -1; \t\t\tif (p.y < 0 || p.y > canvas.height) p.vy *= -1; \t\t\tconst gradient = ctx.createRadialGradient( \t\t\t\tp.x, \t\t\t\tp.y, \t\t\t\t0, \t\t\t\tp.x, \t\t\t\tp.y, \t\t\t\tp.radius * 2 \t\t\t); \t\t\tgradient.addColorStop(0, \"rgba(255,255,255,1)\"); \t\t\tgradient.addColorStop(1, \"rgba(255,255,255,0)\"); \t\t\tctx.fillStyle = gradient; \t\t\tctx.beginPath(); \t\t\tctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); \t\t\tctx.fill(); \t\t\tfor (let j = i + 1; j < particleCount; j++) { \t\t\t\tconst p2 = particles[j], \t\t\t\t\tdistance = Math.sqrt(Math.pow(p.x - p2.x, 2) + Math.pow(p.y - p2.y, 2)); \t\t\t\tif (distance < 100) { \t\t\t\t\tctx.beginPath(); \t\t\t\t\tctx.strokeStyle = `rgba(0, 220, 180, ${0.1 * (1 - distance / 100)})`; \t\t\t\t\tctx.lineWidth = 0.5; \t\t\t\t\tctx.moveTo(p.x, p.y); \t\t\t\t\tctx.lineTo(p2.x, p2.y); \t\t\t\t\tctx.stroke(); \t\t\t\t} \t\t\t} \t\t} \t} \tanimate(); })(); const card = document.getElementById(\"portalCard\"), \tbutton = document.getElementById(\"portalButton\"), \tcanvasTunnel = document.getElementById(\"tunnelCanvas\"), \ttunnelContainer = document.getElementById(\"tunnelContainer\"); card.addEventListener(\"click\", startPortal); button.addEventListener(\"click\", (e) => { \te.stopPropagation(); \tstartPortal(); }); function startPortal() { \t// Hide the background immediately \tdocument.body.style.backgroundImage = \"none\"; \tdocument.body.style.backgroundColor = \"#000000\"; \tcanvasTunnel.style.display = \"block\"; \ttunnelContainer.style.display = \"flex\"; \tinitTunnel(); \trender(); \tsetTimeout(() => { \t\tcanvasTunnel.classList.add(\"active\"); \t\tcard.classList.add(\"zoomIn\"); \t\tsetTimeout(() => { \t\t\tcard.style.display = \"none\"; \t\t}, 2000); \t}, 100); } function createCircularPath() { \tconst points = []; \tconst totalPoints = 200; \tconst controlPoints = [ \t\tnew THREE.Vector3(0, 0, 0), \t\tnew THREE.Vector3(20, 10, -50), \t\tnew THREE.Vector3(40, -10, -100), \t\tnew THREE.Vector3(60, 15, -150), \t\tnew THREE.Vector3(50, -5, -200), \t\tnew THREE.Vector3(0, 0, -250), \t\tnew THREE.Vector3(-100, 0, -200), \t\tnew THREE.Vector3(-150, 0, -100), \t\tnew THREE.Vector3(-100, 0, 0), \t\tnew THREE.Vector3(-50, 10, 100), \t\tnew THREE.Vector3(-20, -10, 150), \t\tnew THREE.Vector3(0, 0, 200) \t]; \tconst curve = new THREE.CatmullRomCurve3(controlPoints); \tcurve.tension = 0.1; \tfor (let i = 0; i < totalPoints; i++) { \t\tconst t = i / (totalPoints - 1), \t\t\tpoint = curve.getPoint(t); \t\tpoints.push(point); \t} \treturn points; } function returnToHome() { \tconst approachAnimation = { \t\tprogress: 0, \t\tduration: 1200, \t\tstartTime: Date.now(), \t\tstartPosition: camera.position.clone(), \t\ttargetPosition: new THREE.Vector3( \t\t\ttunnelEndPoint.x - 5, \t\t\ttunnelEndPoint.y, \t\t\ttunnelEndPoint.z - 5 \t\t), \t\tupdate: function () { \t\t\tconst elapsed = Date.now() - this.startTime; \t\t\tthis.progress = Math.min(elapsed / this.duration, 1); \t\t\tconst t = \t\t\t\tthis.progress < 0.5 \t\t\t\t\t? 4 * this.progress * this.progress * this.progress \t\t\t\t\t: 1 - Math.pow(-2 * this.progress + 2, 3) / 2; \t\t\tcamera.position.lerpVectors(this.startPosition, this.targetPosition, t); \t\t\tif (this.progress >= 1) startPortalTransition(); \t\t} \t}; \tfunction startPortalTransition() { \t\tconst zoomAnimation = { \t\t\tprogress: 0, \t\t\tduration: 800, \t\t\tstartTime: Date.now(), \t\t\tstartPosition: camera.position.clone(), \t\t\ttargetPosition: new THREE.Vector3( \t\t\t\ttunnelEndPoint.x + 2, \t\t\t\ttunnelEndPoint.y, \t\t\t\ttunnelEndPoint.z + 2 \t\t\t), \t\t\tupdate: function () { \t\t\t\tconst elapsed = Date.now() - this.startTime; \t\t\t\tthis.progress = Math.min(elapsed / this.duration, 1); \t\t\t\tconst t = this.progress * this.progress; \t\t\t\tcamera.position.lerpVectors(this.startPosition, this.targetPosition, t); \t\t\t\tif (this.progress > 0.5 && this.progress < 0.6) { \t\t\t\t\tscene.background = new THREE.Color(0xffffff); \t\t\t\t\tscene.fog = null; \t\t\t\t} else if (this.progress >= 0.6) { \t\t\t\t\tscene.background = new THREE.Color(0x000000); \t\t\t\t\tscene.fog = new THREE.FogExp2(0x000000, 0.005); \t\t\t\t\tif (this.progress >= 1) completePortalLoop(); \t\t\t\t} \t\t\t} \t\t}; \t\tanimationQueue.push(zoomAnimation); \t} \tfunction completePortalLoop() { \t\tconst tunnelCanvas = document.getElementById(\"tunnelCanvas\"); \t\ttunnelCanvas.style.transition = \"opacity 0.7s ease-out\"; \t\ttunnelCanvas.style.opacity = \"0\"; \t\tconst card = document.getElementById(\"portalCard\"); \t\tcard.classList.remove(\"zoomIn\"); \t\tsetTimeout(() => { \t\t\ttunnelCanvas.style.display = \"none\"; \t\t\tcard.style.display = \"flex\"; \t\t\tcard.style.opacity = \"0\"; \t\t\tcard.style.transform = \"scale(0.8)\"; \t\t\tcard.style.transition = \"all 1s ease-out\"; \t\t\tsetTimeout(() => { \t\t\t\tcard.style.opacity = \"1\"; \t\t\t\tcard.style.transform = \"scale(1)\"; \t\t\t\tconst portalContent = document.getElementById(\"portalContent\"); \t\t\t\tportalContent.style.opacity = \"1\"; \t\t\t\tportalContent.style.transform = \"scale(1)\"; \t\t\t}, 50); \t\t}, 700); \t\tcancelAnimationFrame(renderFrameId); \t\tisAnimating = false; \t} \tanimationQueue.push(approachAnimation); } const animationQueue = []; let isAnimating = true, \ttunnelEndPoint, \trenderFrameId, \thoverTime = 0; var w = window.innerWidth, \th = window.innerHeight; var cameraSpeed = 0.00015, \tlightSpeed = 0.001, \ttubularSegments = 1200, \tradialSegments = 12, \ttubeRadius = 3; var renderer, scene, camera, tube; var lights = [], \tpath, \tgeometry, \tmaterial, \tpct = 0, \tpct2 = 0; function captureCardFrontImage() { \tconst canvas = document.createElement(\"canvas\"); \tcanvas.width = 1280; \tcanvas.height = 1820; \tconst ctx = canvas.getContext(\"2d\"); \tctx.fillStyle = \"rgba(10, 12, 18, 0.6)\"; \tctx.fillRect(0, 0, canvas.width, canvas.height); \tconst gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height); \tgradient.addColorStop(0, \"#00ffaa\"); \tgradient.addColorStop(1, \"#00a3ff\"); \tfunction drawBlob(x, y, wid, hei, color) { \t\tconst grad = ctx.createRadialGradient(x, y, 0, x, y, wid / 2); \t\tgrad.addColorStop(0, color); \t\tgrad.addColorStop(1, \"rgba(0,0,0,0)\"); \t\tctx.fillStyle = grad; \t\tctx.beginPath(); \t\tctx.ellipse(x, y, wid / 2, hei / 2, 0, 0, Math.PI * 2); \t\tctx.fill(); \t} \tctx.filter = \"blur(12px)\"; \tdrawBlob(150, 300, 250, 250, \"rgba(0, 255, 170, 0.7)\"); \tdrawBlob(350, 200, 200, 200, \"rgba(0, 179, 255, 0.7)\"); \tdrawBlob(250, 500, 180, 180, \"rgba(64, 224, 208, 0.7)\"); \tdrawBlob(400, 600, 220, 220, \"rgba(30, 144, 255, 0.7)\"); \tctx.filter = \"none\"; \tctx.font = \"300 40px Unica One\"; \tctx.fillStyle = \"white\"; \tctx.textAlign = \"center\"; \tctx.textBaseline = \"middle\"; \tctx.shadowColor = \"rgba(0, 255, 170, 0.7)\"; \tctx.shadowBlur = 15; \tctx.fillText(\"ENTER THE\", canvas.width / 2, canvas.height / 2 - 30); \tctx.fillText(\"WEB PORTAL\", canvas.width / 2, canvas.height / 2 + 30); \tctx.shadowBlur = 0; \tconst buttonX = canvas.width / 2, \t\tbuttonY = canvas.height / 2 + 120; \tctx.fillStyle = \"rgba(10, 12, 20, 0.3)\"; \tctx.strokeStyle = \"#00ffaa\"; \tctx.lineWidth = 2; \tctx.beginPath(); \tif (ctx.roundRect) { \t\tctx.roundRect(buttonX - 38, buttonY - 16, 76, 32, 16); \t} else { \t\tctx.moveTo(buttonX - 38, buttonY - 16); \t\tctx.lineTo(buttonX + 38, buttonY - 16); \t\tctx.lineTo(buttonX + 38, buttonY + 16); \t\tctx.lineTo(buttonX - 38, buttonY + 16); \t\tctx.closePath(); \t} \tctx.fill(); \tctx.stroke(); \tctx.font = \"400 20px Unica One\"; \tctx.fillStyle = \"white\"; \tctx.shadowColor = \"rgba(0, 255, 255, 0.5)\"; \tctx.shadowBlur = 5; \tctx.fillText(\"GO\", buttonX, buttonY); \treturn canvas; } function createBackOfPortalCard() { \tconst geometry = new THREE.PlaneGeometry(20, 28); \t// Create a new canvas for the back of the card rather than flipping \tconst canvas = document.createElement(\"canvas\"); \tcanvas.width = 1280; \tcanvas.height = 1820; \tconst ctx = canvas.getContext(\"2d\"); \t// Match the front card but with slight variation \tctx.fillStyle = \"rgba(10, 12, 18, 0.6)\"; \tctx.fillRect(0, 0, canvas.width, canvas.height); \t// Same gradient but reversed direction \tconst gradient = ctx.createLinearGradient(canvas.width, canvas.height, 0, 0); \tgradient.addColorStop(0, \"#00ffaa\"); \tgradient.addColorStop(1, \"#00a3ff\"); \t// Create blobs with same function from captureCardFrontImage \tfunction drawBlob(x, y, wid, hei, color) { \t\tconst grad = ctx.createRadialGradient(x, y, 0, x, y, wid / 2); \t\tgrad.addColorStop(0, color); \t\tgrad.addColorStop(1, \"rgba(0,0,0,0)\"); \t\tctx.fillStyle = grad; \t\tctx.beginPath(); \t\tctx.ellipse(x, y, wid / 2, hei / 2, 0, 0, Math.PI * 2); \t\tctx.fill(); \t} \t// Add glowing blobs in different positions \tctx.filter = \"blur(12px)\"; \tdrawBlob(400, 400, 250, 250, \"rgba(0, 255, 170, 0.7)\"); \tdrawBlob(200, 300, 200, 200, \"rgba(0, 179, 255, 0.7)\"); \tdrawBlob(350, 700, 180, 180, \"rgba(64, 224, 208, 0.7)\"); \tdrawBlob(200, 900, 220, 220, \"rgba(30, 144, 255, 0.7)\"); \tctx.filter = \"none\"; \t// Add text to back of card \tctx.font = \"300 40px Unica One\"; \tctx.fillStyle = \"white\"; \tctx.textAlign = \"center\"; \tctx.textBaseline = \"middle\"; \tctx.shadowColor = \"rgba(0, 255, 170, 0.7)\"; \tctx.shadowBlur = 15; \tctx.fillText(\"YOU'VE REACHED THE\", canvas.width / 2, canvas.height / 2 - 30); \tctx.fillText(\"END OF THE INTERNET\", canvas.width / 2, canvas.height / 2 + 30); \tctx.shadowBlur = 0; \t// Create a texture from the canvas \tconst texture = new THREE.CanvasTexture(canvas); \tconst material = new THREE.MeshBasicMaterial({ \t\tmap: texture, \t\ttransparent: true, \t\topacity: 0.9, \t\tside: THREE.DoubleSide \t}); \treturn new THREE.Mesh(geometry, material); } function createCodeSnippetSprite(text) { \tconst canvas = document.createElement(\"canvas\"); \tcanvas.width = 300; \tcanvas.height = 150; \tconst ctx = canvas.getContext(\"2d\"); \tctx.fillStyle = \"#2d2d2d\"; \tctx.fillRect(0, 0, canvas.width, canvas.height); \tctx.font = \"20px monospace\"; \tctx.fillStyle = \"#8be9fd\"; \tctx.textAlign = \"left\"; \tctx.textBaseline = \"top\"; \tlet lines = text.split(\"\\n\"); \tfor (let i = 0; i < lines.length; i++) { \t\tctx.fillText(lines[i], 10, 10 + i * 24); \t} \tconst texture = new THREE.CanvasTexture(canvas); \ttexture.minFilter = THREE.LinearFilter; \tconst material = new THREE.SpriteMaterial({ \t\tmap: texture, \t\ttransparent: true \t}); \tconst sprite = new THREE.Sprite(material); \tsprite.scale.set(15, 7.5, 1); \treturn sprite; } function initTunnel() { \trenderer = new THREE.WebGLRenderer({ \t\tcanvas: canvasTunnel, \t\tantialias: true, \t\talpha: true, \t\tpowerPreference: \"high-performance\" \t}); \trenderer.setSize(w, h); \tscene = new THREE.Scene(); \tscene.fog = new THREE.FogExp2(0x000000, 0.005); \tcamera = new THREE.PerspectiveCamera(60, w / h, 0.1, 1000); \tconst raycaster = new THREE.Raycaster(), \t\tmouse = new THREE.Vector2(); \tcanvasTunnel.addEventListener(\"click\", function (event) { \t\tmouse.x = (event.clientX / window.innerWidth) * 2 - 1; \t\tmouse.y = -(event.clientY / window.innerHeight) * 2 + 1; \t\traycaster.setFromCamera(mouse, camera); \t\tconst intersects = raycaster.intersectObjects(scene.children); \t\tfor (let i = 0; i < intersects.length; i++) { \t\t\tif ( \t\t\t\tintersects[i].object.userData && \t\t\t\tintersects[i].object.userData.isBackCard \t\t\t) { \t\t\t\treturnToHome(); \t\t\t\tbreak; \t\t\t} \t\t} \t}); \tconst starsCount = 2000; \tconst starsPositions = new Float32Array(starsCount * 3); \tfor (let i = 0; i < starsCount; i++) { \t\tstarsPositions[i * 3] = THREE.MathUtils.randFloatSpread(1500); \t\tstarsPositions[i * 3 + 1] = THREE.MathUtils.randFloatSpread(1500); \t\tstarsPositions[i * 3 + 2] = THREE.MathUtils.randFloatSpread(1500); \t} \tconst starsGeometry = new THREE.BufferGeometry(); \tstarsGeometry.setAttribute( \t\t\"position\", \t\tnew THREE.BufferAttribute(starsPositions, 3) \t); \tconst starsTexture = new THREE.CanvasTexture(createCircleTexture()); \tconst starsMaterial = new THREE.PointsMaterial({ \t\tcolor: 0xffffff, \t\tsize: 1, \t\tmap: starsTexture, \t\ttransparent: true \t}); \tconst starField = new THREE.Points(starsGeometry, starsMaterial); \tscene.add(starField); \tconst organicPoints = createCircularPath(); \tpath = new THREE.CatmullRomCurve3(organicPoints); \tconst tubeGeometry = new THREE.TubeBufferGeometry( \t\tpath, \t\ttubularSegments, \t\ttubeRadius, \t\tradialSegments, \t\tfalse \t); \tconst colors = []; \tfor (let i = 0; i < tubeGeometry.attributes.position.count; i++) { \t\tconst color = new THREE.Color(i % 2 === 0 ? \"#00a3ff\" : \"#00ffaa\"); \t\tcolors.push(color.r, color.g, color.b); \t} \ttubeGeometry.setAttribute( \t\t\"color\", \t\tnew THREE.Float32BufferAttribute(colors, 3) \t); \tmaterial = new THREE.MeshLambertMaterial({ \t\tside: THREE.BackSide, \t\tvertexColors: true, \t\twireframe: true, \t\temissive: 0x333333, \t\temissiveIntensity: 0.4 \t}); \ttube = new THREE.Mesh(tubeGeometry, material); \tscene.add(tube); \tconst backOfCard = createBackOfPortalCard(); \tconst endPoint = organicPoints.length - 1; \tconst position = organicPoints[endPoint]; \tbackOfCard.position.set(position.x, position.y, position.z); \ttunnelEndPoint = position; \tbackOfCard.lookAt(organicPoints[endPoint - 5]); \tbackOfCard.userData = { isBackCard: true }; \tscene.add(backOfCard); \tconst mainLight = new THREE.PointLight(0xffffff, 1, 50); \tscene.add(mainLight); \tscene.add(new THREE.AmbientLight(0x555555)); \tconst lightColors = [0x00a3ff, 0x00ffaa, 0x00a3ff, 0x00ffaa, 0xffffff]; \tfor (let i = 0; i < 5; i++) { \t\tconst offset = i * 0.15 + (i % 3) * 0.05; \t\tlet l = new THREE.PointLight(lightColors[i], 1.2, 20); \t\tlights.push(l); \t\tscene.add(l); \t} \tconst snippetVarieties = [ \t\t// HTML Card Snippet \t\t[ \t\t\t'<div class=\"card\">', \t\t\t\" <h1>Let it Glow</h1>\", \t\t\t\" <p>With a little bit of CSS light.</p>\", \t\t\t\"</div>\" \t\t].join(\"\\n\"), \t\t// CSS Glow Snippet \t\t[ \t\t\t\".card {\", \t\t\t\" background-color: #1b1b1b;\", \t\t\t\" border-radius: 12px;\", \t\t\t\" box-shadow: 0 8px 20px -4px greenyellow;\", \t\t\t\"}\" \t\t].join(\"\\n\"), \t\t// Advanced Glow CSS \t\t[ \t\t\t\".glow-card {\", \t\t\t\" box-shadow:\", \t\t\t\" 0 0 10px rgba(0, 255, 170, 0.5),\", \t\t\t\" 0 0 20px rgba(0, 255, 170, 0.3),\", \t\t\t\" inset 0 0 10px rgba(0, 255, 170, 0.2);\", \t\t\t\"}\" \t\t].join(\"\\n\"), \t\t// JavaScript Interaction \t\t[ \t\t\t\"document.querySelector('.card').addEventListener('mousemove', (e) => {\", \t\t\t\" const { x, y } = e;\", \t\t\t\" updateGlowPosition(x, y);\", \t\t\t\"});\" \t\t].join(\"\\n\"), \t\t// Card Animation \t\t[ \t\t\t\"@keyframes pulse-glow {\", \t\t\t\" 0% { box-shadow: 0 0 10px #00ffaa; }\", \t\t\t\" 50% { box-shadow: 0 0 30px #00a3ff; }\", \t\t\t\" 100% { box-shadow: 0 0 10px #00ffaa; }\", \t\t\t\"}\" \t\t].join(\"\\n\"), \t\t// Reactive Glow Function \t\t[ \t\t\t\"function createDirectionalGlow(event, element) {\", \t\t\t\" const rect = element.getBoundingClientRect();\", \t\t\t\" const x = event.clientX - rect.left;\", \t\t\t\" const y = event.clientY - rect.top;\", \t\t\t\" // Set glow position based on cursor\", \t\t\t\"}\" \t\t].join(\"\\n\"), \t\t// SVG Filter Glow \t\t[ \t\t\t'<filter id=\"glow\">', \t\t\t' <feGaussianBlur stdDeviation=\"5\" result=\"blur\"/>', \t\t\t' <feColorMatrix in=\"blur\" values=\"0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 15 0\"/>', \t\t\t\"</filter>\" \t\t].join(\"\\n\"), \t\t// CSS Variables for Glow \t\t[ \t\t\t\":root {\", \t\t\t\" --glow-color: #00ffaa;\", \t\t\t\" --glow-spread: 8px;\", \t\t\t\" --glow-opacity: 0.7;\", \t\t\t\"}\" \t\t].join(\"\\n\"), \t\t// Card Hover Effect \t\t[ \t\t\t\".card:hover {\", \t\t\t\" box-shadow:\", \t\t\t\" 0 0 15px rgba(0, 255, 170, 0.8),\", \t\t\t\" 0 0 30px rgba(0, 255, 170, 0.4);\", \t\t\t\" transition: box-shadow 0.3s ease;\", \t\t\t\"}\" \t\t].join(\"\\n\") \t]; \tfor (let i = 0; i < 100; i++) { \t\t// Use a random snippet from our variety \t\tlet snippet = \t\t\tsnippetVarieties[Math.floor(Math.random() * snippetVarieties.length)]; \t\tlet sprite = createCodeSnippetSprite(snippet); \t\tsprite.position.set( \t\t\t(Math.random() - 0.5) * 400, \t\t\t(Math.random() - 0.5) * 400, \t\t\t(Math.random() - 0.5) * 400 \t\t); \t\tscene.add(sprite); \t} \t// Add more white/star particles \tconst additionalStars = 5000; \tconst additionalStarsPositions = new Float32Array(additionalStars * 3); \tfor (let i = 0; i < additionalStars; i++) { \t\tadditionalStarsPositions[i * 3] = THREE.MathUtils.randFloatSpread(2000); \t\tadditionalStarsPositions[i * 3 + 1] = THREE.MathUtils.randFloatSpread(2000); \t\tadditionalStarsPositions[i * 3 + 2] = THREE.MathUtils.randFloatSpread(2000); \t} \tconst additionalStarsGeometry = new THREE.BufferGeometry(); \tadditionalStarsGeometry.setAttribute( \t\t\"position\", \t\tnew THREE.BufferAttribute(additionalStarsPositions, 3) \t); \tconst additionalStarsMaterial = new THREE.PointsMaterial({ \t\tcolor: 0xffffff, \t\tsize: 2, \t\topacity: 0.7, \t\ttransparent: true, \t\tmap: starsTexture \t}); \tconst additionalStarField = new THREE.Points( \t\tadditionalStarsGeometry, \t\tadditionalStarsMaterial \t); \tscene.add(additionalStarField); \twindow.onresize = function () { \t\tw = window.innerWidth; \t\th = window.innerHeight; \t\tcamera.aspect = w / h; \t\tcamera.updateProjectionMatrix(); \t\trenderer.setSize(w, h); \t}; } function createCircleTexture() { \tconst canvas = document.createElement(\"canvas\"); \tcanvas.width = 32; \tcanvas.height = 32; \tconst context = canvas.getContext(\"2d\"); \t// Draw a circle \tcontext.beginPath(); \tcontext.arc(16, 16, 16, 0, 2 * Math.PI, false); \tcontext.fillStyle = \"white\"; \tcontext.fill(); \t// Add a soft glow effect \tconst gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16); \tgradient.addColorStop(0, \"rgba(255, 255, 255, 1)\"); \tgradient.addColorStop(0.5, \"rgba(255, 255, 255, 0.5)\"); \tgradient.addColorStop(1, \"rgba(255, 255, 255, 0)\"); \tcontext.globalCompositeOperation = \"source-over\"; \tcontext.fillStyle = gradient; \tcontext.beginPath(); \tcontext.arc(16, 16, 16, 0, 2 * Math.PI, false); \tcontext.fill(); \treturn canvas; } function render() { \tpct += cameraSpeed; \tif (pct >= 0.995) { \t\tpct = 0; \t} \tpct2 += lightSpeed; \tif (pct2 >= 0.995) { \t\tpct2 = 0; \t} \tconst pt1 = path.getPointAt(pct), \t\tlookAheadPct = Math.min(pct + 0.01, 0.995), \t\tpt2 = path.getPointAt(lookAheadPct); \tcamera.position.set(pt1.x, pt1.y, pt1.z); \tcamera.lookAt(pt2); \tconst mainLight = lights[0]; \tmainLight.position.set(pt2.x, pt2.y, pt2.z); \tfor (let i = 1; i < lights.length; i++) { \t\tconst offset = ((i * 13) % 17) / 20, \t\t\tlightPct = (pct2 + offset) % 0.995, \t\t\tpos = path.getPointAt(lightPct); \t\tlights[i].position.set(pos.x, pos.y, pos.z); \t} \trenderer.render(scene, camera); \tif (pct < 0.985) { \t\tif (pct < 0.985) { \t\t\t// Continue through tunnel \t\t\tconst pt1 = path.getPointAt(pct); \t\t\tconst pt2 = path.getPointAt(Math.min(pct + 0.01, 1)); \t\t\tcamera.position.set(pt1.x, pt1.y, pt1.z); \t\t\tcamera.lookAt(pt2); \t\t\t// Move lights with camera \t\t\tconst mainLight = lights[0]; \t\t\tmainLight.position.set(pt2.x, pt2.y, pt2.z); \t\t\tfor (let i = 1; i < lights.length; i++) { \t\t\t\tconst offset = ((i * 13) % 17) / 20; \t\t\t\tconst lightPct = (pct2 + offset) % 0.995; \t\t\t\tconst pos = path.getPointAt(lightPct); \t\t\t\tlights[i].position.set(pos.x, pos.y, pos.z); \t\t\t} \t\t\tpct += cameraSpeed; \t\t\tpct2 += lightSpeed; \t\t\trenderFrameId = requestAnimationFrame(render); \t\t} else { \t\t\t// Float in place at the end of the tunnel \t\t\thoverTime += 0.02; \t\t\tconst hoverOffset = Math.sin(hoverTime) * 0.5; \t\t\tconst base = path.getPointAt(0.985); \t\t\tconst target = path.getPointAt(0.99); \t\t\tcamera.position.set(base.x, base.y + hoverOffset, base.z); \t\t\tcamera.lookAt(target); \t\t\trenderFrameId = requestAnimationFrame(render); \t\t} \t} } function createCodeSnippetSprite(text) { \tconst canvas = document.createElement(\"canvas\"); \tcanvas.width = 400; \tcanvas.height = 250; \tconst ctx = canvas.getContext(\"2d\"); \t// Fully transparent background, no border \tctx.clearRect(0, 0, canvas.width, canvas.height); \t// Syntax highlighting colors from popular themes \tconst colors = { \t\tkeyword: \"#ff79c6\", // pink \t\tstring: \"#f1fa8c\", // yellow \t\tcomment: \"#6272a4\", // blue-grey \t\tfunction: \"#50fa7b\", // green \t\tvariable: \"#8be9fd\", // cyan \t\ttag: \"#ff79c6\", // pink \t\tattribute: \"#50fa7b\" // green \t}; \tctx.font = \"20px 'Consolas', monospace\"; \tctx.textAlign = \"left\"; \tctx.textBaseline = \"top\"; \tconst lines = text.split(\"\\n\"); \tfor (let i = 0; i < lines.length; i++) { \t\tconst line = lines[i]; \t\tlet xPosition = 15; \t\t// Extremely simple syntax highlighting \t\tif ( \t\t\tline.includes(\"const \") || \t\t\tline.includes(\"function \") || \t\t\tline.includes(\"if(\") || \t\t\tline.includes(\"return\") \t\t) { \t\t\t// Keywords and flow control \t\t\tconst parts = line.split(/\\b/); \t\t\tfor (const part of parts) { \t\t\t\tif ( \t\t\t\t\t[ \t\t\t\t\t\t\"const\", \t\t\t\t\t\t\"function\", \t\t\t\t\t\t\"return\", \t\t\t\t\t\t\"if\", \t\t\t\t\t\t\"class\", \t\t\t\t\t\t\"=>\", \t\t\t\t\t\t\"import\", \t\t\t\t\t\t\"export\" \t\t\t\t\t].includes(part) \t\t\t\t) { \t\t\t\t\tctx.fillStyle = colors.keyword; \t\t\t\t} else if (part.startsWith('\"') || part.startsWith(\"'\")) { \t\t\t\t\tctx.fillStyle = colors.string; \t\t\t\t} else if (part.startsWith(\"//\")) { \t\t\t\t\tctx.fillStyle = colors.comment; \t\t\t\t} else if (part.match(/^[a-zA-Z_][a-zA-Z0-9_]*\\(/)) { \t\t\t\t\tctx.fillStyle = colors.function; \t\t\t\t} else if (part.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)) { \t\t\t\t\tctx.fillStyle = colors.variable; \t\t\t\t} else { \t\t\t\t\tctx.fillStyle = \"#f8f8f2\"; // default text color \t\t\t\t} \t\t\t\tconst width = ctx.measureText(part).width; \t\t\t\tctx.fillText(part, xPosition, 15 + i * 24); \t\t\t\txPosition += width; \t\t\t} \t\t} else if (line.includes(\"<\") && line.includes(\">\")) { \t\t\t// HTML-like syntax \t\t\tconst parts = line.split(/(<\\/?[a-zA-Z0-9-]+|>|=\"[^\"]*\")/g); \t\t\tfor (const part of parts) { \t\t\t\tif (part.startsWith(\"<\") && !part.startsWith(\"</\")) { \t\t\t\t\tctx.fillStyle = colors.tag; \t\t\t\t} else if (part.startsWith(\"</\") || part === \">\") { \t\t\t\t\tctx.fillStyle = colors.tag; \t\t\t\t} else if (part.startsWith(\"=\")) { \t\t\t\t\tctx.fillStyle = colors.attribute; \t\t\t\t} else if (part.startsWith('\"')) { \t\t\t\t\tctx.fillStyle = colors.string; \t\t\t\t} else { \t\t\t\t\tctx.fillStyle = \"#f8f8f2\"; // default text color \t\t\t\t} \t\t\t\tconst width = ctx.measureText(part).width; \t\t\t\tctx.fillText(part, xPosition, 15 + i * 24); \t\t\t\txPosition += width; \t\t\t} \t\t} else if (line.includes(\"{\") || line.includes(\"}\") || line.includes(\";\")) { \t\t\t// CSS-like syntax \t\t\tctx.fillStyle = \"#f8f8f2\"; // default for CSS \t\t\tctx.fillText(line, xPosition, 15 + i * 24); \t\t} else { \t\t\t// Default rendering \t\t\tctx.fillStyle = \"#f8f8f2\"; \t\t\tctx.fillText(line, 15, 15 + i * 24); \t\t} \t} \tconst texture = new THREE.CanvasTexture(canvas); \ttexture.minFilter = THREE.LinearFilter; \tconst material = new THREE.SpriteMaterial({ \t\tmap: texture, \t\ttransparent: true, \t\topacity: 0.8, \t\tblending: THREE.AdditiveBlending \t}); \tconst sprite = new THREE.Sprite(material); \t// Randomize scale for variety \tlet scaleFactor = 8 + Math.random() * 12; \tsprite.scale.set(scaleFactor, scaleFactor * (canvas.height / canvas.width), 1); \treturn sprite; }",
    "id": "cyberspace-portal-"
  },
  {
    "title": "Sakura Animation using WebGl",
    "description": "",
    "code": "index.html: <canvas id=\"sakura\"></canvas> <div class=\"btnbg\"> <button type=\"button\" onclick=\"toggleAnimation(this)\">Stop</button> </div> <!-- sakura shader --> <script id=\"sakura_point_vsh\" type=\"x-shader/x_vertex\"> uniform mat4 uProjection; uniform mat4 uModelview; uniform vec3 uResolution; uniform vec3 uOffset; uniform vec3 uDOF; //x:focus distance, y:focus radius, z:max radius uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start attribute vec3 aPosition; attribute vec3 aEuler; attribute vec2 aMisc; //x:size, y:fade varying vec3 pposition; varying float psize; varying float palpha; varying float pdist; //varying mat3 rotMat; varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal; varying float diffuse; varying float specular; varying float rstop; varying float distancefade; void main(void) { // Projection is based on vertical angle vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0); gl_Position = uProjection * pos; gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5; pposition = pos.xyz; psize = aMisc.x; pdist = length(pos.xyz); palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z); vec3 elrsn = sin(aEuler); vec3 elrcs = cos(aEuler); mat3 rotx = mat3( 1.0, 0.0, 0.0, 0.0, elrcs.x, elrsn.x, 0.0, -elrsn.x, elrcs.x ); mat3 roty = mat3( elrcs.y, 0.0, -elrsn.y, 0.0, 1.0, 0.0, elrsn.y, 0.0, elrcs.y ); mat3 rotz = mat3( elrcs.z, elrsn.z, 0.0, -elrsn.z, elrcs.z, 0.0, 0.0, 0.0, 1.0 ); mat3 rotmat = rotx * roty * rotz; normal = rotmat[2]; mat3 trrotm = mat3( rotmat[0][0], rotmat[1][0], rotmat[2][0], rotmat[0][1], rotmat[1][1], rotmat[2][1], rotmat[0][2], rotmat[1][2], rotmat[2][2] ); normX = trrotm[0]; normY = trrotm[1]; normZ = trrotm[2]; const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237); float tmpdfs = dot(lit, normal); if(tmpdfs < 0.0) { normal = -normal; tmpdfs = dot(lit, normal); } diffuse = 0.4 + tmpdfs; vec3 eyev = normalize(-pos.xyz); if(dot(eyev, normal) > 0.0) { vec3 hv = normalize(eyev + lit); specular = pow(max(dot(hv, normal), 0.0), 20.0); } else { specular = 0.0; } rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0); rstop = pow(rstop, 0.5); //-0.69315 = ln(0.5) distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y)); } </script> <script id=\"sakura_point_fsh\" type=\"x-shader/x_fragment\"> #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform vec3 uDOF; //x:focus distance, y:focus radius, z:max radius uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start const vec3 fadeCol = vec3(0.08, 0.03, 0.06); varying vec3 pposition; varying float psize; varying float palpha; varying float pdist; //varying mat3 rotMat; varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal; varying float diffuse; varying float specular; varying float rstop; varying float distancefade; float ellipse(vec2 p, vec2 o, vec2 r) { vec2 lp = (p - o) / r; return length(lp) - 1.0; } void main(void) { vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0; vec3 d = vec3(0.0, 0.0, -1.0); float nd = normZ.z; //dot(-normZ, d); if(abs(nd) < 0.0001) discard; float np = dot(normZ, p); vec3 tp = p + d * np / nd; vec2 coord = vec2(dot(normX, tp), dot(normY, tp)); //angle = 15 degree const float flwrsn = 0.258819045102521; const float flwrcs = 0.965925826289068; mat2 flwrm = mat2(flwrcs, -flwrsn, flwrsn, flwrcs); vec2 flwrp = vec2(abs(coord.x), coord.y) * flwrm; float r; if(flwrp.x < 0.0) { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5); } else { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5); } if(r > rstop) discard; vec3 col = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r); float grady = mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35)); col *= vec3(1.0, grady, grady); col *= mix(0.8, 1.0, pow(abs(coord.x), 0.3)); col = col * diffuse + specular; col = mix(fadeCol, col, distancefade); float alpha = (rstop > 0.001)? (0.5 - r / (rstop * 2.0)) : 1.0; alpha = smoothstep(0.0, 1.0, alpha) * palpha; gl_FragColor = vec4(col * 0.5, alpha); } </script> <!-- effects --> <script id=\"fx_common_vsh\" type=\"x-shader/x_vertex\"> uniform vec3 uResolution; attribute vec2 aPosition; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_Position = vec4(aPosition, 0.0, 1.0); texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5); screenCoord = aPosition.xy * vec2(uResolution.z, 1.0); } </script> <script id=\"bg_fsh\" type=\"x-shader/x_fragment\"> #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform vec2 uTimes; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec3 col; float c; vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0); c = exp(-pow(length(tmpv) * 1.8, 2.0)); col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c); gl_FragColor = vec4(col * 0.5, 1.0); } </script> <script id=\"fx_brightbuf_fsh\" type=\"x-shader/x_fragment\"> #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 col = texture2D(uSrc, texCoord); gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0); } </script> <script id=\"fx_dirblur_r4_fsh\" type=\"x-shader/x_fragment\"> #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; uniform vec4 uBlurDir; //dir(x, y), stride(z, w) varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 col = texture2D(uSrc, texCoord); col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta); col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta); col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta); col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta); gl_FragColor = col / 5.0; } </script> <!-- effect fragment shader template --> <script id=\"fx_common_fsh\" type=\"x-shader/x_fragment\"> #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_FragColor = texture2D(uSrc, texCoord); } </script> <!-- post processing --> <script id=\"pp_final_vsh\" type=\"x-shader/x_vertex\"> uniform vec3 uResolution; attribute vec2 aPosition; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_Position = vec4(aPosition, 0.0, 1.0); texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5); screenCoord = aPosition.xy * vec2(uResolution.z, 1.0); } </script> <script id=\"pp_final_fsh\" type=\"x-shader/x_fragment\"> #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform sampler2D uBloom; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 srccol = texture2D(uSrc, texCoord) * 2.0; vec4 bloomcol = texture2D(uBloom, texCoord); vec4 col; col = srccol + bloomcol * (vec4(1.0) + srccol); col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5); col = pow(col, vec4(0.45454545454545)); //(1.0 / 2.2) gl_FragColor = vec4(col.rgb, 1.0); gl_FragColor.a = 1.0; } </script>\nstyle.css: /*Sakura animation using WebGL. No images are used. The framerate might be slow or the demo might not play at all in some older systems so you can watch this video: http://www.screenr.com/BFZ8. Let me make it clear that I did not make this and just thought is was very cool and wanted to share it. */ body { padding:0; margin:0; overflow:hidden; \t height: 600px; } canvas { padding:0; margin:0; } div.btnbg { position:fixed; left:0; top:0; box-shadow: 0px 0px 15px #ccc; } div.btnbg:hover{ text-shadow: 0px 0px 3px #ccc; box-shadow: 0px 0px 20px #ccc; }\nscript.js: // Utilities var Vector3 = {}; var Matrix44 = {}; Vector3.create = function(x, y, z) { return {'x':x, 'y':y, 'z':z}; }; Vector3.dot = function (v0, v1) { return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z; }; Vector3.cross = function (v, v0, v1) { v.x = v0.y * v1.z - v0.z * v1.y; v.y = v0.z * v1.x - v0.x * v1.z; v.z = v0.x * v1.y - v0.y * v1.x; }; Vector3.normalize = function (v) { var l = v.x * v.x + v.y * v.y + v.z * v.z; if(l > 0.00001) { l = 1.0 / Math.sqrt(l); v.x *= l; v.y *= l; v.z *= l; } }; Vector3.arrayForm = function(v) { if(v.array) { v.array[0] = v.x; v.array[1] = v.y; v.array[2] = v.z; } else { v.array = new Float32Array([v.x, v.y, v.z]); } return v.array; }; Matrix44.createIdentity = function () { return new Float32Array([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]); }; Matrix44.loadProjection = function (m, aspect, vdeg, near, far) { var h = near * Math.tan(vdeg * Math.PI / 180.0 * 0.5) * 2.0; var w = h * aspect; m[0] = 2.0 * near / w; m[1] = 0.0; m[2] = 0.0; m[3] = 0.0; m[4] = 0.0; m[5] = 2.0 * near / h; m[6] = 0.0; m[7] = 0.0; m[8] = 0.0; m[9] = 0.0; m[10] = -(far + near) / (far - near); m[11] = -1.0; m[12] = 0.0; m[13] = 0.0; m[14] = -2.0 * far * near / (far - near); m[15] = 0.0; }; Matrix44.loadLookAt = function (m, vpos, vlook, vup) { var frontv = Vector3.create(vpos.x - vlook.x, vpos.y - vlook.y, vpos.z - vlook.z); Vector3.normalize(frontv); var sidev = Vector3.create(1.0, 0.0, 0.0); Vector3.cross(sidev, vup, frontv); Vector3.normalize(sidev); var topv = Vector3.create(1.0, 0.0, 0.0); Vector3.cross(topv, frontv, sidev); Vector3.normalize(topv); m[0] = sidev.x; m[1] = topv.x; m[2] = frontv.x; m[3] = 0.0; m[4] = sidev.y; m[5] = topv.y; m[6] = frontv.y; m[7] = 0.0; m[8] = sidev.z; m[9] = topv.z; m[10] = frontv.z; m[11] = 0.0; m[12] = -(vpos.x * m[0] + vpos.y * m[4] + vpos.z * m[8]); m[13] = -(vpos.x * m[1] + vpos.y * m[5] + vpos.z * m[9]); m[14] = -(vpos.x * m[2] + vpos.y * m[6] + vpos.z * m[10]); m[15] = 1.0; }; // var timeInfo = { 'start':0, 'prev':0, // Date 'delta':0, 'elapsed':0 // Number(sec) }; // var gl; var renderSpec = { 'width':0, 'height':0, 'aspect':1, 'array':new Float32Array(3), 'halfWidth':0, 'halfHeight':0, 'halfArray':new Float32Array(3) // and some render targets. see setViewport() }; renderSpec.setSize = function(w, h) { renderSpec.width = w; renderSpec.height = h; renderSpec.aspect = renderSpec.width / renderSpec.height; renderSpec.array[0] = renderSpec.width; renderSpec.array[1] = renderSpec.height; renderSpec.array[2] = renderSpec.aspect; renderSpec.halfWidth = Math.floor(w / 2); renderSpec.halfHeight = Math.floor(h / 2); renderSpec.halfArray[0] = renderSpec.halfWidth; renderSpec.halfArray[1] = renderSpec.halfHeight; renderSpec.halfArray[2] = renderSpec.halfWidth / renderSpec.halfHeight; }; function deleteRenderTarget(rt) { gl.deleteFramebuffer(rt.frameBuffer); gl.deleteRenderbuffer(rt.renderBuffer); gl.deleteTexture(rt.texture); } function createRenderTarget(w, h) { var ret = { 'width':w, 'height':h, 'sizeArray':new Float32Array([w, h, w / h]), 'dtxArray':new Float32Array([1.0 / w, 1.0 / h]) }; ret.frameBuffer = gl.createFramebuffer(); ret.renderBuffer = gl.createRenderbuffer(); ret.texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, ret.texture); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.bindFramebuffer(gl.FRAMEBUFFER, ret.frameBuffer); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, ret.texture, 0); gl.bindRenderbuffer(gl.RENDERBUFFER, ret.renderBuffer); gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h); gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, ret.renderBuffer); gl.bindTexture(gl.TEXTURE_2D, null); gl.bindRenderbuffer(gl.RENDERBUFFER, null); gl.bindFramebuffer(gl.FRAMEBUFFER, null); return ret; } function compileShader(shtype, shsrc) { \tvar retsh = gl.createShader(shtype); \t \tgl.shaderSource(retsh, shsrc); \tgl.compileShader(retsh); \t \tif(!gl.getShaderParameter(retsh, gl.COMPILE_STATUS)) { \t\tvar errlog = gl.getShaderInfoLog(retsh); \t\tgl.deleteShader(retsh); \t\tconsole.error(errlog); \t\treturn null; \t} \treturn retsh; } function createShader(vtxsrc, frgsrc, uniformlist, attrlist) { var vsh = compileShader(gl.VERTEX_SHADER, vtxsrc); var fsh = compileShader(gl.FRAGMENT_SHADER, frgsrc); if(vsh == null || fsh == null) { return null; } var prog = gl.createProgram(); gl.attachShader(prog, vsh); gl.attachShader(prog, fsh); gl.deleteShader(vsh); gl.deleteShader(fsh); gl.linkProgram(prog); if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) { var errlog = gl.getProgramInfoLog(prog); console.error(errlog); return null; } if(uniformlist) { prog.uniforms = {}; for(var i = 0; i < uniformlist.length; i++) { prog.uniforms[uniformlist[i]] = gl.getUniformLocation(prog, uniformlist[i]); } } if(attrlist) { prog.attributes = {}; for(var i = 0; i < attrlist.length; i++) { var attr = attrlist[i]; prog.attributes[attr] = gl.getAttribLocation(prog, attr); } } return prog; } function useShader(prog) { gl.useProgram(prog); for(var attr in prog.attributes) { gl.enableVertexAttribArray(prog.attributes[attr]);; } } function unuseShader(prog) { for(var attr in prog.attributes) { gl.disableVertexAttribArray(prog.attributes[attr]);; } gl.useProgram(null); } ///// var projection = { 'angle':60, 'nearfar':new Float32Array([0.1, 100.0]), 'matrix':Matrix44.createIdentity() }; var camera = { 'position':Vector3.create(0, 0, 100), 'lookat':Vector3.create(0, 0, 0), 'up':Vector3.create(0, 1, 0), 'dof':Vector3.create(10.0, 4.0, 8.0), 'matrix':Matrix44.createIdentity() }; var pointFlower = {}; var meshFlower = {}; var sceneStandBy = false; var BlossomParticle = function () { this.velocity = new Array(3); this.rotation = new Array(3); this.position = new Array(3); this.euler = new Array(3); this.size = 1.0; this.alpha = 1.0; this.zkey = 0.0; }; BlossomParticle.prototype.setVelocity = function (vx, vy, vz) { this.velocity[0] = vx; this.velocity[1] = vy; this.velocity[2] = vz; }; BlossomParticle.prototype.setRotation = function (rx, ry, rz) { this.rotation[0] = rx; this.rotation[1] = ry; this.rotation[2] = rz; }; BlossomParticle.prototype.setPosition = function (nx, ny, nz) { this.position[0] = nx; this.position[1] = ny; this.position[2] = nz; }; BlossomParticle.prototype.setEulerAngles = function (rx, ry, rz) { this.euler[0] = rx; this.euler[1] = ry; this.euler[2] = rz; }; BlossomParticle.prototype.setSize = function (s) { this.size = s; }; BlossomParticle.prototype.update = function (dt, et) { this.position[0] += this.velocity[0] * dt; this.position[1] += this.velocity[1] * dt; this.position[2] += this.velocity[2] * dt; this.euler[0] += this.rotation[0] * dt; this.euler[1] += this.rotation[1] * dt; this.euler[2] += this.rotation[2] * dt; }; function createPointFlowers() { // get point sizes var prm = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE); renderSpec.pointSize = {'min':prm[0], 'max':prm[1]}; var vtxsrc = document.getElementById(\"sakura_point_vsh\").textContent; var frgsrc = document.getElementById(\"sakura_point_fsh\").textContent; pointFlower.program = createShader( vtxsrc, frgsrc, ['uProjection', 'uModelview', 'uResolution', 'uOffset', 'uDOF', 'uFade'], ['aPosition', 'aEuler', 'aMisc'] ); useShader(pointFlower.program); pointFlower.offset = new Float32Array([0.0, 0.0, 0.0]); pointFlower.fader = Vector3.create(0.0, 10.0, 0.0); // paramerters: velocity[3], rotate[3] pointFlower.numFlowers = 1600; pointFlower.particles = new Array(pointFlower.numFlowers); // vertex attributes {position[3], euler_xyz[3], size[1]} pointFlower.dataArray = new Float32Array(pointFlower.numFlowers * (3 + 3 + 2)); pointFlower.positionArrayOffset = 0; pointFlower.eulerArrayOffset = pointFlower.numFlowers * 3; pointFlower.miscArrayOffset = pointFlower.numFlowers * 6; pointFlower.buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer); gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, null); unuseShader(pointFlower.program); for(var i = 0; i < pointFlower.numFlowers; i++) { pointFlower.particles[i] = new BlossomParticle(); } } function initPointFlowers() { //area pointFlower.area = Vector3.create(20.0, 20.0, 20.0); pointFlower.area.x = pointFlower.area.y * renderSpec.aspect; pointFlower.fader.x = 10.0; //env fade start pointFlower.fader.y = pointFlower.area.z; //env fade half pointFlower.fader.z = 0.1; //near fade start //particles var PI2 = Math.PI * 2.0; var tmpv3 = Vector3.create(0, 0, 0); var tmpv = 0; var symmetryrand = function() {return (Math.random() * 2.0 - 1.0);}; for(var i = 0; i < pointFlower.numFlowers; i++) { var tmpprtcl = pointFlower.particles[i]; //velocity tmpv3.x = symmetryrand() * 0.3 + 0.8; tmpv3.y = symmetryrand() * 0.2 - 1.0; tmpv3.z = symmetryrand() * 0.3 + 0.5; Vector3.normalize(tmpv3); tmpv = 2.0 + Math.random() * 1.0; tmpprtcl.setVelocity(tmpv3.x * tmpv, tmpv3.y * tmpv, tmpv3.z * tmpv); //rotation tmpprtcl.setRotation( symmetryrand() * PI2 * 0.5, symmetryrand() * PI2 * 0.5, symmetryrand() * PI2 * 0.5 ); //position tmpprtcl.setPosition( symmetryrand() * pointFlower.area.x, symmetryrand() * pointFlower.area.y, symmetryrand() * pointFlower.area.z ); //euler tmpprtcl.setEulerAngles( Math.random() * Math.PI * 2.0, Math.random() * Math.PI * 2.0, Math.random() * Math.PI * 2.0 ); //size tmpprtcl.setSize(0.9 + Math.random() * 0.1); } } function renderPointFlowers() { //update var PI2 = Math.PI * 2.0; var limit = [pointFlower.area.x, pointFlower.area.y, pointFlower.area.z]; var repeatPos = function (prt, cmp, limit) { if(Math.abs(prt.position[cmp]) - prt.size * 0.5 > limit) { //out of area if(prt.position[cmp] > 0) { prt.position[cmp] -= limit * 2.0; } else { prt.position[cmp] += limit * 2.0; } } }; var repeatEuler = function (prt, cmp) { prt.euler[cmp] = prt.euler[cmp] % PI2; if(prt.euler[cmp] < 0.0) { prt.euler[cmp] += PI2; } }; for(var i = 0; i < pointFlower.numFlowers; i++) { var prtcl = pointFlower.particles[i]; prtcl.update(timeInfo.delta, timeInfo.elapsed); repeatPos(prtcl, 0, pointFlower.area.x); repeatPos(prtcl, 1, pointFlower.area.y); repeatPos(prtcl, 2, pointFlower.area.z); repeatEuler(prtcl, 0); repeatEuler(prtcl, 1); repeatEuler(prtcl, 2); prtcl.alpha = 1.0;//(pointFlower.area.z - prtcl.position[2]) * 0.5; prtcl.zkey = (camera.matrix[2] * prtcl.position[0] + camera.matrix[6] * prtcl.position[1] + camera.matrix[10] * prtcl.position[2] + camera.matrix[14]); } // sort pointFlower.particles.sort(function(p0, p1){return p0.zkey - p1.zkey;}); // update data var ipos = pointFlower.positionArrayOffset; var ieuler = pointFlower.eulerArrayOffset; var imisc = pointFlower.miscArrayOffset; for(var i = 0; i < pointFlower.numFlowers; i++) { var prtcl = pointFlower.particles[i]; pointFlower.dataArray[ipos] = prtcl.position[0]; pointFlower.dataArray[ipos + 1] = prtcl.position[1]; pointFlower.dataArray[ipos + 2] = prtcl.position[2]; ipos += 3; pointFlower.dataArray[ieuler] = prtcl.euler[0]; pointFlower.dataArray[ieuler + 1] = prtcl.euler[1]; pointFlower.dataArray[ieuler + 2] = prtcl.euler[2]; ieuler += 3; pointFlower.dataArray[imisc] = prtcl.size; pointFlower.dataArray[imisc + 1] = prtcl.alpha; imisc += 2; } //draw gl.enable(gl.BLEND); //gl.disable(gl.DEPTH_TEST); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); var prog = pointFlower.program; useShader(prog); gl.uniformMatrix4fv(prog.uniforms.uProjection, false, projection.matrix); gl.uniformMatrix4fv(prog.uniforms.uModelview, false, camera.matrix); gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array); gl.uniform3fv(prog.uniforms.uDOF, Vector3.arrayForm(camera.dof)); gl.uniform3fv(prog.uniforms.uFade, Vector3.arrayForm(pointFlower.fader)); gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer); gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW); gl.vertexAttribPointer(prog.attributes.aPosition, 3, gl.FLOAT, false, 0, pointFlower.positionArrayOffset * Float32Array.BYTES_PER_ELEMENT); gl.vertexAttribPointer(prog.attributes.aEuler, 3, gl.FLOAT, false, 0, pointFlower.eulerArrayOffset * Float32Array.BYTES_PER_ELEMENT); gl.vertexAttribPointer(prog.attributes.aMisc, 2, gl.FLOAT, false, 0, pointFlower.miscArrayOffset * Float32Array.BYTES_PER_ELEMENT); // doubler for(var i = 1; i < 2; i++) { var zpos = i * -2.0; pointFlower.offset[0] = pointFlower.area.x * -1.0; pointFlower.offset[1] = pointFlower.area.y * -1.0; pointFlower.offset[2] = pointFlower.area.z * zpos; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); pointFlower.offset[0] = pointFlower.area.x * -1.0; pointFlower.offset[1] = pointFlower.area.y * 1.0; pointFlower.offset[2] = pointFlower.area.z * zpos; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); pointFlower.offset[0] = pointFlower.area.x * 1.0; pointFlower.offset[1] = pointFlower.area.y * -1.0; pointFlower.offset[2] = pointFlower.area.z * zpos; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); pointFlower.offset[0] = pointFlower.area.x * 1.0; pointFlower.offset[1] = pointFlower.area.y * 1.0; pointFlower.offset[2] = pointFlower.area.z * zpos; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); } //main pointFlower.offset[0] = 0.0; pointFlower.offset[1] = 0.0; pointFlower.offset[2] = 0.0; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); gl.bindBuffer(gl.ARRAY_BUFFER, null); unuseShader(prog); gl.enable(gl.DEPTH_TEST); gl.disable(gl.BLEND); } // effects //common util function createEffectProgram(vtxsrc, frgsrc, exunifs, exattrs) { var ret = {}; var unifs = ['uResolution', 'uSrc', 'uDelta']; if(exunifs) { unifs = unifs.concat(exunifs); } var attrs = ['aPosition']; if(exattrs) { attrs = attrs.concat(exattrs); } ret.program = createShader(vtxsrc, frgsrc, unifs, attrs); useShader(ret.program); ret.dataArray = new Float32Array([ -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0 ]); ret.buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, ret.buffer); gl.bufferData(gl.ARRAY_BUFFER, ret.dataArray, gl.STATIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, null); unuseShader(ret.program); return ret; } // basic usage // useEffect(prog, srctex({'texture':texid, 'dtxArray':(f32)[dtx, dty]})); //basic initialize // gl.uniform**(...); //additional uniforms // drawEffect() // unuseEffect(prog) // TEXTURE0 makes src function useEffect(fxobj, srctex) { var prog = fxobj.program; useShader(prog); gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array); if(srctex != null) { gl.uniform2fv(prog.uniforms.uDelta, srctex.dtxArray); gl.uniform1i(prog.uniforms.uSrc, 0); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, srctex.texture); } } function drawEffect(fxobj) { gl.bindBuffer(gl.ARRAY_BUFFER, fxobj.buffer); gl.vertexAttribPointer(fxobj.program.attributes.aPosition, 2, gl.FLOAT, false, 0, 0); gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); } function unuseEffect(fxobj) { unuseShader(fxobj.program); } var effectLib = {}; function createEffectLib() { var vtxsrc, frgsrc; //common var cmnvtxsrc = document.getElementById(\"fx_common_vsh\").textContent; //background frgsrc = document.getElementById(\"bg_fsh\").textContent; effectLib.sceneBg = createEffectProgram(cmnvtxsrc, frgsrc, ['uTimes'], null); // make brightpixels buffer frgsrc = document.getElementById(\"fx_brightbuf_fsh\").textContent; effectLib.mkBrightBuf = createEffectProgram(cmnvtxsrc, frgsrc, null, null); // direction blur frgsrc = document.getElementById(\"fx_dirblur_r4_fsh\").textContent; effectLib.dirBlur = createEffectProgram(cmnvtxsrc, frgsrc, ['uBlurDir'], null); //final composite vtxsrc = document.getElementById(\"pp_final_vsh\").textContent; frgsrc = document.getElementById(\"pp_final_fsh\").textContent; effectLib.finalComp = createEffectProgram(vtxsrc, frgsrc, ['uBloom'], null); } // background function createBackground() { //console.log(\"create background\"); } function initBackground() { //console.log(\"init background\"); } function renderBackground() { gl.disable(gl.DEPTH_TEST); useEffect(effectLib.sceneBg, null); gl.uniform2f(effectLib.sceneBg.program.uniforms.uTimes, timeInfo.elapsed, timeInfo.delta); drawEffect(effectLib.sceneBg); unuseEffect(effectLib.sceneBg); gl.enable(gl.DEPTH_TEST); } // post process var postProcess = {}; function createPostProcess() { //console.log(\"create post process\"); } function initPostProcess() { //console.log(\"init post process\"); } function renderPostProcess() { gl.enable(gl.TEXTURE_2D); gl.disable(gl.DEPTH_TEST); var bindRT = function (rt, isclear) { gl.bindFramebuffer(gl.FRAMEBUFFER, rt.frameBuffer); gl.viewport(0, 0, rt.width, rt.height); if(isclear) { gl.clearColor(0, 0, 0, 0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); } }; //make bright buff bindRT(renderSpec.wHalfRT0, true); useEffect(effectLib.mkBrightBuf, renderSpec.mainRT); drawEffect(effectLib.mkBrightBuf); unuseEffect(effectLib.mkBrightBuf); // make bloom for(var i = 0; i < 2; i++) { var p = 1.5 + 1 * i; var s = 2.0 + 1 * i; bindRT(renderSpec.wHalfRT1, true); useEffect(effectLib.dirBlur, renderSpec.wHalfRT0); gl.uniform4f(effectLib.dirBlur.program.uniforms.uBlurDir, p, 0.0, s, 0.0); drawEffect(effectLib.dirBlur); unuseEffect(effectLib.dirBlur); bindRT(renderSpec.wHalfRT0, true); useEffect(effectLib.dirBlur, renderSpec.wHalfRT1); gl.uniform4f(effectLib.dirBlur.program.uniforms.uBlurDir, 0.0, p, 0.0, s); drawEffect(effectLib.dirBlur); unuseEffect(effectLib.dirBlur); } //display gl.bindFramebuffer(gl.FRAMEBUFFER, null); gl.viewport(0, 0, renderSpec.width, renderSpec.height); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); useEffect(effectLib.finalComp, renderSpec.mainRT); gl.uniform1i(effectLib.finalComp.program.uniforms.uBloom, 1); gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, renderSpec.wHalfRT0.texture); drawEffect(effectLib.finalComp); unuseEffect(effectLib.finalComp); gl.enable(gl.DEPTH_TEST); } ///// var SceneEnv = {}; function createScene() { createEffectLib(); createBackground(); createPointFlowers(); createPostProcess(); sceneStandBy = true; } function initScene() { initBackground(); initPointFlowers(); initPostProcess(); //camera.position.z = 17.320508; camera.position.z = pointFlower.area.z + projection.nearfar[0]; projection.angle = Math.atan2(pointFlower.area.y, camera.position.z + pointFlower.area.z) * 180.0 / Math.PI * 2.0; Matrix44.loadProjection(projection.matrix, renderSpec.aspect, projection.angle, projection.nearfar[0], projection.nearfar[1]); } function renderScene() { //draw Matrix44.loadLookAt(camera.matrix, camera.position, camera.lookat, camera.up); gl.enable(gl.DEPTH_TEST); //gl.bindFramebuffer(gl.FRAMEBUFFER, null); gl.bindFramebuffer(gl.FRAMEBUFFER, renderSpec.mainRT.frameBuffer); gl.viewport(0, 0, renderSpec.mainRT.width, renderSpec.mainRT.height); gl.clearColor(0.005, 0, 0.05, 0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); renderBackground(); renderPointFlowers(); renderPostProcess(); } ///// function onResize(e) { makeCanvasFullScreen(document.getElementById(\"sakura\")); setViewports(); if(sceneStandBy) { initScene(); } } function setViewports() { renderSpec.setSize(gl.canvas.width, gl.canvas.height); gl.clearColor(0.2, 0.2, 0.5, 1.0); gl.viewport(0, 0, renderSpec.width, renderSpec.height); var rtfunc = function (rtname, rtw, rth) { var rt = renderSpec[rtname]; if(rt) deleteRenderTarget(rt); renderSpec[rtname] = createRenderTarget(rtw, rth); }; rtfunc('mainRT', renderSpec.width, renderSpec.height); rtfunc('wFullRT0', renderSpec.width, renderSpec.height); rtfunc('wFullRT1', renderSpec.width, renderSpec.height); rtfunc('wHalfRT0', renderSpec.halfWidth, renderSpec.halfHeight); rtfunc('wHalfRT1', renderSpec.halfWidth, renderSpec.halfHeight); } function render() { renderScene(); } var animating = true; function toggleAnimation(elm) { animating ^= true; if(animating) animate(); if(elm) { elm.innerHTML = animating? \"Stop\":\"Start\"; } } function stepAnimation() { if(!animating) animate(); } function animate() { var curdate = new Date(); timeInfo.elapsed = (curdate - timeInfo.start) / 1000.0; timeInfo.delta = (curdate - timeInfo.prev) / 1000.0; timeInfo.prev = curdate; if(animating) requestAnimationFrame(animate); render(); } function makeCanvasFullScreen(canvas) { var b = document.body; \tvar d = document.documentElement; \tfullw = Math.max(b.clientWidth , b.scrollWidth, d.scrollWidth, d.clientWidth); \tfullh = Math.max(b.clientHeight , b.scrollHeight, d.scrollHeight, d.clientHeight); \tcanvas.width = fullw; \tcanvas.height = fullh; } window.addEventListener('load', function(e) { var canvas = document.getElementById(\"sakura\"); try { makeCanvasFullScreen(canvas); gl = canvas.getContext('experimental-webgl'); } catch(e) { alert(\"WebGL not supported.\" + e); console.error(e); return; } window.addEventListener('resize', onResize); setViewports(); createScene(); initScene(); timeInfo.start = new Date(); timeInfo.prev = timeInfo.start; animate(); }); //set window.requestAnimationFrame (function (w, r) { w['r'+r] = w['r'+r] || w['webkitR'+r] || w['mozR'+r] || w['msR'+r] || w['oR'+r] || function(c){ w.setTimeout(c, 1000 / 60); }; })(window, 'requestAnimationFrame');",
    "id": "sakura-animation-using-webgl"
  },
  {
    "title": "WebGL Light Rays Animated Background",
    "description": "Full-viewport WebGL canvas background rendering animated crimson light rays with configurable origin, spread, length, saturation, and subtle mouse interaction. Ideal as a dynamic atmospheric backdrop for landing pages or hero sections. Has mouse following",
    "code": "<div class=\"light-rays-container\" id=\"lightRaysWrap\"></div>\n\n<style>\n.light-rays-container {\n  position: absolute;\n  top: 0; left: 0;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  pointer-events: none; /* s att den inte str klick */\n  z-index: -1; /* bakgrund */\n}\n\ncanvas#light-rays-canvas {\n  width: 100%;\n  height: 100%;\n  display: block;\n}\n</style>\n\n<script>\n(function(){\n  const container = document.getElementById('lightRaysWrap');\n  const canvas = document.createElement('canvas');\n  canvas.id = 'light-rays-canvas';\n  container.appendChild(canvas);\n\n  const gl = canvas.getContext('webgl', { alpha: true, antialias: true });\n  if (!gl) { console.error('WebGL not supported'); return; }\n\n  // --- Shader helpers ---\n  function compileShader(gl,type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){console.error(gl.getShaderInfoLog(s));gl.deleteShader(s);return null;}return s;}\n  function createProgram(gl,vs,fs){const v=compileShader(gl,gl.VERTEX_SHADER,vs),f=compileShader(gl,gl.FRAGMENT_SHADER,fs);if(!v||!f)return null;const p=gl.createProgram();gl.attachShader(p,v);gl.attachShader(p,f);gl.linkProgram(p);if(!gl.getProgramParameter(p,gl.LINK_STATUS)){console.error(gl.getProgramInfoLog(p));gl.deleteProgram(p);return null;}return p;}\n\n  const vertexSrc = `attribute vec2 a_position; varying vec2 vUv; void main(){vUv=a_position*0.5+0.5; gl_Position=vec4(a_position,0.0,1.0);}`;\n  const fragmentSrc = `precision highp float;\nuniform float iTime;\nuniform vec2 iResolution;\nuniform vec2 rayPos;\nuniform vec2 rayDir;\nuniform vec3 raysColor;\nuniform float raysSpeed;\nuniform float lightSpread;\nuniform float rayLength;\nuniform float pulsating;\nuniform float fadeDistance;\nuniform float saturation;\nuniform vec2 mousePos;\nuniform float mouseInfluence;\nuniform float noiseAmount;\nuniform float distortion;\nvarying vec2 vUv;\nfloat noise(vec2 st){return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);}\nfloat rayStrength(vec2 raySource,vec2 rayRefDirection,vec2 coord,float seedA,float seedB,float speed){\n  vec2 sourceToCoord=coord-raySource;\n  vec2 dirNorm=normalize(sourceToCoord);\n  float cosAngle=dot(dirNorm,rayRefDirection);\n  float distortedAngle=cosAngle+distortion*sin(iTime*2.0+length(sourceToCoord)*0.01)*0.2;\n  float spreadFactor=pow(max(distortedAngle,0.0),1.0/max(lightSpread,0.001));\n  float distance=length(sourceToCoord);\n  float maxDistance=iResolution.x*rayLength;\n  float lengthFalloff=clamp((maxDistance-distance)/maxDistance,0.0,1.0);\n  float fadeFalloff=clamp((iResolution.x*fadeDistance-distance)/(iResolution.x*fadeDistance),0.5,1.0);\n  float pulse=pulsating>0.5?(0.8+0.2*sin(iTime*speed*3.0)):1.0;\n  float baseStrength=clamp((0.45+0.15*sin(distortedAngle*seedA+iTime*speed))+(0.3+0.2*cos(-distortedAngle*seedB+iTime*speed)),0.0,1.0);\n  return baseStrength*lengthFalloff*fadeFalloff*spreadFactor*pulse;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n  vec2 coord=vec2(fragCoord.x,iResolution.y-fragCoord.y);\n  vec2 finalRayDir=rayDir;\n  if(mouseInfluence>0.0){vec2 mouseScreenPos=mousePos*iResolution.xy;vec2 mouseDirection=normalize(mouseScreenPos-rayPos);finalRayDir=normalize(mix(rayDir,mouseDirection,mouseInfluence));}\n  vec4 rays1=vec4(1.0)*rayStrength(rayPos,finalRayDir,coord,36.2214,21.11349,1.5*raysSpeed);\n  vec4 rays2=vec4(1.0)*rayStrength(rayPos,finalRayDir,coord,22.3991,18.0234,1.1*raysSpeed);\n  fragColor=rays1*0.5+rays2*0.4;\n  if(noiseAmount>0.0){float n=noise(coord*0.01+iTime*0.1);fragColor.rgb*=(1.0-noiseAmount+noiseAmount*n);}\n  float brightness=1.0-(coord.y/iResolution.y);\n  fragColor.x*=(0.1+brightness*0.8);\n  fragColor.y*=(0.3+brightness*0.6);\n  fragColor.z*=(0.5+brightness*0.5);\n  if(saturation!=1.0){float gray=dot(fragColor.rgb,vec3(0.299,0.587,0.114));fragColor.rgb=mix(vec3(gray),fragColor.rgb,saturation);}\n  fragColor.rgb*=raysColor;\n}\nvoid main(){vec4 color; mainImage(color,gl_FragCoord.xy); gl_FragColor=color;}`;\n\n  const program = createProgram(gl, vertexSrc, fragmentSrc);\n  gl.useProgram(program);\n\n  const posLoc = gl.getAttribLocation(program,'a_position');\n  const posBuf = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER,posBuf);\n  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),gl.STATIC_DRAW);\n  gl.enableVertexAttribArray(posLoc);\n  gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);\n\n  const uni = {};\n  ['iTime','iResolution','rayPos','rayDir','raysColor','raysSpeed','lightSpread','rayLength','pulsating','fadeDistance','saturation','mousePos','mouseInfluence','noiseAmount','distortion'].forEach(n=>uni[n]=gl.getUniformLocation(program,n));\n\n  // --- Component state (uppdaterade vrden) ---\n  const state = {\n    raysColor:'#dc143c',\n    raysOrigin:'top',\n    raysSpeed:2.2,\n    lightSpread:3.0,\n    rayLength:4.9,\n    pulsating:false,\n    fadeDistance:2.0,\n    saturation:0.6,\n    mouseInfluence:0.12,\n    noiseAmount:0,\n    distortion:0\n  };\n\n  function hexToRgb(hex){const m=/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);return m?[parseInt(m[1],16)/255,parseInt(m[2],16)/255,parseInt(m[3],16)/255]:[1,1,1];}\n  function getAnchorAndDir(origin,w,h){const o=0.2;switch(origin){case'top-left':return{anchor:[0,-o*h],dir:[0,1]};case'top-right':return{anchor:[w,-o*h],dir:[0,1]};case'left':return{anchor:[-o*w,0.5*h],dir:[1,0]};case'right':return{anchor:[(1+o)*w,0.5*h],dir:[-1,0]};case'bottom-left':return{anchor:[0,(1+o)*h],dir:[0,-1]};case'bottom-center':return{anchor:[0.5*w,(1+o)*h],dir:[0,-1]};case'bottom-right':return{anchor:[w,(1+o)*h],dir:[0,-1]};default:return{anchor:[0.5*w,-o*h],dir:[0,1]};}}\n\n  const mouse={x:0.5,y:0.5},smoothMouse={x:0.5,y:0.5};\n  window.addEventListener('mousemove',e=>{const r=canvas.getBoundingClientRect();mouse.x=(e.clientX-r.left)/r.width;mouse.y=(e.clientY-r.top)/r.height;});\n\n  function resize(){const dpr=Math.min(window.devicePixelRatio||1,2);const w=Math.floor(container.clientWidth*dpr);const h=Math.floor(container.clientHeight*dpr);canvas.width=w;canvas.height=h;gl.viewport(0,0,w,h);}\n  window.addEventListener('resize',resize); resize();\n\n  function setUniforms(t){\n    gl.uniform1f(uni.iTime,t*0.001);\n    gl.uniform2f(uni.iResolution,canvas.width,canvas.height);\n    const {anchor,dir} = getAnchorAndDir(state.raysOrigin,canvas.width,canvas.height);\n    gl.uniform2f(uni.rayPos,anchor[0],anchor[1]);\n    gl.uniform2f(uni.rayDir,dir[0],dir[1]);\n    const c = hexToRgb(state.raysColor);\n    gl.uniform3f(uni.raysColor,c[0],c[1],c[2]);\n    gl.uniform1f(uni.raysSpeed,state.raysSpeed);\n    gl.uniform1f(uni.lightSpread,state.lightSpread);\n    gl.uniform1f(uni.rayLength,state.rayLength);\n    gl.uniform1f(uni.pulsating,state.pulsating?1:0);\n    gl.uniform1f(uni.fadeDistance,state.fadeDistance);\n    gl.uniform1f(uni.saturation,state.saturation);\n    gl.uniform2f(uni.mousePos,smoothMouse.x,smoothMouse.y);\n    gl.uniform1f(uni.mouseInfluence,state.mouseInfluence);\n    gl.uniform1f(uni.noiseAmount,state.noiseAmount);\n    gl.uniform1f(uni.distortion,state.distortion);\n  }\n\n  function frame(t){\n    const s=0.92;\n    smoothMouse.x=smoothMouse.x*s+(1-s)*mouse.x;\n    smoothMouse.y=smoothMouse.y*s+(1-s)*mouse.y;\n    setUniforms(t);\n    gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.drawArrays(gl.TRIANGLES,0,6);\n    requestAnimationFrame(frame);\n  }\n  requestAnimationFrame(frame);\n\n})();\n</script>\n\n",
    "id": "webgl-light-rays-animated-background"
  }
]