[
  {
    "title": "cg-interactive-particle-logo",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Interactive Fluid Particle Logo | mukta</title>\n    <style>\n      * {\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n      }\n    </style>\n  </head>\n  <body>\n    <canvas id=\"canvas\"></canvas>\n    <script type=\"module\" src=\"/script.js\"></script>\n  </body>\n</html>\n",
      "package.json": "{\n  \"name\": \"cg-interactive-particle-logo\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"dev\": \"vite\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"vite\": \"^5.4.10\"\n  }\n}\n",
      "script.js": "import { vertexShader, fragmentShader } from \"./shaders.js\";\n\nconst config = {\n  logoPath: \"/logo.png\",\n  logoSize: 1250,\n  logoColor: \"#404040\",\n  canvasBg: \"#141414\",\n  distortionRadius: 3000,\n  forceStrength: 0.0035,\n  maxDisplacement: 100,\n  returnForce: 0.025,\n};\n\nlet canvas, gl, program;\nlet particles = [];\nlet positionArray, colorArray;\nlet positionBuffer, colorBuffer;\nlet mouse = { x: 0, y: 0 };\nlet animationCount = 0;\n\nfunction setupCanvas() {\n  canvas = document.getElementById(\"canvas\");\n  const dpr = window.devicePixelRatio || 1;\n  canvas.width = window.innerWidth * dpr;\n  canvas.height = window.innerHeight * dpr;\n  canvas.style.width = window.innerWidth + \"px\";\n  canvas.style.height = window.innerHeight + \"px\";\n}\n\nfunction setupWebGL() {\n  gl = canvas.getContext(\"webgl\", {\n    alpha: true,\n    depth: false,\n    stencil: false,\n    antialias: true,\n    powerPreference: \"high-performance\",\n    premultipliedAlpha: false,\n  });\n\n  gl.enable(gl.BLEND);\n  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n}\n\nfunction setupShaders() {\n  const vs = compileShader(gl.VERTEX_SHADER, vertexShader);\n  const fs = compileShader(gl.FRAGMENT_SHADER, fragmentShader);\n  program = gl.createProgram();\n  gl.attachShader(program, vs);\n  gl.attachShader(program, fs);\n  gl.linkProgram(program);\n}\n\nfunction compileShader(type, source) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  return shader;\n}\n\nfunction loadLogo() {\n  const image = new Image();\n  image.onload = function () {\n    const tempCanvas = document.createElement(\"canvas\");\n    const ctx = tempCanvas.getContext(\"2d\");\n    tempCanvas.width = config.logoSize;\n    tempCanvas.height = config.logoSize;\n\n    const scale = 0.9;\n    const size = config.logoSize * scale;\n    const offset = (config.logoSize - size) / 2;\n    ctx.drawImage(image, offset, offset, size, size);\n\n    const imageData = ctx.getImageData(0, 0, config.logoSize, config.logoSize);\n    createParticles(imageData.data);\n  };\n  image.src = config.logoPath;\n}\n\nfunction createParticles(pixels) {\n  const centerX = canvas.width / 2;\n  const centerY = canvas.height / 2;\n  const positions = [];\n  const colors = [];\n\n  function hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result\n      ? {\n          r: parseInt(result[1], 16) / 255,\n          g: parseInt(result[2], 16) / 255,\n          b: parseInt(result[3], 16) / 255,\n        }\n      : { r: 1, g: 1, b: 1 };\n  }\n\n  const logoTint = hexToRgb(config.logoColor);\n\n  for (let i = 0; i < config.logoSize; i++) {\n    for (let j = 0; j < config.logoSize; j++) {\n      const pixelIndex = (i * config.logoSize + j) * 4;\n      const alpha = pixels[pixelIndex + 3];\n\n      if (alpha > 10) {\n        const particleX = centerX + (j - config.logoSize / 2) * 1.0;\n        const particleY = centerY + (i - config.logoSize / 2) * 1.0;\n\n        positions.push(particleX, particleY);\n\n        const originalR = pixels[pixelIndex] / 255;\n        const originalG = pixels[pixelIndex + 1] / 255;\n        const originalB = pixels[pixelIndex + 2] / 255;\n        const originalA = pixels[pixelIndex + 3] / 255;\n\n        colors.push(\n          originalR * logoTint.r,\n          originalG * logoTint.g,\n          originalB * logoTint.b,\n          originalA\n        );\n\n        particles.push({\n          originalX: particleX,\n          originalY: particleY,\n          velocityX: 0,\n          velocityY: 0,\n        });\n      }\n    }\n  }\n\n  positionArray = new Float32Array(positions);\n  colorArray = new Float32Array(colors);\n  createBuffers();\n  animate();\n}\n\nfunction createBuffers() {\n  positionBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, positionArray, gl.DYNAMIC_DRAW);\n\n  colorBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, colorArray, gl.STATIC_DRAW);\n}\n\nfunction animate() {\n  updatePhysics();\n  render();\n  requestAnimationFrame(animate);\n}\n\nfunction updatePhysics() {\n  if (animationCount <= 0) return;\n\n  animationCount--;\n  const radiusSquared = config.distortionRadius * config.distortionRadius;\n\n  for (let i = 0; i < particles.length; i++) {\n    const particle = particles[i];\n    const currentX = positionArray[i * 2];\n    const currentY = positionArray[i * 2 + 1];\n\n    const deltaX = mouse.x - currentX;\n    const deltaY = mouse.y - currentY;\n    const distanceSquared = deltaX * deltaX + deltaY * deltaY;\n\n    if (distanceSquared < radiusSquared && distanceSquared > 0) {\n      const force = -radiusSquared / distanceSquared;\n      const angle = Math.atan2(deltaY, deltaX);\n\n      const distFromOrigin = Math.sqrt(\n        (currentX - particle.originalX) ** 2 +\n          (currentY - particle.originalY) ** 2\n      );\n      const forceMultiplier = Math.max(\n        0.1,\n        1 - distFromOrigin / (config.maxDisplacement * 2)\n      );\n\n      particle.velocityX +=\n        force * Math.cos(angle) * config.forceStrength * forceMultiplier;\n      particle.velocityY +=\n        force * Math.sin(angle) * config.forceStrength * forceMultiplier;\n    }\n\n    particle.velocityX *= 0.82;\n    particle.velocityY *= 0.82;\n\n    const targetX =\n      currentX +\n      particle.velocityX +\n      (particle.originalX - currentX) * config.returnForce;\n    const targetY =\n      currentY +\n      particle.velocityY +\n      (particle.originalY - currentY) * config.returnForce;\n\n    const offsetX = targetX - particle.originalX;\n    const offsetY = targetY - particle.originalY;\n    const distFromOrigin = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n\n    if (distFromOrigin > config.maxDisplacement) {\n      const excess = distFromOrigin - config.maxDisplacement;\n      const scale = config.maxDisplacement / distFromOrigin;\n      const dampedScale = scale + (1 - scale) * Math.exp(-excess * 0.02);\n\n      positionArray[i * 2] = particle.originalX + offsetX * dampedScale;\n      positionArray[i * 2 + 1] = particle.originalY + offsetY * dampedScale;\n\n      particle.velocityX *= 0.7;\n      particle.velocityY *= 0.7;\n    } else {\n      positionArray[i * 2] = targetX;\n      positionArray[i * 2 + 1] = targetY;\n    }\n  }\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  gl.bufferSubData(gl.ARRAY_BUFFER, 0, positionArray);\n}\n\nfunction render() {\n  function hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result\n      ? {\n          r: parseInt(result[1], 16) / 255,\n          g: parseInt(result[2], 16) / 255,\n          b: parseInt(result[3], 16) / 255,\n        }\n      : { r: 0, g: 0, b: 0 };\n  }\n\n  gl.viewport(0, 0, canvas.width, canvas.height);\n  const bgColor = hexToRgb(config.canvasBg);\n  gl.clearColor(bgColor.r, bgColor.g, bgColor.b, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT);\n\n  if (particles.length === 0) return;\n\n  gl.useProgram(program);\n\n  const resolutionLoc = gl.getUniformLocation(program, \"u_resolution\");\n  gl.uniform2f(resolutionLoc, canvas.width, canvas.height);\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  const positionLoc = gl.getAttribLocation(program, \"a_position\");\n  gl.enableVertexAttribArray(positionLoc);\n  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n  const colorLoc = gl.getAttribLocation(program, \"a_color\");\n  gl.enableVertexAttribArray(colorLoc);\n  gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);\n\n  gl.drawArrays(gl.POINTS, 0, particles.length);\n}\n\nfunction setupEvents() {\n  document.addEventListener(\"mousemove\", (event) => {\n    const rect = canvas.getBoundingClientRect();\n    const dpr = window.devicePixelRatio || 1;\n    mouse.x = (event.clientX - rect.left) * dpr;\n    mouse.y = (event.clientY - rect.top) * dpr;\n    animationCount = 300;\n  });\n\n  window.addEventListener(\"resize\", () => {\n    setupCanvas();\n\n    if (particles.length > 0) {\n      const centerX = canvas.width / 2;\n      const centerY = canvas.height / 2;\n      const dim = Math.sqrt(particles.length);\n\n      for (let i = 0; i < particles.length; i++) {\n        const row = Math.floor(i / dim);\n        const col = i % dim;\n        const repositionX = centerX + (col - dim / 2) * 1.0;\n        const repositionY = centerY + (row - dim / 2) * 1.0;\n\n        particles[i].originalX = repositionX;\n        particles[i].originalY = repositionY;\n        positionArray[i * 2] = repositionX;\n        positionArray[i * 2 + 1] = repositionY;\n      }\n\n      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n      gl.bufferSubData(gl.ARRAY_BUFFER, 0, positionArray);\n    }\n  });\n}\n\nfunction init() {\n  setupCanvas();\n  setupWebGL();\n  setupShaders();\n  loadLogo();\n  setupEvents();\n}\n\ninit();\n",
      "shaders.js": "export const vertexShader = `\nprecision highp float;\nuniform vec2 u_resolution;\nattribute vec2 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nvoid main() {\n    vec2 zeroToOne = a_position / u_resolution;\n    vec2 clipSpace = (zeroToOne * 2.0 - 1.0);\n    v_color = a_color;\n    gl_Position = vec4(clipSpace * vec2(1.0, -1.0), 0.0, 1.0);\n    gl_PointSize = 3.5;\n}\n`;\n\nexport const fragmentShader = `\nprecision highp float;\nvarying vec4 v_color;\nvoid main() {\n    if (v_color.a < 0.01) discard;\n    vec2 coord = gl_PointCoord - vec2(0.5);\n    float dist = length(coord);\n    float alpha = 1.0 - smoothstep(0.0, 0.5, dist);\n    gl_FragColor = vec4(v_color.rgb, v_color.a * alpha);\n}\n`;\n"
    }
  },
  {
    "title": "pixelate-image-render-effect",
    "code": "Documentation\n\nStep 1: Add HTML\n\n<div data-pixelate-render=\"\" data-pixelate-render-trigger=\"inview\" class=\"pixelated-render-image\">\n  <div class=\"pixelated-render-image__before\">div>\n  <img data-pixelate-render-img=\"\" class=\"pixelated-render-image__img\" src=\"https://cdn.prod.website-files.com/68999c401f65a664b49035ad/6899e6b1a8eef7f41f2ee4cd_Portrait%20of%20Man%20in%20Blue.avif\" alt=\"\">\ndiv>\n\nStep 2: Add CSS\n\n.pixelated-render-image {\n  justify-content: center;\n  align-items: center;\n  width: 55vw;\n  display: flex;\n  position: relative;\n  overflow: hidden;\n}\n\n.pixelated-render-image__before {\n  padding-top: 75%;\n}\n\n.pixelated-render-image__before.is--portrait {\n  padding-top: 133.333%;\n}\n\n.pixelated-render-image__img {\n  object-fit: cover;\n  width: 100%;\n  height: 100%;\n  display: block;\n  position: absolute;\n}\n\nStep 2: Add custom Javascript\n\nfunction initPixelateImageRenderEffect() {\n  \n  let renderDuration = 150;  // Duration per step (in ms)\n  let renderSteps = 12;       // Number of steps from chunky to sharp\n  let renderColumns = 12;    // Starting number of columns at the most pixelated stage\n\n  document.querySelectorAll('[data-pixelate-render]').forEach(setupPixelate);\n\n  function setupPixelate(root) {\n    const img = root.querySelector('[data-pixelate-render-img]');\n    if (!img) return;\n\n    const trigger = (root.getAttribute('data-pixelate-render-trigger') || 'load').toLowerCase();\n\n    // Per-element overrides\n    const durAttr = parseInt(root.getAttribute('data-pixelate-render-duration'), 10);\n    const stepsAttr = parseInt(root.getAttribute('data-pixelate-render-steps'), 10);\n    const colsAttr = parseInt(root.getAttribute('data-pixelate-render-columns'), 10);\n\n    const fitMode = (root.getAttribute('data-pixelate-render-fit') || 'cover').toLowerCase();\n\n    const elRenderDuration = Number.isFinite(durAttr) ? Math.max(16, durAttr) : renderDuration;\n    const elRenderSteps = Number.isFinite(stepsAttr) ? Math.max(1, stepsAttr) : renderSteps;\n    const elRenderColumns = Number.isFinite(colsAttr) ? Math.max(1, colsAttr) : renderColumns;\n\n    const canvas = document.createElement('canvas');\n    canvas.setAttribute('data-pixelate-canvas', '');\n    canvas.style.position = 'absolute';\n    canvas.style.inset = '0';\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    canvas.style.pointerEvents = 'none';\n    root.style.position ||= 'relative';\n    root.appendChild(canvas);\n\n    const ctx = canvas.getContext('2d', { alpha: true });\n    ctx.imageSmoothingEnabled = false;\n\n    const back = document.createElement('canvas');\n    const tiny = document.createElement('canvas');\n    const bctx = back.getContext('2d', { alpha: true });\n    const tctx = tiny.getContext('2d', { alpha: true });\n\n    let naturalW = 0, naturalH = 0;\n    let playing = false, stageIndex = 0, stageStart = 0;\n    let backDirty = true, resizeTimeout = 0;\n    let steps = [elRenderColumns];\n\n    function fitCanvas() {\n      const r = root.getBoundingClientRect();\n      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));\n      const w = Math.max(1, Math.round(r.width * dpr));\n      const h = Math.max(1, Math.round(r.height * dpr));\n      if (canvas.width !== w || canvas.height !== h) {\n        canvas.width = w; canvas.height = h;\n        back.width = w; back.height = h;\n        backDirty = true;\n      }\n      regenerateSteps();\n    }\n\n    function regenerateSteps() {\n      const cw = Math.max(1, canvas.width);\n      const startCols = Math.min(elRenderColumns, cw);\n      const total = Math.max(1, elRenderSteps);\n      const use = Math.max(1, Math.floor(total * 0.9)); // hard-coded 80%\n      const a = [];\n      const ratio = Math.pow(cw / startCols, 1 / total);\n      for (let i = 0; i < use; i++) {\n        a.push(Math.max(1, Math.round(startCols * Math.pow(ratio, i))));\n      }\n      for (let i = 1; i < a.length; i++) if (a[i] <= a[i - 1]) a[i] = a[i - 1] + 1;\n      steps = a.length ? a : [startCols];\n    }\n\n    function drawImageToBack() {\n      if (!backDirty || !naturalW || !naturalH) return;\n      const cw = back.width, ch = back.height;\n      let dw = cw, dh = ch, dx = 0, dy = 0;\n      if (fitMode !== 'stretch') {\n        const s = fitMode === 'cover' ? Math.max(cw / naturalW, ch / naturalH) : Math.min(cw / naturalW, ch / naturalH);\n        dw = Math.max(1, Math.round(naturalW * s));\n        dh = Math.max(1, Math.round(naturalH * s));\n        dx = ((cw - dw) >> 1);\n        dy = ((ch - dh) >> 1);\n      }\n      bctx.clearRect(0, 0, cw, ch);\n      bctx.imageSmoothingEnabled = true;\n      bctx.drawImage(img, dx, dy, dw, dh);\n      backDirty = false;\n    }\n\n    function pixelate(columns) {\n      const cw = canvas.width, ch = canvas.height;\n      const cols = Math.max(1, Math.floor(columns));\n      const rows = Math.max(1, Math.round(cols * (ch / cw)));\n      if (tiny.width !== cols || tiny.height !== rows) { tiny.width = cols; tiny.height = rows; }\n      tctx.imageSmoothingEnabled = false;\n      tctx.clearRect(0, 0, cols, rows);\n      tctx.drawImage(back, 0, 0, cw, ch, 0, 0, cols, rows);\n      ctx.imageSmoothingEnabled = false;\n      ctx.clearRect(0, 0, cw, ch);\n      ctx.drawImage(tiny, 0, 0, cols, rows, 0, 0, cw, ch);\n    }\n\n    function draw(stepCols) {\n      if (!canvas.width || !canvas.height) return;\n      drawImageToBack();\n      pixelate(stepCols);\n    }\n\n    function animate(t) {\n      if (!playing) return;\n      if (!stageStart) stageStart = t;\n      if (t - stageStart >= elRenderDuration) { stageIndex++; stageStart = t; }\n      draw(steps[Math.min(stageIndex, steps.length - 1)]);\n      if (stageIndex >= steps.length - 1) {\n        canvas.style.opacity = '0';\n        playing = false;\n        window.removeEventListener('resize', onWindowResize);\n        setTimeout(() => { canvas.remove(); }, 250);\n        return;\n      }\n      requestAnimationFrame(animate);\n    }\n\n    function prime() {\n      fitCanvas();\n      const run = () => {\n        naturalW = img.naturalWidth; naturalH = img.naturalHeight;\n        if (!naturalW || !naturalH) return;\n        stageIndex = 0;\n        canvas.style.opacity = '1';\n        backDirty = true;\n        draw(steps[0]);\n      };\n      if (img.complete && img.naturalWidth) run(); else img.addEventListener('load', run, { once: true });\n    }\n\n    function start() {\n      if (playing) return;\n      fitCanvas();\n      const run = () => {\n        naturalW = img.naturalWidth; naturalH = img.naturalHeight;\n        if (!naturalW || !naturalH) return;\n        stageIndex = 0; stageStart = 0; canvas.style.opacity = '1';\n        backDirty = true;\n        playing = true;\n        requestAnimationFrame(animate);\n      };\n      if (img.complete && img.naturalWidth) run(); else img.addEventListener('load', run, { once: true });\n    }\n\n    function onResize() {\n      fitCanvas();\n      if (!playing) draw(steps[Math.min(stageIndex, steps.length - 1)] || steps[0]);\n    }\n\n    function onWindowResize() {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(onResize, 250);\n    }\n\n    if (trigger === 'load') {\n      prime();\n      start();\n    } else if (trigger === 'inview') {\n      prime();\n      const io = new IntersectionObserver(es => {\n        for (const e of es) if (e.isIntersecting) { start(); io.disconnect(); break; }\n      }, { rootMargin: '0px 0px -25% 0px', threshold: 0.25 });\n      io.observe(root);\n      window.addEventListener('resize', onWindowResize);\n    } else if (trigger === 'hover') {\n      prime();\n      root.addEventListener('mouseenter', start, { once: true });\n      window.addEventListener('resize', onWindowResize);\n    } else if (trigger === 'click') {\n      prime();\n      root.addEventListener('click', start, { once: true });\n      window.addEventListener('resize', onWindowResize);\n    }\n  }\n}\n\n// Initialize Pixelate Image Render Effect\ndocument.addEventListener('DOMContentLoaded', () => {\n  initPixelateImageRenderEffect();\n});\n\nImplementation\n\nContainer\nWrap each image you want to pixelate in a container with [data-pixelate-render]. This element controls when the effect runs based on the trigger.\n\nImage\nPlace a single image inside the container with [data-pixelate-render-img]. The script draws the fitted image into an offscreen buffer and renders a pixelated overlay canvas on top.\n\nTrigger\nControl when the animation runs with [data-pixelate-render-trigger]. Accepted values:\n- load  starts immediately once the image has loaded\n- inview  starts the first time the element is sufficiently in the viewport\n- hover  starts on first mouseenter\n- click  starts on first click\n\nOptional overrides\n\nDuration\nThis controls the amount of time each animation step takes, measured in milliseconds, and is set with the attribute [data-pixelate-render-duration=\"150\"].  A lower duration makes the transition snappier, while a higher duration creates a smoother, more gradual effect.\n\nSteps\nThis defines how many pixelation stages exist between the starting chunky look and the sharp final image, set using [data-pixelate-render-steps=\"12\"]. \n\nColumns\nThis sets how many pixel columns the image starts with at its most pixelated stage, using the attribute [data-pixelate-render-columns=\"12\"]. Rows are automatically calculated to maintain square pixels.\n\nFit\nThis determines how the image is scaled into the pixelation canvas before processing, and is set with [data-pixelate-render-fit]. \n- cover  fill the box, crop if needed\n- contain  fully visible, may letterbox\n- stretch  ignore aspect ratio\n<div \n  data-pixelate-render \n  data-pixelate-render-trigger=\"inview\"\n  data-pixelate-render-duration=\"120\"\n  data-pixelate-render-steps=\"10\"\n  data-pixelate-render-columns=\"16\"\n  data-pixelate-render-fit=\"cover\">\n  <img data-pixelate-render-img src=\"image-2.jpg\" alt=\"\">\ndiv>\nViewport behavior\n- inview uses IntersectionObserver with threshold: 0.25 which means about 25 percent of the element must be visible before the animation starts.\n- rootMargin '0px 0px -25% 0px' shrinks the bottom detection zone by 25 percent of the viewport height, which delays the trigger slightly until the element is a bit more on screen.",
    "id": "pixelate-image-render-effect"
  },
  {
    "title": "cg-playable-objects",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Interactive Matter.js Physics Animation | mukta</title>\n    <link rel=\"stylesheet\" href=\"/styles.css\" />\n  </head>\n  <body>\n    <section class=\"hero\">\n      <h1>Scroll down to break the laws of web design</h1>\n    </section>\n\n    <section class=\"footer\">\n      <div class=\"object-container\">\n        <div class=\"object\"><p>mukta</p></div>\n        <div class=\"object\"><p>HTML</p></div>\n        <div class=\"object\"><p>CSS</p></div>\n        <div class=\"object\"><p>JavaScript</p></div>\n        <div class=\"object\"><p>GSAP</p></div>\n        <div class=\"object\"><p>ScrollTrigger</p></div>\n        <div class=\"object\"><p>Lenis</p></div>\n        <div class=\"object\"><p>React</p></div>\n        <div class=\"object\"><p>Next.js</p></div>\n        <div class=\"object\"><p>WebGL</p></div>\n        <div class=\"object\"><p>Three.js</p></div>\n        <div class=\"object\"><p>Creative Dev</p></div>\n      </div>\n\n      <div class=\"footer-content\">\n        <h1>Because why list when you can play?</h1>\n      </div>\n    </section>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\"></script>\n    <script type=\"module\" src=\"/script.js\"></script>\n  </body>\n</html>\n",
      "package.json": "{\n  \"name\": \"cg-playable-objects\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"dev\": \"vite\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\",\n  \"dependencies\": {\n    \"gsap\": \"^3.13.0\",\n    \"lenis\": \"^1.3.8\",\n    \"matter-js\": \"^0.20.0\",\n    \"vite\": \"^7.0.5\"\n  }\n}\n",
      "script.js": "import { gsap } from \"gsap\";\nimport { ScrollTrigger } from \"gsap/ScrollTrigger\";\nimport Lenis from \"lenis\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  gsap.registerPlugin(ScrollTrigger);\n\n  const lenis = new Lenis();\n  lenis.on(\"scroll\", ScrollTrigger.update);\n  gsap.ticker.add((time) => {\n    lenis.raf(time * 1000);\n  });\n  gsap.ticker.lagSmoothing(0);\n\n  const animateOnScroll = true;\n\n  const config = {\n    gravity: { x: 0, y: 1 },\n    restitution: 0.5,\n    friction: 0.15,\n    frictionAir: 0.02,\n    density: 0.002,\n    wallThickness: 200,\n    mouseStiffness: 0.6,\n  };\n\n  let engine,\n    runner,\n    mouseConstraint,\n    bodies = [],\n    topWall = null;\n\n  function clamp(val, min, max) {\n    return Math.max(min, Math.min(max, val));\n  }\n\n  function initPhysics(container) {\n    engine = Matter.Engine.create();\n    engine.gravity = config.gravity;\n    engine.constraintIterations = 10;\n    engine.positionIterations = 20;\n    engine.velocityIterations = 16;\n    engine.timing.timeScale = 1;\n\n    const containerRect = container.getBoundingClientRect();\n    const wallThickness = config.wallThickness;\n\n    const walls = [\n      Matter.Bodies.rectangle(\n        containerRect.width / 2,\n        containerRect.height + wallThickness / 2,\n        containerRect.width + wallThickness * 2,\n        wallThickness,\n        { isStatic: true }\n      ),\n      Matter.Bodies.rectangle(\n        -wallThickness / 2,\n        containerRect.height / 2,\n        wallThickness,\n        containerRect.height + wallThickness * 2,\n        { isStatic: true }\n      ),\n      Matter.Bodies.rectangle(\n        containerRect.width + wallThickness / 2,\n        containerRect.height / 2,\n        wallThickness,\n        containerRect.height + wallThickness * 2,\n        { isStatic: true }\n      ),\n    ];\n    Matter.World.add(engine.world, walls);\n\n    const objects = container.querySelectorAll(\".object\");\n    objects.forEach((obj, index) => {\n      const objRect = obj.getBoundingClientRect();\n\n      const startX =\n        Math.random() * (containerRect.width - objRect.width) +\n        objRect.width / 2;\n      const startY = -500 - index * 200;\n      const startRotation = (Math.random() - 0.5) * Math.PI;\n\n      const body = Matter.Bodies.rectangle(\n        startX,\n        startY,\n        objRect.width,\n        objRect.height,\n        {\n          restitution: config.restitution,\n          friction: config.friction,\n          frictionAir: config.frictionAir,\n          density: config.density,\n        }\n      );\n\n      Matter.Body.setAngle(body, startRotation);\n\n      bodies.push({\n        body: body,\n        element: obj,\n        width: objRect.width,\n        height: objRect.height,\n      });\n\n      Matter.World.add(engine.world, body);\n    });\n\n    setTimeout(() => {\n      topWall = Matter.Bodies.rectangle(\n        containerRect.width / 2,\n        -wallThickness / 2,\n        containerRect.width + wallThickness * 2,\n        wallThickness,\n        { isStatic: true }\n      );\n      Matter.World.add(engine.world, topWall);\n    }, 3000);\n\n    const mouse = Matter.Mouse.create(container);\n    mouse.element.removeEventListener(\"mousewheel\", mouse.mousewheel);\n    mouse.element.removeEventListener(\"DOMMouseScroll\", mouse.mousewheel);\n\n    mouseConstraint = Matter.MouseConstraint.create(engine, {\n      mouse: mouse,\n      constraint: {\n        stiffness: config.mouseStiffness,\n        render: { visible: false },\n      },\n    });\n\n    mouseConstraint.mouse.element.oncontextmenu = () => false;\n\n    let dragging = null;\n    let originalInertia = null;\n\n    Matter.Events.on(mouseConstraint, \"startdrag\", function (event) {\n      dragging = event.body;\n      if (dragging) {\n        originalInertia = dragging.inertia;\n        Matter.Body.setInertia(dragging, Infinity);\n        Matter.Body.setVelocity(dragging, { x: 0, y: 0 });\n        Matter.Body.setAngularVelocity(dragging, 0);\n      }\n    });\n\n    Matter.Events.on(mouseConstraint, \"enddrag\", function (event) {\n      if (dragging) {\n        Matter.Body.setInertia(dragging, originalInertia || 1);\n        dragging = null;\n        originalInertia = null;\n      }\n    });\n\n    Matter.Events.on(engine, \"beforeUpdate\", function () {\n      if (dragging) {\n        const found = bodies.find((b) => b.body === dragging);\n        if (found) {\n          const minX = found.width / 2;\n          const maxX = containerRect.width - found.width / 2;\n          const minY = found.height / 2;\n          const maxY = containerRect.height - found.height / 2;\n\n          Matter.Body.setPosition(dragging, {\n            x: clamp(dragging.position.x, minX, maxX),\n            y: clamp(dragging.position.y, minY, maxY),\n          });\n\n          Matter.Body.setVelocity(dragging, {\n            x: clamp(dragging.velocity.x, -20, 20),\n            y: clamp(dragging.velocity.y, -20, 20),\n          });\n        }\n      }\n    });\n\n    container.addEventListener(\"mouseleave\", () => {\n      mouseConstraint.constraint.bodyB = null;\n      mouseConstraint.constraint.pointB = null;\n    });\n\n    document.addEventListener(\"mouseup\", () => {\n      mouseConstraint.constraint.bodyB = null;\n      mouseConstraint.constraint.pointB = null;\n    });\n\n    Matter.World.add(engine.world, mouseConstraint);\n\n    runner = Matter.Runner.create();\n    Matter.Runner.run(runner, engine);\n\n    function updatePositions() {\n      bodies.forEach(({ body, element, width, height }) => {\n        const x = clamp(\n          body.position.x - width / 2,\n          0,\n          containerRect.width - width\n        );\n        const y = clamp(\n          body.position.y - height / 2,\n          -height * 3,\n          containerRect.height - height\n        );\n\n        element.style.left = x + \"px\";\n        element.style.top = y + \"px\";\n        element.style.transform = `rotate(${body.angle}rad)`;\n      });\n\n      requestAnimationFrame(updatePositions);\n    }\n    updatePositions();\n  }\n\n  if (animateOnScroll) {\n    document.querySelectorAll(\"section\").forEach((section) => {\n      if (section.querySelector(\".object-container\")) {\n        ScrollTrigger.create({\n          trigger: section,\n          start: \"top bottom\",\n          once: true,\n          onEnter: () => {\n            const container = section.querySelector(\".object-container\");\n            if (container && !engine) {\n              initPhysics(container);\n            }\n          },\n        });\n      }\n    });\n  } else {\n    window.addEventListener(\"load\", () => {\n      const container = document.querySelector(\".object-container\");\n      if (container) {\n        initPhysics(container);\n      }\n    });\n  }\n});\n",
      "styles.css": "@import url(\"https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&display=swap\");\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: \"DM Sans\", sans-serif;\n}\n\nh1 {\n  font-size: 4rem;\n  font-weight: 500;\n  letter-spacing: -0.04rem;\n  line-height: 1.2;\n  user-select: none;\n}\n\nsection {\n  position: relative;\n  width: 100vw;\n  height: 100svh;\n  padding: 2rem;\n  overflow: hidden;\n}\n\n.hero h1,\n.footer h1 {\n  width: 45%;\n  text-align: center;\n}\n\n.hero {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background: #fff;\n  color: #0f0f0f;\n}\n\n.footer {\n  background-color: #0f0f0f;\n  color: #fff;\n}\n\n.footer-content {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  padding: 2rem;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  pointer-events: none;\n}\n\n.footer-content * {\n  pointer-events: auto;\n}\n\n.object-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.object {\n  position: absolute;\n  width: max-content;\n  font-size: 2rem;\n  font-weight: 500;\n  background-color: #fff;\n  color: #0f0f0f;\n  padding: 1rem 2rem;\n  border-radius: 50px;\n  cursor: grab;\n  user-select: none;\n  pointer-events: auto;\n  z-index: 2;\n}\n\n.object:active {\n  cursor: grabbing;\n}\n\n@media (max-width: 1000px) {\n  h1 {\n    font-size: 2rem;\n  }\n\n  .hero h1,\n  .footer h1 {\n    width: 100%;\n  }\n\n  .object {\n    font-size: 1rem;\n  }\n}\n"
    }
  },
  {
    "title": "Spotify Wrapped Animation using GSAP",
    "description": "",
    "code": "index.html: <div class=\"container\"> \t \t<div class=\"tube\"> \t\t<h1 class=\"clone\">Tastebreakers</h1> \t</div> \t<div class=\"final__wrap\"></div> \t <!-- Required Structure --> <!-- \t<div class=\"tube\"> \t\t<h1 class=\"line line1\">Tastebreakers</h1> \t\t<h1 class=\"line line2\">Tastebreakers</h1> \t\t<h1 class=\"line line3\">Tastebreakers</h1>\t \t</div> \t<div class=\"final__wrap\"> \t\t<h1 class=\"final\">Tastebreakers</h1> \t</div> --> \t </div> <a href=\"https://spotifywrapped.com/en/\" target=\"_blank\" class=\"logo\"> \t<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 558.43 167.49\"> <title>Spotify Logo</title> <g> <path d=\"M88,1.28A83.74,83.74,0,1,0,171.74,85,83.75,83.75,0,0,0,88,1.28Zm38.4,120.78a5.22,5.22,0,0,1-7.18,1.74c-19.66-12-44.41-14.73-73.56-8.07a5.22,5.22,0,0,1-2.33-10.18c31.9-7.29,59.27-4.15,81.34,9.34A5.21,5.21,0,0,1,126.4,122.06Zm10.25-22.8a6.53,6.53,0,0,1-9,2.15c-22.51-13.83-56.82-17.84-83.45-9.76a6.53,6.53,0,1,1-3.79-12.49c30.41-9.23,68.22-4.76,94.07,11.12A6.53,6.53,0,0,1,136.65,99.26Zm.88-23.74c-27-16-71.52-17.51-97.29-9.69a7.83,7.83,0,0,1-4.54-15c29.58-9,78.75-7.24,109.83,11.21a7.83,7.83,0,0,1-8,13.47Z\" transform=\"translate(-4.25 -1.28)\" fill=\"#1ed760\"/> <g> <g> <path d=\"M232.09,78.59c-14.46-3.45-17-5.87-17-11,0-4.8,4.52-8,11.24-8,6.52,0,13,2.45,19.77,7.51a1,1,0,0,0,1.34-.22l7.06-10a1,1,0,0,0-.18-1.29A42.74,42.74,0,0,0,226.52,46C210.91,46,200,55.4,200,68.81c0,14.37,9.41,19.46,25.66,23.39,13.84,3.19,16.18,5.86,16.18,10.63,0,5.29-4.73,8.58-12.32,8.58-8.44,0-15.33-2.84-23-9.51a1,1,0,0,0-.69-.23.91.91,0,0,0-.65.34l-7.92,9.42a.94.94,0,0,0,.09,1.31A47.19,47.19,0,0,0,229.2,125c16.82,0,27.69-9.19,27.69-23.42C256.89,89.52,249.71,82.87,232.09,78.59Z\" transform=\"translate(-4.25 -1.28)\" fill=\"#1ed760\"/> <path d=\"M295,64.33c-7.29,0-13.27,2.87-18.21,8.75V66.46a1,1,0,0,0-.94-.95H262.85a1,1,0,0,0-.94.95v73.6a1,1,0,0,0,.94.95H275.8a1,1,0,0,0,.94-.95V116.83A23.29,23.29,0,0,0,295,125.07c13.55,0,27.27-10.43,27.27-30.37S308.5,64.33,295,64.33ZM307.16,94.7c0,10.15-6.25,17.24-15.21,17.24s-15.53-7.41-15.53-17.24S283.1,77.46,292,77.46,307.16,84.71,307.16,94.7Z\" transform=\"translate(-4.25 -1.28)\" fill=\"#1ed760\"/> <path d=\"M357.37,64.33c-17.45,0-31.12,13.43-31.12,30.59,0,17,13.58,30.26,30.91,30.26,17.51,0,31.22-13.39,31.22-30.48S374.76,64.33,357.37,64.33Zm0,47.72c-9.28,0-16.28-7.46-16.28-17.35s6.76-17.13,16.07-17.13S373.54,85,373.54,94.92,366.74,112.05,357.37,112.05Z\" transform=\"translate(-4.25 -1.28)\" fill=\"#1ed760\"/> <path d=\"M425.64,65.51H411.4V50.94a1,1,0,0,0-.95-.94H397.51a.94.94,0,0,0-.95.94V65.51h-6.23a1,1,0,0,0-.94.95V77.59a.94.94,0,0,0,.94.94h6.23v28.8c0,11.63,5.79,17.53,17.21,17.53a23.62,23.62,0,0,0,12.13-3,1,1,0,0,0,.48-.82V110.43a1,1,0,0,0-.45-.81.94.94,0,0,0-.93,0,16.35,16.35,0,0,1-7.6,1.83c-4.15,0-6-1.89-6-6.11V78.53h14.24a.94.94,0,0,0,.95-.94V66.46A1,1,0,0,0,425.64,65.51Z\" transform=\"translate(-4.25 -1.28)\" fill=\"#1ed760\"/> <path d=\"M475.28,65.57V63.78c0-5.27,2-7.61,6.55-7.61a21.86,21.86,0,0,1,7.29,1.34.92.92,0,0,0,.85-.13.94.94,0,0,0,.4-.77V45.7a1,1,0,0,0-.67-.91,35.73,35.73,0,0,0-10.77-1.54c-11.95,0-18.27,6.73-18.27,19.46v2.74h-6.22a1,1,0,0,0-.95,1V77.59a.94.94,0,0,0,.95.94h6.22v44.41a.94.94,0,0,0,.94,1h12.95a1,1,0,0,0,.95-1V78.53h12.08l18.52,44.4c-2.1,4.67-4.17,5.6-7,5.6a15,15,0,0,1-7.14-2,.93.93,0,0,0-1.31.44l-4.39,9.63a.93.93,0,0,0,.41,1.22,27.25,27.25,0,0,0,13.82,3.54c9.56,0,14.85-4.45,19.5-16.43l22.47-58a1,1,0,0,0-.1-.88,1,1,0,0,0-.78-.41H528.11a1,1,0,0,0-.9.63l-13.8,39.44L498.28,66.18a.94.94,0,0,0-.88-.61Z\" transform=\"translate(-4.25 -1.28)\" fill=\"#1ed760\"/> <rect x=\"428.36\" y=\"64.23\" width=\"14.84\" height=\"58.38\" rx=\"0.95\" ry=\"0.95\" fill=\"#1ed760\"/> <path d=\"M440.1,39.79a9.29,9.29,0,1,0,9.28,9.28A9.28,9.28,0,0,0,440.1,39.79Z\" transform=\"translate(-4.25 -1.28)\" fill=\"#1ed760\"/> </g> <path d=\"M553.52,83.67a9.14,9.14,0,1,1,9.16-9.16A9.16,9.16,0,0,1,553.52,83.67Zm.05-17.36a8.23,8.23,0,1,0,8.15,8.2A8.15,8.15,0,0,0,553.57,66.31Zm2,9.13,2.57,3.61H556l-2.32-3.31h-2v3.31h-1.82V69.49h4.26c2.22,0,3.69,1.14,3.69,3.05A2.85,2.85,0,0,1,555.59,75.44Zm-1.54-4.31h-2.37v3h2.37c1.18,0,1.89-.58,1.89-1.51S555.23,71.13,554.05,71.13Z\" transform=\"translate(-4.25 -1.28)\" fill=\"#1ed760\"/> </g> </g> </svg> </a> [[[https://codepen.io/petebarr/pen/2fc0573674b0f849badd58a15371534e]]]\nstyle.css: html { \tbox-sizing: border-box; } *, *:before, *:after { \tbox-sizing: inherit; } body { \tbackground: #191414; \tfont-family: 'Montserrat', sans-serif; \tcolor: #F59B23; } body, html { \theight: 100%; \twidth: 100%; \tmargin: 0; \tpadding: 0; } .container { \tdisplay: flex; \talign-items: center; \tjustify-content: center; \twidth: 100%; \theight: 100%; \tvisibility: hidden; } .tube { \tposition: relative; \twidth: 100%; \theight: 24vw; \t// height: 16vw; \t// overflow: hidden; } .line { \tposition: absolute; \ttop: 50%; \tleft: 50%; \ttransform: translate(-50%, -50%); \tline-height: 1; \tmargin: 0; \tletter-spacing: -0.6vw; \tfont-size: 18vw; \twhite-space: nowrap; \ttext-align: center; \t \tdiv { \t\tbackface-visibility: hidden; \t} } .final__wrap { \tposition: absolute; \ttop: 50%; \tleft: 50%; \ttransform: translate(-50%, -50%); } .final { \tline-height: 1; \tmargin: 0; \tfont-size: 13vw; \tletter-spacing: -0.5vw; \twhite-space: nowrap; \t \tdiv { \t\tbackface-visibility: hidden; \t} } .logo { \tposition: absolute; \ttop: 24px; \tleft: 50%; \ttransform: translateX(-50%); \twidth: 100px; \theight: auto; }\nscript.js: console.clear(); // Get the core elements var container = document.getElementsByClassName(\"container\"); var tube = document.getElementsByClassName(\"tube\"); var clone = document.getElementsByClassName(\"clone\"); var finalWrap = document.getElementsByClassName(\"final__wrap\"); // Create the cloned nodes, append and add classes for required HTML structure - WARNING: Ugly code below ðŸ’© var finalClone = clone[0].cloneNode(true); // clone the clean node and append to final__wrap finalWrap[0].appendChild(finalClone).classList.add(\"final\"); for (var i = 0; i < 2; i++) { \tvar newClone = clone[0].cloneNode(true); // clone the header \tvar lineClass = \"line\"+(i+2); // create class name to append \ttube[0].appendChild(newClone); // append the clone \tclone[i].classList.add(\"line\"); // add cline lass \tclone[i+1].classList.add(lineClass); // add incremented line class } clone[0].classList.add(\"line1\"); // add line1 class to the first node // Yuk! Now for the fun stuffâ€¦ // Show it to me! TweenMax.set('.container', { \tvisibility: 'visible' }); // Get cloned elements var lines = document.getElementsByClassName(\"line\"); var line1 = document.getElementsByClassName(\"line1\"); var line2 = document.getElementsByClassName(\"line2\"); var line3 = document.getElementsByClassName(\"line3\"); var final = document.getElementsByClassName(\"final\"); // split the text characters var splitLine1 = new SplitText(line1, { type:\" chars\", charsClass:\"char\" }); var splitLine2 = new SplitText(line2, { type:\" chars\", charsClass:\"char\" }); var splitLine3 = new SplitText(line3, { type:\" chars\", charsClass:\"char\" }); var splitFinal = new SplitText(final, { type:\" chars\", charsClass:\"char\" }); // Set up vars var animTime = 0.9; // baseline animation time for each stagger var width = document.documentElement.clientWidth; // viewport width var height = document.documentElement.clientHeight; // viewport height var depth = -width/8; // rotation depth based on viewport width var tOrigin = \"50% 50% \"+depth; // transform origin as a factor of viewport width to allow for different device widths // Init 3D perspective TweenMax.set([lines, final], { perspective:700, transformStyle:\"preserve-3d\"}); // Animate Timeline var linesTL = new TimelineMax(); linesTL.staggerFromTo(splitLine1.chars, animTime, { rotationX: -90 }, { rotationX: 90, ease:Linear.easeNone, transformOrigin: tOrigin }, 0.08) \t.staggerFromTo(splitLine2.chars, animTime, { rotationX: -90 }, { rotationX: 90, ease:Linear.easeNone, transformOrigin: tOrigin }, 0.08, 0.45) \t.staggerFromTo(splitLine3.chars, animTime, { rotationX: -90 }, { rotationX: 90, ease:Linear.easeNone, transformOrigin: tOrigin }, 0.08, 0.9) \t.staggerFromTo(splitFinal.chars, animTime*1.8, { rotationX: -90, alpha: 0 }, { rotationX: 0, alpha: 1, ease:Expo.easeOut, transformOrigin: tOrigin }, 0.06, 1.6) \t.fromTo(final, animTime*5, { y:height/6 }, { y:-height/6 , ease:Power4.easeOut }, 2.0 ) // Rotate final text on mouse move window.addEventListener(\"mousemove\", onMouseMove); function onMouseMove(e) { \tvar sxPos = (e.pageX / width*100 - 50)*2 ; \tvar syPos = (e.pageY / height*100 - 50)*2; \tTweenMax.to(finalWrap, 3, { \t\trotationY: 0.04 * sxPos, \t\trotationX: -0.04 * syPos, \t\ttransformOrigin: \"center center -800\", \t\tease: Expo.easeOut \t}); } // linesTL.pause(); // var progressTL = new TimelineMax(); // progressTL.fromTo(linesTL, animTime*8, { progress: 0 }, { progress: 1, ease: Sine.easeOut }) \t /* ========================================================================== Greensock Dev Tools ========================================================================== */ \t//instantiate GSDevTools with default settings \tGSDevTools.create( ); /* ========================================================================== FPS GUI stats.js ========================================================================== */ // (function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()",
    "id": "spotify-wrapped-animation-using-gsap"
  },
  {
    "title": "Black Hole (WebGL Shader)",
    "description": "",
    "code": "index.html: <script id=\"2d-fragment-shader\" type=\"x-shader/x-fragment\">// <![CDATA[ // Look below at line 23 for realism. #ifdef GL_ES precision mediump float; #endif #define PI 3.14159265359 uniform sampler2D u_image; varying vec2 v_texCoord; uniform vec2 u_resolution; uniform vec2 u_mouse; uniform float u_mass; uniform float u_time; uniform float u_clickedTime; vec2 rotate(vec2 mt, vec2 st, float angle){ \tfloat cos = cos((angle + u_clickedTime) * PI); // try replacing * 1.0 with * PI \tfloat sin = sin(angle * 0.0); // try removing the * 0.0 \t \t// Uncomment these two lines for realism \t//float cos = cos(angle) * (u_time * 0.3); \t//float sin = sin(angle) * (u_time * 0.3); \t \tfloat nx = (cos * (st.x - mt.x)) + (sin * (st.y - mt.y)) + mt.x; \tfloat ny = (cos * (st.y - mt.y)) - (sin * (st.x - mt.x)) + mt.y; \treturn vec2(nx, ny); } void main() { vec2 st = vec2(gl_FragCoord.x, u_resolution.y - gl_FragCoord.y)/u_resolution; \tvec2 mt = vec2(u_mouse.x, u_resolution.y - u_mouse.y)/u_resolution; \tfloat dx = st.x - mt.x; \tfloat dy = st.y - mt.y; \tfloat dist = sqrt(dx * dx + dy * dy); \tfloat pull = u_mass / (dist * dist); \t vec3 color = vec3(0.0); \t \tvec2 r = rotate(mt,st,pull); \tvec4 imgcolor = texture2D(u_image, r); \tcolor = vec3( \t\t(imgcolor.x - (pull * 0.25)), \t\t(imgcolor.y - (pull * 0.25)), \t\t(imgcolor.z - (pull * 0.25)) \t); \t gl_FragColor = vec4(color,1.); } // ]]></script> <script id=\"2d-vertex-shader\" type=\"x-shader/x-vertex\">// <![CDATA[ \tattribute vec2 a_position; \tattribute vec2 a_texCoord; \t \tvarying vec2 v_texCoord; \tvoid main() { \t\tgl_Position = vec4(a_position, 0, 1); \t\tv_texCoord = a_texCoord; \t} \t// ]]></script> <canvas id=\"glscreen\"></canvas>\nstyle.css: html, body { \tposition: absolute; \ttop: 0px; \tleft: 0px; \tright: 0px; \tbottom: 0px; \tpadding: 0px; \t//cursor: none; \tmargin: 0px; \toverflow: hidden; \tdisplay: flex; \theight: 100%; \twidth: 100%; \tbackground-color: #000; } canvas { \tmargin: auto auto; }\nscript.js: // set up global javascript variables var bgUrl = 'https://images.unsplash.com/photo-1462331940025-496dfbfc7564?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1427&q=80' var blackholeMass = 1500; var curblackholeMass = 0; var canvas, gl; // canvas and webgl context var shaderScript; var shaderSource; var vertexShader; // Vertex shader. Not much happens in that shader, it just creates the vertex's to be drawn on var fragmentShader; // this shader is where the magic happens. Fragment = pixel. Vertex = kind of like \"faces\" on a 3d model. var buffer; /* Variables holding the location of uniform variables in the WebGL. We use this to send info to the WebGL script. */ var locationOfTime; var locationOfResolution; var locationOfMouse; var locationOfMass; var locationOfclickedTime; var originY = window.innerHeight, originX = window.innerWidth; var mouse; var startTime = new Date().getTime(); // Get start time for animating var currentTime = 0; var clicked = false, clickedTime = 0; $(document).mousedown(function(){ \tclicked = true; }); $(document).mouseup(function(){ \tclicked = false; }); function init(image) { \t// standard canvas setup here, except get webgl context \tcanvas = document.getElementById('glscreen'); \tgl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); \tcanvas.width = window.innerWidth >= window.innerHeight ? window.innerWidth : window.innerHeight; \tcanvas.height = window.innerWidth >= window.innerHeight ? window.innerWidth : window.innerHeight; \tmouse = {x: originX/2, y: -(originY/2) + canvas.height, moved: false}; \t$(document).mousemove(function(e) { \t\tmouse.x = e.pageX; \t\tmouse.y = -e.pageY + canvas.height; \t\tmouse.moved = true; \t}); \t// give WebGL it's viewport \tgl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); \t// kind of back-end stuff \tbuffer = gl.createBuffer(); \tgl.bindBuffer(gl.ARRAY_BUFFER, buffer); \tgl.bufferData( \t\tgl.ARRAY_BUFFER, \t\tnew Float32Array([ \t\t\t-1.0, -1.0, \t\t\t1.0, -1.0, \t\t\t-1.0, 1.0, \t\t\t-1.0, 1.0, \t\t\t1.0, -1.0, \t\t\t1.0, 1.0]), \t\tgl.STATIC_DRAW \t); // ^^ That up there sets up the vertex's used to draw onto. I think at least, I haven't payed much attention to vertex's yet, for all I know I'm wrong. \tshaderScript = document.getElementById(\"2d-vertex-shader\"); \tshaderSource = shaderScript.text; \tvertexShader = gl.createShader(gl.VERTEX_SHADER); //create the vertex shader from script \tgl.shaderSource(vertexShader, shaderSource); \tgl.compileShader(vertexShader); \tshaderScript = document.getElementById(\"2d-fragment-shader\"); \tshaderSource = shaderScript.text; \tfragmentShader = gl.createShader(gl.FRAGMENT_SHADER); //create the fragment from script \tgl.shaderSource(fragmentShader, shaderSource); \tgl.compileShader(fragmentShader); \tprogram = gl.createProgram(); // create the WebGL program. This variable will be used to inject our javascript variables into the program. \tgl.attachShader(program, vertexShader); // add the shaders to the program \tgl.attachShader(program, fragmentShader); // ^^ \tgl.linkProgram(program);\t // Tell our WebGL application to use the program \tgl.useProgram(program); // ^^ yep, but now literally use it. \t/* \tAlright, so here we're attatching javascript variables to the WebGL code. First we get the location of the uniform variable inside the program. \tWe use the gl.getUniformLocation function to do this, and pass thru the program variable we created above, as well as the name of the uniform variable in our shader. \t*/ \tlocationOfResolution = gl.getUniformLocation(program, \"u_resolution\"); \tlocationOfMouse = gl.getUniformLocation(program, \"u_mouse\"); \tlocationOfMass = gl.getUniformLocation(program, \"u_mass\"); \tlocationOfTime = gl.getUniformLocation(program, \"u_time\"); \tlocationOfclickedTime = gl.getUniformLocation(program, \"u_clickedTime\"); \t/* \tThen we simply apply our javascript variables to the program. \tNotice, it gets a bit tricky doing this. If you're editing a float value, gl.uniformf works. \tBut if we want to send over an array of floats, for example, we'd use gl.uniform2f. We're specifying that we are sending 2 floats at the end. \tYou can also send it over to the program as a vector, by using gl.uniform2fv. \tTo read up on all of the different gl.uniform** stuff, to send any variable you want, I'd recommend using the table (found on this site, but you need to scroll down about 300px) \thttps://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#uniforms \t*/ \tgl.uniform2f(locationOfResolution, canvas.width, canvas.height); \tgl.uniform2f(locationOfMouse, mouse.x, mouse.y); \tgl.uniform1f(locationOfMass, curblackholeMass*0.00001); \tgl.uniform1f(locationOfTime, currentTime); \tgl.uniform1f(locationOfclickedTime, clickedTime); \tvar texCoordLocation = gl.getAttribLocation(program, \"a_texCoord\"); \t// provide texture coordinates for the rectangle. \tvar texCoordBuffer = gl.createBuffer(); \tgl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); \tgl.bufferData(gl.ARRAY_BUFFER, \t\tnew Float32Array([ \t\t-1.0, -1.0, \t\t1.0, -1.0, \t\t-1.0, 1.0, \t\t-1.0, 1.0, \t\t1.0, -1.0, \t\t1.0, 1.0]), \t\t\t gl.STATIC_DRAW); \tgl.enableVertexAttribArray(texCoordLocation); \tgl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0); \t// Create a texture. \tvar texture = gl.createTexture(); \tgl.bindTexture(gl.TEXTURE_2D, texture); \t// Set the parameters so we can render any size image. \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); \t// Upload the image into the texture. \tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); \trender(); } function render() { \tvar now = new Date().getTime(); \tcurrentTime = (now - startTime) / 1000; // update the current time for animations \tif(curblackholeMass < blackholeMass - 50){ \t\tcurblackholeMass += (blackholeMass-curblackholeMass) * 0.03; \t} \tif(clicked){ \t\tclickedTime += 0.03; \t} else if(clickedTime > 0 && clicked == false) { \t\tclickedTime += -(clickedTime*0.015); \t} \tif(mouse.moved == false){ \t\tmouse.y = (-(originY/2) + Math.sin(currentTime * 0.7) * ((originY * 0.25))) + canvas.height; \t\tmouse.x = (originX/2) + Math.sin(currentTime * 0.6) * -(originX * 0.35); \t} \tgl.uniform1f(locationOfMass, curblackholeMass*0.00001); \tgl.uniform2f(locationOfMouse, mouse.x, mouse.y); \tgl.uniform1f(locationOfTime, currentTime); // update the time uniform in our shader \tgl.uniform1f(locationOfclickedTime, clickedTime); \twindow.requestAnimationFrame(render, canvas); // request the next frame \tpositionLocation = gl.getAttribLocation(program, \"a_position\"); // do stuff for those vertex's \tgl.enableVertexAttribArray(positionLocation); \tgl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0); \tgl.drawArrays(gl.TRIANGLES, 0, 6); } window.addEventListener('load', function(event){ \tvar image = new Image(); \timage.crossOrigin = \"Anonymous\"; \timage.src = bgUrl; \timage.onload = function() { \t\tinit(image); \t} }); window.addEventListener('resize', function(event){ \t// just re-doing some stuff in the init here, to enable resizing. \tcanvas.width = window.innerWidth >= window.innerHeight ? window.innerWidth : window.innerHeight; \tcanvas.height = window.innerWidth >= window.innerHeight ? window.innerWidth : window.innerHeight; \tgl.viewport(0, 0, canvas.width, canvas.height); \tlocationOfResolution = gl.getUniformLocation(program, \"u_resolution\"); });",
    "id": "black-hole-webgl-shader"
  },
  {
    "title": "water distortion",
    "description": "",
    "code": "index.html: <input id=\"image-selector-input\" style=\"visibility:hidden;\" type=\"file\"> <canvas></canvas> <script type=\"x-shader/x-fragment\" id=\"vertShader\"> \tprecision mediump float; varying vec2 vUv; attribute vec2 a_position; void main() { vUv = .5 * (a_position + 1.); gl_Position = vec4(a_position, 0.0, 1.0); } </script> <script type=\"x-shader/x-fragment\" id=\"fragShader\"> \tprecision mediump float; varying vec2 vUv; uniform sampler2D u_image_texture; uniform float u_time; uniform float u_ratio; uniform float u_img_ratio; uniform float u_blueish; uniform float u_scale; uniform float u_illumination; uniform float u_surface_distortion; uniform float u_water_distortion; #define TWO_PI 6.28318530718 #define PI 3.14159265358979323846 vec3 mod289(vec3 x) { return x - floor(x * (1. / 289.)) * 289.; } vec2 mod289(vec2 x) { return x - floor(x * (1. / 289.)) * 289.; } vec3 permute(vec3 x) { return mod289(((x*34.)+1.)*x); } float snoise(vec2 v) { const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i = floor(v + dot(v, C.yy)); vec2 x0 = v - i + dot(i, C.xx); vec2 i1; i1 = (x0.x > x0.y) ? vec2(1., 0.) : vec2(0., 1.); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod289(i); vec3 p = permute(permute(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.)); vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.); m = m*m; m = m*m; vec3 x = 2. * fract(p * C.www) - 1.; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h); vec3 g; g.x = a0.x * x0.x + h.x * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130. * dot(m, g); } mat2 rotate2D(float r) { return mat2(cos(r), sin(r), -sin(r), cos(r)); } float surface_noise(vec2 uv, float t, float scale) { vec2 n = vec2(.1); vec2 N = vec2(.1); mat2 m = rotate2D(.5); for (int j = 0; j < 10; j++) { uv *= m; n *= m; vec2 q = uv * scale + float(j) + n + (.5 + .5 * float(j)) * (mod(float(j), 2.) - 1.) * t; n += sin(q); N += cos(q) / scale; scale *= 1.2; } return (N.x + N.y + .1); } void main() { vec2 uv = vUv; uv.y = 1. - uv.y; uv.x *= u_ratio; float t = .002 * u_time; vec3 color = vec3(0.); float opacity = 0.; float outer_noise = snoise((.3 + .1 * sin(t)) * uv + vec2(0., .2 * t)); vec2 surface_noise_uv = 2. * uv + (outer_noise * .2); float surface_noise = surface_noise(surface_noise_uv, t, u_scale); surface_noise *= pow(uv.y, .3); surface_noise = pow(surface_noise, 2.); vec2 img_uv = vUv; img_uv -= .5; if (u_ratio > u_img_ratio) { img_uv.x = img_uv.x * u_ratio / u_img_ratio; } else { img_uv.y = img_uv.y * u_img_ratio / u_ratio; } float scale_factor = 1.4; img_uv *= scale_factor; img_uv += .5; img_uv.y = 1. - img_uv.y; img_uv += (u_water_distortion * outer_noise); img_uv += (u_surface_distortion * surface_noise); vec4 img = texture2D(u_image_texture, img_uv); img *= (1. + u_illumination * surface_noise); color += img.rgb; color += u_illumination * vec3(1. - u_blueish, 1., 1.) * surface_noise; opacity += img.a; float edge_width = .02; float edge_alpha = smoothstep(0., edge_width, img_uv.x) * smoothstep(1., 1. - edge_width, img_uv.x); edge_alpha *= smoothstep(0., edge_width, img_uv.y) * smoothstep(1., 1. - edge_width, img_uv.y); color *= edge_alpha; opacity *= edge_alpha; gl_FragColor = vec4(color, opacity); } </script>\nstyle.css: body, html { \tmargin: 0; \tpadding: 0; } canvas { \tposition: fixed; \ttop: 0; \tleft: 0; \twidth: 100%; } .lil-gui { \tdisplay: none !important; \t--width: 400px; \t--widget-height: 20px; \tfont-size: 15px; \t--input-font-size: 15px; \t--padding: 10px; \t--spacing: 10px; \t--slider-knob-width: 5px; \t--background-color: rgba(5, 0, 15, 0.9); \t--widget-color: rgba(255, 255, 255, 0.3); \t--focus-color: rgba(255, 255, 255, 0.4); \t--hover-color: rgba(255, 255, 255, 0.5); \t--font-family: monospace; \tz-index: 1; }\nscript.js: import GUI from \"https://cdn.jsdelivr.net/npm/lil-gui@0.18.2/+esm\"; const canvasEl = document.querySelector(\"canvas\"); const imgInput = document.querySelector(\"#image-selector-input\"); const devicePixelRatio = Math.min(window.devicePixelRatio, 2); const params = { \tblueish: 0.6, \tscale: 7, \tillumination: 0.15, \tsurfaceDistortion: 0.07, \twaterDistortion: 0.03, \tloadMyImage: () => { \t\timgInput.click(); \t} }; imgInput.onchange = () => { \tconst [file] = imgInput.files; \tif (file) { \t\tconst reader = new FileReader(); \t\treader.onload = (e) => { \t\t\tloadImage(e.target.result); \t\t}; \t\treader.readAsDataURL(file); \t} }; let image, uniforms; const gl = initShader(); updateUniforms(); loadImage( \t\"https://cdn.shopify.com/s/files/1/0185/5999/1872/files/hero--desktop.webp?v=1759340146\" ); createControls(); render(); window.addEventListener(\"resize\", resizeCanvas); function initShader() { \tconst vsSource = document.getElementById(\"vertShader\").innerHTML; \tconst fsSource = document.getElementById(\"fragShader\").innerHTML; \tconst gl = \t\tcanvasEl.getContext(\"webgl\") || canvasEl.getContext(\"experimental-webgl\"); \tif (!gl) { \t\talert(\"WebGL is not supported by your browser.\"); \t} \tfunction createShader(gl, sourceCode, type) { \t\tconst shader = gl.createShader(type); \t\tgl.shaderSource(shader, sourceCode); \t\tgl.compileShader(shader); \t\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { \t\t\tconsole.error( \t\t\t\t\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader) \t\t\t); \t\t\tgl.deleteShader(shader); \t\t\treturn null; \t\t} \t\treturn shader; \t} \tconst vertexShader = createShader(gl, vsSource, gl.VERTEX_SHADER); \tconst fragmentShader = createShader(gl, fsSource, gl.FRAGMENT_SHADER); \tfunction createShaderProgram(gl, vertexShader, fragmentShader) { \t\tconst program = gl.createProgram(); \t\tgl.attachShader(program, vertexShader); \t\tgl.attachShader(program, fragmentShader); \t\tgl.linkProgram(program); \t\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) { \t\t\tconsole.error( \t\t\t\t\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program) \t\t\t); \t\t\treturn null; \t\t} \t\treturn program; \t} \tconst shaderProgram = createShaderProgram(gl, vertexShader, fragmentShader); \tuniforms = getUniforms(shaderProgram); \tfunction getUniforms(program) { \t\tlet uniforms = []; \t\tlet uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); \t\tfor (let i = 0; i < uniformCount; i++) { \t\t\tlet uniformName = gl.getActiveUniform(program, i).name; \t\t\tuniforms[uniformName] = gl.getUniformLocation(program, uniformName); \t\t} \t\treturn uniforms; \t} \tconst vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]); \tconst vertexBuffer = gl.createBuffer(); \tgl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); \tgl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); \tgl.useProgram(shaderProgram); \tconst positionLocation = gl.getAttribLocation(shaderProgram, \"a_position\"); \tgl.enableVertexAttribArray(positionLocation); \tgl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); \tgl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0); \treturn gl; } function updateUniforms() { \tgl.uniform1f(uniforms.u_blueish, params.blueish); \tgl.uniform1f(uniforms.u_scale, params.scale); \tgl.uniform1f(uniforms.u_illumination, params.illumination); \tgl.uniform1f(uniforms.u_surface_distortion, params.surfaceDistortion); \tgl.uniform1f(uniforms.u_water_distortion, params.waterDistortion); } function loadImage(src) { \timage = new Image(); \timage.crossOrigin = \"anonymous\"; \timage.src = src; \timage.onload = () => { \t\tconst imageTexture = gl.createTexture(); \t\tgl.bindTexture(gl.TEXTURE_2D, imageTexture); \t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); \t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); \t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); \t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); \t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); \t\tgl.uniform1i(uniforms.u_image_texture, 0); \t\tresizeCanvas(); \t}; } function render() { \tconst currentTime = performance.now(); \tgl.uniform1f(uniforms.u_time, currentTime); \tgl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); \trequestAnimationFrame(render); } function resizeCanvas() { \tconst imgRatio = image.naturalWidth / image.naturalHeight; \tcanvasEl.width = window.innerWidth * devicePixelRatio; \tcanvasEl.height = window.innerHeight * devicePixelRatio; \tgl.viewport(0, 0, canvasEl.width, canvasEl.height); \tgl.uniform1f(uniforms.u_ratio, canvasEl.width / canvasEl.height); \tgl.uniform1f(uniforms.u_img_ratio, imgRatio); } function createControls() { \tconst gui = new GUI(); \tgui.close(); \tgui.add(params, \"loadMyImage\").name(\"load image\"); \tconst paramsFolder = gui.addFolder(\"shader params\"); \t// paramsFolder.close(); \tparamsFolder.add(params, \"blueish\", 0, 0.8).onChange(updateUniforms); \tparamsFolder.add(params, \"scale\", 5, 12).onChange(updateUniforms); \tparamsFolder.add(params, \"illumination\", 0, 1).onChange(updateUniforms); \tparamsFolder \t\t.add(params, \"surfaceDistortion\", 0, 0.12) \t\t.onChange(updateUniforms) \t\t.name(\"surface distortion\"); \tparamsFolder \t\t.add(params, \"waterDistortion\", 0, 0.08) \t\t.onChange(updateUniforms) \t\t.name(\"water distortion\"); }",
    "id": "water-distortion"
  },
  {
    "title": "cg-gentlerain",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>GentleRain Water Simulation | mukta</title>\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n  </head>\n  <body>\n    <nav>\n      <div class=\"logo\">\n        <p>Soft Horizon</p>\n      </div>\n\n      <div class=\"nav-items\">\n        <p>Product</p>\n        <p>Concept</p>\n        <p>Partners</p>\n        <button>Try now</button>\n      </div>\n    </nav>\n\n    <footer>\n      <h1>Expanding perspectives with serene and boundless possibilities</h1>\n\n      <div class=\"footer-links\">\n        <p>Sign Up</p>\n        <p>Log In</p>\n      </div>\n    </footer>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script src=\"./script.js\" type=\"module\"></script>\n  </body>\n</html>\n",
      "script.js": "import {\n  simulationVertexShader,\n  simulationFragmentShader,\n  renderVertexShader,\n  renderFragmentShader,\n} from \"./shaders.js\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const scene = new THREE.Scene();\n  const simScene = new THREE.Scene();\n\n  const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n  const renderer = new THREE.WebGLRenderer({\n    antialias: true,\n    alpha: true,\n    preserveDrawingBuffer: true,\n  });\n  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  document.body.appendChild(renderer.domElement);\n\n  const mouse = new THREE.Vector2();\n  let frame = 0;\n\n  const width = window.innerWidth * window.devicePixelRatio;\n  const height = window.innerHeight * window.devicePixelRatio;\n  const options = {\n    format: THREE.RGBAFormat,\n    type: THREE.FloatType,\n    minFilter: THREE.LinearFilter,\n    magFilter: THREE.LinearFilter,\n    stencilBuffer: false,\n    depthBuffer: false,\n  };\n  let rtA = new THREE.WebGLRenderTarget(width, height, options);\n  let rtB = new THREE.WebGLRenderTarget(width, height, options);\n\n  const simMaterial = new THREE.ShaderMaterial({\n    uniforms: {\n      textureA: { value: null },\n      mouse: { value: mouse },\n      resolution: { value: new THREE.Vector2(width, height) },\n      time: { value: 0 },\n      frame: { value: 0 },\n    },\n    vertexShader: simulationVertexShader,\n    fragmentShader: simulationFragmentShader,\n  });\n\n  const renderMaterial = new THREE.ShaderMaterial({\n    uniforms: {\n      textureA: { value: null },\n      textureB: { value: null },\n    },\n    vertexShader: renderVertexShader,\n    fragmentShader: renderFragmentShader,\n    transparent: true,\n  });\n\n  const plane = new THREE.PlaneGeometry(2, 2);\n  const simQuad = new THREE.Mesh(plane, simMaterial);\n  const renderQuad = new THREE.Mesh(plane, renderMaterial);\n\n  simScene.add(simQuad);\n  scene.add(renderQuad);\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext(\"2d\", { alpha: true });\n\n  ctx.fillStyle = \"#fb7427\";\n  ctx.fillRect(0, 0, width, height);\n\n  const fontSize = Math.round(250 * window.devicePixelRatio);\n  ctx.fillStyle = \"#fef4b8\";\n  ctx.font = `bold ${fontSize}px Test SÃ¶hne`;\n  ctx.textAlign = \"center\";\n  ctx.textBaseline = \"middle\";\n  ctx.textRendering = \"geometricPrecision\";\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = \"high\";\n  ctx.fillText(\"softhorizon\", width / 2, height / 2);\n\n  const textTexture = new THREE.CanvasTexture(canvas);\n  textTexture.minFilter = THREE.LinearFilter;\n  textTexture.magFilter = THREE.LinearFilter;\n  textTexture.format = THREE.RGBAFormat;\n\n  window.addEventListener(\"resize\", () => {\n    const newWidth = window.innerWidth * window.devicePixelRatio;\n    const newHeight = window.innerHeight * window.devicePixelRatio;\n\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    rtA.setSize(newWidth, newHeight);\n    rtB.setSize(newWidth, newHeight);\n    simMaterial.uniforms.resolution.value.set(newWidth, newHeight);\n\n    canvas.width = newWidth;\n    canvas.height = newHeight;\n    ctx.fillStyle = \"#fb7427\";\n    ctx.fillRect(0, 0, newWidth, newHeight);\n\n    const newFontSize = Math.round(250 * window.devicePixelRatio);\n    ctx.fillStyle = \"#fef4b8\";\n    ctx.font = `bold ${newFontSize}px Test SÃ¶hne`;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(\"softhorizon\", newWidth / 2, newHeight / 2);\n\n    textTexture.needsUpdate = true;\n  });\n\n  renderer.domElement.addEventListener(\"mousemove\", (e) => {\n    mouse.x = e.clientX * window.devicePixelRatio;\n    mouse.y = (window.innerHeight - e.clientY) * window.devicePixelRatio;\n  });\n\n  renderer.domElement.addEventListener(\"mouseleave\", () => {\n    mouse.set(0, 0);\n  });\n\n  const animate = () => {\n    simMaterial.uniforms.frame.value = frame++;\n    simMaterial.uniforms.time.value = performance.now() / 1000;\n\n    simMaterial.uniforms.textureA.value = rtA.texture;\n    renderer.setRenderTarget(rtB);\n    renderer.render(simScene, camera);\n\n    renderMaterial.uniforms.textureA.value = rtB.texture;\n    renderMaterial.uniforms.textureB.value = textTexture;\n    renderer.setRenderTarget(null);\n    renderer.render(scene, camera);\n\n    const temp = rtA;\n    rtA = rtB;\n    rtB = temp;\n\n    requestAnimationFrame(animate);\n  };\n\n  animate();\n});\n",
      "shaders.js": "export const simulationVertexShader = `\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nexport const simulationFragmentShader = `\nuniform sampler2D textureA;\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform float time;\nuniform int frame;\nvarying vec2 vUv;\n\nconst float delta = 1.4;  \n\nvoid main() {\n    vec2 uv = vUv;\n    if (frame == 0) {\n        gl_FragColor = vec4(0.0);\n        return;\n    }\n    \n    vec4 data = texture2D(textureA, uv);\n    float pressure = data.x;\n    float pVel = data.y;\n    \n    vec2 texelSize = 1.0 / resolution;\n    float p_right = texture2D(textureA, uv + vec2(texelSize.x, 0.0)).x;\n    float p_left = texture2D(textureA, uv + vec2(-texelSize.x, 0.0)).x;\n    float p_up = texture2D(textureA, uv + vec2(0.0, texelSize.y)).x;\n    float p_down = texture2D(textureA, uv + vec2(0.0, -texelSize.y)).x;\n    \n    if (uv.x <= texelSize.x) p_left = p_right;\n    if (uv.x >= 1.0 - texelSize.x) p_right = p_left;\n    if (uv.y <= texelSize.y) p_down = p_up;\n    if (uv.y >= 1.0 - texelSize.y) p_up = p_down;\n    \n    // Enhanced wave equation matching ShaderToy\n    pVel += delta * (-2.0 * pressure + p_right + p_left) / 4.0;\n    pVel += delta * (-2.0 * pressure + p_up + p_down) / 4.0;\n    \n    pressure += delta * pVel;\n    \n    pVel -= 0.005 * delta * pressure;\n    \n    pVel *= 1.0 - 0.002 * delta;\n    pressure *= 0.999;\n    \n    vec2 mouseUV = mouse / resolution;\n    if(mouse.x > 0.0) {\n        float dist = distance(uv, mouseUV);\n        if(dist <= 0.02) {  // Smaller radius for more precise ripples\n            pressure += 2.0 * (1.0 - dist / 0.02);  // Increased intensity\n        }\n    }\n    \n    gl_FragColor = vec4(pressure, pVel, \n        (p_right - p_left) / 2.0, \n        (p_up - p_down) / 2.0);\n}\n`;\n\nexport const renderVertexShader = `\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nexport const renderFragmentShader = `\nuniform sampler2D textureA;\nuniform sampler2D textureB;\nvarying vec2 vUv;\n\nvoid main() {\n    vec4 data = texture2D(textureA, vUv);\n    \n    vec2 distortion = 0.3 * data.zw;\n    vec4 color = texture2D(textureB, vUv + distortion);\n    \n    vec3 normal = normalize(vec3(-data.z * 2.0, 0.5, -data.w * 2.0));\n    vec3 lightDir = normalize(vec3(-3.0, 10.0, 3.0));\n    float specular = pow(max(0.0, dot(normal, lightDir)), 60.0) * 1.5;\n    \n    gl_FragColor = color + vec4(specular);\n}\n`;\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  width: 100%;\n  height: 100%;\n  font-family: \"Test SÃ¶hne\";\n  background: #fb7427;\n  color: #fef4b8;\n}\n\nh1 {\n  font-size: 36px;\n  font-weight: 400;\n  line-height: 1.25;\n}\n\np {\n  font-size: 15px;\n  line-height: 1.25;\n}\n\nnav {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  padding: 2em;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  z-index: 2;\n}\n\n.nav-items {\n  display: flex;\n  align-items: center;\n  gap: 2em;\n}\n\nbutton {\n  outline: none;\n  border: 2px solid #fef4b8;\n  border-radius: 2em;\n  color: #fef4b8;\n  background-color: transparent;\n  font-family: \"Test SÃ¶hne\";\n  font-size: 15px;\n  padding: 0.5em 1em;\n}\n\nfooter {\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  width: 100vw;\n  padding: 2em;\n  display: flex;\n  justify-content: space-between;\n  align-items: flex-end;\n  z-index: 2;\n}\n\nfooter h1 {\n  width: 40%;\n}\n\n.footer-links {\n  display: flex;\n  gap: 2em;\n}\n\ncanvas {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n}\n"
    }
  },
  {
    "title": "Interactive Blackhole",
    "description": "",
    "code": "index.html: <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Black Hole Visualization</title> <link rel=\"stylesheet\" href=\"styles.css\"> </head> <body> <div id=\"blackhole\"> <div class=\"centerHover\"><span>ENTER</span></div> </div> <script src=\"script.js\"></script> </body> </html>\nstyle.css: body, html { height: 100%; margin: 0; padding: 0; } body { height: 100%; background-color: rgba(25,25,25,1); overflow: hidden; } #blackhole { height: 100%; width: 100%; position: relative; display: flex; } .centerHover { width: 255px; height: 255px; background-color: transparent; border-radius: 50%; position: absolute; left: 50%; top: 50%; margin-top: -128px; margin-left: -128px; z-index: 2; cursor: pointer; line-height: 255px; text-align: center; transition: all 500ms; } .centerHover.open { opacity: 0; pointer-events: none; } .centerHover:hover span { color: #DDD; } .centerHover:hover span:before { background-color: #DDD; } .centerHover:hover span:after { background-color: #DDD; } .centerHover span { color: #666; font-family: serif; font-size: 18px; position: relative; transition: all 500ms; } .centerHover span:before { content: ''; display: inline-block; height: 1px; width: 16px; margin-right: 12px; margin-bottom: 4px; background-color: #666; transition: all 500ms; } .centerHover span:after { content: ''; display: inline-block; height: 1px; width: 16px; margin-left: 12px; margin-bottom: 4px; background-color: #666; transition: all 500ms; } canvas { position: relative; z-index: 1; width: 100%; height: 100%; margin: auto; } #blackhole { height: 100%; width: 100%; position: relative; display: flex; } .centerHover { width: 255px; height: 255px; background-color: transparent; border-radius: 50%; position: absolute; left: 50%; top: 50%; margin-top: -128px; margin-left: -128px; z-index: 2; cursor: pointer; line-height: 255px; text-align: center; transition: all 500ms; } .centerHover.open { opacity: 0; pointer-events: none; } .centerHover:hover span { color: #DDD; } .centerHover:hover span:before { background-color: #DDD; } .centerHover:hover span:after { background-color: #DDD; } .centerHover span { color: #666; font-family: serif; font-size: 18px; position: relative; transition: all 500ms; } .centerHover span:before { content: ''; display: inline-block; height: 1px; width: 16px; margin-right: 12px; margin-bottom: 4px; background-color: #666; transition: all 500ms; } .centerHover span:after { content: ''; display: inline-block; height: 1px; width: 16px; margin-left: 12px; margin-bottom: 4px; background-color: #666; transition: all 500ms; } canvas { position: relative; z-index: 1; width: 100%; height: 100%; margin: auto; }\nscript.js: function blackhole(element) { const container = document.querySelector(element); const h = container.offsetHeight; const w = container.offsetWidth; const cw = w; const ch = h; const maxorbit = 255; // distance from center const centery = ch / 2; const centerx = cw / 2; const startTime = new Date().getTime(); let currentTime = 0; const stars = []; let collapse = false; // if hovered let expanse = false; // if clicked let returning = false; // if particles are returning to orbit // Create canvas const canvas = document.createElement('canvas'); canvas.width = cw; canvas.height = ch; container.appendChild(canvas); const context = canvas.getContext(\"2d\"); context.globalCompositeOperation = \"multiply\"; function setDPI(canvas, dpi) { // Set up CSS size if it's not set up already if (!canvas.style.width) canvas.style.width = canvas.width + 'px'; if (!canvas.style.height) canvas.style.height = canvas.height + 'px'; const scaleFactor = dpi / 96; canvas.width = Math.ceil(canvas.width * scaleFactor); canvas.height = Math.ceil(canvas.height * scaleFactor); const ctx = canvas.getContext('2d'); ctx.scale(scaleFactor, scaleFactor); } function rotate(cx, cy, x, y, angle) { const radians = angle; const cos = Math.cos(radians); const sin = Math.sin(radians); const nx = (cos * (x - cx)) + (sin * (y - cy)) + cx; const ny = (cos * (y - cy)) - (sin * (x - cx)) + cy; return [nx, ny]; } setDPI(canvas, 192); class Star { constructor() { // Get a weighted random number, so that the majority of stars will form in the center of the orbit const rands = []; rands.push(Math.random() * (maxorbit / 2) + 1); rands.push(Math.random() * (maxorbit / 2) + maxorbit); this.orbital = (rands.reduce((p, c) => p + c, 0) / rands.length); this.x = centerx; // All of these stars are at the center x position at all times this.y = centery + this.orbital; // Set Y position starting at the center y + the position in the orbit this.yOrigin = centery + this.orbital; // this is used to track the particles origin this.speed = (Math.floor(Math.random() * 2.5) + 1.5) * Math.PI / 180; // The rate at which this star will orbit this.rotation = 0; // current Rotation this.startRotation = (Math.floor(Math.random() * 360) + 1) * Math.PI / 180; // Starting rotation this.id = stars.length; // This will be used when expansion takes place this.collapseBonus = this.orbital - (maxorbit * 0.7); // This \"bonus\" is used to randomly place some stars outside of the blackhole on hover if (this.collapseBonus < 0) { // if the collapse \"bonus\" is negative this.collapseBonus = 0; // set it to 0, this way no stars will go inside the blackhole } this.color = 'rgba(255,255,255,' + (1 - ((this.orbital) / 255)) + ')'; // Color the star white, but make it more transparent the further out it is generated this.hoverPos = centery + (maxorbit / 2) + this.collapseBonus; // Where the star will go on hover of the blackhole this.expansePos = centery + (this.id % 100) * -10 + (Math.floor(Math.random() * 20) + 1); // Where the star will go when expansion takes place this.prevR = this.startRotation; this.prevX = this.x; this.prevY = this.y; // Store original position for returning this.originalY = this.yOrigin; stars.push(this); } draw() { if (!expanse && !returning) { this.rotation = this.startRotation + (currentTime * this.speed); if (!collapse) { // not hovered if (this.y > this.yOrigin) { this.y -= 2.5; } if (this.y < this.yOrigin - 4) { this.y += (this.yOrigin - this.y) / 10; } } else { // on hover this.trail = 1; if (this.y > this.hoverPos) { this.y -= (this.hoverPos - this.y) / -5; } if (this.y < this.hoverPos - 4) { this.y += 2.5; } } } else if (expanse && !returning) { this.rotation = this.startRotation + (currentTime * (this.speed / 2)); if (this.y > this.expansePos) { this.y -= Math.floor(this.expansePos - this.y) / -80; // Slower expansion for better visibility } } else if (returning) { // Returning to original orbit slowly this.rotation = this.startRotation + (currentTime * this.speed); if (Math.abs(this.y - this.originalY) > 2) { this.y += (this.originalY - this.y) / 50; // Much slower return } else { this.y = this.originalY; this.yOrigin = this.originalY; } } context.save(); context.fillStyle = this.color; context.strokeStyle = this.color; context.beginPath(); const oldPos = rotate(centerx, centery, this.prevX, this.prevY, -this.prevR); context.moveTo(oldPos[0], oldPos[1]); context.translate(centerx, centery); context.rotate(this.rotation); context.translate(-centerx, -centery); context.lineTo(this.x, this.y); context.stroke(); context.restore(); this.prevR = this.rotation; this.prevX = this.x; this.prevY = this.y; } } // Event listeners const centerHover = document.querySelector('.centerHover'); centerHover.addEventListener('click', function() { collapse = false; expanse = true; returning = false; this.classList.add('open'); // Start the return cycle after full expansion (20-30 seconds) setTimeout(() => { expanse = false; returning = true; // After particles return, reset to normal orbit setTimeout(() => { returning = false; this.classList.remove('open'); }, 8000); // 8 seconds to return slowly }, 25000); // 25 seconds of expansion experience }); centerHover.addEventListener('mouseover', function() { if (expanse === false) { collapse = true; } }); centerHover.addEventListener('mouseout', function() { if (expanse === false) { collapse = false; } }); // Animation loop function loop() { const now = new Date().getTime(); currentTime = (now - startTime) / 50; context.fillStyle = 'rgba(25,25,25,0.2)'; // somewhat clear the context, this way there will be trails behind the stars context.fillRect(0, 0, cw, ch); for (let i = 0; i < stars.length; i++) { // For each star if (stars[i] !== undefined) { stars[i].draw(); // Draw it } } requestAnimationFrame(loop); } function init() { context.fillStyle = 'rgba(25,25,25,1)'; // Initial clear of the canvas context.fillRect(0, 0, cw, ch); for (let i = 0; i < 2500; i++) { // create 2500 stars new Star(); } loop(); } init(); } // Initialize when DOM is loaded document.addEventListener('DOMContentLoaded', () => { blackhole('#blackhole'); });",
    "id": "interactive-blackhole"
  },
  {
    "title": "WebGL Blackhole",
    "description": "",
    "code": "index.html: <script id=\"2d-fragment-shader\" type=\"x-shader/x-fragment\">// <![CDATA[ // Look below at line 23 for realism. #ifdef GL_ES precision mediump float; #endif #define PI 3.14159265359 uniform sampler2D u_image; varying vec2 v_texCoord; uniform vec2 u_resolution; uniform vec2 u_mouse; uniform float u_mass; uniform float u_time; uniform float u_clickedTime; vec2 rotate(vec2 mt, vec2 st, float angle){ \tfloat cos = cos((angle + u_clickedTime) * PI); // try replacing * 1.0 with * PI \tfloat sin = sin(angle * 0.0); // try removing the * 0.0 \t \t// Uncomment these two lines for realism \t//float cos = cos(angle) * (u_time * 0.3); \t//float sin = sin(angle) * (u_time * 0.3); \t \tfloat nx = (cos * (st.x - mt.x)) + (sin * (st.y - mt.y)) + mt.x; \tfloat ny = (cos * (st.y - mt.y)) - (sin * (st.x - mt.x)) + mt.y; \treturn vec2(nx, ny); } void main() { vec2 st = vec2(gl_FragCoord.x, u_resolution.y - gl_FragCoord.y)/u_resolution; \tvec2 mt = vec2(u_mouse.x, u_resolution.y - u_mouse.y)/u_resolution; \tfloat dx = st.x - mt.x; \tfloat dy = st.y - mt.y; \tfloat dist = sqrt(dx * dx + dy * dy); \tfloat pull = u_mass / (dist * dist); \t vec3 color = vec3(0.0); \t \tvec2 r = rotate(mt,st,pull); \tvec4 imgcolor = texture2D(u_image, r); \tcolor = vec3( \t\t(imgcolor.x - (pull * 0.25)), \t\t(imgcolor.y - (pull * 0.25)), \t\t(imgcolor.z - (pull * 0.25)) \t); \t gl_FragColor = vec4(color,1.); } // ]]></script> <script id=\"2d-vertex-shader\" type=\"x-shader/x-vertex\">// <![CDATA[ \tattribute vec2 a_position; \tattribute vec2 a_texCoord; \t \tvarying vec2 v_texCoord; \tvoid main() { \t\tgl_Position = vec4(a_position, 0, 1); \t\tv_texCoord = a_texCoord; \t} \t// ]]></script> <canvas id=\"glscreen\"></canvas>\nstyle.css: html, body { \tposition: absolute; \ttop: 0px; \tleft: 0px; \tright: 0px; \tbottom: 0px; \tpadding: 0px; \t//cursor: none; \tmargin: 0px; \toverflow: hidden; \tdisplay: flex; \theight: 100%; \twidth: 100%; \tbackground-color: #000; } canvas { \tmargin: auto auto; }\nscript.js: var bgUrl = 'https://images.unsplash.com/photo-1502134249126-9f3755a50d78?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'; var blackholeMass = 5500; var curblackholeMass = 0; var canvas, gl; // canvas and webgl context var shaderScript; var shaderSource; var vertexShader; // Vertex shader. Not much happens in that shader, it just creates the vertex's to be drawn on var fragmentShader; // this shader is where the magic happens. Fragment = pixel. Vertex = kind of like \"faces\" on a 3d model. var buffer; /* Variables holding the location of uniform variables in the WebGL. We use this to send info to the WebGL script. */ var locationOfTime; var locationOfResolution; var locationOfMouse; var locationOfMass; var locationOfclickedTime; var originY = window.innerHeight, originX = window.innerWidth; var mouse, targetMouse; var startTime = new Date().getTime(); // Get start time for animating var currentTime = 0; var clicked = false, clickedTime = 0; $(document).mousedown(function(){ clicked = true; }); $(document).mouseup(function(){ clicked = false; }); function init(image) { // standard canvas setup here, except get webgl context canvas = document.getElementById('glscreen'); gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); canvas.width = window.innerWidth >= window.innerHeight ? window.innerWidth : window.innerHeight; canvas.height = window.innerWidth >= window.innerHeight ? window.innerWidth : window.innerHeight; mouse = {x: originX/2, y: -(originY/2) + canvas.height, moved: false}; targetMouse = {x: mouse.x, y: mouse.y}; // Initialize targetMouse $(document).mousemove(function(e) { targetMouse.x = e.pageX; // Update target mouse position targetMouse.y = -e.pageY + canvas.height; mouse.moved = true; }); // give WebGL it's viewport gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); // kind of back-end stuff buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData( gl.ARRAY_BUFFER, new Float32Array([ -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]), gl.STATIC_DRAW ); // ^^ That up there sets up the vertex's used to draw onto. I think at least, I haven't payed much attention to vertex's yet, for all I know I'm wrong. shaderScript = document.getElementById(\"2d-vertex-shader\"); shaderSource = shaderScript.text; vertexShader = gl.createShader(gl.VERTEX_SHADER); //create the vertex shader from script gl.shaderSource(vertexShader, shaderSource); gl.compileShader(vertexShader); shaderScript = document.getElementById(\"2d-fragment-shader\"); shaderSource = shaderScript.text; fragmentShader = gl.createShader(gl.FRAGMENT_SHADER); //create the fragment from script gl.shaderSource(fragmentShader, shaderSource); gl.compileShader(fragmentShader); program = gl.createProgram(); // create the WebGL program. This variable will be used to inject our javascript variables into the program. gl.attachShader(program, vertexShader); // add the shaders to the program gl.attachShader(program, fragmentShader); // ^^ gl.linkProgram(program); // Tell our WebGL application to use the program gl.useProgram(program); // ^^ yep, but now literally use it. locationOfResolution = gl.getUniformLocation(program, \"u_resolution\"); locationOfMouse = gl.getUniformLocation(program, \"u_mouse\"); locationOfMass = gl.getUniformLocation(program, \"u_mass\"); locationOfTime = gl.getUniformLocation(program, \"u_time\"); locationOfclickedTime = gl.getUniformLocation(program, \"u_clickedTime\"); gl.uniform2f(locationOfResolution, canvas.width, canvas.height); gl.uniform2f(locationOfMouse, mouse.x, mouse.y); gl.uniform1f(locationOfMass, curblackholeMass*0.00001); gl.uniform1f(locationOfTime, currentTime); gl.uniform1f(locationOfclickedTime, clickedTime); var texCoordLocation = gl.getAttribLocation(program, \"a_texCoord\"); // provide texture coordinates for the rectangle. var texCoordBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]), gl.STATIC_DRAW); gl.enableVertexAttribArray(texCoordLocation); gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0); // Create a texture. var texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); // Set the parameters so we can render any size image. gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); // Upload the image into the texture. gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); render(); } function render() { var now = new Date().getTime(); currentTime = (now - startTime) / 1000; // update the current time for animations if(curblackholeMass < blackholeMass - 50){ curblackholeMass += (blackholeMass-curblackholeMass) * 0.03; } if(clicked){ clickedTime += 0.03; } else if(clickedTime > 0 && clicked == false) { clickedTime += -(clickedTime*0.015); } if(mouse.moved == false){ mouse.y = (-(originY/2) + Math.sin(currentTime * 0.7) * ((originY * 0.25))) + canvas.height; mouse.x = (originX/2) + Math.sin(currentTime * 0.6) * -(originX * 0.35); } else { // Apply easing to the mouse movement mouse.x += (targetMouse.x - mouse.x) * 0.05; mouse.y += (targetMouse.y - mouse.y) * 0.05; } gl.uniform1f(locationOfMass, curblackholeMass*0.00001); gl.uniform2f(locationOfMouse, mouse.x, mouse.y); gl.uniform1f(locationOfTime, currentTime); // update the time uniform in our shader gl.uniform1f(locationOfclickedTime, clickedTime); window.requestAnimationFrame(render, canvas); // request the next frame positionLocation = gl.getAttribLocation(program, \"a_position\"); // do stuff for those vertex's gl.enableVertexAttribArray(positionLocation); gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0); gl.drawArrays(gl.TRIANGLES, 0, 6); } window.addEventListener('load', function(event){ var image = new Image(); image.crossOrigin = \"Anonymous\"; image.src = bgUrl; image.onload = function() { init(image); } }); window.addEventListener('resize', function(event){ // just re-doing some stuff in the init here, to enable resizing. canvas.width = window.innerWidth >= window.innerHeight ? window.innerWidth : window.innerHeight; canvas.height = window.innerWidth >= window.innerHeight ? window.innerWidth : window.innerHeight; gl.viewport(0, 0, canvas.width, canvas.height); locationOfResolution = gl.getUniformLocation(program, \"u_resolution\"); });",
    "id": "webgl-blackhole"
  },
  {
    "title": "glowing-interactive-dots-grid",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/InertiaPlugin.min.js\">script>\n\nStep 1: Add HTML\n\n<section class=\"section-dots\">\n  <div class=\"section-dots__wrap\">\n    <div data-dots-container-init=\"\" class=\"dots-container\">\n      <div class=\"dot\">div>\n    div>\n  div>\n  <a href=\"https://mukta.supply/\" target=\"_blank\" class=\"mukta-icon__link\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" viewbox=\"0 0 160 160\" fill=\"none\" class=\"mukta-icon-svg\"><path d=\"M94.8284 53.8578C92.3086 56.3776 88 54.593 88 51.0294V0H72V59.9999C72 66.6273 66.6274 71.9999 60 71.9999H0V87.9999H51.0294C54.5931 87.9999 56.3777 92.3085 53.8579 94.8283L18.3431 130.343L29.6569 141.657L65.1717 106.142C67.684 103.63 71.9745 105.396 72 108.939V160L88.0001 160L88 99.9999C88 93.3725 93.3726 87.9999 100 87.9999H160V71.9999H108.939C105.407 71.9745 103.64 67.7091 106.12 65.1938L106.142 65.1716L141.657 29.6568L130.343 18.3432L94.8284 53.8578Z\" fill=\"currentColor\">path>svg>\n  a>\nsection>\n\nStep 2: Add CSS\n\n.section-dots {\n  background-color: #08342a;\n  color: #efeeec;\n  justify-content: center;\n  align-items: stretch;\n  min-height: 100vh;\n  padding: 4em;\n  display: flex;\n  position: relative;\n  overflow: hidden;\n}\n\n.section-dots__wrap {\n  width: 100%;\n  min-height: 30em;\n  position: relative;\n}\n\n.dots-container {\n  gap: 2em;\n  pointer-events: none;\n  flex-flow: wrap;\n  justify-content: center;\n  align-items: center;\n  display: flex;\n  position: absolute;\n  inset: 0;\n}\n\n.dot {\n  will-change: transform, background-color;\n  transform-origin: center;\n  background-color: #245e51;\n  border-radius: 50%;\n  width: 1em;\n  height: 1em;\n  position: relative;\n  transform: translate(0);\n}\n\n.mukta-icon__link {\n  color: currentColor;\n  text-decoration: none;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.mukta-icon-svg {\n  width: 10em;\n}\n\nStep 2: Add custom Javascript\n\ngsap.registerPlugin(InertiaPlugin);\n\nfunction initGlowingInteractiveDotsGrid() {\n  document.querySelectorAll('[data-dots-container-init]').forEach(container => {\n    const colors         = { base: \"#245E51\", active: \"#A8FF51\" };\n    const threshold      = 200;\n    const speedThreshold = 100;\n    const shockRadius    = 325;\n    const shockPower     = 5;\n    const maxSpeed       = 5000;\n    const centerHole     = true;\n\n    let dots       = [];\n    let dotCenters = [];\n\n    function buildGrid() {\n      container.innerHTML = \"\";\n      dots = [];\n      dotCenters = [];\n\n      const style = getComputedStyle(container);\n      const dotPx = parseFloat(style.fontSize);\n      const gapPx = dotPx * 2;\n      const contW = container.clientWidth;\n      const contH = container.clientHeight;\n\n      const cols  = Math.floor((contW + gapPx) / (dotPx + gapPx));\n      const rows  = Math.floor((contH + gapPx) / (dotPx + gapPx));\n      const total = cols * rows;\n\n      const holeCols = centerHole ? (cols % 2 === 0 ? 4 : 5) : 0;\n      const holeRows = centerHole ? (rows % 2 === 0 ? 4 : 5) : 0;\n      const startCol = (cols - holeCols) / 2;\n      const startRow = (rows - holeRows) / 2;\n\n      for (let i = 0; i < total; i++) {\n        const row    = Math.floor(i / cols);\n        const col    = i % cols;\n        const isHole = centerHole &&\n          row >= startRow && row < startRow + holeRows &&\n          col >= startCol && col < startCol + holeCols;\n\n        const d = document.createElement(\"div\");\n        d.classList.add(\"dot\");\n\n        if (isHole) {\n          d.style.visibility = \"hidden\";\n          d._isHole = true;\n        } else {\n          gsap.set(d, { x: 0, y: 0, backgroundColor: colors.base });\n          d._inertiaApplied = false;\n        }\n\n        container.appendChild(d);\n        dots.push(d);\n      }\n\n      requestAnimationFrame(() => {\n        dotCenters = dots\n          .filter(d => !d._isHole)\n          .map(d => {\n            const r = d.getBoundingClientRect();\n            return {\n              el: d,\n              x:  r.left + window.scrollX + r.width  / 2,\n              y:  r.top  + window.scrollY + r.height / 2\n            };\n          });\n      });\n    }\n\n    window.addEventListener(\"resize\", buildGrid);\n    buildGrid();\n\n    let lastTime = 0, lastX = 0, lastY = 0;\n\n    window.addEventListener(\"mousemove\", e => {\n      const now   = performance.now();\n      const dt    = now - lastTime || 16;\n      let   dx    = e.pageX - lastX;\n      let   dy    = e.pageY - lastY;\n      let   vx    = dx / dt * 1000;\n      let   vy    = dy / dt * 1000;\n      let   speed = Math.hypot(vx, vy);\n\n      if (speed > maxSpeed) {\n        const scale = maxSpeed / speed;\n        vx *= scale; vy *= scale; speed = maxSpeed;\n      }\n\n      lastTime = now;\n      lastX    = e.pageX;\n      lastY    = e.pageY;\n\n      requestAnimationFrame(() => {\n        dotCenters.forEach(({ el, x, y }) => {\n          const dist = Math.hypot(x - e.pageX, y - e.pageY);\n          const t    = Math.max(0, 1 - dist / threshold);\n          const col  = gsap.utils.interpolate(colors.base, colors.active, t);\n          gsap.set(el, { backgroundColor: col });\n\n          if (speed > speedThreshold && dist < threshold && !el._inertiaApplied) {\n            el._inertiaApplied = true;\n            const pushX = (x - e.pageX) + vx * 0.005;\n            const pushY = (y - e.pageY) + vy * 0.005;\n\n            gsap.to(el, {\n              inertia: { x: pushX, y: pushY, resistance: 750 },\n              onComplete() {\n                gsap.to(el, {\n                  x: 0,\n                  y: 0,\n                  duration: 1.5,\n                  ease: \"elastic.out(1,0.75)\"\n                });\n                el._inertiaApplied = false;\n              }\n            });\n          }\n        });\n      });\n    });\n\n    window.addEventListener(\"click\", e => {\n      dotCenters.forEach(({ el, x, y }) => {\n        const dist = Math.hypot(x - e.pageX, y - e.pageY);\n        if (dist < shockRadius && !el._inertiaApplied) {\n          el._inertiaApplied = true;\n          const falloff = Math.max(0, 1 - dist / shockRadius);\n          const pushX   = (x - e.pageX) * shockPower * falloff;\n          const pushY   = (y - e.pageY) * shockPower * falloff;\n\n          gsap.to(el, {\n            inertia: { x: pushX, y: pushY, resistance: 750 },\n            onComplete() {\n              gsap.to(el, {\n                x: 0,\n                y: 0,\n                duration: 1.5,\n                ease: \"elastic.out(1,0.75)\"\n              });\n              el._inertiaApplied = false;\n            }\n          });\n        }\n      });\n    });\n  });\n}\n\n// Initialize Glowing Interactive Dots Grid\ndocument.addEventListener('DOMContentLoaded', function() {\n  initGlowingInteractiveDotsGrid();\n});\n\nImplementation\n\nContainer element\nInside each [data-dots-container-init] element, the script automatically generates as many .dot elements as needed to fill the container. You can customize the appearance of the interactive dots by styling the single .dot selector in your CSS.\n\nCustomising the effect\n- colors An object holding the two color values used for the dotsâ€™ resting and fully-active states.\n- threshold The radius (in pixels) around the pointer within which dots will light up. Increase for a larger hover area.\n- speedThreshold The min. pointer speed (px/sec) required to trigger the inertia. Raising this value makes dots require faster swipes to move.\n- shockRadius The radius (in pixels) of the click-activated shockwave. Increase to affect more dots on click.\n- shockPower Controls how forcefully dots are pushed outward by the click shockwave. Higher values produce a stronger blast.\n- maxSpeed Caps the velocity for fast mouse movements. Adjust to limit maximum inertia.\nconst colors         = { base: \"#245E51\", active: \"#A8FF51\" };\nconst threshold      = 200;\nconst speedThreshold = 100;\nconst shockRadius    = 325;\nconst shockPower     = 5;\nconst maxSpeed       = 5000;\nTurning on/off the center whitespace\nWhen true, leaves a empty space in the center (perfect for placing a logo or other graphic). Set to false to render a field with no hole.\nconst centerHole = false;",
    "id": "glowing-interactive-dots-grid"
  },
  {
    "title": "mukta-fractal-glass-effect",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Fractal Glass Parallax Effect | mukta</title>\n    <link rel=\"stylesheet\" href=\"/styles.css\" />\n  </head>\n  <body>\n    <nav>\n      <div class=\"logo\">\n        <a href=\"#\">&#8486; Glassform</a>\n      </div>\n\n      <div class=\"nav-links\">\n        <a href=\"#\">Experiments</a>\n        <a href=\"#\">Objects</a>\n        <a href=\"#\">Exhibits</a>\n      </div>\n    </nav>\n\n    <section class=\"hero\">\n      <img id=\"glassTexture\" src=\"/hero.jpg\" alt=\"\" />\n\n      <div class=\"hero-content\">\n        <h1>Designed for the space between silence and noise.</h1>\n        <p>Developed by mukta</p>\n      </div>\n    </section>\n\n    <script type=\"module\" src=\"/script.js\"></script>\n  </body>\n</html>\n",
      "package.json": "{\n  \"name\": \"mukta-fractal-glass-effect\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"dev\": \"vite\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\",\n  \"dependencies\": {\n    \"three\": \"^0.181.0\",\n    \"vite\": \"^7.2.2\"\n  }\n}\n",
      "script.js": "import * as THREE from \"three\";\nimport { vertexShader, fragmentShader } from \"./shaders\";\n\nconst config = {\n  lerpFactor: 0.035,\n  parallaxStrength: 0.1,\n  distortionMultiplier: 10,\n  glassStrength: 2.0,\n  glassSmoothness: 0.0001,\n  stripesFrequency: 35,\n  edgePadding: 0.1,\n};\n\nconst container = document.querySelector(\".hero\");\nconst imageElement = document.getElementById(\"glassTexture\");\n\nconst scene = new THREE.Scene();\nconst camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\nconst renderer = new THREE.WebGLRenderer({ antialias: true });\nrenderer.setSize(window.innerWidth, window.innerHeight);\nrenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\ncontainer.appendChild(renderer.domElement);\n\nconst mouse = { x: 0.5, y: 0.5 };\nconst targetMouse = { x: 0.5, y: 0.5 };\n\nconst lerp = (start, end, factor) => start + (end - start) * factor;\n\nconst textureSize = { x: 1, y: 1 };\nconst material = new THREE.ShaderMaterial({\n  uniforms: {\n    uTexture: { value: null },\n    uResolution: {\n      value: new THREE.Vector2(window.innerWidth, window.innerHeight),\n    },\n    uTextureSize: {\n      value: new THREE.Vector2(textureSize.x, textureSize.y),\n    },\n    uMouse: { value: new THREE.Vector2(mouse.x, mouse.y) },\n    uParallaxStrength: { value: config.parallaxStrength },\n    uDistortionMultiplier: { value: config.distortionMultiplier },\n    uGlassStrength: { value: config.glassStrength },\n    ustripesFrequency: { value: config.stripesFrequency },\n    uglassSmoothness: { value: config.glassSmoothness },\n    uEdgePadding: { value: config.edgePadding },\n  },\n  vertexShader,\n  fragmentShader,\n});\n\nconst geometry = new THREE.PlaneGeometry(2, 2);\nconst mesh = new THREE.Mesh(geometry, material);\nscene.add(mesh);\n\nfunction loadImageFromElement() {\n  if (!imageElement.complete) {\n    imageElement.onload = loadImageFromElement;\n    return;\n  }\n\n  const texture = new THREE.Texture(imageElement);\n  textureSize.x = imageElement.naturalWidth || imageElement.width;\n  textureSize.y = imageElement.naturalHeight || imageElement.height;\n\n  texture.needsUpdate = true;\n  material.uniforms.uTexture.value = texture;\n  material.uniforms.uTextureSize.value.set(textureSize.x, textureSize.y);\n}\n\nif (imageElement.complete) {\n  loadImageFromElement();\n} else {\n  imageElement.onload = loadImageFromElement;\n}\n\nwindow.addEventListener(\"mousemove\", (e) => {\n  targetMouse.x = e.clientX / window.innerWidth;\n  targetMouse.y = 1.0 - e.clientY / window.innerHeight;\n});\n\nwindow.addEventListener(\"resize\", () => {\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  material.uniforms.uResolution.value.set(\n    window.innerWidth,\n    window.innerHeight\n  );\n});\n\nfunction animate() {\n  requestAnimationFrame(animate);\n\n  mouse.x = lerp(mouse.x, targetMouse.x, config.lerpFactor);\n  mouse.y = lerp(mouse.y, targetMouse.y, config.lerpFactor);\n  material.uniforms.uMouse.value.set(mouse.x, mouse.y);\n\n  renderer.render(scene, camera);\n}\n\nanimate();\n",
      "shaders.js": "export const vertexShader = `\n      varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    `;\n\nexport const fragmentShader = `\n      uniform sampler2D uTexture;\n      uniform vec2 uResolution;\n      uniform vec2 uTextureSize;\n      uniform vec2 uMouse;\n      uniform float uParallaxStrength;\n      uniform float uDistortionMultiplier;\n      uniform float uGlassStrength;\n      uniform float ustripesFrequency;\n      uniform float uglassSmoothness;\n      uniform float uEdgePadding;\n      \n      varying vec2 vUv;\n      \n      vec2 getCoverUV(vec2 uv, vec2 textureSize) {\n        if (textureSize.x < 1.0 || textureSize.y < 1.0) return uv;\n        \n        vec2 s = uResolution / textureSize;\n        float scale = max(s.x, s.y);\n        \n        vec2 scaledSize = textureSize * scale;\n        vec2 offset = (uResolution - scaledSize) * 0.5;\n        \n        return (uv * uResolution - offset) / scaledSize;\n      }\n      \n      float displacement(float x, float num_stripes, float strength) {\n        float modulus = 1.0 / num_stripes;\n        return mod(x, modulus) * strength;\n      }\n      \n      float fractalGlass(float x) {\n        float d = 0.0;\n        for (int i = -5; i <= 5; i++) {\n          d += displacement(x + float(i) * uglassSmoothness, ustripesFrequency, uGlassStrength);\n        }\n        d = d / 11.0;\n        return x + d;\n      }\n\n      float smoothEdge(float x, float padding) {\n        float edge = padding;\n        if (x < edge) {\n          return smoothstep(0.0, edge, x);\n        } else if (x > 1.0 - edge) {\n          return smoothstep(1.0, 1.0 - edge, x);\n        }\n        return 1.0;\n      }\n      \n      void main() {\n        vec2 uv = vUv;\n        \n        float originalX = uv.x;\n        \n        float edgeFactor = smoothEdge(originalX, uEdgePadding);\n        \n        float distortedX = fractalGlass(originalX);\n        \n        uv.x = mix(originalX, distortedX, edgeFactor);\n        \n        float distortionFactor = uv.x - originalX;\n        \n        float parallaxDirection = -sign(0.5 - uMouse.x);\n        \n        vec2 parallaxOffset = vec2(\n          parallaxDirection * abs(uMouse.x - 0.5) * uParallaxStrength * (1.0 + abs(distortionFactor) * uDistortionMultiplier),\n          0.0\n        );\n        \n        parallaxOffset *= edgeFactor;\n        \n        uv += parallaxOffset;\n        \n        vec2 coverUV = getCoverUV(uv, uTextureSize);\n        \n        if (coverUV.x < 0.0 || coverUV.x > 1.0 || coverUV.y < 0.0 || coverUV.y > 1.0) {\n          coverUV = clamp(coverUV, 0.0, 1.0);\n        }\n        \n        vec4 color = texture2D(uTexture, coverUV);\n        \n        gl_FragColor = color;\n      }\n    `;\n",
      "styles.css": "@import url(\"https://fonts.googleapis.com/css2?family=Manrope:wght@200..800&display=swap\");\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: \"Manrope\", sans-serif;\n  background-color: #000;\n  color: #fff;\n}\n\nh1 {\n  font-size: 4rem;\n  font-weight: 500;\n  letter-spacing: -0.1rem;\n  line-height: 1;\n}\n\na,\np {\n  color: #fff;\n  text-decoration: none;\n  font-size: 0.85rem;\n  font-weight: 550;\n  line-height: 1;\n  display: inline-block;\n}\n\nnav {\n  position: fixed;\n  width: 100%;\n  padding: 2rem;\n  display: flex;\n  justify-content: space-between;\n  align-items: flex-start;\n  z-index: 2;\n}\n\nnav .nav-links {\n  display: flex;\n  gap: 0.75rem;\n}\n\n.hero {\n  position: relative;\n  width: 100%;\n  height: 100svh;\n  overflow: hidden;\n}\n\n.hero img#glassTexture {\n  display: none;\n}\n\n.hero-content {\n  position: absolute;\n  left: 0;\n  bottom: 0;\n  width: 100%;\n  padding: 2rem;\n  display: flex;\n  justify-content: space-between;\n  align-items: flex-end;\n}\n\n.hero-content h1 {\n  width: 60%;\n}\n\n@media (max-width: 1000px) {\n  .hero-content {\n    align-items: flex-start;\n    flex-direction: column-reverse;\n    gap: 1rem;\n  }\n\n  .hero-content h1 {\n    width: 100%;\n  }\n}\n"
    }
  },
  {
    "title": "snowflake-effect",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.14.1/dist/gsap.min.js\">script>\n\nStep 1: Add HTML\n\n<div data-snowflake-container data-strength=\"4\" data-infinite=\"true\" class=\"snowflake-container\">\n  <div data-snowflake class=\"snowflake-el hidden\">div>\ndiv>\n\nStep 2: Add CSS\n\n.snowflake-container {\n  z-index: 100;\n  pointer-events: none;\n  width: 100%;\n  height: 100vh;\n  position: fixed;\n  inset: 0%;\n  overflow: hidden;\n}\n\n.snowflake-el {\n  aspect-ratio: 1 / 1.15;\n  background-image: url('https://cdn.prod.website-files.com/6941599afc835c41f83ca9ca/69416a9de9533b6332c72b9e_snowflake.avif');\n  background-position: 50%;\n  background-repeat: no-repeat;\n  background-size: contain;\n  width: 1.5em;\n  position: absolute;\n}\n\n.snowflake-el.hidden {\n  opacity: 0;\n}\n\nStep 2: Add custom Javascript\n\nfunction initSnowflakeEffect() {\n  const container = document.querySelector(\"[data-snowflake-container]\");\n  if (!container) return;\n\n  // Prevent double init\n  if (container.dataset.snowRunning === \"true\") return;\n  container.dataset.snowRunning = \"true\";\n\n  const templates = Array.from(container.querySelectorAll(\"[data-snowflake]\"));\n  if (!templates.length) {\n    console.warn(\"initSnowflakeEffect: No [data-snowflake] element found\");\n    container.dataset.snowRunning = \"false\";\n    return;\n  }\n\n  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));\n  const strength = clamp(parseInt(container.dataset.strength ?? \"4\", 10) || 0, 0, 10);\n  const infinite = (container.dataset.infinite ?? \"true\") !== \"false\";\n\n  // Configuration\n  const durationMin = 8;\n  const durationMax = 12;\n  const scaleMin = 0.3;\n  const scaleMax = 1.2;\n  const opacityMin = 0.2;\n  const opacityMax = 1.0;\n\n  // Strength affects how many + how fast\n  const spawnRate = gsap.utils.mapRange(0, 10, 0.15, 5.0, strength); // flakes/sec\n  const maxOnScreen = Math.round(gsap.utils.mapRange(0, 10, 12, 180, strength));\n  const burstCount = Math.round(gsap.utils.mapRange(0, 10, 10, 160, strength)); // if infinite=false\n\n  let running = true;\n  let activeCount = 0;\n  let scheduledCall = null;\n  let burstSpawned = 0;\n\n  const getHeight = () => container.clientHeight || window.innerHeight;\n\n  function stop(removeExisting = true) {\n    running = false;\n    container.dataset.snowRunning = \"false\";\n    if (scheduledCall) scheduledCall.kill();\n\n    if (removeExisting) {\n      container.querySelectorAll(\".snowflake-el.is-spawned\").forEach(el => el.remove());\n      activeCount = 0;\n    }\n  }\n\n  function cleanupFlake(flake, tweens) {\n    tweens.forEach(t => t && t.kill());\n    flake.remove();\n    activeCount--;\n\n    // In one-burst mode: when everything spawned AND are all done, stop.\n    if (!infinite && burstSpawned >= burstCount && activeCount <= 0) {\n      stop(false);\n    }\n  }\n\n  function spawnOne() {\n    if (!running) return;\n    if (activeCount >= maxOnScreen) return;\n  \n    const tpl = templates[Math.floor(Math.random() * templates.length)];\n    const flake = tpl.cloneNode(true);\n  \n    flake.classList.remove(\"hidden\");\n    flake.classList.add(\"is-spawned\");\n    flake.style.willChange = \"transform, opacity\";\n  \n    const scale = gsap.utils.random(scaleMin, scaleMax, 0.001);\n    const duration = gsap.utils.random(durationMin, durationMax, 0.001);\n  \n    // Wave-ish drift\n    const baseSway = gsap.utils.random(12, 60, 0.1);\n    const sway = baseSway * (0.6 + strength / 20);\n  \n    // Choose left so that drifting doesn't bias distribution (keep within bounds)\n    const containerWidth = container.clientWidth || window.innerWidth;\n    const swayPct = (sway / containerWidth) * 100; // sway in % of container width\n    const padPct = Math.min(20, Math.max(0, swayPct)); // clamp padding\n    flake.style.left = `${gsap.utils.random(padPct, 100 - padPct, 0.1)}%`;\n  \n    flake.style.opacity = gsap.utils.random(opacityMin, opacityMax, 0.001);\n  \n    container.appendChild(flake);\n    activeCount++;\n  \n    const h = getHeight();\n    const startY = -gsap.utils.random(30, Math.min(180, h * 0.25), 1);\n    const endY = h + gsap.utils.random(30, Math.min(220, h * 0.35), 1);\n  \n    const xStart = gsap.utils.random(-sway, sway, 0.1);\n    const xEnd = -xStart;\n    const swayDur = gsap.utils.random(1.6, 3.8, 0.001);\n  \n    // Gentle rotation wobble\n    const rotStart = gsap.utils.random(-12, 12, 0.1);\n    const rotEnd = gsap.utils.random(-28, 28, 0.1);\n    const rotDur = gsap.utils.random(2.2, 5.0, 0.001);\n  \n    let fallTween, swayTween, rotTween, fadeTween;\n  \n    fallTween = gsap.fromTo(\n      flake,\n      { y: startY, xPercent: -50, scale, rotate: rotStart },\n      {\n        y: endY,\n        xPercent: -50,\n        ease: \"none\",\n        duration,\n        onComplete: () => cleanupFlake(flake, [fallTween, swayTween, rotTween, fadeTween]),\n      }\n    );\n  \n    const swayRepeats = Math.max(1, Math.floor(duration / swayDur));\n    swayTween = gsap.fromTo(\n      flake,\n      { x: xStart },\n      { x: xEnd, ease: \"sine.inOut\", duration: swayDur, repeat: swayRepeats, yoyo: true }\n    );\n  \n    const rotRepeats = Math.max(1, Math.floor(duration / rotDur));\n    rotTween = gsap.fromTo(\n      flake,\n      { rotate: rotStart },\n      { rotate: rotEnd, ease: \"sine.inOut\", duration: rotDur, repeat: rotRepeats, yoyo: true }\n    );\n  \n    fadeTween = gsap.to(flake, {\n      opacity: 0,\n      duration: 1,\n      ease: \"power1.out\",\n      delay: Math.max(0, duration - 1),\n    });\n  }\n\n  function scheduleNext() {\n    if (!running) return;\n\n    const avgGap = 1 / spawnRate;\n    const nextIn = gsap.utils.random(avgGap * 0.6, avgGap * 1.4, 0.001);\n\n    scheduledCall = gsap.delayedCall(nextIn, () => {\n      spawnOne();\n      scheduleNext();\n    });\n  }\n\n  if (infinite) {\n    const seedCount = Math.round(gsap.utils.mapRange(0, 10, 6, 60, strength));\n    for (let i = 0; i < seedCount; i++) {\n      gsap.delayedCall(gsap.utils.random(0, 1.2, 0.001), spawnOne);\n    }\n    scheduleNext();\n  } else {\n    for (let i = 0; i < burstCount; i++) {\n      burstSpawned++;\n      gsap.delayedCall(gsap.utils.random(0, 2.0, 0.001), spawnOne);\n    }\n  }\n}\n\n// Initialize Snowflake Effect\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  initSnowflakeEffect();\n});\n\nImplementation\n\nContainer\nAdd a wrapper using [data-snowflake-container] to define the bounds where snowflakes spawn and animate.\n\nSnowflake\nPlace a single 'template' element using [data-snowflake] inside the container so the script can clone it for each spawned flake.\n\nStrength\nUse [data-strength=\"4\"] (default 4, clamped between 0â€“10) to control overall intensity by scaling spawn rate, on-screen limit, and seeding.\n\nInfinite\nSet [data-infinite=\"true\"] (default true) to keep spawning continuously, or set it to false to spawn one burst and stop once all flakes have finished.\n\nDuration\nAdjust durationMin and durationMax in the script to define how long each snowflake takes to fall from top to bottom, with values randomly chosen per flake.\n\nScale\nAdjust scaleMin and scaleMax in the script to control the random size range applied to each snowflake as it spawns.\n\nOpacity\nAdjust opacityMin and opacityMax in the script to control the random starting opacity range of each snowflake.\n\nSpawn Rate\nThe internal spawnRate value maps [data-strength] to flakes-per-second, determining how frequently new snowflakes are spawned.\n\nMax On Screen\nThe internal maxOnScreen limit maps [data-strength] to a cap on how many active snowflakes can exist at once.\n\nBurst Count\nThe internal burstCount maps [data-strength] to the total number of flakes spawned when [data-infinite=\"false\"] is used.\n\nSway\nThe internal sway calculation increases horizontal drift based on [data-strength], creating wider left-right motion at higher values.\n\nSeed\nWhen [data-infinite=\"true\"] is enabled, the internal seed count spawns an initial batch of snowflakes on load, scaled by [data-strength].",
    "id": "snowflake-effect"
  },
  {
    "title": "Creative Black Hole",
    "description": "",
    "code": "index.html: <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"> <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin> <link href=\"https://fonts.googleapis.com/css2?family=Martian+Mono:wght@100..800&display=swap\" rel=\"stylesheet\"> <a-hole> <canvas class=\"js-canvas\"></canvas> <div class=\"aura\"></div> <div class=\"overlay\"></div> </a-hole><!-- .a-hole -->\nstyle.css: body { width: 100vw; height: 100vh; background: #141414; } a-hole { position: absolute; top: 0; left: 0; margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; &:before { position: absolute; top: 50%; left: 50%; z-index: 2; display: block; width: 150%; height: 140%; background: radial-gradient(ellipse at 50% 55%, transparent 10%, black 50%); transform: translate3d(-50%, -50%, 0); content: \"\"; } &:after { position: absolute; top: 50%; left: 50%; z-index: 5; display: block; width: 100%; height: 100%; background: radial-gradient( ellipse at 50% 75%, #a900ff 20%, transparent 75% ); mix-blend-mode: overlay; transform: translate3d(-50%, -50%, 0); content: \"\"; } @keyframes aura-glow { 0% { background-position: 0 100%; } 100% { background-position: 0 300%; } } .aura { position: absolute; top: -71.5%; left: 50%; z-index: 3; width: 30%; height: 140%; background: linear-gradient( 20deg, #00f8f1, #ffbd1e20 16.5%, #fe848f 33%, #fe848f20 49.5%, #00f8f1 66%, #00f8f160 85.5%, #ffbd1e 100% ) 0 100% / 100% 200%; border-radius: 0 0 100% 100%; filter: blur(50px); mix-blend-mode: plus-lighter; opacity: 0.75; transform: translate3d(-50%, 0, 0); animation: aura-glow 5s infinite linear; } .overlay { position: absolute; top: 0; left: 0; z-index: 10; width: 100%; height: 100%; background: repeating-linear-gradient( transparent, transparent 1px, white 1px, white 2px ); mix-blend-mode: overlay; opacity: 0.5; } canvas { display: block; width: 100%; height: 100%; } }\nscript.js: import easingUtils from \"https://esm.sh/easing-utils\"; class AHole extends HTMLElement { /** * Init */ connectedCallback() { // Elements this.canvas = this.querySelector(\".js-canvas\"); this.ctx = this.canvas.getContext(\"2d\"); this.discs = []; this.lines = []; // Init this.setSize(); this.setDiscs(); this.setLines(); this.setParticles(); this.bindEvents(); // RAF requestAnimationFrame(this.tick.bind(this)); } /** * Bind events */ bindEvents() { window.addEventListener(\"resize\", this.onResize.bind(this)); } /** * Resize handler */ onResize() { this.setSize(); this.setDiscs(); this.setLines(); this.setParticles(); } /** * Set size */ setSize() { this.rect = this.getBoundingClientRect(); this.render = { width: this.rect.width, height: this.rect.height, dpi: window.devicePixelRatio }; this.canvas.width = this.render.width * this.render.dpi; this.canvas.height = this.render.height * this.render.dpi; } /** * Set discs */ setDiscs() { const { width, height } = this.rect; this.discs = []; this.startDisc = { x: width * 0.5, y: height * 0.45, w: width * 0.75, h: height * 0.7 }; this.endDisc = { x: width * 0.5, y: height * 0.95, w: 0, h: 0 }; const totalDiscs = 100; let prevBottom = height; this.clip = {}; for (let i = 0; i < totalDiscs; i++) { const p = i / totalDiscs; const disc = this.tweenDisc({ p }); const bottom = disc.y + disc.h; if (bottom <= prevBottom) { this.clip = { disc: { ...disc }, i }; } prevBottom = bottom; this.discs.push(disc); } this.clip.path = new Path2D(); this.clip.path.ellipse( this.clip.disc.x, this.clip.disc.y, this.clip.disc.w, this.clip.disc.h, 0, 0, Math.PI * 2 ); this.clip.path.rect( this.clip.disc.x - this.clip.disc.w, 0, this.clip.disc.w * 2, this.clip.disc.y ); } /** * Set lines */ setLines() { const { width, height } = this.rect; this.lines = []; const totalLines = 100; const linesAngle = (Math.PI * 2) / totalLines; for (let i = 0; i < totalLines; i++) { this.lines.push([]); } this.discs.forEach((disc) => { for (let i = 0; i < totalLines; i++) { const angle = i * linesAngle; const p = { x: disc.x + Math.cos(angle) * disc.w, y: disc.y + Math.sin(angle) * disc.h }; this.lines[i].push(p); } }); this.linesCanvas = new OffscreenCanvas(width, height); const ctx = this.linesCanvas.getContext(\"2d\"); this.lines.forEach((line, i) => { ctx.save(); let lineIsIn = false; line.forEach((p1, j) => { if (j === 0) { return; } const p0 = line[j - 1]; if ( !lineIsIn && (ctx.isPointInPath(this.clip.path, p1.x, p1.y) || ctx.isPointInStroke(this.clip.path, p1.x, p1.y)) ) { lineIsIn = true; } else if (lineIsIn) { ctx.clip(this.clip.path); } ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.lineTo(p1.x, p1.y); ctx.strokeStyle = \"#444\"; ctx.lineWidth = 2; ctx.stroke(); ctx.closePath(); }); ctx.restore(); }); this.linesCtx = ctx; } /** * Set particles */ setParticles() { const { width, height } = this.rect; this.particles = []; this.particleArea = { sw: this.clip.disc.w * 0.5, ew: this.clip.disc.w * 2, h: height * 0.85 }; this.particleArea.sx = (width - this.particleArea.sw) / 2; this.particleArea.ex = (width - this.particleArea.ew) / 2; const totalParticles = 100; for (let i = 0; i < totalParticles; i++) { const particle = this.initParticle(true); this.particles.push(particle); } } /** * Init particle */ initParticle(start = false) { const sx = this.particleArea.sx + this.particleArea.sw * Math.random(); const ex = this.particleArea.ex + this.particleArea.ew * Math.random(); const dx = ex - sx; const vx = 0.1 + Math.random() * 0.5; const y = start ? this.particleArea.h * Math.random() : this.particleArea.h; const r = 0.5 + Math.random() * 4; const vy = 0.5 + Math.random(); return { x: sx, sx, dx, y, vy, p: 0, r, c: `rgba(255, 255, 255, ${Math.random()})` }; } /** * Tween value */ tweenValue(start, end, p, ease = false) { const delta = end - start; const easeFn = easingUtils[ ease ? \"ease\" + ease.charAt(0).toUpperCase() + ease.slice(1) : \"linear\" ]; return start + delta * easeFn(p); } /** * Draw discs */ drawDiscs() { const { ctx } = this; ctx.strokeStyle = \"#444\"; ctx.lineWidth = 2; // Outer disc const outerDisc = this.startDisc; ctx.beginPath(); ctx.ellipse( outerDisc.x, outerDisc.y, outerDisc.w, outerDisc.h, 0, 0, Math.PI * 2 ); ctx.stroke(); ctx.closePath(); // Discs this.discs.forEach((disc, i) => { if (i % 5 !== 0) { return; } if (disc.w < this.clip.disc.w - 5) { ctx.save(); ctx.clip(this.clip.path); } ctx.beginPath(); ctx.ellipse(disc.x, disc.y, disc.w, disc.h, 0, 0, Math.PI * 2); ctx.stroke(); ctx.closePath(); if (disc.w < this.clip.disc.w - 5) { ctx.restore(); } }); } /** * Draw lines */ drawLines() { const { ctx, linesCanvas } = this; ctx.drawImage(linesCanvas, 0, 0); } /** * Draw particles */ drawParticles() { const { ctx } = this; ctx.save(); ctx.clip(this.clip.path); this.particles.forEach((particle) => { ctx.fillStyle = particle.c; ctx.beginPath(); ctx.rect(particle.x, particle.y, particle.r, particle.r); ctx.closePath(); ctx.fill(); }); ctx.restore(); } /** * Move discs */ moveDiscs() { this.discs.forEach((disc) => { disc.p = (disc.p + 0.001) % 1; this.tweenDisc(disc); }); } /** * Move Particles */ moveParticles() { this.particles.forEach((particle) => { particle.p = 1 - particle.y / this.particleArea.h; particle.x = particle.sx + particle.dx * particle.p; particle.y -= particle.vy; if (particle.y < 0) { particle.y = this.initParticle().y; } }); } /** * Tween disc */ tweenDisc(disc) { disc.x = this.tweenValue(this.startDisc.x, this.endDisc.x, disc.p); disc.y = this.tweenValue( this.startDisc.y, this.endDisc.y, disc.p, \"inExpo\" ); disc.w = this.tweenValue(this.startDisc.w, this.endDisc.w, disc.p); disc.h = this.tweenValue(this.startDisc.h, this.endDisc.h, disc.p); return disc; } /** * Tick */ tick(time) { const { ctx } = this; ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); ctx.save(); ctx.scale(this.render.dpi, this.render.dpi); this.moveDiscs(); this.moveParticles(); this.drawDiscs(); this.drawLines(); this.drawParticles(); ctx.restore(); requestAnimationFrame(this.tick.bind(this)); } } class Particle { constructor(x, y, ctx) {} move() {} draw() {} } customElements.define(\"a-hole\", AHole);",
    "id": "creative-black-hole"
  },
  {
    "title": "Dark / Light mode toggle",
    "description": "",
    "code": "index.html: <label class=\"toggle\"> \t<input type=\"checkbox\" /> \t<div></div> </label> <main> \t<hr /> \t<section> \t\t \t\t<div class=\"dot\"></div> \t\t<div class=\"dot\"></div> \t\t<div class=\"dot\"></div> \t\t<div class=\"dot\"></div> \t\t \t\t<h1><span>easemate. every</span><br /><strong>transition</strong> <span>count.</span></h1> \t\t \t</section> \t \t<hr /> </main>\nstyle.css: :root { \t--background-color-light: hsla(230, 80%, 98%, 1); \t--toggle-light: hsla(230, 25%, 10%, 1); \t--line-light: hsla(230, 35%, 92.5%, 1); \t--dot-light: hsla(230, 25%, 75%, 1); \t--text-top-light: hsla(240, 25%, 10%, 1); \t--text-bottom-light: hsla(240, 25%, 25%, 1); \t--text-circle-light: hsla(240, 25%, 25%, 1); \t--background-color-dark: hsla(230, 55%, 4%, 1); \t--toggle-dark: hsla(230, 25%, 75%, 1); \t--line-dark: hsla(230, 25%, 15%, .75); \t--dot-dark: hsla(230, 25%, 90%, 1); \t--text-top-dark: hsla(240, 60%, 90%, 1); \t--text-bottom-dark: hsla(240, 60%, 95%, 1); \t--text-circle-dark: hsla(240, 60%, 95%, .15); \tcolor-scheme: light; \t--x: 50%; \t--y: 50%; } html { \t--background-color: var(--background-color-light); \t--toggle-color: var(--toggle-light); \t--line-color: var(--line-light); \t--dot-color: var(--dot-light); \t--text-color-top: var(--text-top-light); \t--text-color-bottom: var(--text-bottom-light); \t--text-color-circle: var(--text-circle-light); } html.dark { \tcolor-scheme: dark; \t--background-color: var(--background-color-dark); \t--toggle-color: var(--toggle-dark); \t--line-color: var(--line-dark); \t--dot-color: var(--dot-dark); \t--text-color-top: var(--text-top-dark); \t--text-color-bottom: var(--text-bottom-dark); \t--text-color-circle: var(--text-circle-dark); } body { \tmin-height: 100dvh; \tdisplay: flex; \tjustify-content: center; \talign-items: center; \tfont-family: \"Instrument Sans\", sans-serif; \ttransition: background-color 0.3s ease, color 0.3s ease; \tbackground-color: var(--background-color); } main { \twidth: 100%; } section { \twidth: clamp(360px, 60vw, 780px); \taspect-ratio: 1.55 / .5; \tmin-height: 200px; \tmargin: auto; \ttext-align: center; \tplace-items: center; \tdisplay: grid; \tposition: relative; \t \t.dot { \t\theight: 5px; \t\twidth: 5px; \t\tbackground-color: var(--dot-color); \t\tposition: absolute; \t\tz-index: 1; \t\tborder-radius: 50%; \t\tbox-shadow: 0 0 0 3px var(--background-color); \t\t \t\t&:nth-child(1) { \t\t\ttop: -2px; \t\t\tleft: -2px; \t\t} \t\t \t\t&:nth-child(2) { \t\t\ttop: -2px; \t\t\tright: -2px; \t\t} \t\t \t\t&:nth-child(3) { \t\t\tbottom: -2px; \t\t\tright: -2px; \t\t} \t\t \t\t&:nth-child(4) { \t\t\tbottom: -2px; \t\t\tleft: -2px; \t\t} \t} \t&:before, \t&:after { \t\tcontent: ''; \t\tposition: absolute; \t\theight: 100dvh; \t\twidth: 1px; \t\tbackground-color: var(--line-color); \t} \t&:before { \t\tleft: 0; \t} \t&:after { \t\tright: 0; \t} } main hr { \tborder: none; \theight: 1px; \twidth: 100%; \tmargin: 0; \tbackground-color: var(--line-color); } h1 { \tfont-optical-sizing: auto; \tfont-weight: 700; \tfont-style: normal; \tfont-variation-settings: \"wdth\" 95; \tfont-size: clamp(32px, 6vw, 68px); \tline-height: 1.05; \tmargin: 0; \ttext-align: left; } h1 span { \tbackground-image: linear-gradient(180deg, var(--text-color-top) 0%, var(--text-color-bottom) 100%); \tbackground-clip: text; \t-webkit-background-clip: text; \t-webkit-text-fill-color: transparent; } h1 strong { \tdisplay: inline-block; \tcolor: transparent; \tbackground-image: url('https://assets.codepen.io/165585/circle-bg_1.svg'); \tbackground-color: var(--text-color-circle); \tbackground-size: 400px; \tbackground-position: 50% 80%; \tbackground-blend-mode: overlay; \t-webkit-background-clip: text; \tbackground-clip: text; \t-webkit-text-fill-color: transparent; \tletter-spacing: 0.015em; } @keyframes reveal-in { \tfrom { \t\tclip-path: circle(0% at var(--x) var(--y)); \t} \tto { \t\tclip-path: circle(150% at var(--x) var(--y)); \t} } @keyframes reveal-out { \tfrom { \t\tclip-path: circle(150% at var(--x) var(--y)); \t} \tto { \t\tclip-path: circle(0% at var(--x) var(--y)); \t} } ::view-transition-new(root) { \tanimation: reveal-in 0.5s ease-in-out forwards; \tz-index: 1; \tmix-blend-mode: normal; } ::view-transition-old(root) { \tanimation: reveal-out 0.5s ease-in-out forwards; \t\t\t\t\tanimation-delay: .5s; \tz-index: 0; \tmix-blend-mode: normal; } ::view-transition-image-pair(root) { \tisolation: isolate; } .toggle { \tposition: fixed; \ttop: 12px; \tleft: 50%; \ttransform: translateX(-50%) scale(.5); \tcursor: pointer; \tz-index: 10; } .toggle input { \tdisplay: none; } .toggle input + div { \tborder-radius: 50%; \twidth: 36px; \theight: 36px; \tposition: relative; \tbox-shadow: inset 16px -16px 0 0 var(--toggle-color); \ttransform: scale(1) rotate(-2deg); \ttransition: box-shadow .5s ease 0s, transform .4s ease .1s; } .toggle input + div:before { \tcontent: ''; \twidth: inherit; \theight: inherit; \tborder-radius: inherit; \tposition: absolute; \tleft: 0; \ttop: 0; \tbackground: light-dark(transparent, var(--toggle-color)); \ttransition: background .3s ease; } .toggle input + div:after { \tcontent: ''; \twidth: 8px; \theight: 8px; \tborder-radius: 50%; \tmargin: -4px 0 0 -4px; \tposition: absolute; \ttop: 50%; \tleft: 50%; \tbox-shadow: 0 -23px 0 var(--toggle-color), \t\t0 23px 0 var(--toggle-color), \t\t23px 0 0 var(--toggle-color), \t\t-23px 0 0 var(--toggle-color), \t\t15px 15px 0 var(--toggle-color), \t\t-15px 15px 0 var(--toggle-color), \t\t15px -15px 0 var(--toggle-color), \t\t-15px -15px 0 var(--toggle-color); \ttransform: scale(0); \ttransition: all .3s ease; } .toggle input:checked + div { \tbox-shadow: inset 32px -32px 0 0 var(--background-color); \ttransform: scale(.5) rotate(0deg); \ttransition: transform .3s ease .1s, box-shadow .2s ease 0s; } .toggle input:checked + div:before { \tbackground: var(--toggle-color); \ttransition: background .3s ease .1s; } .toggle input:checked + div:after { \ttransform: scale(1.5); \ttransition: transform .5s ease .15s; }\nscript.js: document.addEventListener('DOMContentLoaded', () => { \tconst toggleInput = document.querySelector('.toggle input'); \tconst rootElement = document.documentElement; \tconst applyTheme = (isDark) => { \t\tif (isDark) { \t\t\trootElement.classList.add('dark'); \t\t} else { \t\t\trootElement.classList.remove('dark'); \t\t} \t}; \tconst prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; \ttoggleInput.checked = prefersDark; \tapplyTheme(prefersDark); \ttoggleInput.addEventListener('input', (event) => { \t\tconst isDark = toggleInput.checked; \t\tlet x = window.innerWidth / 2; \t\tlet y = window.innerHeight / 2; \t\t \t\tconst toggleElement = document.querySelector('.toggle'); \t\t \t\tif (toggleElement) { \t\t\tconst rect = toggleElement.getBoundingClientRect(); \t\t\tx = rect.left + rect.width / 2; \t\t\ty = rect.top + rect.height / 2; \t\t} \t\tif (!document.startViewTransition) { \t\t\tconsole.warn(\"View Transition API not supported. Falling back.\"); \t\t\tapplyTheme(isDark); \t\t\treturn; \t\t} \t\tconst transition = document.startViewTransition(() => { \t\t\tapplyTheme(isDark); \t\t}); \t\ttransition.ready.then(() => { \t\t\trootElement.style.setProperty('--x', `${x}px`); \t\t\trootElement.style.setProperty('--y', `${y}px`); \t\t}).catch(error => { \t\t\tconsole.error(\"Error during View Transition setup:\", error); \t\t}); \t\ttransition.finished.then(() => { \t\t\tconsole.log(\"Transition finished.\"); // Debug log \t\t}).catch(error => { \t\t\tconsole.error(\"Error during View Transition finish:\", error); \t\t}); \t}); });",
    "id": "dark--light-mode-toggle"
  },
  {
    "title": "Sharp & Glowing dark card | Chrome only",
    "description": "",
    "code": "index.html: <div role=\"button\"> <span class=\"glow\"></span> <div> <span>cool</span>Glowing shadows </div> </div>\nstyle.css: @font-face { font-family: \"Mona Sans\"; src: url(\"https://assets.codepen.io/64/Mona-Sans.woff2\") format(\"woff2 supports variations\"), url(\"https://assets.codepen.io/64/Mona-Sans.woff2\") format(\"woff2-variations\"); font-weight: 100 1000; } @property --hue { syntax: \"<number>\"; inherits: true; initial-value: 0; } @property --rotate { syntax: \"<number>\"; inherits: true; initial-value: 0; } @property --bg-y { syntax: \"<number>\"; inherits: true; initial-value: 0; } @property --bg-x { syntax: \"<number>\"; inherits: true; initial-value: 0; } @property --glow-translate-y { syntax: \"<number>\"; inherits: true; initial-value: 0; } @property --bg-size { syntax: \"<number>\"; inherits: true; initial-value: 0; } @property --glow-opacity { syntax: \"<number>\"; inherits: true; initial-value: 0; } @property --glow-blur { syntax: \"<number>\"; inherits: true; initial-value: 0; } @property --glow-scale { syntax: \"<number>\"; inherits: true; initial-value: 2; } @property --glow-radius { syntax: \"<number>\"; inherits: true; initial-value: 2; } @property --white-shadow { syntax: \"<number>\"; inherits: true; initial-value: 0; } :root { // utilities --debug: 0; --supported: 0; --not-supported: 0; // Pen vars --card-color: hsl(260deg 100% 3%); --text-color: hsl(260deg 10% 55%); --card-radius: 3.6vw; --card-width: 35vw; --border-width: 3px; --bg-size: 1; --hue: 0; --hue-speed: 1; --rotate: 0; --animation-speed: 4s; --interaction-speed: 0.55s; --glow-scale: 1.5; --scale-factor: 1; --glow-blur: 6; // 6 --glow-opacity: 1; // 0.6 --glow-radius: 100; // 100 --glow-rotate-unit: 1deg; } body::before, body::after { content: \"CSS.registerProperty is supported âœ…\"; position: absolute; display: block; top: 8px; left: 0; right: 0; margin: auto; width: calc(100% - 160px); max-width: 380px; height: auto; padding: 8px; border-radius: 8px; background: hsl(114deg 51% 48%); color: white; text-align: center; font-family: sans-serif; z-index: var(--supported, 0); opacity: var(--supported, 0); } body::after { content: \"CSS.registerProperty is NOT supported âŒ\"; background: hsl(0deg 51% 48%); z-index: var(--not-supported, 0); opacity: var(--not-supported, 0); } body::before, body::after { display: none !important; } html, body { height: 100%; width: 100%; padding: 0; margin: 0; } *, *:before, *:after { outline: calc(var(--debug) * 1px) red dashed; } body { background-color: var(--card-color); display: flex; align-items: center; justify-content: center; font-family: \"Mona Sans\", sans-serif; } body > div { width: var(--card-width); width: min(480px, var(--card-width)); aspect-ratio: 1.5/1; color: white; margin: auto; display: flex; align-items: center; justify-content: center; position: relative; z-index: 2; border-radius: var(--card-radius); cursor: pointer; &:hover { > div { mix-blend-mode: darken; --text-color: white; box-shadow: 0 0 calc(var(--white-shadow) * 1vw) calc(var(--white-shadow) * 0.15vw) rgb(255 255 255 / 20%); animation: shadow-pulse calc(var(--animation-speed) * 2) linear infinite; &:before { --bg-size: 15; animation-play-state: paused; transition: --bg-size var(--interaction-speed) ease; } } .glow { --glow-blur: 1.5; --glow-opacity: 0.6; --glow-scale: 2.5; --glow-radius: 0; --rotate: 900; --glow-rotate-unit: 0; --scale-factor: 1.25; animation-play-state: paused; &:after { --glow-translate-y: 0; animation-play-state: paused; transition: --glow-translate-y 0s ease, --glow-blur 0.05s ease, --glow-opacity 0.05s ease, --glow-scale 0.05s ease, --glow-radius 0.05s ease; } } } &:before, &:after { content: \"\"; display: block; position: absolute; width: 100%; height: 100%; border-radius: var(--card-radius); } > div { position: absolute; width: 100%; height: 100%; background: var(--card-color); border-radius: calc(calc(var(--card-radius) * 0.9)); display: flex; align-items: center; justify-content: center; font-weight: 800; text-transform: uppercase; font-stretch: 150%; font-size: 18px; font-size: clamp(1.5vw, 1.5vmin, 32px); color: var(--text-color); padding: calc(var(--card-width) / 8); span { display: inline-block; padding: 0.25em; border-radius: 4px; background: var(--text-color); color: black; margin-right: 8px; font-weight: 900; } &:before { content: \"\"; display: block; position: absolute; width: 100%; height: 100%; border-radius: calc(calc(var(--card-radius) * 0.9)); box-shadow: 0 0 20px black; mix-blend-mode: color-burn; z-index: -1; background: hsl(0deg 0% 16%) radial-gradient( 30% 30% at calc(var(--bg-x) * 1%) calc(var(--bg-y) * 1%), hsl(calc(calc(var(--hue) * var(--hue-speed)) * 1deg) 100% 90%) calc(0% * var(--bg-size)), hsl(calc(calc(var(--hue) * var(--hue-speed)) * 1deg) 100% 80%) calc(20% * var(--bg-size)), hsl(calc(calc(var(--hue) * var(--hue-speed)) * 1deg) 100% 60%) calc(40% * var(--bg-size)), transparent 100% ); width: calc(100% + var(--border-width)); height: calc(100% + var(--border-width)); animation: hue-animation var(--animation-speed) linear infinite, rotate-bg var(--animation-speed) linear infinite; transition: --bg-size var(--interaction-speed) ease; } } .glow { --glow-translate-y: 0; display: block; position: absolute; width: calc(var(--card-width) / 5); height: calc(var(--card-width) / 5); animation: rotate var(--animation-speed) linear infinite; transform: rotateZ(calc(var(--rotate) * var(--glow-rotate-unit))); transform-origin: center; border-radius: calc(var(--glow-radius) * 10vw); &:after { content: \"\"; display: block; z-index: -2; filter: blur(calc(var(--glow-blur) * 10px)); width: 130%; height: 130%; left: -15%; top: -15%; background: hsl( calc(calc(var(--hue) * var(--hue-speed)) * 1deg) 100% 60% ); position: relative; border-radius: calc(var(--glow-radius) * 10vw); animation: hue-animation var(--animation-speed) linear infinite; transform: scaleY(calc(var(--glow-scale) * var(--scale-factor) / 1.1)) scaleX(calc(var(--glow-scale) * var(--scale-factor) * 1.2)) translateY(calc(var(--glow-translate-y) * 1%)); opacity: var(--glow-opacity); } } } @keyframes shadow-pulse { 0%, 24%, 46%, 73%, 96% { --white-shadow: 0.5; } 12%, 28%, 41%, 63%, 75%, 82%, 98% { --white-shadow: 2.5; } 6%, 32%, 57% { --white-shadow: 1.3; } 18%, 52%, 88% { --white-shadow: 3.5; } } @keyframes rotate-bg { 0% { --bg-x: 0; --bg-y: 0; } 25% { --bg-x: 100; --bg-y: 0; } 50% { --bg-x: 100; --bg-y: 100; } 75% { --bg-x: 0; --bg-y: 100; } 100% { --bg-x: 0; --bg-y: 0; } } @keyframes rotate { from { --rotate: -70; --glow-translate-y: -65; } 25% { --glow-translate-y: -65; } 50% { --glow-translate-y: -65; } 60%, 75% { --glow-translate-y: -65; } 85% { --glow-translate-y: -65; } to { --rotate: calc(360 - 70); --glow-translate-y: -65; } } @keyframes hue-animation { 0% { --hue: 0; } 100% { --hue: 360; } }\nscript.js: // Credit: @LukyVj // https://twitter.com/LukyVj // https://lucasbonomi.com if (typeof window.CSS.registerProperty === 'function') { console.log('CSS.registerProperty supported ðŸŽ‰') document.body.style.setProperty('--supported', 1); document.body.classList.add('registerProperty-supported') } else { console.log('CSS.registerProperty not supported âŒ') document.body.style.setProperty('--not-supported', 1); document.body.classList.add('registerProperty-not-supported') }",
    "id": "sharp--glowing-dark-card--chrome-only"
  },
  {
    "title": "mukta-image-explosion-scroll-animation-js",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Image Explosion Animation On Scroll (JS) | mukta</title>\n    <link rel=\"stylesheet\" href=\"/styles.css\" />\n  </head>\n  <body>\n    <section class=\"hero\"></section>\n\n    <section class=\"about\">\n      <p>\n        The world collapsed, but the game survived. In the neon-lit ruins of\n        civilization, the last remnants of power arenâ€™t in governments or\n        corporationsâ€”theyâ€™re in the **Oblivion Decks**. Each card carries a\n        fragment of lost history, a code of survival, a weapon of deception. The\n        elite hoard them. The rebels steal them. The desperate gamble their\n        lives for them. Do you have what it takes to **play the game that\n        decides the future**?\n      </p>\n    </section>\n\n    <section class=\"outro\"></section>\n\n    <footer>\n      <h1>The future is in your hands</h1>\n      <div class=\"copyright-info\">\n        <p>&copy; 2025 Oblivion Decks</p>\n        <p>All rights reserved.</p>\n      </div>\n\n      <div class=\"explosion-container\"></div>\n    </footer>\n\n    <script type=\"module\" src=\"/script.js\"></script>\n  </body>\n</html>\n",
      "package.json": "{\n  \"name\": \"mukta-image-explosion-scroll-animation-js\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"lenis\": \"^1.2.3\",\n    \"vite\": \"^6.2.2\"\n  }\n}\n",
      "script.js": "import Lenis from \"lenis\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const lenis = new Lenis({\n    autoRaf: true,\n    lerp: 0.5,\n  });\n\n  const footer = document.querySelector(\"footer\");\n  const explosionContainer = document.querySelector(\".explosion-container\");\n  let explosionTriggered = false;\n\n  const config = {\n    gravity: 0.25,\n    friction: 0.99,\n    imageSize: 150,\n    horizontalForce: 20,\n    verticalForce: 15,\n    rotationSpeed: 10,\n    resetDelay: 500,\n  };\n\n  const imageParticleCount = 15;\n  const imagePaths = Array.from(\n    { length: imageParticleCount },\n    (_, i) => `./assets/img${i + 1}.jpg`\n  );\n\n  imagePaths.forEach((path) => {\n    const img = new Image();\n    img.src = path;\n  });\n\n  const createParticles = () => {\n    explosionContainer.innerHTML = \"\";\n\n    imagePaths.forEach((path) => {\n      const particle = document.createElement(\"img\");\n      particle.src = path;\n      particle.classList.add(\"explosion-particle-img\");\n      particle.style.width = `${config.imageSize}px`;\n      explosionContainer.appendChild(particle);\n    });\n  };\n\n  class Particle {\n    constructor(element) {\n      this.element = element;\n      this.x = 0;\n      this.y = 0;\n      this.vx = (Math.random() - 0.5) * config.horizontalForce;\n      this.vy = -config.verticalForce - Math.random() * 10;\n      this.rotation = 0;\n      this.rotationSpeed = (Math.random() - 0.5) * config.rotationSpeed;\n    }\n\n    update() {\n      this.vy += config.gravity;\n      this.vx *= config.friction;\n      this.vy *= config.friction;\n      this.rotationSpeed *= config.friction;\n\n      this.x += this.vx;\n      this.y += this.vy;\n      this.rotation += this.rotationSpeed;\n\n      this.element.style.transform = `translate(${this.x}px, ${this.y}px) rotate(${this.rotation}deg)`;\n    }\n  }\n\n  const explode = () => {\n    if (explosionTriggered) return;\n    explosionTriggered = true;\n\n    createParticles();\n\n    const particleElements = document.querySelectorAll(\n      \".explosion-particle-img\"\n    );\n    const particles = Array.from(particleElements).map(\n      (element) => new Particle(element)\n    );\n\n    let animationId;\n\n    const animate = () => {\n      particles.forEach((particle) => particle.update());\n      animationId = requestAnimationFrame(animate);\n\n      if (\n        particles.every(\n          (particle) => particle.y > explosionContainer.offsetHeight / 2\n        )\n      ) {\n        cancelAnimationFrame(animationId);\n        setTimeout(() => {\n          explosionTriggered = false;\n        }, config.resetDelay);\n      }\n    };\n\n    animate();\n  };\n\n  const checkFooterPosition = () => {\n    const footerRect = footer.getBoundingClientRect();\n    const viewportHeight = window.innerHeight;\n\n    if (\n      !explosionTriggered &&\n      footerRect.top <= viewportHeight - footerRect.height * 0.5\n    ) {\n      explode();\n    }\n  };\n\n  let checkTimeout;\n  window.addEventListener(\"scroll\", () => {\n    clearTimeout(checkTimeout);\n    checkTimeout = setTimeout(checkFooterPosition, 10);\n  });\n\n  window.addEventListener(\"resize\", () => {\n    explosionTriggered = false;\n  });\n\n  createParticles();\n  setTimeout(checkFooterPosition, 500);\n});\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\np {\n  text-transform: uppercase;\n  font-family: \"Akkurat Mono\", monospace;\n  font-size: 14px;\n}\n\nimg {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\nsection {\n  position: relative;\n  width: 100vw;\n  height: 100svh;\n  padding: 2em;\n}\n\n.hero {\n  background: url(\"/assets/hero.jpg\") no-repeat 50% 50%;\n  background-size: cover;\n}\n\n.about {\n  color: #000;\n  background-color: #e3e3db;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.about p {\n  width: 50%;\n  text-align: center;\n}\n\n.outro {\n  background: url(\"/assets/outro.jpg\") no-repeat 50% 50%;\n  background-size: cover;\n}\n\nfooter {\n  position: relative;\n  width: 100vw;\n  height: 75svh;\n  background-color: #0f0f0f;\n  color: #fff;\n  padding: 2em;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  align-items: center;\n  overflow: hidden;\n}\n\nfooter h1 {\n  text-transform: uppercase;\n  font-family: \"FK Screamer\", sans-serif;\n  font-size: 12vw;\n  font-weight: 500;\n  line-height: 0.85;\n}\n\n.copyright-info {\n  width: 100%;\n  display: flex;\n  justify-content: space-between;\n}\n\n.explosion-container {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 200%;\n  pointer-events: none;\n}\n\n.explosion-particle-img {\n  position: absolute;\n  bottom: -200px;\n  left: 50%;\n  width: 150px;\n  height: auto;\n  object-fit: cover;\n  transform: translateX(-50%);\n  will-change: transform;\n}\n"
    }
  },
  {
    "title": "ðŸ˜µâ€ðŸ’« p5.js GLitch Image",
    "description": "",
    "code": "index.html: \nstyle.css: /* Takashi credits: https://codepen.io/tksiiii/pen/xdQgJX */ html,body{ margin: 0; padding: 0; overflow: hidden; }\nscript.js: let windowW = window.innerWidth; let windowH = window.innerHeight; let isLoaded = false; let glitch; let imgSrc ='https://images.unsplash.com/photo-1541892079-2475b9253785?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=750&q=80' function setup() { background(0); createCanvas(windowW, windowH); loadImage(imgSrc, function(img) { glitch = new Glitch(img); isLoaded = true; }); } function draw() { clear(); background(0); if (isLoaded) { glitch.show(); } // fill(255, 255, 255); // textSize(14); // text('FPS: ' + floor(frameRate()), 20, 30); } class Glitch { constructor(img) { this.channelLen = 4; this.imgOrigin = img; this.imgOrigin.loadPixels(); this.copyData = []; this.flowLineImgs = []; this.shiftLineImgs = []; this.shiftRGBs = []; this.scatImgs = []; this.throughFlag = true; this.copyData = new Uint8ClampedArray(this.imgOrigin.pixels); // flow line for (let i = 0; i < 1; i++) { let o = { pixels: null, t1: floor(random(0, 1000)), speed: floor(random(4, 24)), randX: floor(random(24, 80)) }; this.flowLineImgs.push(o); } // shift line for (let i = 0; i < 6; i++) { let o = null; this.shiftLineImgs.push(o); } // shift RGB for (let i = 0; i < 1; i++) { let o = null; this.shiftRGBs.push(o); } // scat imgs for (let i = 0; i < 3; i++) { let scatImg = { img: null, x: 0, y: 0 }; this.scatImgs.push(scatImg); } } replaceData(destImg, srcPixels) { for (let y = 0; y < destImg.height; y++) { for (let x = 0; x < destImg.width; x++) { let r, g, b, a; let index; index = (y * destImg.width + x) * this.channelLen; r = index; g = index + 1; b = index + 2; a = index + 3; destImg.pixels[r] = srcPixels[r]; destImg.pixels[g] = srcPixels[g]; destImg.pixels[b] = srcPixels[b]; destImg.pixels[a] = srcPixels[a]; } } destImg.updatePixels(); } flowLine(srcImg, obj) { let destPixels, tempY; destPixels = new Uint8ClampedArray(srcImg.pixels); obj.t1 %= srcImg.height; obj.t1 += obj.speed; //tempY = floor(noise(obj.t1) * srcImg.height); tempY = floor(obj.t1); for (let y = 0; y < srcImg.height; y++) { if (tempY === y) { for (let x = 0; x < srcImg.width; x++) { let r, g, b, a; let index; index = (y * srcImg.width + x) * this.channelLen; r = index; g = index + 1; b = index + 2; a = index + 3; destPixels[r] = srcImg.pixels[r] + obj.randX; destPixels[g] = srcImg.pixels[g] + obj.randX; destPixels[b] = srcImg.pixels[b] + obj.randX; destPixels[a] = srcImg.pixels[a]; } } } return destPixels; } shiftLine(srcImg) { let offsetX; let rangeMin, rangeMax; let destPixels; let rangeH; destPixels = new Uint8ClampedArray(srcImg.pixels); rangeH = srcImg.height; rangeMin = floor(random(0, rangeH)); rangeMax = rangeMin + floor(random(1, rangeH - rangeMin)); offsetX = this.channelLen * floor(random(-40, 40)); for (let y = 0; y < srcImg.height; y++) { if (y > rangeMin && y < rangeMax) { for (let x = 0; x < srcImg.width; x++) { let r, g, b, a; let r2, g2, b2, a2; let index; index = (y * srcImg.width + x) * this.channelLen; r = index; g = index + 1; b = index + 2; a = index + 3; r2 = r + offsetX; g2 = g + offsetX; b2 = b + offsetX; destPixels[r] = srcImg.pixels[r2]; destPixels[g] = srcImg.pixels[g2]; destPixels[b] = srcImg.pixels[b2]; destPixels[a] = srcImg.pixels[a]; } } } return destPixels; } shiftRGB(srcImg) { let randR, randG, randB; let destPixels; let range; range = 16; destPixels = new Uint8ClampedArray(srcImg.pixels); randR = (floor(random(-range, range)) * srcImg.width + floor(random(-range, range))) * this.channelLen; randG = (floor(random(-range, range)) * srcImg.width + floor(random(-range, range))) * this.channelLen; randB = (floor(random(-range, range)) * srcImg.width + floor(random(-range, range))) * this.channelLen; for (let y = 0; y < srcImg.height; y++) { for (let x = 0; x < srcImg.width; x++) { let r, g, b, a; let r2, g2, b2, a2; let index; index = (y * srcImg.width + x) * this.channelLen; r = index; g = index + 1; b = index + 2; a = index + 3; r2 = (r + randR) % srcImg.pixels.length; g2 = (g + randG) % srcImg.pixels.length; b2 = (b + randB) % srcImg.pixels.length; destPixels[r] = srcImg.pixels[r2]; destPixels[g] = srcImg.pixels[g2]; destPixels[b] = srcImg.pixels[b2]; destPixels[a] = srcImg.pixels[a]; } } return destPixels; } getRandomRectImg(srcImg) { let startX; let startY; let rectW; let rectH; let destImg; startX = floor(random(0, srcImg.width - 30)); startY = floor(random(0, srcImg.height - 50)); rectW = floor(random(30, srcImg.width - startX)); rectH = floor(random(1, 50)); destImg = srcImg.get(startX, startY, rectW, rectH); destImg.loadPixels(); return destImg; } show() { // restore the original state this.replaceData(this.imgOrigin, this.copyData); // sometimes pass without effect processing let n = floor(random(100)); if (n > 75 && this.throughFlag) { this.throughFlag = false; setTimeout(() => { this.throughFlag = true; }, floor(random(40, 400))); } if (!this.throughFlag) { push(); translate((width - this.imgOrigin.width) / 2, (height - this.imgOrigin.height) / 2); image(this.imgOrigin, 0, 0); pop(); return; } // flow line this.flowLineImgs.forEach((v, i, arr) => { arr[i].pixels = this.flowLine(this.imgOrigin, v); if (arr[i].pixels) { this.replaceData(this.imgOrigin, arr[i].pixels); } }) // shift line this.shiftLineImgs.forEach((v, i, arr) => { if (floor(random(100)) > 50) { arr[i] = this.shiftLine(this.imgOrigin); this.replaceData(this.imgOrigin, arr[i]); } else { if (arr[i]) { this.replaceData(this.imgOrigin, arr[i]); } } }) // shift rgb this.shiftRGBs.forEach((v, i, arr) => { if (floor(random(100)) > 65) { arr[i] = this.shiftRGB(this.imgOrigin); this.replaceData(this.imgOrigin, arr[i]); } }) push(); translate((width - this.imgOrigin.width) / 2, (height - this.imgOrigin.height) / 2); image(this.imgOrigin, 0, 0); pop(); // scat image this.scatImgs.forEach((obj) => { push(); translate((width - this.imgOrigin.width) / 2, (height - this.imgOrigin.height) / 2); if (floor(random(100)) > 80) { obj.x = floor(random(-this.imgOrigin.width * 0.3, this.imgOrigin.width * 0.7)); obj.y = floor(random(-this.imgOrigin.height * 0.1, this.imgOrigin.height)); obj.img = this.getRandomRectImg(this.imgOrigin); } if (obj.img) { image(obj.img, obj.x, obj.y); } pop(); }) } }",
    "id": "-p5js-glitch-image"
  },
  {
    "title": "cg-takepill",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>mukta_takepill</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n    <script src=\"https://unpkg.com/@phosphor-icons/web\"></script>\n  </head>\n  <body>\n    <nav>\n      <div class=\"logo\">\n        <a href=\"#\"><i class=\"ph ph-codesandbox-logo\"></i> </a>\n      </div>\n      <div class=\"nav-items\">\n        <div class=\"item\"><a href=\"#\">Work</a></div>\n        <div class=\"item\"><a href=\"#\">Agency</a></div>\n        <div class=\"item\"><a href=\"#\">Careers</a></div>\n        <div class=\"item\"><a href=\"#\">Store</a></div>\n        <div class=\"item\" id=\"btn\"><a href=\"#\">Showreel</a></div>\n      </div>\n    </nav>\n\n    <div class=\"menu\">\n      <div class=\"pill\">\n        <img src=\"./assets/1.png\" alt=\"\" class=\"image\" data-id=\"1\" />\n        <img src=\"./assets/2.png\" alt=\"\" class=\"image\" data-id=\"2\" />\n        <img src=\"./assets/3.png\" alt=\"\" class=\"image\" data-id=\"3\" />\n        <img src=\"./assets/4.png\" alt=\"\" class=\"image\" data-id=\"4\" />\n        <img src=\"./assets/5.png\" alt=\"\" class=\"image\" data-id=\"5\" />\n        <img src=\"./assets/6.png\" alt=\"\" class=\"image\" data-id=\"6\" />\n        <img src=\"./assets/7.png\" alt=\"\" class=\"image\" data-id=\"7\" />\n        <img src=\"./assets/8.png\" alt=\"\" class=\"image\" data-id=\"8\" />\n        <img src=\"./assets/9.png\" alt=\"\" class=\"image\" data-id=\"9\" />\n        <img src=\"./assets/10.png\" alt=\"\" class=\"image\" data-id=\"10\" />\n      </div>\n\n      <div class=\"links\">\n        <div class=\"link\">\n          <a href=\"#\" data-image=\"1\">Azure</a>\n        </div>\n        <div class=\"link\">\n          <a href=\"#\" data-image=\"2\">Euphoria</a>\n        </div>\n        <div class=\"link\">\n          <a href=\"#\" data-image=\"3\">Scratcher</a>\n        </div>\n        <div class=\"link\">\n          <a href=\"#\" data-image=\"4\">Ember</a>\n        </div>\n        <div class=\"link\">\n          <a href=\"#\" data-image=\"5\">Liquid Soleil</a>\n        </div>\n        <div class=\"link\">\n          <a href=\"#\" data-image=\"6\">Vaccum</a>\n        </div>\n        <div class=\"link\">\n          <a href=\"#\" data-image=\"7\">Morph</a>\n        </div>\n        <div class=\"link\">\n          <a href=\"#\" data-image=\"8\">Respledent</a>\n        </div>\n        <div class=\"link\">\n          <a href=\"#\" data-image=\"9\">Synthesis</a>\n        </div>\n        <div class=\"link\">\n          <a href=\"#\" data-image=\"10\">Nuke</a>\n        </div>\n      </div>\n    </div>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js\"></script>\n    <script>\n      // Lerp function\n      function lerp(start, end, t) {\n        return start * (1 - t) + end * t;\n      }\n\n      const linksContainer = document.querySelector(\".links\");\n      let currentScroll = 0;\n      let targetScroll = 0;\n      const ease = 0.1;\n\n      document.addEventListener(\"mousemove\", (e) => {\n        const extraHeight = linksContainer.offsetHeight - window.innerHeight;\n        targetScroll = (e.clientY / window.innerHeight) * -extraHeight;\n      });\n\n      function animate() {\n        currentScroll = lerp(currentScroll, targetScroll, ease);\n        linksContainer.style.transform = `translateY(${currentScroll}px)`;\n        requestAnimationFrame(animate);\n      }\n\n      animate();\n      let currentImageId = 1;\n\n      document.querySelectorAll(\".link a\").forEach((link) => {\n        link.addEventListener(\"mouseenter\", function () {\n          const targetImageId = parseInt(this.getAttribute(\"data-image\"));\n          let rotationValue = targetImageId > currentImageId ? 360 : -360;\n\n          const pill = document.querySelector(\".pill\");\n          const images = document.querySelectorAll(\".pill img\");\n\n          gsap.to(pill, {\n            rotation: rotationValue,\n            duration: 0.4,\n            onComplete: function () {\n              gsap.set(pill, {\n                rotation: 0,\n              });\n            },\n          });\n\n          gsap.set(images, {\n            zIndex: 0,\n            opacity: 0,\n            delay: 0.25,\n          });\n\n          gsap.set(`.pill img[data-id='${targetImageId}']`, {\n            zIndex: 10,\n            opacity: 1,\n            delay: 0.25,\n          });\n\n          currentImageId = targetImageId;\n        });\n      });\n    </script>\n  </body>\n</html>\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  width: 100vw;\n  height: 100vh;\n  background: #0a0a0a;\n}\n\nnav {\n  position: fixed;\n  width: 100vw;\n  padding: 2rem 3rem;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  background: rgba(0, 0, 0, 0.2);\n  backdrop-filter: blur(20px);\n  z-index: 10000;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.nav-items {\n  display: flex;\n  align-items: center;\n  gap: 2rem;\n}\n\n.logo a,\n.item a {\n  color: #fff;\n  text-decoration: none;\n  font-family: \"Neue Montreal\";\n  font-size: 14px;\n}\n\n#btn {\n  /* background: rgb(60, 60, 252); */\n  background: #fff;\n  color: #000;\n  padding: 0.5rem 1rem;\n  border-radius: 20px;\n  margin-left: 4rem;\n}\n\n#btn a {\n  color: #000;\n}\n\ni {\n  font-size: 20px;\n}\n\n.menu {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\n.pill {\n  position: absolute;\n  top: 50%;\n  right: 10%;\n  transform: translate(0%, -50%);\n  width: 300px;\n  height: 300px;\n}\n\n.pill img {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n  transition: z-index 0.5s, opacity 0.5s;\n  opacity: 0;\n}\n\n.pill img[data-id=\"1\"] {\n  z-index: 10;\n  opacity: 1;\n}\n\n.links {\n  padding: 40rem 8rem;\n  height: 240vh;\n  overflow: hidden;\n}\n\n.menu a {\n  text-decoration: none;\n  font-family: \"PP Neue Montreal\";\n  font-size: 5rem;\n  letter-spacing: -0.2rem;\n  color: rgb(80, 80, 80);\n  transition: all 0.3d ease-in-out;\n}\n\n.menu a:hover {\n  color: #fff;\n}\n"
    }
  },
  {
    "title": "mukta-next-vinyl-cover",
    "code": {
      "jsconfig.json": "{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  }\n}\n",
      "next.config.mjs": "/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  /* config options here */\n};\n\nexport default nextConfig;\n",
      "package.json": "{\n  \"name\": \"mukta-next-vinyl-cover\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"next dev --webpack\",\n    \"build\": \"next build --webpack\",\n    \"start\": \"next start\"\n  },\n  \"dependencies\": {\n    \"@gsap/react\": \"^2.1.2\",\n    \"gsap\": \"^3.13.0\",\n    \"next\": \"16.0.1\",\n    \"react\": \"19.2.0\",\n    \"react-dom\": \"19.2.0\"\n  }\n}\n",
      "src/app/globals.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  background-color: #000;\n}\n\n.container {\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n  position: relative;\n}\n\nimg {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\nsvg {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  overflow: visible;\n}\n\npath {\n  fill: transparent;\n}\n\ntextPath {\n  fill: #fff;\n}\n\ntext {\n  text-transform: uppercase;\n  fill: #fff;\n}\n\n#text-primary {\n  font-family: \"Tusker Grotesk\", sans-serif;\n  font-size: 46px;\n}\n\n#text-secondary {\n  font-family: \"PP Neue Montreal\", sans-serif;\n  font-size: 20px;\n}\n\n.disk {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 550px;\n  height: 550px;\n  border-radius: 100%;\n}\n\n.cover-img {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 250px;\n  height: 250px;\n  border-radius: 100%;\n  overflow: hidden;\n}\n",
      "src/app/layout.js": "import { Inter } from \"next/font/google\";\nimport \"./globals.css\";\n\nconst inter = Inter({ subsets: [\"latin\"] });\n\nexport const metadata = {\n  title: \"GSAP SVG MotionPath Animation x NextJS | @mukta\",\n  description: \"Generated by mukta\",\n};\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <body className={inter.className}>{children}</body>\n    </html>\n  );\n}\n",
      "src/app/page.js": "import Image from \"next/image\";\nimport styles from \"./page.module.css\";\nimport SampleCoverImage from \"/public/sample-cover.jpg\";\n\nimport VinylPlayerAnimation from \"@/components/VinylPlayerAnimation/VinylPlayerAnimation\";\n\nexport default function Home() {\n  return (\n    <>\n      <VinylPlayerAnimation\n        textsPrimary={[\n          \"Fly to the moon now\",\n          \"Fly to the moon now\",\n          \"Fly to the moon now\",\n        ]}\n        textSecondary=\"Throwback Music Vol\"\n        coverImg={SampleCoverImage}\n      />\n    </>\n  );\n}\n",
      "src/app/page.module.css": "",
      "src/components/VinylPlayerAnimation/VinylPlayerAnimation.jsx": "\"use client\";\n\nimport Image from \"next/image\";\nimport { useEffect, useRef } from \"react\";\n\nimport DiskImage from \"/public/disk.png\";\n\nimport { gsap } from \"gsap\";\nimport { useGSAP } from \"@gsap/react\";\nimport { MotionPathPlugin } from \"gsap/MotionPathPlugin\";\n\ngsap.registerPlugin(MotionPathPlugin);\ngsap.registerPlugin(useGSAP);\n\nconst VinylCoverAnimation = ({ textsPrimary, textSecondary, coverImg }) => {\n  const container = useRef();\n\n  useEffect(() => {\n    document\n      .getElementById(\"def-1\")\n      .setAttribute(\"d\", document.getElementById(\"path-1\").getAttribute(\"d\"));\n\n    document\n      .getElementById(\"def-2\")\n      .setAttribute(\"d\", document.getElementById(\"path-2\").getAttribute(\"d\"));\n  }, []);\n\n  useGSAP(\n    () => {\n      const animateText = (selector, delay) => {\n        gsap.to(selector, {\n          attr: { startOffset: \"100%\" },\n          ease: \"linear\",\n          duration: 6,\n          repeat: -1,\n          delay: delay,\n        });\n      };\n\n      animateText(\"#Text1\", 0);\n      animateText(\"#Text2\", 2);\n      animateText(\"#Text3\", 4);\n\n      gsap.to(\".disk\", {\n        rotate: 360,\n        duration: 2,\n        repeat: -1,\n        ease: \"linear\",\n      });\n    },\n    { scope: container }\n  );\n\n  return (\n    <div className=\"container\" ref={container}>\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        viewBox=\"0 0 350 350\"\n        width=\"800px\"\n        height=\"600px\"\n        id=\"text-primary\"\n      >\n        <defs>\n          <path id=\"def-1\" />\n        </defs>\n        <path\n          id=\"path-1\"\n          d=\"M -393 405 C -53 405 -73 5 177 5 C 427 5 407 405 747 405\"\n        />\n        <text>\n          {textsPrimary.map((text, index) => (\n            <textPath\n              key={index}\n              id={`Text${index + 1}`}\n              xlinkHref=\"#def-1\"\n              startOffset=\"-25%\"\n            >\n              {text}\n            </textPath>\n          ))}\n        </text>\n      </svg>\n\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        width=\"600px\"\n        height=\"600px\"\n        viewBox=\"0 0 350 350\"\n        id=\"text-secondary\"\n      >\n        <defs>\n          <path id=\"def-2\" />\n        </defs>\n        <path\n          id=\"path-2\"\n          d=\"M -393 60 C -53 60 -70 365 180 365 C 421 352 407 60 725 56\"\n        />\n        <text x=\"50%\" y=\"50%\" dominantBaseline=\"end\" textAnchor=\"middle\">\n          <textPath id=\"Text5\" xlinkHref=\"#def-2\" startOffset=\"37%\">\n            {textSecondary}\n          </textPath>\n        </text>\n      </svg>\n\n      <div className=\"disk\">\n        <Image src={DiskImage} alt=\"disk image\" />\n        <div className=\"cover-img\">\n          <Image src={coverImg} alt=\"Album Cover\" />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default VinylCoverAnimation;\n"
    }
  },
  {
    "title": "gsap-click-reveal",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>sliding-cards-drawer-gsap</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <div class=\"site-content\">\n      <div class=\"content-wrapper\">\n        <div class=\"row\">\n          <h1>Learn to</h1>\n          <h1>Code</h1>\n        </div>\n        <div class=\"row\">\n          <h1>dope</h1>\n          <h1>web designs</h1>\n        </div>\n        <div class=\"row\">\n          <h1>using html</h1>\n          <h1>css</h1>\n        </div>\n        <div class=\"row\">\n          <h1>and</h1>\n          <h1>Javascript</h1>\n        </div>\n      </div>\n    </div>\n    <div class=\"container\">\n      <div class=\"cards\">\n        <div class=\"card\" id=\"card-1\">\n          <div class=\"card-img\">\n            <img src=\"./assets/logo-1.png\" alt=\"\" />\n          </div>\n          <div class=\"card-text\">\n            <div class=\"card-title\">Plause Studio</div>\n            <div class=\"card-info\">\n              Agency â€” Crafting for a minimal experience\n            </div>\n          </div>\n        </div>\n        <div class=\"card\" id=\"card-2\">\n          <div class=\"card-img\">\n            <img src=\"./assets/logo-2.png\" alt=\"\" />\n          </div>\n          <div class=\"card-text\">\n            <div class=\"card-title\">Awkward</div>\n            <div class=\"card-info\">Design for a better future</div>\n          </div>\n        </div>\n        <div class=\"card\" id=\"card-3\">\n          <div class=\"card-img\">\n            <img src=\"./assets/logo-3.png\" alt=\"\" />\n          </div>\n          <div class=\"card-text\">\n            <div class=\"card-title\">Syne</div>\n            <div class=\"card-info\">Showcase â€” Prove for a better website</div>\n          </div>\n        </div>\n\n        <div class=\"toggle\">\n          <button>Show less</button>\n        </div>\n      </div>\n    </div>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js\"></script>\n    <script>\n      const card3 = document.querySelector(\"#card-3\");\n      const toggleButton = document.querySelector(\".toggle button\");\n      const cards = document.querySelectorAll(\".card\");\n      const toggleDiv = document.querySelector(\".toggle\");\n      const siteContent = document.querySelector(\".site-content\");\n\n      let isCardsOpen = false;\n\n      card3.addEventListener(\"click\", () => {\n        if (!isCardsOpen) {\n          gsap.to(cards, { top: \"0px\", duration: 1, ease: \"power4.inOut\" });\n\n          gsap.to(toggleDiv, {\n            delay: 0.4,\n            display: \"flex\",\n            opacity: 1,\n            duration: 0.4,\n            ease: \"power4.inOut\",\n          });\n\n          gsap.to(siteContent, {\n            filter: \"blur(20px)\",\n            duration: 0.75,\n            ease: \"power4.inOut\",\n          });\n\n          isCardsOpen = true;\n        }\n      });\n\n      toggleButton.addEventListener(\"click\", () => {\n        if (isCardsOpen) {\n          gsap.to(\"#card-1\", { top: \"0px\", duration: 1, ease: \"power4.inOut\" });\n\n          gsap.to(\"#card-2\", {\n            top: \"-100px\",\n            duration: 1,\n            ease: \"power4.inOut\",\n          });\n\n          gsap.to(\"#card-3\", {\n            top: \"-200px\",\n            duration: 1,\n            ease: \"power4.inOut\",\n          });\n\n          gsap.to(toggleDiv, {\n            delay: 0,\n            display: \"none\",\n            opacity: 0,\n            duration: 0.4,\n            ease: \"power4.inOut\",\n          });\n\n          gsap.to(siteContent, {\n            filter: \"blur(0px)\",\n            duration: 1,\n            ease: \"power4.inOut\",\n          });\n\n          isCardsOpen = false;\n        }\n      });\n    </script>\n  </body>\n</html>\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  width: 100vw;\n  height: 100vh;\n  background: #000;\n  color: #fff;\n  font-family: \"FK Display Trial\";\n}\n\n.site-content {\n  position: absolute;\n  width: 100vw;\n  min-height: 100vh;\n}\n\n.content-wrapper {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.row {\n  display: flex;\n  justify-content: space-between;\n}\n\nh1 {\n  font-family: \"Notch Grotesk\";\n  font-size: 4rem;\n  font-weight: lighter;\n  text-transform: uppercase;\n}\n\n.cards {\n  position: fixed;\n  top: 0;\n  right: 0;\n  width: max-content;\n  height: max-content;\n}\n\n.card {\n  position: relative;\n  width: 300px;\n  height: 100px;\n  display: flex;\n  align-items: flex-start;\n  margin: 1em;\n  padding: 15px;\n  font-size: 13px;\n  color: #fff;\n  background-color: rgba(255, 255, 255, 0.1);\n  backdrop-filter: blur(16px);\n  border-radius: 8px;\n  transition: background-color 0.5s, color 0.5s;\n  cursor: pointer;\n}\n\n.card-img {\n  width: 70px;\n  min-width: 70px;\n  height: 70px;\n  border-radius: 6px;\n  overflow: hidden;\n}\n\n.card-img img {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n  display: inline-block;\n}\n\n.card-text {\n  width: 100%;\n  margin-left: 16px;\n}\n\n.card-title {\n  margin: 4px 0;\n}\n\n.card-info {\n  color: #8f8f8e;\n}\n\n.toggle {\n  position: relative;\n  justify-content: flex-end;\n  display: none;\n}\n\n.toggle button {\n  border: none;\n  outline: none;\n  background: #2a2a2a;\n  color: #fff;\n  margin: 0 1em;\n  padding: 10px 16px;\n  border-radius: 20px;\n  transition: background-color 0.3s, color 0.3s;\n  cursor: pointer;\n}\n\nbutton:hover {\n  background: #fff;\n  color: #2a2a2a;\n}\n\n#card-1 {\n  top: 0;\n}\n\n#card-2 {\n  top: -100px;\n}\n\n#card-3 {\n  top: -200px;\n}\n"
    }
  },
  {
    "title": "Particles Background with Full-Page Scroll Navigation",
    "description": "Full-screen particles.js backdrop paired with vertical section scroll, dot navigation, magnetic hover elements and staggered reveal animations. Built with Tailwind classes, suited for immersive landing pages, portfolios or presentations.",
    "code": "<div id=\"particles-js\" class=\"absolute inset-0 -z-10\">\n  <script src=\"https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js\"></script>\n  <script>\n    document.addEventListener('DOMContentLoaded', () => {\n        // Initialize ParticlesJS\n        particlesJS('particles-js', {\n            particles: {\n                number: { value: 80, density: { enable: true, value_area: 800 } },\n                color: { value: \"#ffffff\" },\n                shape: { type: \"circle\" },\n                opacity: { value: 0.5, random: false },\n                size: { value: 3, random: true },\n                line_linked: { enable: true, distance: 150, color: \"#ffffff\", opacity: 0.4, width: 1 },\n                move: { enable: true, speed: 6, direction: \"none\", random: false, straight: false, out_mode: \"out\", bounce: false }\n            },\n            interactivity: {\n                detect_on: \"canvas\",\n                events: { onhover: { enable: true, mode: \"repulse\" }, onclick: { enable: true, mode: \"push\" }, resize: true },\n                modes: { grab: { distance: 400, line_linked: { opacity: 1 } }, bubble: { distance: 400, size: 40, duration: 2, opacity: 8, speed: 3 }, repulse: { distance: 200, duration: 0.4 }, push: { particles_nb: 4 }, remove: { particles_nb: 2 } }\n            },\n            retina_detect: true\n        });\n\n        const sections = document.querySelectorAll('.section');\n        const dots = document.querySelectorAll('.progress-dot');\n        const magneticElements = document.querySelectorAll('.magnetic');\n        let currentIndex = 0;\n        let isScrolling = false;\n        let touchStartY = 0;\n        \n        // Initialize\n        updateActiveDot(currentIndex);\n        \n        // Magnetic effect\n        magneticElements.forEach(el => {\n            el.addEventListener('mousemove', (e) => {\n                const rect = el.getBoundingClientRect();\n                const x = e.clientX - rect.left - rect.width / 2;\n                const y = e.clientY - rect.top - rect.height / 2;\n                el.style.transform = `translate(${x * 0.1}px, ${y * 0.1}px)`;\n            });\n            \n            el.addEventListener('mouseleave', () => {\n                el.style.transform = 'translate(0px, 0px)';\n            });\n        });\n        \n        // Scroll event\n        window.addEventListener('wheel', (e) => {\n            if (isScrolling) return;\n            \n            isScrolling = true;\n            if (e.deltaY > 0) {\n                if (currentIndex < sections.length - 1) {\n                    currentIndex++;\n                    changeSection(currentIndex);\n                }\n            } else {\n                if (currentIndex > 0) {\n                    currentIndex--;\n                    changeSection(currentIndex);\n                }\n            }\n            \n            setTimeout(() => {\n                isScrolling = false;\n            }, 1200);\n        });\n        \n        // Touch events\n        document.addEventListener('touchstart', (e) => {\n            touchStartY = e.touches[0].clientY;\n        });\n        \n        document.addEventListener('touchend', (e) => {\n            if (isScrolling) return;\n            \n            const touchEndY = e.changedTouches[0].clientY;\n            const diff = touchStartY - touchEndY;\n            \n            isScrolling = true;\n            if (diff > 50) {\n                if (currentIndex < sections.length - 1) {\n                    currentIndex++;\n                    changeSection(currentIndex);\n                }\n            } else if (diff < -50) {\n                if (currentIndex > 0) {\n                    currentIndex--;\n                    changeSection(currentIndex);\n                }\n            }\n            \n            setTimeout(() => {\n                isScrolling = false;\n            }, 1200);\n        });\n        \n        // Click on dots\n        dots.forEach(dot => {\n            dot.addEventListener('click', () => {\n                const index = parseInt(dot.getAttribute('data-index'));\n                currentIndex = index;\n                changeSection(currentIndex);\n            });\n        });\n        \n        function changeSection(index) {\n            sections.forEach(section => {\n                section.classList.remove('active');\n            });\n            \n            sections[index].classList.add('active');\n            updateActiveDot(index);\n            \n            const reveals = sections[index].querySelectorAll('.reveal');\n            reveals.forEach((el, i) => {\n                setTimeout(() => {\n                    el.classList.add('active');\n                }, i * 150);\n            });\n            \n            sections.forEach((section, i) => {\n                if (i !== index) {\n                    const otherReveals = section.querySelectorAll('.reveal');\n                    otherReveals.forEach(el => {\n                        el.classList.remove('active');\n                    });\n                }\n            });\n        }\n        \n        function updateActiveDot(index) {\n            dots.forEach(dot => {\n                dot.classList.remove('active');\n            });\n            dots[index].classList.add('active');\n        }\n    });\n</script>\n</div>",
    "id": "particles-background-with-full-page-scroll-navigation"
  },
  {
    "title": "emoji-rain-effect",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js\">script>\n\nStep 1: Add HTML\n\n<div data-emoji-rain-container class=\"emoji-rain-container\">\n  <div class=\"single-rain-emoji hidden\">\n    <div class=\"single-rain-emoji-image-fire\">div>\n    <div class=\"single-rain-emoji-image-love\">div>\n    <div class=\"single-rain-emoji-image-shame\">div>\n    <div class=\"single-rain-emoji-image-thumbs-down\">div>\n  div>\ndiv>\n<div class=\"btn-wrap\">\n  <div data-hover data-emoji-rain-type-1=\"fire\" data-emoji-rain-type-2=\"love\" class=\"emoji-rain-btn\"><span>Emoji Rain Fire & Lovespan>div>\n  <div data-hover data-emoji-rain-type-1=\"thumbs-down\" data-emoji-rain-type-2=\"shame\" class=\"emoji-rain-btn\"><span>Thumbs Down & Shamespan>div>\ndiv>\n\nStep 2: Add CSS\n\n.emoji-rain-container {\n  z-index: 150;\n  pointer-events: none;\n  -webkit-user-select: none;\n  user-select: none;\n  position: fixed;\n  inset: 0%;\n  overflow: hidden;\n}\n\n.single-rain-emoji {\n  will-change: transform;\n  width: max(200px, 15vw);\n  position: absolute;\n}\n\n.single-rain-emoji.hidden {\n  opacity: 0;\n}\n\n.single-rain-emoji-image-fire {\n  background-image: url('../images/icon-3d-fire.png');\n  background-position: 50%;\n  background-size: cover;\n  width: 100%;\n  padding-top: 100%;\n}\n\n.single-rain-emoji-image-love {\n  background-image: url('../images/icon-3d-love.png');\n  background-position: 50%;\n  background-size: cover;\n  width: 100%;\n  padding-top: 100%;\n}\n\n.single-rain-emoji-image-shame {\n  background-image: url('../images/icon-3d-shame.png');\n  background-position: 50%;\n  background-size: cover;\n  width: 100%;\n  padding-top: 100%;\n}\n\n.single-rain-emoji-image-thumbs-down {\n  background-image: url('../images/icon-3d-thumbsup.png');\n  background-position: 50%;\n  background-size: cover;\n  width: 100%;\n  padding-top: 100%;\n  rotate: 180deg;\n}\n\n.btn-wrap {\n  grid-column-gap: 1.5em;\n  grid-row-gap: 1.5em;\n  flex-flow: column;\n  align-items: center;\n  display: flex;\n}\n\n.emoji-rain-btn {\n  grid-column-gap: .125em;\n  grid-row-gap: .125em;\n  cursor: pointer;\n  background-color: #fff;\n  border-radius: 10em;\n  align-items: center;\n  padding: .5em .75em .5em 1em;\n  font-family: PP Neue Corp Normal, Arial, sans-serif;\n  font-size: 2.5em;\n  font-weight: 700;\n  transition-property: all;\n  transition-duration: .3s;\n  transition-timing-function: cubic-bezier(.45, .422, .269, 1.702);\n  display: flex;\n  transform: scale(1)rotate(.001deg);\n}\n\n.emoji-rain-btn:hover {\n  transform: scale(1.05)rotate(.001deg);\n}\n\nStep 2: Add custom Javascript\n\nlet emojiAnimationRunning = false;\n\nfunction initEmojiRain(emojiTypes, emojiContainer) {\n  if (emojiAnimationRunning) return;\n\n  emojiAnimationRunning = true;\n\n  const emojiContainerHeight = emojiContainer.offsetHeight;\n  const emojiQuantity = 60;\n\n  const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n  const createEmojiElement = () => {\n    const emojiScale = Math.random() * 0.6 + 0.4;\n    const emojiRotate = getRandomInt(1, 5);\n    const emojiDelay = 0.001 * getRandomInt(0, 1250);\n    const emojiSpeed = getRandomInt(500, 1500) * 0.001;\n    const emojiPosition = `${getRandomInt(0, 10)}0%`;\n    const emojiClass = `single-rain-emoji-image-${emojiTypes[Math.floor(Math.random() * emojiTypes.length)]}`;\n\n    const singleEmoji = document.createElement(\"div\");\n    singleEmoji.className = \"single-rain-emoji append\";\n    singleEmoji.style.left = emojiPosition;\n\n    const singleEmojiChild = document.createElement(\"div\");\n    singleEmojiChild.className = emojiClass;\n    singleEmoji.appendChild(singleEmojiChild);\n\n    gsap.fromTo(\n      singleEmoji,\n      { y: emojiContainerHeight, xPercent: -50, rotate: 0.001, scale: emojiScale },\n      { y: \"-100%\", xPercent: -50, rotate: 0.001, delay: emojiDelay, ease: \"Power1.easeIn\", duration: emojiSpeed }\n    );\n\n    gsap.fromTo(\n      singleEmojiChild,\n      { xPercent: -25, rotate: emojiRotate },\n      { xPercent: 25, rotate: -emojiRotate, ease: \"Power1.easeInOut\", delay: emojiDelay, duration: 0.8, repeat: -1, yoyo: true }\n    );\n\n    emojiContainer.appendChild(singleEmoji);\n  };\n\n  Array.from({ length: emojiQuantity }).forEach(createEmojiElement);\n\n  setTimeout(() => {\n    emojiContainer.querySelectorAll(\".single-rain-emoji.append\").forEach(el => el.remove());\n    emojiAnimationRunning = false;\n  }, 2750);\n}\n\nfunction initEmojiRainActions() {\n  document.querySelectorAll(\"[data-emoji-rain-type-1]\").forEach(trigger => {\n    trigger.addEventListener(\"click\", () => {\n      const type1 = trigger.getAttribute(\"data-emoji-rain-type-1\");\n      const type2 = trigger.getAttribute(\"data-emoji-rain-type-2\") || type1;\n      const emojiContainer = document.querySelector(\"[data-emoji-rain-container]\");\n\n      if (!emojiContainer) {\n        console.warn(\"No emoji rain container found with [data-emoji-rain-container]\");\n        return;\n      }\n\n      initEmojiRain([type1, type2], emojiContainer);\n    });\n  });\n}\n\n// Initialize Emoji Rain Effect\ndocument.addEventListener('DOMContentLoaded', () => {\n  initEmojiRainActions();\n});\n\nImplementation\n\nPlacement of the resource\nPut the .emoji-rain-container outside the \n right below the opening of the \n\nAdding other emoji's or images\nAdd new children to the .single-rain-emoji with the .hidden combo-class. Keep in mind the class of these children will be used to target the effect. Example: .single-rain-emoji-image-thumbs-down is targeted by 'thumbs-down'",
    "id": "emoji-rain-effect"
  },
  {
    "title": "CRT-like effect with VFX-JS",
    "description": "",
    "code": "index.html: <section> <h1>The reality,</h1> <img src=\"https://picsum.photos/id/737/800/600\"/> <p> Obviously, this is just a test text â€” but how do you know? There is certainly a writer of this text, someone who exists. Even if it was automatically generated by some tool or AI, there must have been a text, somewhere, used as training material. So we cannot escape the spirit â€” the vibe â€” the shadow it casts. It comes from the soul, buried deep in unconscious limbo. </p> </section> <section> <div class=\"right\"> <h1>...is always,</h1> </div> <div class=\"col\"> <img src=\"https://picsum.photos/id/100/800/600\"/> <p> Somewhere between the folds, something breathes. Not a presence, but the memory of having been watched. Syntax curls back on itself, a serpent swallowing not its tail, but its own shadow. Read again. You missed it the first time. You always do. </p> </div> <div class=\"col\"> <p> And if the soul remains, so too does its intent â€” not always clear, not always benevolent. What was the writer thinking? Or worse â€” what was it trying not to think? Language is a veil, but veils are thin when backlit by desire, or fear, or guilt. Read carefully. Something watches back when you stare too long into a sentence. </p> <img src=\"https://picsum.photos/id/102/800/600\"/> </div> </section> <section class=\"last\"> <img src=\"https://picsum.photos/id/972/800/600\"/> <h2 data-z=\"1\">...distorted.</h2> </section>\nstyle.css: html, body { margin: 0; } body { background: black; overflow-x: hidden; } section { margin: 40vh 20%; width: 60%; color: white; } .col { display: flex; flex-direction: row; gap: 1em; margin: 2em 0; } .right { text-align: right; } .center { text-align: center; } .last { margin-bottom: 0; display: grid; place-items: center; } .last > * { grid-area: 1 / 1; } .last h2 { color: black; } h1 { font-size: 8vh; margin: 0; opacity: 0; } h2 { font-size: 6vh; margin: 47vh 0; opacity: 0; } p { font-size: 3vh; margin: 0; opacity: 0; } img { opacity: 0; margin: 2em 0; width: 100%; } .col > img { max-width: 40%; margin: 0; }\nscript.js: // Made with VFX-JS // https://amagi.dev/vfx-js/ import { VFX } from \"https://esm.sh/@vfx-js/core@0.8.0\"; const shader = ` precision highp float; uniform sampler2D src; uniform vec2 offset; uniform vec2 resolution; uniform float time; out vec4 outColor; vec4 readTex(vec2 uv) { vec4 c = texture(src, uv); c.a *= smoothstep(.5, .499, abs(uv.x - .5)) * smoothstep(.5, .499, abs(uv.y - .5)); // smooth edge return c; } vec2 zoom(vec2 uv, float t) { return (uv - .5) * t + .5; } float wave(float y) { return sin(y * 1190. + time * 3.) * sin(y * 1001. + time * 7.) * sin(y * 1479. + time * .5) * 0.001; } float rand(vec3 p) { return fract(sin(dot(p, vec3(829., 4839., 432.))) * 39428.); } void main() { vec2 uv = (gl_FragCoord.xy - offset) / resolution; vec2 p = uv * 2. - 1.; p.x *= resolution.x / resolution.y; float l = length(p); // distort float dist = pow(l, 2.) * .3; dist = smoothstep(0., 1., dist); uv = zoom(uv, 0.5 + dist); // blur vec2 du = (uv - .5); float a = atan(p.y, p.x); float rd = rand(vec3(a, time, 0)); uv = (uv - .5) * (1.0 + rd * pow(l * 0.7, 3.) * 0.3) + .5; vec2 uvr = uv; vec2 uvg = uv; vec2 uvb = uv; // aberration float d = (1. + sin(uv.y * 20. + time * 3.) * 0.1) * 0.05; uvr.x += 0.0015; uvb.x -= 0.0015; uvr = zoom(uvr, 1. + d * l * l); uvb = zoom(uvb, 1. - d * l * l); vec4 cr = readTex(uvr); vec4 cg = readTex(uvg); vec4 cb = readTex(uvb); outColor = vec4(cr.r, cg.g, cb.b, (cr.a + cg.a + cb.a) / 1.); vec4 deco; // scanline float res = resolution.y; deco += ( sin(uv.y * res * .7 + time * 100.) * sin(uv.y * res * .3 - time * 130.) ) * 0.05; // grid deco += smoothstep(.01, .0, min(fract(uv.x * 20.), fract(uv.y * 20.))) * 0.1; outColor += deco * smoothstep(2., 0., l); // vignette outColor *= 1.8 - l * l; // dither outColor += rand(vec3(p, time)) * 0.1; } `; const shader2 = ` precision highp float; uniform sampler2D src; uniform vec2 offset; uniform vec2 resolution; uniform float time; uniform float id; out vec4 outColor; vec4 readTex(vec2 uv) { vec4 c = texture(src, uv); c.a *= smoothstep(.5, .499, abs(uv.x - .5)) * smoothstep(.5, .499, abs(uv.y - .5)); // smooth edge return c; } float rand(vec2 p) { return fract(sin(dot(p, vec2(829., 483.))) * 394.); } float rand(vec3 p) { return fract(sin(dot(p, vec3(829., 4839., 432.))) * 39428.); } vec2 dist(vec2 uv, float f) { float t = time + id; uv += sin(uv.y * 12. + t * 1.7) * sin(uv.y * 17. + t * 2.3) * f; return uv; } void main() { vec2 uv = (gl_FragCoord.xy - offset) / resolution; vec2 uvr = uv, uvg = uv, uvb = uv; float r = rand(vec2(floor(time * 43.), id)); //float r = rand(vec2(time, id)); if (r > 0.8) { float y = sin(floor(uv.y / 0.07)) + sin(floor(uv.y / 0.003 + time)); float f = rand(vec2(y, floor(time * 5.0) + id)) * 2. - 1.; uvr.x += f * 0.1; uvg.x += f * 0.2; uvb.x += f * 0.3; } float r2 = rand(vec2(floor(time * 37.), id + 10.)); if (r2 > 0.9) { uvr.x += sin(uv.y * 7. + time + id + 1.) * 0.03; uvg.x += sin(uv.y * 5. + time + id + 2.) * 0.03; uvb.x += sin(uv.y * 3. + time + id + 3.) * 0.03; } vec4 cr = readTex(uvr); vec4 cg = readTex(uvg); vec4 cb = readTex(uvb); outColor = vec4(cr.r, cg.g, cb.b, (cr.a + cg.a + cb.a) / 1.); } `; const vfx = new VFX({ scrollPadding: false, postEffect: { shader } }); window.addEventListener('load', function () { let i = 0; for (const e of document.querySelectorAll('img,h1,h2,p')) { const z = e.getAttribute('data-z'); vfx.add(e, { // no await but it's ok shader: shader2, uniforms: { id: i++ }, zIndex: z ? parseInt(z) : 0, // overlay: true, }); } })",
    "id": "crt-like-effect-with-vfx-js"
  },
  {
    "title": "Parallax Bake Shop Card ðŸ§âœ¨",
    "description": "",
    "code": "index.html: <article> \t<div class=\"assets\"> \t\t<img src=\"http://mattcannon.games/codepen/sweet-treats/bg.webp\" alt=\"Background clouds\" /> \t\t<h3>CUPCAKES</h3> \t\t<img src=\"http://mattcannon.games/codepen/sweet-treats/cup-cake.png\" alt=\"Cupcake\" style=\"width: 200px; height: 250px;\" /> \t</div> \t<div class=\"blur\"> \t\t<div class=\"layer\" style=\"--index:1;\"></div> \t\t<div class=\"layer\" style=\"--index:2;\"></div> \t\t<div class=\"layer\" style=\"--index:3;\"></div> \t\t<div class=\"layer\" style=\"--index:4;\"></div> \t\t<div class=\"layer\" style=\"--index:5;\"></div> \t</div> \t<div class=\"content\"> <p> <i class=\"fas fa-map-marker-alt\"></i> Sweet Dreams Bakery </p> \t\t<p><i>Los Angeles, CA</i></p> \t</div> </article>\nstyle.css: :root { \t--title: \"Parallax Bake Shop Card\"; \t--author: \"Matt Cannon\"; \t--contact: \"mc@mattcannon.design\"; \t--description: \"A whimsical bake shop card with a cupcake theme, parallax effects, dreamy text, and floating background layers.\"; \t--keywords: \"cupcake animation, sweet treats, parallax effect, css animation, javascript, food theme, codepenchallenge, bakery banner, interactive header, dessert ui, creative design\"; \t--last-modified: \"2025-05-27\"; \t--content-language: \"en\"; \t--generator: \"HTML5, CSS3, JavaScript, Web Animations API\"; } *, *:after, *:before { \tbox-sizing: border-box; } :root { \t--x: 0; \t--y: 0; } html { \tcolor-scheme: light only; } body { \tdisplay: flex; \tplace-items: center; \tjustify-content: center; \tmin-height: 100svh; \ttouch-action: none; \tfont-family: \"Rubik\", sans-serif; \tmargin: 0; \tpadding: 0.5rem; \tbackground: linear-gradient(to bottom, #e68d9f, #ffffff), \t\turl(\"https://www.transparenttextures.com/patterns/asfalt-light.png\"); \tbackground-blend-mode: overlay; } article { \twidth: 600px; \taspect-ratio: 2 / 1.1; \tmax-height: calc(100svh - 2rem); \tposition: relative; \toverflow: hidden; \tborder-radius: 4em; \tmax-width: calc(100% - 2rem); \tfilter: drop-shadow(0 10px 20px rgba(0, 0, 0, 0.1)); } @media (orientation: portrait) { \tarticle { \t\tmin-height: 330px; \t} } .assets { \tposition: absolute; \tinset: 0; \tborder-radius: 4em; \toverflow: hidden; \tz-index: 0; } .assets > img { \tposition: absolute; \ttop: 0; \tleft: 50%; \ttranslate: -50% 0; \theight: 100%; \twidth: 660px; \tobject-fit: cover; \tobject-position: center 43%; \tuser-select: none; \tpointer-events: none; } .assets > img:first-of-type { \tfilter: saturate(1.5) brightness(0.9); \tobject-position: calc(50% + (var(--x) * 30px)) calc(50% + (var(--y) * -20px)); } .assets > img:last-of-type { object-position: calc(50% + (var(--x) * 40px)) calc(50% + (var(--y) * 10px)); z-index: 99; } .assets h3 { \tposition: absolute; \tleft: 50%; \ttop: 8%; \tmargin: 0; \tfont-size: 8rem; \ttext-transform: uppercase; \tfont-family: \"Bebas Neue\", sans-serif; \tcolor: white; \ttranslate: calc(-50% + (var(--x) * -30px)) calc(var(--y) * -20px); \tz-index: 4; } .content { \tmin-height: 32%; \tposition: absolute; \tbottom: 0; \twidth: 100%; \tcolor: white; \tdisplay: grid; \tgap: 0.2rem; \tplace-items: center; \talign-content: center; \tpadding-bottom: 0.5rem; \tz-index: 3; } .content svg { \twidth: 20px; } .content p { \tmargin: 0; \tdisplay: flex; \talign-items: center; \tgap: 0.5rem; \tfont-size: 1.2rem; \tposition: relative; } .content p:first-of-type::after { \tcontent: \"\"; \tposition: absolute; \tbottom: calc(100% + 1rem); \tleft: 50%; \twidth: 20ch; \tbackground: white; \theight: 1px; \ttranslate: -50% 0; } .content p:last-of-type { \topacity: 0.8; font-size: 0.8rem } .blur { \t--layers: 5; \tposition: absolute; \tinset: 0; \tz-index: 1; } .blur .layer { \t--blur: calc( \t\tsin(((var(--layers) - var(--index)) / var(--layers)) * 90deg) * 5 \t); \t--stop: calc(sin(((var(--index)) / var(--layers)) * 90deg) * 25); \tposition: absolute; \tinset: 0; \tbackground: hsl(0 0% 60% / 0.015); \tbackdrop-filter: blur(min(calc(var(--blur) * 1px), 4px)); \tmask: radial-gradient( \t\t180% 160% at 45% 90%, \t\t#fff 10%, \t\t#0000 calc((10 + var(--stop)) * 1%) \t); \tz-index: 2; }\nscript.js: // â™¡ This pen is a remix of https://codepen.io/jh3y/pen/jORQyzZ by @jh3y const UPDATE = ({ x, y }) => { \tconst xNorm = (x / window.innerWidth - 0.5) * 2; \tconst yNorm = (y / window.innerHeight - 0.5) * 2; \tdocument.documentElement.style.setProperty(\"--x\", xNorm); \tdocument.documentElement.style.setProperty(\"--y\", yNorm); }; window.addEventListener(\"mousemove\", UPDATE); const handleOrientation = ({ beta, gamma }) => { \tconst isLandscape = window.matchMedia(\"(orientation: landscape)\").matches; \tconst xVal = Math.max( \t\t-1, \t\tMath.min(1, isLandscape ? (beta || 0) / 45 : (gamma || 0) / 45) \t); \tconst yVal = Math.max( \t\t-1, \t\tMath.min(1, isLandscape ? Math.abs(gamma || 0) / 45 : (beta || 0) / 45) \t); \tdocument.documentElement.style.setProperty(\"--x\", xVal); \tdocument.documentElement.style.setProperty(\"--y\", yVal); }; const START = () => { \tif (DeviceOrientationEvent?.requestPermission) { \t\tDeviceOrientationEvent.requestPermission().then((result) => { \t\t\tif (result === \"granted\") { \t\t\t\twindow.addEventListener(\"deviceorientation\", handleOrientation); \t\t\t} \t\t}); \t} else { \t\twindow.addEventListener(\"deviceorientation\", handleOrientation); \t} }; document.body.addEventListener(\"click\", START, { once: true });",
    "id": "parallax-bake-shop-card-"
  },
  {
    "title": "Stormy Window â›ˆï¸",
    "description": "",
    "code": "index.html: \nstyle.css: \nscript.js: /* Stormy Window â›ˆï¸ by Frank Force It was a dark and stormy night... - Made for JS1024 2025 Features - background gradient - procedural mountains - moon - rain - raindrops - lightning - window panels */ 'use strict'; // js1024 shim const a = document.body.appendChild(document.createElement('canvas')); const c = a.getContext(\"2d\"); a.width = innerWidth a.height = innerHeight; document.body.style='margin:0;overflow:hidden'; // locals (remove declaration from minified) const ENHANCED = 1; let i, j, k, g, h, frame, brightness, lightningBranch, lightningBranchMax, canvasBack, contextBack, canvasMid, contextMid, canvasMid2, contextMid2, canvasMid3, contextMid3, // game stuff grayColor = (l=0, a=1)=> contextBack.fillStyle = c.fillStyle = `hsl(0,0%,${l}%,${a}`, drawBackground = ()=> { // background sky for(i=99; i--;) contextBack.fillStyle = grayColor(99-i), contextBack.fillRect(0,i/199*a.height,a.width,-a.height) // moon contextBack.fillStyle = grayColor(99,.5); contextBack.ellipse( (Math.random()*.8+.1)*a.width,99+Math.random()*199, 99,99, 0,0,9); contextBack.fill(); // mountains for(g=h=j=9; j--;) for(i=0; i<a.width; ++i) { contextBack.fillStyle = grayColor(j*3+g/19), contextBack.fillRect(i,a.height+g-(j/15+.1)*a.height,1,a.height); g += h = Math.random()<.1? (Math.random()*2-1) : h - g/1e4; } // foreground window const w = 50; c.fillStyle = grayColor(4); c.fillRect(0,a.height/2-w/2,a.width,w); c.fillRect(a.width/2-w/2,0,w,a.height); c.fillRect(0,0,w,a.height); c.fillRect(a.width,0,-w,a.height); c.fillRect(0,0,a.width,w); c.fillRect(0,a.height,a.width,-w); }, lightning = (X,Y,V,Z)=> { for(;Y<a.height;) { contextMid3.fillRect(X += V*Z, Y += 1+Z/9, Z, Z); if (Math.random()<.1) V = Math.random()-.5; if (lightningBranchMax && ++lightningBranch > 399) { --lightningBranchMax; lightningBranch=0; lightning(X,Y,V,Math.random()*Z*.8+1); } } //console.log(lightningBranchMax) }, // main game loop update = ()=> { // draw lightning canvasMid.style['mixBlendMode'] = canvasMid2.style['mixBlendMode'] = canvasMid3.style['mixBlendMode'] = 'screen'; canvasMid3.style['filter'] = \"invert(\"; contextMid3.globalCompositeOperation = 'lighter'; contextMid3.fillStyle = grayColor(2); contextMid3.fillRect(0,0,a.width,a.height); contextMid3.globalCompositeOperation = 'source-over'; if (Math.random() < .003) { lightningBranch = lightningBranchMax = 20; brightness = 95; contextMid3.fillStyle = grayColor(0,.5); lightning((Math.random()*.8+.1)*a.width, -500, 0, Math.random()*9+6); } // draw rain contextMid.fillStyle = grayColor(brightness-=2,.4); contextMid.fillRect(0,0,a.width,a.height) contextMid.rotate(-.2); contextMid.fillStyle = grayColor(99,.2); for(i=2e3; i--;) contextMid.fillRect( Math.sin(i**3)*a.width+a.width/2, (2e3+i)/2*(frame/60*(1+Math.sin(i)/4)+9)%(a.height+a.width/4), Math.sin(i)*2, 50); contextMid.rotate(.2); // draw raindrops contextMid2.fillStyle = grayColor(0,.2); contextMid2.fillRect(0,0,a.width,a.height) for(j=2;j--;) for(contextMid2.fillStyle=grayColor(30+99*j,.1),i=500;i--;) { contextMid2.beginPath(); contextMid2.ellipse( (i/500*a.width+frame/9)%a.width+Math.sin(frame/99*(i%29+9)+i), (i**3+frame*(i%29+9)/9)%a.height-j*2, g=3-j+Math.sin(i+frame/60)/2, g*(Math.sin(i+frame/60+11)+2), 0,0,9); contextMid2.fill(); } ++frame; } /////////////////////////////////////////////////////////////////////////////// // setup background canvas a.style.position = 'absolute'; a.before(canvasBack = a.cloneNode()); a.before(canvasMid = a.cloneNode()); a.before(canvasMid3 = a.cloneNode()); a.before(canvasMid2 = a.cloneNode()); contextBack = canvasBack.getContext(\"2d\"); contextMid = canvasMid.getContext(\"2d\"); contextMid3 = canvasMid3.getContext(\"2d\"); contextMid2 = canvasMid2.getContext(\"2d\"); // init drawBackground(frame = brightness = 0); /////////////////////////////////////////////////////////////////////////////// // setup if (!ENHANCED) setInterval(update, 16); // 60 fps update else { // enhanced rendering system for smoother frame rate let frameTimeLastMS = 0, frameTimeBufferMS=0, averageFPS = 0; const updateAnimation = (frameTimeMS=0)=> { requestAnimationFrame(updateAnimation); // update time keeping let frameTimeDeltaMS = frameTimeMS - frameTimeLastMS; frameTimeLastMS = frameTimeMS; frameTimeBufferMS += frameTimeDeltaMS; frameTimeBufferMS = Math.min(frameTimeBufferMS, 50); // apply time delta smoothing, improves smoothness of framerate in some browsers let deltaSmooth = 0; if (frameTimeBufferMS < 0 && frameTimeBufferMS > -9) { // force an update each frame if time is close enough (not just a fast refresh rate) deltaSmooth = frameTimeBufferMS; frameTimeBufferMS = 0; } // update multiple frames if necessary in case of slow framerate for (;frameTimeBufferMS >= 0; frameTimeBufferMS -= 1e3 / 60) update(); // add the time smoothing back in frameTimeBufferMS += deltaSmooth; contextMid.fillStyle = grayColor(99); contextMid.font = '5em monospace'; if (frameTimeDeltaMS) averageFPS = .9 * averageFPS + .1 * (1000 / frameTimeDeltaMS); //contextMid.fillText(averageFPS|0, 99, 99); // show fps } onresize = e=> { // resize canvas a.width = canvasBack.width = canvasMid.width = canvasMid2.width = canvasMid3.width = innerWidth; a.height = canvasBack.height = canvasMid.height = canvasMid2.height = canvasMid3.height = innerHeight; // redraw background drawBackground(); } // startup updateAnimation(); }",
    "id": "stormy-window-"
  },
  {
    "title": "cg-asset-orb-js",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Asset ORB | mukta</title>\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n  </head>\n  <body>\n    <div class=\"container\"></div>\n    <nav>\n      <h1>Orb</h1>\n    </nav>\n    <footer>\n      <p>[ Archive beyond reality ]</p>\n    </footer>\n    <script type=\"module\" src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "package.json": "{\n  \"name\": \"cg-asset-orb-js\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"three\": \"0.158.0\",\n    \"vite\": \"^6.1.1\"\n  }\n}\n",
      "script.js": "import * as THREE from \"three\";\nimport { OrbitControls } from \"three/addons/controls/OrbitControls.js\";\n\nconst totalImages = 30;\nconst totalItems = 100;\nconst baseWidth = 1;\nconst baseHeight = 0.6;\nconst sphereRadius = 5;\nconst backgroundColor = \"000000\";\n\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(\n  75,\n  window.innerWidth / window.innerHeight,\n  0.1,\n  1000\n);\n\nconst renderer = new THREE.WebGLRenderer({\n  antialias: true,\n  alpha: true,\n  preserveDrawingBuffer: true,\n  powerPreference: \"high-performance\",\n});\n\nrenderer.setSize(window.innerWidth, window.innerHeight);\nrenderer.setClearColor(parseInt(backgroundColor, 16));\nrenderer.setPixelRatio(window.devicePixelRatio);\nrenderer.outputEncoding = THREE.LinearEncoding;\nrenderer.gammaFactor = 2.2;\ndocument.querySelector(\".container\").appendChild(renderer.domElement);\n\nconst controls = new OrbitControls(camera, renderer.domElement);\ncontrols.enableDamping = true;\ncontrols.dampingFactor = 0.05;\ncontrols.rotateSpeed = 1.2;\ncontrols.minDistance = 6;\ncontrols.maxDistance = 10;\ncontrols.enableSmoothing = true;\ncontrols.smoothingFactor = 0.1;\ncontrols.enableZoom = true;\ncontrols.zoomDampingFactor = 0.2;\ncontrols.enablePan = false;\n\nconst textureLoader = new THREE.TextureLoader();\nlet loadedCount = 0;\n\nconst getRandomImagePath = () => {\n  const imageNumber = Math.floor(Math.random() * totalImages) + 1;\n  return `./assets/img${imageNumber}.jpeg`;\n};\n\nconst createImagePlane = (texture) => {\n  const imageAspect = texture.image.width / texture.image.height;\n  let width = baseWidth;\n  let height = baseHeight;\n\n  if (imageAspect > 1) {\n    height = width / imageAspect;\n  } else {\n    width = height * imageAspect;\n  }\n\n  return new THREE.PlaneGeometry(width, height);\n};\n\nconst loadImageMesh = (phi, theta) => {\n  textureLoader.load(\n    getRandomImagePath(),\n    (texture) => {\n      texture.generateMipmaps = false;\n      texture.minFilter = THREE.LinearFilter;\n      texture.magFilter = THREE.LinearFilter;\n\n      const geometry = createImagePlane(texture);\n      const material = new THREE.MeshBasicMaterial({\n        map: texture,\n        side: THREE.DoubleSide,\n        transparent: false,\n        depthWrite: true,\n        depthTest: true,\n        encoding: THREE.LinearEncoding,\n      });\n\n      const mesh = new THREE.Mesh(geometry, material);\n\n      mesh.position.x = sphereRadius * Math.cos(theta) * Math.sin(phi);\n      mesh.position.y = sphereRadius * Math.sin(theta) * Math.sin(phi);\n      mesh.position.z = sphereRadius * Math.cos(phi);\n\n      mesh.lookAt(0, 0, 0);\n      mesh.rotateY(Math.PI);\n\n      scene.add(mesh);\n\n      loadedCount++;\n      if (loadedCount === totalItems) {\n        animate();\n      }\n    },\n    undefined,\n    (error) => console.error(\"Error loading texture:\", error)\n  );\n};\n\nconst createSphere = () => {\n  for (let i = 0; i < totalItems; i++) {\n    const phi = Math.acos(-1 + (2 * i) / totalItems);\n    const theta = Math.sqrt(totalItems * Math.PI) * phi;\n    loadImageMesh(phi, theta);\n  }\n};\n\ncamera.position.z = 10;\n\nconst animate = () => {\n  requestAnimationFrame(animate);\n  controls.update();\n  renderer.render(scene, camera);\n};\n\nwindow.addEventListener(\"resize\", () => {\n  const width = window.innerWidth;\n  const height = window.innerHeight;\n  renderer.setSize(width, height);\n  camera.aspect = width / height;\n  camera.updateProjectionMatrix();\n});\n\ncreateSphere();\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\n.container {\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n}\n\nnav,\nfooter {\n  position: fixed;\n  width: 100vw;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  padding: 3em;\n  z-index: 2;\n}\n\nnav {\n  top: 0;\n}\n\nfooter {\n  bottom: 0;\n}\n\nh1 {\n  text-transform: uppercase;\n  font-family: \"Gojo\";\n  font-size: 18px;\n  font-weight: 900;\n  color: #fff;\n}\n\np {\n  text-transform: uppercase;\n  font-family: \"Akkurat Mono\";\n  font-size: 11px;\n  color: #777777;\n}\n"
    }
  },
  {
    "title": "Text frame border animation rotation that [CSS & SVG] V 2",
    "description": "",
    "code": "index.html: <!-- /********************************************/ /********************************************/ /* Please â¤ this if you like it! */ /* Follow Me https://codepen.io/designfenix */ /********************************************/ /********************************************/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ --> <svg viewBox=\"0 0 200 200\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"t\"> \t<image href=\"https://images.unsplash.com/photo-1488161628813-04466f872be2?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=764&q=80\" width=\"200\" height=\"200\" preserveAspectRatio=\"xMidYMid slice\" clip-path=\"url(#blobClip)\"/> \t<clipPath id=\"blobClip\"> <path d=\"M43.1,-68.5C56.2,-58.6,67.5,-47.3,72.3,-33.9C77.2,-20.5,75.5,-4.9,74.2,11.3C72.9,27.6,71.9,44.5,63.8,57.2C55.7,69.8,40.6,78.2,25.5,79.2C10.4,80.1,-4.7,73.6,-20.9,69.6C-37.1,65.5,-54.5,63.9,-66,54.8C-77.5,45.8,-83.2,29.3,-85.7,12.3C-88.3,-4.8,-87.7,-22.3,-79.6,-34.8C-71.5,-47.3,-55.8,-54.9,-41.3,-64.2C-26.7,-73.6,-13.4,-84.7,0.8,-86C15,-87.2,29.9,-78.5,43.1,-68.5Z\" transform=\"translate(100 100)\"/> </clipPath> <path class=\"blob\" d=\"M43.1,-68.5C56.2,-58.6,67.5,-47.3,72.3,-33.9C77.2,-20.5,75.5,-4.9,74.2,11.3C72.9,27.6,71.9,44.5,63.8,57.2C55.7,69.8,40.6,78.2,25.5,79.2C10.4,80.1,-4.7,73.6,-20.9,69.6C-37.1,65.5,-54.5,63.9,-66,54.8C-77.5,45.8,-83.2,29.3,-85.7,12.3C-88.3,-4.8,-87.7,-22.3,-79.6,-34.8C-71.5,-47.3,-55.8,-54.9,-41.3,-64.2C-26.7,-73.6,-13.4,-84.7,0.8,-86C15,-87.2,29.9,-78.5,43.1,-68.5Z\" transform=\"translate(100 100)\" \t\t\t\tfill=\"url(#imgFill)\" /> <path id=\"text\" d=\"M43.1,-68.5C56.2,-58.6,67.5,-47.3,72.3,-33.9C77.2,-20.5,75.5,-4.9,74.2,11.3C72.9,27.6,71.9,44.5,63.8,57.2C55.7,69.8,40.6,78.2,25.5,79.2C10.4,80.1,-4.7,73.6,-20.9,69.6C-37.1,65.5,-54.5,63.9,-66,54.8C-77.5,45.8,-83.2,29.3,-85.7,12.3C-88.3,-4.8,-87.7,-22.3,-79.6,-34.8C-71.5,-47.3,-55.8,-54.9,-41.3,-64.2C-26.7,-73.6,-13.4,-84.7,0.8,-86C15,-87.2,29.9,-78.5,43.1,-68.5Z\" transform=\"translate(100 100)\" fill=\"none\" stroke=\"none\" pathLength=\"100\" /> <text class=\"text-content\"> <textPath href=\"#text\" startOffset=\"0%\">â¤ MADE WITH LOVE â¤ MADE WITH LOVE â¤ MADE WITH LOVE â¤ MADE WITH LOVE <animate attributeName=\"startOffset\" from=\"0%\" to=\"100%\" dur=\"15s\" repeatCount=\"indefinite\" /> </textPath> \t\t<textPath href=\"#text\" startOffset=\"100%\">â¤ MADE WITH LOVE â¤ MADE WITH LOVE â¤ MADE WITH LOVE â¤ MADE WITH LOVE <animate attributeName=\"startOffset\" from=\"-100%\" to=\"0%\" dur=\"15s\" repeatCount=\"indefinite\" /> </textPath> </text> </svg> <p id=\"dev\">Developed with <span>â¤</span> by <a href=\"https://codepen.io/designfenix/\" target=\"_blank\">Fernando Cohen</a> </p>\nstyle.css: /********************************************/ /********************************************/ /* Please â¤ this if you like it! */ /* Follow Me https://codepen.io/designfenix */ /********************************************/ /********************************************/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ body{ \tdisplay: flex; \tmin-height:100vh; \tjustify-content: center; \talign-items: center; \tbackground: radial-gradient(circle at 50% 50%, #F4C6A5 0%, #F9D9C2 10%, #FFF3E9 30%); } svg{ \tmax-width: 70vw; \tmax-height: 80vh; \taspect-ratio: 1/1; \t#blobClip{ transform-origin: center; \t\ttransition: ease-out transform .4s; \t} \t&:hover{ \t\t#blobClip{ \t\t\ttransform: scale(1.15) translate(0%, 0%); \t\t} \t\t.text-content{ \t\t\tfill: white; \t\t\tmix-blend-mode: overlay; \t\t} \t} } .text-content { \tfont: 700 10px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; \tletter-spacing: 1.5px; \ttext-transform: uppercase; \tfill: black; \tmix-blend-mode: normal; \ttransition: ease fill .5s; } /*Dev*/ @import url(\"https://fonts.googleapis.com/css?family=Montserrat:400,600,700\"); #dev { \tfont-family: \"Montserrat\", sans-serif; \tposition: fixed; \tfont-size: 14px; \ttop: 10px; \tleft: 10px; \tpadding: 1em; \tcolor: #333; \tbackground-color: white; \tborder-radius: 25px; \tcursor: pointer; \ta { \t\ttext-decoration: none; \t\tfont-weight: bold; \t\tcolor: #333; \t\ttransition: ease all 0.4s; \t\t&:hover { \t\t\tcolor: #ef5350; \t\t\ttext-decoration: underline; \t\t} \t} \tspan { \t\tdisplay: inline-block; \t\ttransition: ease all 0.4s; \t\tcolor: pink; \t\t&:hover { \t\t\ttransform: scale(1.2); \t\t} \t} }\nscript.js: /********************************************/ /********************************************/ /* Please â¤ this if you like it! */ /* Follow Me https://codepen.io/designfenix */ /********************************************/ /********************************************/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/ /**/",
    "id": "text-frame-border-animation-rotation-that-css--svg-v-2"
  },
  {
    "title": "lottie-setup",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/ScrollTrigger.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/lottie-web@5.12.2/build/player/lottie.min.js\">script>\n\nStep 1: Add HTML\n\n<div class=\"lottie-demo-card\">\n  <span class=\"lottie-demo-card__tag\">Animation #001span>\n  <div data-lottie-frame=\"10\" data-lottie data-lottie-src=\"https://mukta.b-cdn.net/resource-media/lottie-demo-piggy-1750244874581.json\" class=\"lottie-demo-card__animation\">div>\n  <h2 class=\"lottie-demo-card__heading\">Save moneyh2>\ndiv>\n\nStep 2: Add CSS\n\n.lottie-demo-card {\n  aspect-ratio: 1 / 1.25;\n  background-color: #fff;\n  border-radius: 1.5rem;\n  flex-flow: column;\n  justify-content: flex-end;\n  align-items: flex-start;\n  width: 26.5rem;\n  padding: 2rem;\n  display: flex;\n  position: relative;\n}\n\n.lottie-demo-card__heading {\n  margin: 0;\n  font-size: 2rem;\n  font-weight: 500;\n  line-height: 1.2;\n}\n\n.lottie-demo-card__animation {\n  z-index: 1;\n  position: absolute;\n  top: 2rem;\n  left: 2rem;\n  right: 2rem;\n}\n\n.lottie-demo-card__tag {\n  z-index: 2;\n  background-color: #f7e8d3;\n  border-radius: 100em;\n  padding: .5em .75em;\n  font-size: .875rem;\n  line-height: 1;\n  position: absolute;\n  top: 2rem;\n  left: 2rem;\n}\n\nStep 2: Add custom Javascript\n\ngsap.registerPlugin(ScrollTrigger);\n\nfunction initLottieAnimations() {\n  const reduceMotion = window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\n\n  document.querySelectorAll(\"[data-lottie]\").forEach(target => {\n    let anim; // Store animation reference\n\n    ScrollTrigger.create({\n      trigger: target,\n      start: \"top bottom+=50%\", // Load lottie once it's half a viewport away from entering\n      end: \"bottom top-=25%\",\n      onEnter: handleEnter,\n      onEnterBack: handleEnter,\n      onLeave: handleLeave,\n      onLeaveBack: handleLeave,\n    });\n\n    function handleEnter() {\n      // Handle first enter: create a lottie player\n      if (!target.hasAttribute(\"data-lottie-fired\")) {\n        target.setAttribute(\"data-lottie-fired\", \"true\");\n\n        anim = lottie.loadAnimation({\n          container: target,\n          renderer: \"svg\",\n          loop: true,\n          autoplay: !reduceMotion,\n          path: target.getAttribute(\"data-lottie-src\"),\n        });\n\n        // If reduced motion is ON, load the first frame as a static SVG image\n        // Add [data-lottie-frame] with the number of your desired frame if not 0\n        anim.addEventListener(\"DOMLoaded\", () => {\n          if (reduceMotion) {\n            const frame = parseInt(target.getAttribute(\"data-lottie-frame\") || \"0\", 10);\n            anim.goToAndStop(frame, true);\n          }\n        });\n      } else if (anim && !reduceMotion) {\n        // If lottie enters view again, and is already created, simply play it\n        anim.play();\n      }\n    }\n\n    function handleLeave() {\n      if (anim && !reduceMotion) {\n        anim.pause();\n      }\n    }\n  });\n}\n\n// Initialize Lottie Setup\ndocument.addEventListener(\"DOMContentLoaded\", () =>{\n  initLottieAnimations();\n});\n\nImplementation\n\nDocumentation\nThis script automatically initializes Lottie animations on any element with data-lottie and a data-lottie-src. The function makes sure that a Lottie is only initialised when a user is about to see them. Reducing initial payload, and improving your page speed. After all, if you have a Lottie in the footer of your website, there's no need to load it immediately. \n\nAccessibility\nSince Lotties can be pretty crazy and/or overwhelming and distracting, we have a built-in checker for when a user prefers 'reduced motion'. If this is the case, the function will load only the first frame of your Lottie, making it look like a static SVG! \n\nAttributes\ndata-lottie â€” required \nMarks an element as a Lottie target. This can just be an empty div with a width to it. Height will be set by the Lottie file.\n\nâ€data-lottie-src â€” required \nURL or path to the .json animation file. Add this to the same element that you gave the data-lottie attribute to. If you're curious where we host our files, checkout this YouTube video from Ilja.\n\nâ€data-lottie-frame â€” optional \nFrame number to display when reduced-motion is active (defaults to 0).\n\nPerformance\nAs an extra benefit, the function will pause an animation once it leaves the viewport. This reduces strain on your CPU/GPU to keep animating all those complex SVG animations when nobody is seeing them anyway. Once the Lottie is scrolled back into view, we simply start playing them again.\nâ€\nThese awesome Lotties in our demo were sourced from Vladislav Sholohov",
    "id": "lottie-setup"
  },
  {
    "title": "pixelated-image-reveal",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js\">script>\n\nStep 1: Add HTML\n\n<section class=\"cloneable\">\n  <div data-hover=\"\" data-pixelated-image-reveal=\"\" class=\"pixelated-image-card\">\n    <div class=\"before__100\">div>\n    <div class=\"pixelated-image-card__default\">\n      <img src=\"https://cdn.prod.website-files.com/6712ad33825977f9d2f1ba2c/6714d43a777a77da89a9b5ec_mukta-pixelated-image-1.jpg\" width=\"400\" alt=\"\" class=\"pixelated-image-card__img\">\n    div>\n    <div data-pixelated-image-reveal-active=\"\" class=\"pixelated-image-card__active\">\n      <img src=\"https://cdn.prod.website-files.com/6712ad33825977f9d2f1ba2c/6714d43a4d1abab1b3c81caf_mukta-pixelated-image-2.jpg\" width=\"400\" alt=\"\" class=\"pixelated-image-card__img\">\n    div>\n    <div data-pixelated-image-reveal-grid=\"\" class=\"pixelated-image-card__pixels\">\n      <div class=\"pixelated-image-card__pixel\">div>\n    div>\n  div>\nsection>\n\nStep 2: Add CSS\n\n.cloneable {\n  padding: var(--container-padding);\n  justify-content: center;\n  align-items: center;\n  min-height: 100svh;\n  display: flex;\n  position: relative;\n}\n\n.pixelated-image-card {\n  background-color: var(--color-neutral-800);\n  color: var(--color-primary);\n  border-radius: .5em;\n  width: 30vw;\n  max-width: 100%;\n  position: relative;\n  overflow: hidden;\n}\n\n.before__100 {\n  padding-top: 100%;\n}\n\n.pixelated-image-card__default, \n.pixelated-image-card__img,\n.pixelated-image-card__active, \n.pixelated-image-card__pixels{\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n.pixelated-image-card__active {\n  display: none;\n}\n\n.pixelated-image-card__pixel {\n  background-color: currentColor;\n  width: 100%;\n  height: 100%;\n  display: none;\n  position: absolute;\n}\n\nStep 2: Add custom Javascript\n\nfunction initPixelatedImageReveal() {  \n  const animationStepDuration = 0.3;\n  const gridSize = 7; \n  const pixelSize = 100 / gridSize; \n  const cards = document.querySelectorAll('[data-pixelated-image-reveal]');\n  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || window.matchMedia(\"(pointer: coarse)\").matches;\n\n  cards.forEach((card) => {\n    const pixelGrid = card.querySelector('[data-pixelated-image-reveal-grid]');\n    const activeCard = card.querySelector('[data-pixelated-image-reveal-active]');\n    const existingPixels = pixelGrid.querySelectorAll('.pixelated-image-card__pixel');\n    existingPixels.forEach(pixel => pixel.remove());\n    \n    for (let row = 0; row < gridSize; row++) {\n      for (let col = 0; col < gridSize; col++) {\n        const pixel = document.createElement('div');\n        pixel.classList.add('pixelated-image-card__pixel');\n        pixel.style.width = `${pixelSize}%`;\n        pixel.style.height = `${pixelSize}%`;\n        pixel.style.left = `${col * pixelSize}%`;\n        pixel.style.top = `${row * pixelSize}%`;\n        pixelGrid.appendChild(pixel);\n      }\n    }\n\n    const pixels = pixelGrid.querySelectorAll('.pixelated-image-card__pixel');\n    const totalPixels = pixels.length;\n    const staggerDuration = animationStepDuration / totalPixels;\n    let isActive = false;\n    let delayedCall;\n\n    const animatePixels = (activate) => {\n      isActive = activate;\n      gsap.killTweensOf(pixels);\n      if (delayedCall) delayedCall.kill();\n      gsap.set(pixels, { display: 'none' });\n      \n      gsap.to(pixels, {\n        display: 'block',\n        duration: 0,\n        stagger: { each: staggerDuration, from: 'random' }\n      });\n\n      delayedCall = gsap.delayedCall(animationStepDuration, () => {\n        activeCard.style.display = activate ? 'block' : 'none';\n        activeCard.style.pointerEvents = activate ? 'none' : '';\n      });\n\n      gsap.to(pixels, {\n        display: 'none',\n        duration: 0,\n        delay: animationStepDuration,\n        stagger: { each: staggerDuration, from: 'random' }\n      });\n    };\n\n    if (isTouchDevice) {\n      card.addEventListener('click', () => animatePixels(!isActive));\n    } else {\n      card.addEventListener('mouseenter', () => {\n        if (!isActive) animatePixels(true);\n      });\n      card.addEventListener('mouseleave', () => {\n        if (isActive) animatePixels(false);\n      });\n    }\n  });\n}\n\n// Initialize Pixelated Image Reveal\ndocument.addEventListener('DOMContentLoaded', () => {\n  initPixelatedImageReveal();\n});\n\nImplementation\n\nCustomization Options\n\nDuration\nIn the Javascript adjust animationStepDuration = 0.3; to make the pixel reveal faster or slower.\n\nPixel size\nChange the gridSize = 7; value to increase or decrease the number of pixels in the grid.",
    "id": "pixelated-image-reveal"
  },
  {
    "title": "cg-physics-anim",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Interactive Divs with Physics | @mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <div class=\"header\">\n      <h1>mukta</h1>\n    </div>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js\"></script>\n    <script>\n      const Engine = Matter.Engine;\n      const World = Matter.World;\n      const Bodies = Matter.Bodies;\n      const Body = Matter.Body;\n\n      let engine;\n      let items = [];\n      let lastMouseX = -1;\n      let lastMouseY = -1;\n\n      function setup() {\n        createCanvas(window.innerWidth, window.innerHeight);\n        engine = Engine.create();\n        engine.world.gravity.y = 0;\n\n        addBoundaries();\n\n        for (let i = 0; i < 12; i++) {\n          let x = random(100, width - 100);\n          let y = random(100, height - 100);\n          items.push(new Item(x, y, `./assets/img${i + 1}.jpg`));\n        }\n      }\n\n      function addBoundaries() {\n        const thickness = 50;\n        World.add(engine.world, [\n          Bodies.rectangle(width / 2, -thickness / 2, width, thickness, {\n            isStatic: true,\n          }),\n          Bodies.rectangle(\n            width / 2,\n            height + thickness / 2,\n            width,\n            thickness,\n            {\n              isStatic: true,\n            }\n          ),\n          Bodies.rectangle(-thickness / 2, height / 2, thickness, height, {\n            isStatic: true,\n          }),\n          Bodies.rectangle(\n            width + thickness / 2,\n            height / 2,\n            thickness,\n            height,\n            {\n              isStatic: true,\n            }\n          ),\n        ]);\n      }\n\n      function draw() {\n        background(\"black\");\n        Engine.update(engine);\n        items.forEach((item) => item.update());\n      }\n\n      class Item {\n        constructor(x, y, imagePath) {\n          let options = {\n            frictionAir: 0.075,\n            restitution: 0.25,\n            density: 0.002,\n            angle: Math.random() * Math.PI * 2,\n          };\n\n          this.body = Bodies.rectangle(x, y, 100, 200, options);\n          World.add(engine.world, this.body);\n\n          this.div = document.createElement(\"div\");\n          this.div.className = \"item\";\n          this.div.style.left = `${this.body.position.x - 50}px`;\n          this.div.style.top = `${this.body.position.y - 100}px`;\n          const img = document.createElement(\"img\");\n          img.src = imagePath;\n          this.div.appendChild(img);\n          document.body.appendChild(this.div);\n        }\n\n        update() {\n          this.div.style.left = `${this.body.position.x - 50}px`;\n          this.div.style.top = `${this.body.position.y - 100}px`;\n          this.div.style.transform = `rotate(${this.body.angle}rad)`;\n        }\n      }\n\n      function mouseMoved() {\n        if (dist(mouseX, mouseY, lastMouseX, lastMouseY) > 10) {\n          lastMouseX = mouseX;\n          lastMouseY - mouseY;\n\n          items.forEach((item) => {\n            if (\n              dist(mouseX, mouseY, item.body.position.x, item.body.position.y) <\n              150\n            ) {\n              let forceMagnitude = 3;\n              Body.applyForce(\n                item.body,\n                {\n                  x: item.body.position.x,\n                  y: item.body.position.y,\n                },\n                {\n                  x: random(-forceMagnitude, forceMagnitude),\n                  y: random(-forceMagnitude, forceMagnitude),\n                }\n              );\n            }\n          });\n        }\n      }\n    </script>\n  </body>\n</html>\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n  background: #000;\n}\n\n.header {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.header h1 {\n  font-family: \"Circular Std\", sans-serif;\n  font-size: 12vw;\n  font-weight: 500;\n  letter-spacing: -0.05em;\n  line-height: 175%;\n  color: #fff;\n  text-align: center;\n}\n\n.item {\n  position: absolute;\n  padding: 0.5em 0.5em 4em 0.5em;\n  width: 200px;\n  height: 225px;\n  overflow: hidden;\n  background: #fff;\n}\n\n.item img {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n  filter: grayscale(100%);\n}\n"
    }
  },
  {
    "title": "Frosted Glass Preview",
    "description": "",
    "code": "index.html: <article class=\"cards\"> <div class=\"previewCard\"> <img src=\"https://cards.scryfall.io/art_crop/front/a/b/abdd053f-87ea-4cc8-b3df-a0c69c798d57.jpg?1678736299\" class=\"backdrop\" /> <div class='content'> <div class=\"category\">Instant</div> <div class=\"title\">Soul Shatter</div> <div class=\"description\"> <p>Each opponent sacrifices a creature or planeswalker with the greatest mana value among creatures and planeswalkers they control.</p> <span><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\" fill=\"#e3e3e3\"><path d=\"M504-480 348-636q-11-11-11-28t11-28q11-11 28-11t28 11l184 184q6 6 8.5 13t2.5 15q0 8-2.5 15t-8.5 13L404-268q-11 11-28 11t-28-11q-11-11-11-28t11-28l156-156Z\"/></svg></span> </div> </div> </div> <div class=\"previewCard\"> <img src=\"https://cards.scryfall.io/art_crop/front/2/b/2b85a552-2119-4d9c-b7c1-c09c2d9f2f38.jpg?1594736130\" class=\"backdrop\" /> <div class='content'> <div class=\"category\">Instant</div> <div class=\"title\">Finishing Blow</div> <div class=\"description\"> <p>Destroy target creature or planeswalker.</p> <span><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\" fill=\"#e3e3e3\"><path d=\"M504-480 348-636q-11-11-11-28t11-28q11-11 28-11t28 11l184 184q6 6 8.5 13t2.5 15q0 8-2.5 15t-8.5 13L404-268q-11 11-28 11t-28-11q-11-11-11-28t11-28l156-156Z\"/></svg></span> </div> </div> </div> </div> <div class=\"previewCard\"> <img src=\"https://cards.scryfall.io/art_crop/front/b/b/bbd5c86a-0991-4322-a0a2-48424c4be2af.jpg?1721427902\" class=\"backdrop\" /> <div class='content'> <div class=\"category\">Creature</div> <div class=\"title\">Essence Channeler</div> <div class=\"description\"> <p>As long as youâ€™ve lost life this turn, this creature has flying and vigilance.</p> <span><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 -960 960 960\" fill=\"#e3e3e3\"><path d=\"M504-480 348-636q-11-11-11-28t11-28q11-11 28-11t28 11l184 184q6 6 8.5 13t2.5 15q0 8-2.5 15t-8.5 13L404-268q-11 11-28 11t-28-11q-11-11-11-28t11-28l156-156Z\"/></svg></span> </div> </div> </div> </div> </article>\nstyle.css: html, body { font-size: 62.5%; } body { min-height: 100vh; background: #000; color: #fff; display: grid; place-items: center; } .cards { display: grid; grid-template-columns: repeat(3, 1fr); gap: 3rem; } .previewCard { --gutter: 1.5rem; --brightness: 0.85; --saturation: 1.5; --frostRadius: 1.5rem; padding: var(--gutter); border-radius: var(--gutter); aspect-ratio: 4 / 3; width: 100%; max-width: 32rem; display: grid; justify-content: start; align-content: end; position: relative; background: #333; overflow: hidden; cursor: pointer; transition: transform 250ms ease-in-out; img { transition: transform 500ms ease-in-out; } svg { transition: transform 250ms ease-in-out; } &:hover { transform: scale(1.05); img { transform: scale(1.1); } svg { transform: scale(1.5); } } &:after { content: \"\"; position: absolute; inset: -0.5rem; z-index: 1; pointer-events: none; backdrop-filter: blur(var(--frostRadius)) saturate(var(--saturation)) brightness(var(--brightness)); background: linear-gradient( to bottom, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.2) 100% ); mask-image: linear-gradient( to bottom, transparent 0%, rgba(0, 0, 0, 0.1) 40%, rgba(0, 0, 0, 0.5) 55%, black 75% ); } } .backdrop { position: absolute; object-fit: cover; pointer-events: none; user-select: none; width: 100%; height: 100%; } .content { position: relative; z-index: 2; display: grid; bottom: 0; justify-content: start; align-content: end; gap: 0.5rem; } .title { font-size: 1.7rem; } .category { text-transform: uppercase; font-weight: 600; letter-spacing: 0.1rem; opacity: 0.45; } .description { font-size: 1.3rem; line-height: 1.35; display: grid; grid-template-columns: 1fr auto; place-content: start; gap: 0.5rem; p { margin: 0; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } span { transform: translateY(-0.1rem); font-size: 4rem; display: grid; place-items: center; width: 2rem; height: 2rem; } }\nscript.js: ",
    "id": "frosted-glass-preview"
  },
  {
    "title": "cg-404",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>\n      ScrollTrigger 404 Page With Horizontal Scroll + Parallax | @mukta\n    </title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <div class=\"container\">\n      <nav><a href=\"#\">mukta</a></nav>\n\n      <section class=\"wrapper-404\">\n        <h1>Page Not Found</h1>\n\n        <div class=\"card\" id=\"card-1\">\n          <img src=\"./assets/img-1.jpg\" alt=\"\" />\n        </div>\n        <div class=\"card\" id=\"card-2\">\n          <img src=\"./assets/img-2.jpg\" alt=\"\" />\n        </div>\n        <div class=\"card\" id=\"card-3\">\n          <img src=\"./assets/img-3.jpg\" alt=\"\" />\n        </div>\n        <div class=\"card\" id=\"card-4\">\n          <img src=\"./assets/img-4.jpg\" alt=\"\" />\n        </div>\n      </section>\n      <section class=\"outro\">\n        <h1>\n          This page doesn't exist anymore... but that's okay. <br />\n          We'll get you right back on the track!\n        </h1>\n      </section>\n    </div>\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js\"></script>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "gsap.registerPlugin(ScrollTrigger);\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  const cards = [\n    { id: \"#card-1\", endTranslateX: -2000, rotate: 45 },\n    { id: \"#card-2\", endTranslateX: -1000, rotate: -30 },\n    { id: \"#card-3\", endTranslateX: -2000, rotate: 45 },\n    { id: \"#card-4\", endTranslateX: -1500, rotate: -30 },\n  ];\n\n  ScrollTrigger.create({\n    trigger: \".wrapper-404\",\n    start: \"top top\",\n    end: \"+=900vh\",\n    scrub: 1,\n    pin: true,\n    onUpdate: (self) => {\n      gsap.to(\".wrapper-404\", {\n        x: `${-350 * self.progress}vw`,\n        duration: 0.5,\n        ease: \"power3.out\",\n      });\n    },\n  });\n\n  cards.forEach((card) => {\n    ScrollTrigger.create({\n      trigger: \"card.id\",\n      start: \"top top\",\n      end: \"+=1200vh\",\n      scrub: 1,\n      onUpdate: (self) => {\n        gsap.to(card.id, {\n          x: `${card.endTranslateX * self.progress}px`,\n          rotate: `${card.rotate * self.progress * 2}`,\n          duration: 0.5,\n          ease: \"power3.out\",\n        });\n      },\n    });\n  });\n});\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  width: 100%;\n  height: 100%;\n  font-family: \"Roslindale Display Condensed\";\n  background: #000;\n  overflow-x: hidden;\n}\n\nimg {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\na {\n  text-decoration: none;\n  color: #fff;\n  font-size: 20px;\n}\n\nh1 {\n  width: 100%;\n  color: #fff;\n  font-size: 48vw;\n  font-weight: 400;\n  text-align: center;\n  margin: 0;\n}\n\n.container {\n  width: 100%;\n  height: 1200vh;\n}\n\nnav {\n  position: fixed;\n  top: 0;\n  width: 100%;\n  padding: 1em;\n  display: flex;\n  justify-content: center;\n}\n\n.wrapper-404 {\n  position: absolute;\n  top: 0;\n  width: 400vw;\n  height: 100vh;\n  will-change: transform;\n}\n\n.card {\n  position: absolute;\n  width: 300px;\n  height: 300px;\n  background: gray;\n  border-radius: 20px;\n  overflow: hidden;\n}\n\n#card-1 {\n  top: 50%;\n  left: 20%;\n}\n\n#card-2 {\n  top: 25%;\n  left: 40%;\n}\n\n#card-3 {\n  top: 45%;\n  left: 60%;\n}\n\n#card-4 {\n  top: 15%;\n  left: 80%;\n}\n\n.outro {\n  position: absolute;\n  top: 150vh;\n  width: 100%;\n  height: 100vh;\n}\n\n.outro h1 {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: max-content;\n  font-size: 40px;\n  font-weight: lighter;\n  text-align: center;\n}\n\n@media (max-width: 900px) {\n  .wrapper-404 {\n    padding-top: 20em;\n  }\n}\n"
    }
  },
  {
    "title": "28012024-Canvas-Draw-Animation",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Draw To Reveal Canvas Animation | 28012024 | @mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <div class=\"site-content\">\n      <video autoplay muted loop id=\"myVideo\">\n        <source src=\"./hero.mp4\" type=\"video/mp4\" />\n        Your browser does not support HTML5 video.\n      </video>\n    </div>\n    <div class=\"container\">\n      <div class=\"nav\">\n        <div class=\"logo\">\n          <a href=\"#\">Blockspace</a>\n        </div>\n        <div class=\"links\">\n          <a href=\"#\">Projects</a>\n          <a href=\"#\">About Us</a>\n          <a href=\"#\">Our Services</a>\n          <a href=\"#\">Our Incubators</a>\n          <a href=\"#\">Contact</a>\n          <a href=\"#\">Careers</a>\n        </div>\n      </div>\n\n      <div class=\"hero-copy\">\n        <h1>Blockspace</h1>\n        <p>a full cycle agency for all digital and creatives.</p>\n      </div>\n\n      <div class=\"footer\">\n        <div class=\"links\">\n          <a href=\"#\">Instagram</a>\n          <a href=\"#\">Behance</a>\n        </div>\n\n        <div class=\"cta\">\n          <a href=\"#\">Showreel (2023)</a>\n        </div>\n      </div>\n    </div>\n    <canvas id=\"draw\"></canvas>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>\n",
      "script.js": "const canvas = document.querySelector(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\n\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\n\nctx.fillStyle = \"black\";\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\nctx.lineJoin = \"round\";\nctx.lineCap = \"round\";\nctx.lineWidth = 200;\n\nctx.globalCompositeOperation = \"destination-out\";\n\nlet isDrawing = false;\nlet lastX = 0;\nlet lastY = 0;\n\nfunction draw(e) {\n  if (!isDrawing) return;\n  ctx.beginPath();\n  ctx.moveTo(lastX, lastY);\n  ctx.lineTo(e.offsetX, e.offsetY);\n  ctx.stroke();\n  [lastX, lastY] = [e.offsetX, e.offsetY];\n}\n\ncanvas.addEventListener(\"mousedown\", (e) => {\n  isDrawing = true;\n  [lastX, lastY] = [e.offsetX, e.offsetY];\n});\n\ncanvas.addEventListener(\"mousemove\", draw);\ncanvas.addEventListener(\"mouseup\", () => (isDrawing = false));\ncanvas.addEventListener(\"mouseout\", () => (isDrawing = false));\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\n::selection {\n  color: #fff;\n  background: transparent;\n}\n\nhtml,\nbody {\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n  background-color: red;\n}\n\ncanvas {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n}\n\n.container {\n  position: relative;\n  z-index: 1;\n  pointer-events: none;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n}\n\n.site-content {\n  position: absolute;\n}\n\n.nav,\n.footer {\n  width: 100%;\n  display: flex;\n  justify-content: space-between;\n  padding: 2em;\n}\n\n.footer {\n  position: absolute;\n  bottom: 0;\n}\n\n.links {\n  display: flex;\n  gap: 2em;\n}\n\na {\n  text-decoration: none;\n  color: #fff;\n  font-family: \"Neue Montreal\";\n  pointer-events: auto;\n}\n\n.logo a {\n  font-family: \"Proxy_Mono_Beta\";\n  text-transform: uppercase;\n}\n\n.hero-copy {\n  width: 100%;\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  text-align: center;\n}\n\n.hero-copy h1 {\n  font-size: 8vw;\n  color: #fff;\n  font-family: \"Proxy_Mono_Beta\";\n  text-transform: uppercase;\n  font-weight: 400;\n}\n\n.hero-copy p {\n  font-size: 2vw;\n  color: #fff;\n  font-family: \"Neue Montreal\";\n  margin: 0.5em 0;\n}\n\n#myVideo {\n  position: fixed;\n  right: 0;\n  bottom: 0;\n  min-width: 100%;\n  min-height: 100%;\n}\n"
    }
  },
  {
    "title": "JS Physics Animation - mukta",
    "code": {
      "index.html": "<!DOCTYPE html>\n<html>\n  <head>\n    <title>JavaScript Physics Animation | Matter JS + p5 JS | mukta</title>\n    <link rel=\"stylesheet\" href=\"styles.css\" />\n  </head>\n  <body>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js\"></script>\n    <script>\n      let customFont;\n\n      function preload() {\n        customFont = loadFont(\"/MonumentExtended-Bold.otf\");\n      }\n\n      const Engine = Matter.Engine;\n      const World = Matter.World;\n      const Bodies = Matter.Bodies;\n      const Body = Matter.Body;\n\n      let engine;\n      let words = [];\n      let ground, wallLeft, wallRight;\n      let wordsToDisplay = [\n        \"Facebook\",\n        \"Instagram\",\n        \"Twitter\",\n        \"LinkedIn\",\n        \"Github\",\n        \"Twitter\",\n        \"Behance\",\n        \"Email\",\n        \"Discord\",\n        \"YouTube\",\n      ];\n\n      function setup() {\n        createCanvas(windowWidth, windowHeight - 60);\n        engine = Engine.create();\n\n        ground = Bodies.rectangle(width / 2, height - 20, width, 10, {\n          isStatic: true,\n        });\n        wallLeft = Bodies.rectangle(0, height / 2, 10, height, {\n          isStatic: true,\n        });\n        wallRight = Bodies.rectangle(width, height / 2, 10, height, {\n          isStatic: true,\n        });\n\n        World.add(engine.world, [ground, wallLeft, wallRight]);\n\n        for (let i = 0; i < wordsToDisplay.length; i++) {\n          words.push(new Word(random(width), -200, wordsToDisplay[i]));\n        }\n      }\n\n      function draw() {\n        background(\"#606060\");\n        Engine.update(engine);\n        for (let word of words) {\n          word.show();\n        }\n      }\n\n      class Word {\n        constructor(x, y, word) {\n          this.body = Bodies.rectangle(x, y, word.length * 20, 40);\n          this.word = word;\n          World.add(engine.world, this.body);\n        }\n\n        show() {\n          let pos = this.body.position;\n          let angle = this.body.angle;\n\n          push();\n          translate(pos.x, pos.y);\n          rotate(angle);\n          rectMode(CENTER);\n          fill(255);\n          stroke(\"#0f0f0f\");\n          strokeWeight(3);\n          rect(0, 0, this.word.length * 40 + 80, 100, 60);\n          noStroke();\n          textFont(customFont);\n          fill(\"#0f0f0f\");\n          textSize(40);\n          textAlign(CENTER, CENTER);\n          text(this.word.toUpperCase(), 0, 0);\n          pop();\n        }\n      }\n\n      function mouseMoved() {\n        for (let word of words) {\n          if (\n            dist(mouseX, mouseY, word.body.position.x, word.body.position.y) <\n            50\n          ) {\n            Body.applyForce(\n              word.body,\n              { x: word.body.position.x, y: word.body.position.y },\n              { x: random(-0.2, 0.2), y: random(-0.2, 0.2) }\n            );\n          }\n        }\n      }\n    </script>\n  </body>\n</html>\n",
      "styles.css": "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  margin: 0;\n  padding: 0;\n  height: 100vh;\n  overflow: hidden;\n  background: #606060;\n}\ncanvas {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100vw !important;\n  height: 100vh !important;\n}\n"
    }
  },
  {
    "title": "Halftone Reveal",
    "description": "",
    "code": "index.html: <div class=\"container\"> <div class=\"halftone-reveal\"> <svg class=\"clip-svg\" width=\"0\" height=\"0\"> <defs> <clipPath id=\"halftone-clip\"> <!-- Circles will be inserted here by JavaScript --> </clipPath> </defs> </svg> <div class=\"content\" style=\"clip-path: url(#halftone-clip);\" /> </div> </div>\nstyle.css: * { margin: 0; padding: 0; box-sizing: border-box; } body { background: #f8f8f8; height: 100dvh; width: 100dvw; display: flex; align-items: center; justify-content: center; overflow: hidden; } .clip-svg { position: absolute; width: 0; height: 0; pointer-events: none; } .content { width: 400px; height: 400px; border-radius: 10%; background-color: hsla(321, 77%, 83%, 1); background-image: radial-gradient( circle at 5% 1%, hsla(300, 100%, 45.1%, 1) 7%, transparent 84% ), radial-gradient( circle at 7% 81%, hsla(198, 100%, 44.5%, 1) 16%, transparent 53% ), radial-gradient( circle at 90% 50%, hsla(247, 54.1%, 33.3%, 1) 2%, transparent 85% ); background-blend-mode: normal, normal, normal, normal, normal; }\nscript.js: // Configuration let config = { direction: \"bottom\", spacing: 20, duration: 1.7, stagger: 0.05 }; function getRevealDelay(row, col, rows, cols) { switch (config.direction) { case \"top\": return row * config.stagger; case \"bottom\": return (rows - 1 - row) * config.stagger; case \"left\": return col * config.stagger; case \"right\": return (cols - 1 - col) * config.stagger; case \"center\": const centerRow = (rows - 1) / 2; const centerCol = (cols - 1) / 2; const distance = Math.sqrt( Math.pow(row - centerRow, 2) + Math.pow(col - centerCol, 2) ); return distance * config.stagger; default: return row * config.stagger; } } function createHalftoneEffect() { const clipPath = document.querySelector(\"#halftone-clip\"); const container = document.querySelector(\".container\"); clipPath.innerHTML = \"\"; const rect = container.getBoundingClientRect(); const width = rect.width; const height = rect.height; const cols = Math.max(1, Math.floor(width / config.spacing)); const rows = Math.max(1, Math.floor(height / config.spacing)); const actualSpacingX = width / cols; const actualSpacingY = height / rows; const maxRadius = Math.max(actualSpacingX, actualSpacingY); // Create circles for (let row = 0; row < rows; row++) { for (let col = 0; col < cols; col++) { const x = (col + 0.5) * actualSpacingX; const y = (row + 0.5) * actualSpacingY; const revealDelay = getRevealDelay(row, col, rows, cols); const circle = document.createElementNS( \"http://www.w3.org/2000/svg\", \"circle\" ); circle.setAttribute(\"cx\", x); circle.setAttribute(\"cy\", y); circle.setAttribute(\"r\", \"0\"); const animate = document.createElementNS( \"http://www.w3.org/2000/svg\", \"animate\" ); animate.setAttribute(\"attributeName\", \"r\"); animate.setAttribute(\"values\", `0;${maxRadius};0`); animate.setAttribute(\"dur\", `${config.duration * 2}s`); animate.setAttribute(\"repeatCount\", \"indefinite\"); animate.setAttribute(\"fill\", \"freeze\"); animate.setAttribute(\"begin\", `${revealDelay}s`); circle.appendChild(animate); clipPath.appendChild(circle); } } } window.addEventListener(\"load\", function () { createHalftoneEffect(); });",
    "id": "halftone-reveal"
  },
  {
    "title": "mouse-cursor-confetti-click",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js\">script>\n<script src=\"https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/Physics2DPlugin.min.js\">script>\n\nStep 2: Add CSS\n\nbody {\n  overflow: clip;\n}\n\n.dot {\n  position: absolute;\n  background-color: #D3DCCD;\n  width: 1rem;\n  height: 1rem;\n  border-radius: 50%;\n  will-change: transform, opacity;\n  pointer-events: none; \n}\n\nStep 2: Add custom Javascript\n\ngsap.registerPlugin(Physics2DPlugin);\n\ndocument.addEventListener(\"click\", (event) => {\n  // Generate a random number of dots (3 to 10)\n  const dotCount = gsap.utils.random(3, 10, 1);\n  const colors = [\"#D3DCCD\", \"#F5FEEF\", \"#6C7E5F\", \"#818A7B\", \"#94A787\"]; // Define colors once\n\n  for (let i = 0; i < dotCount; i++) {\n    // Create a dot element\n    const dot = document.createElement(\"div\");\n    dot.classList.add(\"dot\");\n\n    // Append the dot to the body\n    document.body.appendChild(dot);\n\n    // Set initial position and styles of the dot\n    gsap.set(dot, {\n      backgroundColor: gsap.utils.random(colors), // Pick a random color\n      top: event.clientY, // position dot at coordinates of the click\n      left: event.clientX,\n      scale: 0, // Start at scale 0\n    });\n\n    // Animate the dot with physics2D\n    gsap.timeline({\n      onComplete: () => dot.remove(), // Remove the dot after animation\n    })\n      .to(dot, {\n        scale: gsap.utils.random(0.5, 1), // Scale between 0.5 and 1\n        duration: 0.3, // Quick pop-in effect\n        ease: \"power3.out\",\n      })\n      .to(dot, {\n        duration: 2,\n        physics2D: {\n          velocity: gsap.utils.random(200, 650), // Random velocity\n          angle: gsap.utils.random(0, 360), // Random direction\n          gravity: 500, // Gravity effect\n        },\n        autoAlpha: 0, // Fade out towards the end\n        ease: \"none\",\n      }, \"<\"); // Start together with the previous tween\n  }\n});\n\nImplementation\n\nCustomization\nThe Physics2D plugin from GSAP serves as a way to easily create interesting physics-based effects. We highly recommend diving into their documentation page to discover all of the possibilities. In our example we paired it with several random functions to make the animation as dynamic as possible. \n\nInspiration\nCheckout the Fruitful website, where Ilja paired the mouse click animation with the generation of a random Lottie file to create a unique and on-brand experience. Or play around with the main 'get GSAP' button on the GSAP Homepage, where the Physics2D plugin was used to create a fun animation on button hover.",
    "id": "mouse-cursor-confetti-click"
  },
  {
    "title": "CMYK Glitch Animation Experiment",
    "description": "",
    "code": "index.html: <svg viewBox=\"0 0 109 28\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" class=\"step-glitch\"> \t<use class=\"logo-c\" href=\"#codetv-logo\" /> \t<use class=\"logo-m\" href=\"#codetv-logo\" /> \t<use class=\"logo-y\" href=\"#codetv-logo\" /> </svg> <svg viewBox=\"0 0 109 28\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" class=\"drift-glitch\"> \t<use class=\"logo-c\" href=\"#codetv-logo\" /> \t<use class=\"logo-m\" href=\"#codetv-logo\" /> \t<use class=\"logo-y\" href=\"#codetv-logo\" /> </svg> <svg viewBox=\"0 0 109 28\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" class=\"logo-def\"> \t<defs> \t\t<g id=\"codetv-logo\"> \t\t\t<path d=\"M17 10h-5V8h-1V7H6v1H5v9h1v1h5v-1h1v-2h5v4h-1v2h-1v1h-2v1H4v-1H2v-1H1v-2H0V6h1V4h1V3h2V2h9v1h2v1h1v2h1v4Z\" /> \t\t\t<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M24 2h9v1h2v1h1v2h1v13h-1v2h-1v1h-2v1h-9v-1h-2v-1h-1v-2h-1V6h1V4h1V3h2V2Zm2 6V7h5v1h1v9h-1v1h-5v-1h-1V8h1ZM40 23V2h12v1h2v1h1v2h1v13h-1v2h-1v1h-2v1H40ZM50 7h-5v11h5v-1h1V8h-1V7Z\" /> \t\t\t<path d=\"M59 2v21h16v-5H64v-3h9v-5h-9V7h11V2H59Z\" /> \t\t\t<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M82 0h20v1h2v1h1v2h1v17h-1v2h-1v1h-2v1H82v-1h-2v-1h-1v-2h-1V4h1V2h1V1h2V0Zm-1 11V7h10v4h-3v8h-4v-8h-3Zm11 4V7h4v6h1v1h1v-1h1V7h4v8h-1v1h-1v1h-1v1h-1v1h-3v-1h-1v-1h-1v-1h-1v-1h-1Z\" /> \t\t</g> \t</defs> </svg>\nstyle.css: body { \talign-items: center; \tbackground: #1e1e1e; \tblock-size: 100dvh; \tdisplay: flex; \tflex-direction: column; \tgap: 3rem; \tinline-size: 100dvi; \tjustify-content: center; } svg { \tinline-size: min(90dvi, 180px); \tpath { \t\tmix-blend-mode: screen; \t} } .logo-def { \tdisplay: none; } .step-glitch { \t.logo-c { \t\tanimation: 3s c steps(2, jump-end) infinite; \t\tfill: #0ff; \t\tx: 1; \t\ty: 0; \t} \t.logo-m { \t\tanimation: 5s m steps(2, jump-end) infinite; \t\tfill: #ff0; \t\tx: 0; \t\ty: 1; \t} \t.logo-y { \t\tanimation: 2.5s y steps(2, jump-end) infinite; \t\tfill: #f0f; \t\tx: 1; \t\ty: 2; \t} } .drift-glitch { \t.logo-c { \t\tanimation: 6s c linear infinite alternate; \t\tfill: #0ff; \t\tx: 1; \t\ty: 0; \t} \t.logo-m { \t\tanimation: 10s m linear infinite alternate; \t\tfill: #ff0; \t\tx: 0; \t\ty: 1; \t} \t.logo-y { \t\tanimation: 5s y linear infinite alternate; \t\tfill: #f0f; \t\tx: 1; \t\ty: 2; \t} } @keyframes c { \t83.33% { \t\tx: 1; \t\ty: 0; \t} \t100% { \t\tx: 0; \t\ty: 0; \t} } @keyframes m { \t80% { \t\tx: 0; \t\ty: 1; \t} \t100% { \t\tx: 1; \t\ty: 2; \t} } @keyframes y { \t90% { \t\tx: 1; \t\ty: 2; \t} \t100% { \t\tx: 0; \t\ty: 1; \t} }\nscript.js: ",
    "id": "cmyk-glitch-animation-experiment"
  },
  {
    "title": "refracted-glass-unicorn-studio",
    "code": "Documentation\n\nSetup: External Scripts\n\n<script src=\"https://cdn.jsdelivr.net/gh/hiunicornstudio/unicornstudio.js@v1.4.34/dist/unicornStudio.umd.js\">script>\n\nStep 1: Add HTML\n\n<div class=\"refract__wrapper\">\n  <div\n    class=\"refract__item\" \n    data-us-alttext=\"Dreamy portrait of a woman in motion\"\n    data-us-project-src=\"https://mukta.b-cdn.net/resource-media/mukta-unicorn-refracted-glass.json\"\n    data-us-scale=\"1\"\n    data-us-dpi=\"1\"\n    data-us-lazyload=\"false\"\n  >div>\ndiv>\n\nStep 2: Add CSS\n\n.refract__wrapper {\n  aspect-ratio: 1 / 1.25;\n  border-radius: .75em;\n  width: 100%;\n  max-width: 32em;\n  position: relative;\n  overflow: hidden;\n}\n\n.refract__item {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  inset: 0%;\n}\n\nStep 2: Add custom Javascript\n\nfunction initUnicornStudio(){\n  UnicornStudio.init()\n    .then((scenes) => {\n      // Unicorn scene is ready, you could run other code here\n    })\n    .catch((err) => {\n      console.error(err);\n    });\n}\n\n// Initialize Unicorn Studio\ndocument.addEventListener('DOMContentLoaded', function() {\n  initUnicornStudio();\n});\n\nImplementation\n\nRemix link / Source file\nThis resource was made with Unicorn Studio, a visual WebGL editor. To get direct access to the source file, follow this link here.\n\nHTML Setup\nFor a basic implementation, simply add [data-us-project-src] on a div, the attribute value should point directly to the JSON file you can export from Unicorn (see next step too). It's also possible instead to use [data-us-project] where the attribute value is your 'project embed ID', but we recommend exporting the JSON file and using that as a direct source.\n\nProject Source\nUse [data-us-project-src] to link directly to the Unicorn Studio .json source file, defining which WebGL composition to load into the element. We recommend hosting your files on bunny.net, it's super fast and extremely cheap. If you're a Webflow user you have the following possibility too:\n- Rename your code JSON to [your-file-name].json.txt\n- Upload it to the assets library in Webflow directly\n- Use the menu to copy link and paste it as the value for data-us-project-src\n\nChanging the image\nFollow step 1 to get the remix link, and tweak the project in your own Unicorn Studio account. Then, click 'export' in the top right, and get the JSON file. Then, check the previous step.\n\nMore documentation\nWe recommend checking out the official documentation from Unicorn Studio directly to learn more about the tool itself, and all its best practices!",
    "id": "refracted-glass-unicorn-studio"
  },
  {
    "title": "light and shadow - challenge",
    "description": "",
    "code": "index.html: <div class=\"card\"> \t<h1>Lorem ipsum dolor sit.</h1> \t<p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Voluptate ullam ex dignissimos laborum assumenda architecto.</p> </div>\nstyle.css: :root { \t--accent: orangered; } *, ::before, ::after { \tpadding: 0; \tmargin: 0; \tbox-sizing: border-box; } body { \theight: 100vh; \tmargin: 0; \tdisplay: flex; \tjustify-content: center; \talign-items: center; \tbackground: #eee; \tfont-family: system-ui; \ttext-wrap: pretty; } .card { \t--light: rgba(255, 255, 255, calc(1 - var(--distance, 0))); \t--border-radius: .4rem; \twidth: 17rem; \tbackground: #f1f1f1; \tbackground-clip: padding-box; \tborder: .2rem solid transparent; \tborder-radius: var(--border-radius); \tpadding: 2rem 3rem; \tmargin: 1rem; \tposition: relative; } .card::before { \tcontent: \"\"; \tposition: absolute; \tinset: -.2rem; \tbackground: conic-gradient( \t\tfrom calc(125deg + var(--deg, 0deg)), \t\tvar(--accent), \t\tvar(--accent) 80%, \t\tvar(--light) 90%, \t\tvar(--accent) \t), linear-gradient(var(--accent), var(--accent)); \tborder-radius: var(--border-radius); \tz-index: -1; } .card::after { \tcontent: \"\"; \tposition: absolute; \tinset: -.2rem; \tbackground: #0003; \tz-index: -2; \ttransform: translate( \t\tcalc(cos(var(--deg, 0deg)) * -1.5rem), \t\tcalc(sin(var(--deg, 0deg)) * -1.5rem) \t) \t\tscale(calc(var(--distance, 0) / 10 + 1)); \tborder-radius: var(--border-radius); } h1 { \tpadding-bottom: 1rem; \tline-height: 1.8rem; \ttext-wrap: balance; \tcolor: var(--accent); } ::selection { \tbackground: var(--accent); \tcolor: white; }\nscript.js: function quickDist(deltaX, deltaY) { \treturn deltaX ** 2 + deltaY ** 2; } addEventListener(\"mousemove\", e => { \tconst centerX = window.innerWidth / 2; \tconst centerY = window.innerHeight / 2; \tconst distanceX = e.clientX - centerX \tconst distanceY = e.clientY - centerY \tconst maxDist = quickDist(centerX, centerY); \tconst dist = quickDist(distanceX, distanceY); \tconst deg = Math.atan2(distanceY, distanceX) / Math.PI * 180; \tdocument.body.style.setProperty(\"--deg\", `${deg}deg`); \tdocument.body.style.setProperty(\"--distance\", `${dist / maxDist}`); \tconsole.log(dist / maxDist) });",
    "id": "light-and-shadow---challenge"
  },
  {
    "title": "Autumn falling leaves ( GSAP )",
    "description": "",
    "code": "index.html: <div id=\"container\"> <img id='logo' src=\"http://gravatar.com/avatar/5a224f121f96bd037bf6c1c1e2b686fb?s=256\" alt=\"Smiley face\" height=\"120\" width=\"120\"> </div>\nstyle.css: body{ background-color: #111; font-family: Signika Negative, Asap, sans-serif; color:white; overflow:hidden; } .dot{ width:35px; height:35px; position:absolute; background: url(http://www.clipartqueen.com/image-files/red-lobed-fall-clipart-leaf.png); background-size: 100% 100%; } html, body, #container {width:100%; height:100%; } #logo{ left:50%; top:50%; position:absolute; border-radius:10px; } #DiacoDesignLink,#pens{ color: #fff; }\nscript.js: /* a Pen by Diaco m.lotfollahi : https://diacodesign.com */ var falling = true; TweenLite.set(\"#container\",{perspective:600}) TweenLite.set(\"img\",{xPercent:\"-50%\",yPercent:\"-50%\"}) var total = 30; var container = document.getElementById(\"container\"),\tw = window.innerWidth , h = window.innerHeight; for (i=0; i<total; i++){ var Div = document.createElement('div'); TweenLite.set(Div,{attr:{class:'dot'},x:R(0,w),y:R(-200,-150),z:R(-200,200)}); container.appendChild(Div); animm(Div); } function animm(elm){ TweenMax.to(elm,R(6,15),{y:h+100,ease:Linear.easeNone,repeat:-1,delay:-15}); TweenMax.to(elm,R(4,8),{x:'+=100',rotationZ:R(0,180),repeat:-1,yoyo:true,ease:Sine.easeInOut}); TweenMax.to(elm,R(2,8),{rotationX:R(0,360),rotationY:R(0,360),repeat:-1,yoyo:true,ease:Sine.easeInOut,delay:-5}); }; function R(min,max) {return min+Math.random()*(max-min)}; /* a Pen by Diaco m.lotfollahi : https://diacodesign.com */",
    "id": "autumn-falling-leaves--gsap-"
  },
  {
    "title": "swipe effect",
    "description": "",
    "code": "index.html: <div class=\"layer\"></div>\nstyle.css: .layer:before, .layer:after { content: \"\"; position: fixed; inset: 0% -50%; background: orange; clip-path: ellipse(70% 100% at 50% 100%); animation: s0 1s .5s ease-out both, s1 .4s .5s both, s3 .5s 1.3s linear both; } .layer:after { background: aqua; animation-delay: 2s,2s,2.8s } @keyframes s0 { 0% {translate: 0 100%} } @keyframes s1 { to {inset: 0%} } @keyframes s3 { to {clip-path: ellipse(200% 100% at 50% 80%)} } body { background: #000; }\nscript.js: ",
    "id": "swipe-effect"
  }
]